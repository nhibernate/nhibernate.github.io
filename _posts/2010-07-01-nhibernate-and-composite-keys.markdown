---
layout: post
title: "NHibernate and Composite Keys"
date: 2010-07-01 05:11:00 +1200
comments: true
published: true
categories: ["blogs", "nhibernate", "archive"]
tags: ["&quot;Composite Keys&quot;"]
redirect_from: ["/blogs/nhibernate/archive/2010/06/30/nhibernate-and-composite-keys.aspx/", "/blogs/nhibernate/archive/2010/06/30/nhibernate-and-composite-keys.html"]
author: ajepst
gravatar: fad7db02ad0cbbcd20f8bba5fdc1fc81
---
{% include imported_disclaimer.html %}
<p>(If this post looks familiar, it&rsquo;s because I originally posted this over on <a href="http://devlicio.us/">http://devlicio.us/</a> and I have given myself full permission to repost it here, with minor edits)</p>
<p>Composite IDs are a common pain point a beginning NHibernate user runs into.&nbsp; Here's everything you need to get them up and running. </p>
<p>First, a caveat: composite keys are certainly mappable in NHibernate, but it's a little trickier than a typical single identity key would be.&nbsp; Compared to a normal key, there's some extra setup work, queries are more painful, and they tend to be less optimized in terms of lazy loading. Because of these things, experienced NHibernate users often avoid composite keys entirely when possible.&nbsp; However, there are many legacy situations where multiple existing apps all hit the same db-a situation in which, if a composite key is already in place, it&rsquo;s may be really difficult to change.&nbsp; As this kind of legacy situation is the most common use case for mapping composite keys with NHibernate, I'll start from the assumption that you've got an existing database that you can't alter. (this is a *bad thing* - see <a href="/blogs/nhibernate/archive/2009/06/26/database-the-eliot-ness-of-it.aspx">THIS POST</a> for why, but as developers, those kinds of decisions aren't always under our control-but if you <i>can</i> change the structure to avoid composite keys, you should really, really consider it)</p>
<h3>YOUR OBJECTS</h3>
<p>As I mentioned above, if you're considering mapping a composite key, you probably already have a database. (if not,&nbsp; I&rsquo;d highly advise an alternative-perhaps sets, perhaps idbags, but that&rsquo;s for another blog post) The NORMAL, PREFERRED direction of model design would be to work up your classes and once they work the way you want, extract the persistence structure from that (i.e. your DB). But if that were an option for you... well, you probably wouldn't be using a composite key in the first place.&nbsp; Anyway, let's take a scenario:</p>
<p>Your existing tables:</p>
<p><img src="http://docs.google.com/File?id=dtmkfh7_29ghmckcd7_b" /></p>
<p>&nbsp;</p>
<p>In our brand new NHibernate app, we want to have an object that corresponds to the CategoryProducts idea.&nbsp; This is a start:</p>
<pre class="c-sharp" name="code">namespace SuperShop.Domain<br />{<br />    public class CategoryProduct<br />    {<br />        public virtual Product Product { get; set; }<br />        public virtual Category Category { get; set; }<br />        public virtual string CustomizedProductDescription { get; set; }<br /><br />        private DateTime _LastModifiedOn;<br /><br />        public override bool Equals(object obj)<br />        {<br />            if (obj == null)<br />                return false;<br />            var t = obj as CategoryProduct;<br />            if (t == null)<br />                return false;<br />            if (Product == t.Product &amp;&amp; Category == t.Category)<br />                return true;<br />            return false;<br />        }<br />        public override int GetHashCode()<br />        {<br />            return (Product.SKU + "|" + Category.Name).GetHashCode();<br />        }<br />    }<br />}</pre>
<p>So, why the Equals and GetHashcode?&nbsp; If you try to map a composite key without them, you'll get an NHibernate error stating that they are required.&nbsp; Here's why: With this two part identifier, NHibernate can't do a simple single id object compare - you need to tell it how to decide equality. Implementing Equals and GetHashcode are always a good idea for anyway so your objects will be have properly in cases like multi-session scenarios where an unsaved object might really be the same as an existing object elsewhere, but in the composite key scenario, not having it is not an option- NHibernate doesn't even *have* a mostly-works technique to fall back on. (Note, this is almost certainly not the most ideal Equals and GetHashcode implementation-take a look <a href="/blogs/billy_mccafferty/archive/2007/04/25/using-equals-gethashcode-effectively.aspx">here</a> for more on the topic- but hopefully this gives you the general idea. )</p>
<h3>MAPPING</h3>
<p>A mapping:</p>
<pre class="xml" name="code">&lt;hibernate-mapping&gt;   <br />&lt;class table="OrderItemProductDetails" name="SuperShop.Domain.ComponentPersonalization, SuperShop.Domain"&gt;<br />    &lt;composite-id&gt;<br />        &lt;key-many-to-one class="SuperShop.Domain.OrderItemComponent,SuperShop.Domain" name="OrderItemComponent" column="OrderItemProductID" /&gt;<br />        &lt;key-property name="DetailType" column="DetailTypeID" type="SuperShop.Domain.DetailTypes,SuperShop.Domain" /&gt;<br />    &lt;/composite-id&gt;<br />    &lt;version name="LastModifiedOn" column="LastModifiedOn" type="timestamp" access="field.pascalcase-underscore" /&gt;<br />    &lt;property name="DetailValue" column="DetailValue" type="String"&gt;&lt;/property&gt;<br />    &lt;property name="DetailCharge" column="DetailCharge" type="Decimal"&gt;&lt;/property&gt;<br /><br />&lt;/class&gt;<br />&lt;/hibernate-mapping&gt;</pre>
<p>Note the <b>&lt;version&gt;</b> element, as well as the matching _LastModifiedOn in the class above. These two items combined let NHibernate know how to tell if an entity is new or not.&nbsp; In the usual scenario where NHibernate manages the ID, NHibernate monitors whether the id value is the original unsaved value and determines whether to Save or Update for you if you call SaveOrUpdate(), a very handy method.&nbsp; If NHibernate is not managing the ID, as is the case in an Assigned ID (think an SSN that you manage) or in composite (where you create the relationships or values yourself that make the id)&nbsp; then it doesn't know how to tell if your id is saved or not-its usual technique doesn't work.&nbsp; So with <b>&lt;version&gt;</b> NHibernate gets a column it has control over, and can safely monitor for an unsaved value. Without this, you'd be unable to use SaveOrUpdate with this element-you'd have to call Save or Update as appropriate-additionally, since ALL cascading functions on collections are essentially NHibernate calling SaveOrUpdate, you're not going to be able to use cascading. Alternatively, if you don't like the <b>&lt;version&gt;</b> column, you could implement IInterceptor 's IsTransient() method to get similar functionality.&nbsp;&nbsp; (<a href="http://www.nhforge.org/doc/nh/en/index.html#components-compositeid">see documentation at nhforge</a>)</p>
<p>So, if you want to take the <b>&lt;version&gt;</b> approach, you'll need to add a new DateTime column to your CategoryProducts table:</p>
<p><img src="http://docs.google.com/File?id=dtmkfh7_30fmsbthcg_b" /></p>
<p>&nbsp;</p>
<h3>QUERYING</h3>
<p>An inconvenient aspect of composite ids is the need to query on all parts of the id.&nbsp; For instance: when working with single-column keys, a GetByID query comes built-in-you don&rsquo;t have to write it:</p>
<p><b>session.Get&lt;MyFooObject&gt;(myFooId),</b> </p>
<p>However, when querying for an entity with a composite key, the equivalent query is NOT built-in; it needs to be hand-written, like the following: </p>
<p>
  <br /><b>from CategoryProducts c where c.Products = :p and c.Category = :cat</b></p>
<p>
  <br />but it's not just on the GetByID, it's *whenever* you might need to search using a particular CategoryProduct. For instance,</p>
<p>
  <br /><b>select distinct p from ProductImages p join p.CategoryProducts c where c.Products = :p and c.Category = :cat</b></p>
<h3>ID OBJECT</h3>
<p>Composite IDs can be problematic for lazy loading... When lazy loading, NHibernate will get just the ids of a collection, and hold off on getting the rest of the object until it's needed. An important fact- NHibernate can't (yet) partially load an object-it works in terms of discrete "things". If you're talking a plain integer ID, it can load up the integer as a <i>single</i> identifier, proxy the object, and then load up the associated object later.&nbsp; With our object as specified above, the smallest <i>single</i> discrete thing that contains the key is... the whole object- so, you've effectively killed your lazy loading as it&rsquo;s going to have to work with the whole object.&nbsp; What to do if we want lazy loading?&nbsp; Well, make something smaller than the whole that just contains the key.&nbsp; Let's make that ID object:</p>
<pre class="c-sharp" name="code">[Serializable]<br />public class CategoryProductIdentifier {<br />        public virtual int ProductId { get; set; }<br />        public virtual int CategoryId { get; set; }<br /><br />        public override bool Equals(object obj)<br />        {<br />            if (obj == null)<br />                return false;<br />            var t = obj as CategoryProductIdentifier;<br />            if (t == null)<br />                return false;<br />            if (ProductId == t.ProductId &amp;&amp; CategoryId == t.CategoryId)<br />                return true;<br />            return false;<br />        }<br />        public override int GetHashCode()<br />        {<br />            return (ProductId + "|" + CategoryId).GetHashCode();<br />        }<br />}</pre>
<p>then, CategoryProduct becomes: </p>
<pre class="c-sharp" name="code">public class CategoryProduct<br />{<br />        private CategoryProductIdentifier _categoryProductIdentifier = new CategoryProductIdentifier();<br />        public virtual CategoryProductIdentifier CategoryProductIdentifier<br />        {<br />            get { return _categoryProductIdentifier; }<br />            set { _categoryProductIdentifier = value; }<br />        }<br /><br />        private Product _Product;<br />        public virtual Product Product<br />        {<br />            get { return _Product; }<br />            set { _Product = value;<br />                _categoryProductIdentifier.ProductId = _Product.Id; }<br />        }<br /><br />        private Category _Category;<br />        public virtual Category Category<br />        {<br />            get { return _Category; }<br />            set { _Category = value;<br />                _categoryProductIdentifier.CategoryId = _Category.Id; }<br />        }<br />        public virtual string CustomizedProductDescription { get; set; }<br /><br />}</pre>
<p>Mapping Tweaks: </p>
<pre class="xml" name="code"> <br />&lt;hibernate-mapping&gt;<br />&lt;class name="CategoryProduct" table="CategoryProducts"&gt;<br />    &lt;composite-id name="CategoryProductIdentifier" class="CategoryProductIdentifier"&gt;<br />        &lt;key-property name="ProductId" column="ProductID" type="Int32" /&gt;<br />        &lt;key-property name="CategoryId" column="CategoryID" type="Int32" /&gt;<br />        &lt;version name="LastModifiedOn" type="timestamp" column="LastModifiedOn" /&gt;<br />    &lt;/composite-id&gt;<br />    &lt;many-to-one name="Product" column="ProductID" class="Product" insert="false" update="false" access="field.pascalcase-underscore" /&gt;<br />    &lt;many-to-one name="Category" column="CategoryID" class="Category" insert="false" update="false" access="field.pascalcase-underscore" /&gt;<br />    &lt;property name="CustomizedProductDescription" column="CustomizedProductDesc" /&gt;<br />&lt;/class&gt;<br />&lt;/hibernate-mapping&gt;</pre>
<p>The key thing to note here is that Product and Category are referred to twice in both the class and the mapping.&nbsp; The reason for this is that the caching mechanism uses primitives like int or string, so we need to feed it something caching-ready. This is because to index by a custom class in the cache, this composite id class, like an ordinary id, gets serialized and used as the key in the cache hashtable.&nbsp; This serializability comes for free if your id is a single int, but if your id is your own custom object, as with this composite id class, you've got to explicitly both specify that serialization is allowed, and make sure the object is valid for serialization.&nbsp; So we've pulled out those ids as ints into the identifier. However, we still want to be able to traverse these relationships as entities in our code, so we still include the class.&nbsp; However, if NHibernate were to try to update the same db field twice, you'd get errors.&nbsp; To be able to have both the product relation and the ProductId mapped separately in the same class, we mark the class reference as non-updatable.&nbsp; Also, note that the Equals and GetHashcode moved to the CategoryProductIdentifier class - the CategoryProduct class is for the most part free of the burden of the composite key; the burden of composite-ness is now on the CategoryProductIdentifier class.</p>
<p><i>It&rsquo;s entirely possible I&rsquo;ve missed something in regards to NHibernate usage with composite keys-if so, let me know, and I&rsquo;ll add it in.&nbsp; If I got anything factually wrong, let me know about that too so I can make it right!</i></p>
<p><i>Editing Credit from original post:&nbsp; Added in serialization info that I'd forgotten. Thanks to bonskijr for letting me know!</i></p>
