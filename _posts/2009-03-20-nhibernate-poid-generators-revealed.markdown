---
layout: post
title: "NHibernate POID Generators revealed"
date: 2009-03-20 07:49:00 +1300
comments: true
published: true
categories: ["blog", "archives"]
tags: ["NHibernate", "poid", "identifier"]
alias: ["/blogs/nhibernate/archive/2009/03/20/nhibernate-poid-generators-revealed.aspx"]
---
<!-- more -->
{% include imported_disclaimer.html %}
<p><b>(Disclaimer: This post will be more or less a paraphrase of <a href="http://fabiomaulo.blogspot.com/2009/02/nh210-generators-behavior-explained.html" target="_blank">Fabio Maulo&rsquo;s post</a>, and I hope I can improve it a bit)</b></p>
<p>This topic is something that I wanted to write because I wasn&rsquo;t aware of the drawbacks of &ldquo; native/identity<a href="http://nhforge.org"><img title="image" style="border-top-width: 0px; display: inline; border-left-width: 0px; border-bottom-width: 0px; margin-left: 0px; margin-right: 0px; border-right-width: 0px" alt="image" src="/cfs-file.ashx/__key/CommunityServer.Blogs.Components.WeblogFiles/nhibernate/image8_5F00_3AC8A74C.png" align="right" border="0" width="244" height="137" /></a>&rdquo; generator has unt<a href="http://fabiomaulo.blogspot.com" target="_blank"></a>il <a href="http://fabiomaulo.blogspot.com" target="_blank">Fabio</a> told me. Now it is my turn to spread the information to those who aren&rsquo;t aware too. I even made a small poll via twitter, to see who uses what, and the result turns out to be that majority of people <b>use identity/native </b>for some reasons.</p>
<p>NHibernate has several object identifier generators for entities. Each of them has their cons and pros as anything else does. </p>
<p>We can basically seperate generators into two: PostInsertGenerator and ORM Style generators ( you can also call them identity style vs orm stlye generators). impact on your&nbsp; I will investigate them in their categories.</p>
<p><b>ORM Style Generators</b>&nbsp; </p>
<p>ORM style generator can generate the identifiers before objects are sent to database. This is advantageous because you don&rsquo;t need to go to database in order to have the ID, then set a relation based on this id. It also promotes Unit-Of-Work since you don&rsquo;t need to go to database everytime an object is added/updated instead you do those at the moment of commit. Those generators are what WE SUGGEST.</p>
<p>Currently NHibernate provides several ORM style generators, some of them are listed below.</p>
<ul>
<li><b>Guid        <br /></b>Generates id&rsquo;s by calling Guid.NewGuid(). Main drawback of this is with indexes. We know that Guids are more or less random(or pseudo-random let&rsquo;s say) and this randomness creates fragmentation in database index. If you also think that the field is a PK, then it becomes more dramatic since they are stored in sorted manner.       </li>
<li><b>Guid.Comb        <br /></b>A very clever improvement over the Guid way. It creates guid based on the system time, and the guid it creates is database friendly. It doesn&rsquo;t cause fragmentation in the table. You can see it from here       <br />      <br /><img title="I wonder if anybody reads the ALT of images?" style="border-top-width: 0px; display: inline; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" alt="I wonder if anybody reads the ALT of images?" src="/cfs-file.ashx/__key/CommunityServer.Blogs.Components.WeblogFiles/nhibernate/image_5F00_2A6D2F93.png" border="0" width="562" height="394" />&nbsp; <br />(Image taken from <a href="http://pamirerdem.blogspot.com/" target="_blank">Pamir Erdem&rsquo;s blog</a>)       <br />The effect of SequentialNewId() for default value has more or less the same effect of Guid.Comb       </li>
<li><b>HiLo/Sequence HiLo</b>       <br />This one is the one I like the most. It is both index friendly and user friendly. A HiLo id has 2 parts as the name suggests they are Hi and Lo. Each session factory gets the Hi value from database (with locking enabled), and lo values are managed by the session factory on its own. This algorithm also scales really well. All factories gets the Hi value only once. This reduces the the database traffic that aims to get the Hi values. </li>
</ul>
<p><b>Post Insert Generators / Identity Style Generators</b></p>
<p>Post insert generators, as the name suggest, assigns the id&rsquo;s after the entity is stored in the database. A select statement is executed against database. They have many drawbacks, and in my opinion they must be used only on brownfield projects. Those generators are what WE DO NOT SUGGEST as NH Team.</p>
<p>Some of the drawbacks are the following</p>
<ol>
<li>Unit Of Work is broken with the use of those strategies. It doesn&rsquo;t matter if you&rsquo;re using FlushMode.Commit, each Save results in an insert statement against DB. As a best practice, we should defer insertions to the commit, but using a post insert generator makes it commit on save (which is what UoW doesn&rsquo;t do). </li>
<li>Those strategies nullify batcher, you can&rsquo;t take the advantage of sending multiple queries at once(as it must go to database at the time of Save) </li>
</ol>
<p>There are several Post Insert Generator strategies (hey 2.1 has even more!) some of which are listed below(there are many, check <a href="http://fabiomaulo.blogspot.com/2009/02/nh210-new-generators.html" target="_blank">Fabio&rsquo;s post here</a>)</p>
<ol>
<li><b>Identity        <br /></b>Identity generator uses the value that is generated by MsSQL "identity&rdquo; stuff. However, it&rsquo;s meaning in the mapping changes depending on the dialect. For example, if database supports MsSQL like identity, then it will be used, if it supports sequences, then sequences will be used, etc. <a href="https://connect.microsoft.com/SQLServer/feedback/ViewFeedback.aspx?FeedbackID=328811" target="_blank">Something I learnt today</a> from the NHUsers group is that MSSQL may sometimes return invalid SCOPE_IDENTITY() value.       </li>
<li><b>Guid.Native        <br /></b>If I am to speak in terms of MsSQL terminology, it uses the NEWID() function to get a uniqueidentifier. </li>
</ol>
<p><b>Comparison</b></p>
<p>I hear you say &ldquo;you speak too much, all those doesn&rsquo;t tell much, show me the code!&rdquo; There it is, the comparison of post insert generators vs ORM style generators.</p>
<p>I will first start with demonstrating how they break UoW, then continue with Batcher! (did you know that NH uses NonBatchingBatcher by default? ;) )</p>
<p>The code under test is simple</p>
<pre class="code">[<span style="color: #2b91af">Test</span>]<br /><span style="color: blue">public void </span>Should_not_insert_entity_in_a_transaction_HiLo()<br />{<br />    <span style="color: blue">var </span>post = <span style="color: blue">new </span><span style="color: #2b91af">PostWithHiLo </span>{Title = <span style="color: #a31515">"Identity Generators Revealed"</span>};<br />    <span style="color: blue">var </span>postComment = <span style="color: blue">new </span><span style="color: #2b91af">PostCommentWithHiLo </span>{ Post = post, Comment = <span style="color: #a31515">"Comment" </span>};<br />    <span style="color: blue">using </span>(<span style="color: #2b91af">ISession </span>session = factory.OpenSession())<br />    <span style="color: blue">using </span>(<span style="color: blue">var </span>tran = session.BeginTransaction())<br />    {<br />        session.Save(post); <span style="color: green">//No commit here<br />        </span>session.Save(postComment);<br />        <span style="color: blue">long </span>insertCount = factory.Statistics.EntityInsertCount;<br />        <span style="color: #2b91af">Assert</span>.That(insertCount, <span style="color: #2b91af">Is</span>.EqualTo(0), <span style="color: #a31515">"Shouldn't insert entity in a transaction before commit."</span>);<br />    }<br />}<br /><br />[<span style="color: #2b91af">Test</span>]<br /><span style="color: blue">public void </span>Should_not_insert_entity_in_a_transaction_Identity()<br />{<br />    <span style="color: blue">var </span>post = <span style="color: blue">new </span><span style="color: #2b91af">PostWithIdentity </span>{Title = <span style="color: #a31515">"Identity Generators Revealed"</span>};<br />    <span style="color: blue">var </span>postComment = <span style="color: blue">new </span><span style="color: #2b91af">PostCommentWithIdentity </span>{Post = post, Comment = <span style="color: #a31515">"Comment"</span>};<br />    <span style="color: blue">using </span>(<span style="color: #2b91af">ISession </span>session = factory.OpenSession())<br />    <span style="color: blue">using </span>(<span style="color: blue">var </span>tran = session.BeginTransaction())<br />    {<br />        session.Save(post);<br />        session.Save(postComment);<br />        <span style="color: blue">long </span>insertCount = factory.Statistics.EntityInsertCount;<br />        <span style="color: #2b91af">Assert</span>.That(insertCount, <span style="color: #2b91af">Is</span>.EqualTo(0), <span style="color: #a31515">"Shouldn't insert entity in a transaction before commit."</span>);<br />    }<br />}</pre>
<p>Now, let&rsquo;s try it. What do you expect in both cases? Should both test pass? The test with <b>identity strategy fails</b> as it tries to insert the entity even before calling a commit.</p>
<p>Now here is the explanation for the batcher:</p>
<pre class="code"><span style="color: blue">using </span>(<span style="color: #2b91af">ISession </span>session = factory.OpenSession())<br /><span style="color: blue">using </span>(<span style="color: blue">var </span>tran = session.BeginTransaction())<br />{<br />    <span style="color: blue">for </span>(<span style="color: blue">int </span>i = 0; i &lt; 3; i++)<br />    {<br />        <span style="color: blue">var </span>post = <span style="color: blue">new </span><span style="color: #2b91af">PostWithHiLo </span>{Title = <span style="color: blue">string</span>.Format(<span style="color: #a31515">"Identity Generators Revealed {0}"</span>, i)};<br />        session.Save(post);<br />    }<br />    tran.Commit();<br />}</pre>
<p>The upper code sends queries to database only once. However, if you&rsquo;re using the Identity style generators, then you&rsquo;re in trouble.</p>
<p><b>Conclusion</b></p>
<p>You should know what you&rsquo;re gaining and what you&rsquo;re losing when using an identifier strategies. In case of a greenfield application, my choice would be to use HiLo as it is more user friendly(and this is what NH team suggests actually), and Guid.Comb in case a replication kinda thing is required. Most probably I wouldn&rsquo;t use Identity. However, on a brownfield application, where you can&rsquo;t really change the DB schema for some reason, than Identity should be used as a last resort. </p>
<p>I&rsquo;d like to end this post with two sayings that I hear/see from Fabio</p>
<p><b>Human knowledge belongs to the world! 
    <br />Quality is not achieved by chance!</b></p>
