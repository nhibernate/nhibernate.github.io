---
layout: post
title: "Introducing NHiberate and WPF: The ChinookMediaManager"
date: 2009-08-16 00:26:25 +1200
comments: true
published: true
categories: ["blogs", "nhibernate", "archive"]
tags: ["Session", "WPF"]
redirect_from: ["/blogs/nhibernate/archive/2009/08/15/introducing-nhiberate-and-wpf-the-chinookmediamanager.aspx/", "/blogs/nhibernate/archive/2009/08/15/introducing-nhiberate-and-wpf-the-chinookmediamanager.html"]
author: jfromainello
gravatar: d1a7e0fbfb2c1d9a8b10fd03648da78f
---
{% include imported_disclaimer.html %}

<p>As you can note in my previous posts I’ve talked a lot about NHibernate and WPF. So I've decided to write an ongoing series of blog posts about the integration of these two technologies. </p>  <h3>Motivation</h3>  <p>The motivation behind this series of posts is very simple most of the articles that you can read about NHibernate are for web technologies such as ASP.Net or ASP.NET MVC. Despite the fact that NHibernate is an <em>ORM</em> and has nothing to do with the presentation layer there are certain consideration that you have to take into account to build a good architecture. </p>  <h3>Sample Domain</h3>  <p>For this series of post I have chosen to use a small subset of the <a href="http://www.codeplex.com/ChinookDatabase">Chinook</a> database with few modifications. I have changed all the Identities primary keys to HiLo. You can find both the original and the slightly modified version <a href="http://code.google.com/p/unhaddins/source/browse/#svn/trunk/SampleDomain">here</a> (with class, mappings and read only tests).</p>  <p>This is the full database schema:</p>  <p><img src="/images/posts/2009/08/16/ChinookDatabaseSchema1.1.png" width="609" height="492" /> </p>  <p>However we will focus in this subset of the domain:    <br />    <br /><a href="http://nhforge.org/cfs-file.ashx/__key/CommunityServer.Blogs.Components.WeblogFiles/nhibernate/ClassDiagram1_5F00_055516A1.png"><img src="/images/MissingPicture.png"/><!--<img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="ClassDiagram1" border="0" alt="ClassDiagram1" src="http://nhforge.org/cfs-file.ashx/__key/CommunityServer.Blogs.Components.WeblogFiles/nhibernate/ClassDiagram1_5F00_thumb_5F00_4FDEE52C.png" width="331" height="477" />--></a> </p>  <p>&#160;</p>  <h3>A word about session management</h3>  <p>Most of the examples of NHibernate for web applications uses a pattern called “Session-per-Request”, this means that the session and the transaction has the same lifetime that the web request. This pattern is very easy to work with and very easy to understood but is not suitable for desktop applications.    <br />There are two antipatterns called “session-per-application” and “session-per-call” that you need to avoid.     <br />The pattern that I will use for this series is called “conversation per bussines transactions” and is very well described by his inventor <a href="http://fabiomaulo.blogspot.com/">Fabio Maulo</a>. I’ve learned a lot with Fabio and <a href="http://gustavoringel.blogspot.com/">Gustavo Ringel</a>&#160; about CpBT. </p>  <p></p>  <h3>A word about data binding</h3>  <p>In this series of post we will make intensive use of WPF data binding capabilities. Is for that reason that I’ve written <a href="http://code.google.com/p/unhaddins/source/browse/#svn/trunk/uNhAddIns/uNhAddIns.WPF">uNHAddIns.WPF</a> that uses NHibernate extensions points to bring us few behaviors that we need for data binding.</p>  <h4>The interface that we have to solve</h4>  <p><a href="http://nhforge.org/cfs-file.ashx/__key/CommunityServer.Blogs.Components.WeblogFiles/nhibernate/albums_5F00_37E02626.png"><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="albums" border="0" alt="albums" src="/images/posts/2009/08/16/albums_5F00_thumb_5F00_03647540.png" width="482" height="388" /></a> </p>  <p>The user need this very complex GUI. The user-story is as follows:</p>  <ul>   <li>The user can have multiple instances of this window open for editing albums of different artists. </li>    <li>The user can add albums. </li>    <li>The user can add tracks to the new albums and preexistent albums. </li>    <li>None of the information is persisted until the user press “Save All”. </li>    <li>If the user press close the application will ask to the user if he really want to discard all changes. </li> </ul>  <p>   <br />This is all for now, in the next post I will talk about the architecture that I will use.</p>
