---
layout: post
title: "Ensuring updates on Flush"
date: 2009-04-03 15:01:00 -0300
comments: true
published: true
categories: ["blogs", "nhibernate", "archive"]
tags: ["event listener", "NHibernate"]
alias: ["/blogs/nhibernate/archive/2009/04/03/ensuring-updates-on-flush.aspx"]
author: fabiomaulo
gravatar: cd6db202ce94ed7e5f1fde30e702dc7f
---
{% include imported_disclaimer.html %}
<p>Two assertions:</p>
<ul>
<li>I like the dirty check of NHibernate because I can work without worry about explicit updates. </li>
<li>I don&rsquo;t like the dirty check of NHibernate because I can&rsquo;t have full control about updates and the dirty-check, in my application, is slow. </li>
</ul>
<p>Both true ? Can we implements something to prevent Auto-Dirty-Check on flush ?</p>
<h4>Domain</h4>
<p><a href="/cfs-file.ashx/__key/CommunityServer.Blogs.Components.WeblogFiles/nhibernate/Domain_5F00_003F435D.png"><img border="0" width="496" src="/cfs-file.ashx/__key/CommunityServer.Blogs.Components.WeblogFiles/nhibernate/Domain_5F00_thumb_5F00_28DDAF64.png" alt="Domain" height="466" style="border-top-width: 0px; display: block; border-left-width: 0px; float: none; border-bottom-width: 0px; margin-left: auto; margin-right: auto; border-right-width: 0px" title="Domain" /></a></p>
<h4>Test</h4>
<h5>Part of the configuration</h5>
<pre class="code"><span style="color: blue">&lt;</span><span style="color: #a31515">property </span><span style="color: red">name</span><span style="color: blue">=</span>"<span style="color: blue">generate_statistics</span>"<span style="color: blue">&gt;</span>true<span style="color: blue">&lt;/</span><span style="color: #a31515">property</span><span style="color: blue">&gt;</span></pre>
<p>
<a href="http://11011.net/software/vspaste"></a></p>
<p>I&rsquo;m using NHibernate <a href="/blogs/nhibernate/archive/2008/10/26/exploring-nhibernate-statistics-part-1-simple-data-fetching.aspx">SessionFactory statistics</a> to check some operation.</p>
<h5>Populating DB</h5>
<pre class="code"><span style="color: blue">public void </span>FillDb()<br />{<br />sessionFactory.EncloseInTransaction(session =&gt;<br />{<br />    <span style="color: blue">for </span>(<span style="color: blue">int </span>i = 0; i &lt; 100; i++)<br />    {<br />        <span style="color: blue">var </span>reptileFamily = <span style="color: #2b91af">ReptileFamilyBuilder<br />            </span>.StartRecording()<br />            .WithChildren(2)<br />            .Build();<br /><br />        session.Save(ReptilesfamilyEntityName, reptileFamily);<br />    }<br /><br />    <span style="color: blue">for </span>(<span style="color: blue">int </span>i = 0; i &lt; 100; i++)<br />    {<br />        <span style="color: blue">var </span>humanFamily = <span style="color: #2b91af">HumanFamilyBuilder<br />            </span>.StartRecording()<br />            .WithChildren(1)<br />            .Build();<br /><br />        session.Save(HumanfamilyEntityName, humanFamily);<br />    }<br />});<br />}</pre>
<p>In a transaction I&rsquo;m creating 100 <span style="color: #2b91af">Family</span>&lt;<span style="color: #2b91af">Reptile</span>&gt; and 100 <span style="color: #2b91af">Family</span>&lt;<span style="color: #2b91af">Human</span>&gt;. Each <span style="color: #2b91af">Family</span>&lt;<span style="color: #2b91af">Reptile</span>&gt; has a father, a mother and two children (total 5 entities). Each <span style="color: #2b91af">Family</span>&lt;<span style="color: #2b91af">Human</span>&gt; has a father, a mother and one children (total 4 entities). The DB will have 900 entities states (the Family is mapped to use <span style="text-decoration: underline;">all cascade</span>).</p>
<h5>The test</h5>
<pre class="code"><span style="color: blue">public void </span>ShouldNotAutoUpdate()<br />{<br />FillDb();<br /><br /><span style="color: blue">using </span>(<span style="color: #2b91af">ISession </span>s = sessionFactory.OpenSession())<br /><span style="color: blue">using </span>(<span style="color: #2b91af">ITransaction </span>tx = s.BeginTransaction())<br />{<br />    <span style="color: blue">var </span>reptiles = s.CreateQuery(<span style="color: #a31515">"from ReptilesFamily"</span>)<br />        .Future&lt;<span style="color: #2b91af">Family</span>&lt;<span style="color: #2b91af">Reptile</span>&gt;&gt;();<br /><br />    <span style="color: blue">var </span>humans = s.CreateQuery(<span style="color: #a31515">"from HumanFamily"</span>)<br />        .Future&lt;<span style="color: #2b91af">Family</span>&lt;<span style="color: #2b91af">Human</span>&gt;&gt;();<br /><br />    ModifyAll(reptiles);<br />    ModifyAll(humans);<br /><br />    sessionFactory.Statistics.Clear();<br /><br />    s.Update(ReptilesfamilyEntityName, reptiles.First());<br />    s.Update(HumanfamilyEntityName, humans.First());<br /><br />    tx.Commit();<br />}<br /><br />sessionFactory.Statistics.EntityUpdateCount<br />    .Should().Be.Equal(7);<br /><br />CleanDb();<br />}</pre>
<p>After populate the DB I&rsquo;m loading and modifying all instances of <span style="color: #2b91af">Human</span> and <span style="color: #2b91af">Reptile</span> (that mean 400 entities of Reptile and 300 entities of Human). The result is that I have 900 entities loaded and 700 modified in a session.</p>
<p>In the two session.Update I&rsquo;m calling explicitly the update only for the first <span style="color: #2b91af">Family</span>&lt;<span style="color: #2b91af">Reptile</span>&gt; and the first <span style="color: #2b91af">Family</span>&lt;<span style="color: #2b91af">Human</span>&gt; (that mean only for 7 entities).</p>
<p>The test assertion is:</p>
<pre class="code">sessionFactory.Statistics.EntityUpdateCount<br />.Should().Be.Equal(7);</pre>
<p>
<a href="http://11011.net/software/vspaste"></a></p>
<p>The summary is that even if I have 700 modified entities,&nbsp; NHibernate should update only 7 entities because I call explicitly Update only for two families.</p>
<h4>How change the default behavior</h4>
<p>If you are familiar with NH2.0.0 and above you can imagine which will be the place where look&hellip; yes, <strong>Events/Listeners</strong>.</p>
<p>As first the configuration where you can see which events I&rsquo;m using and which listeners and in which order will be executed.</p>
<pre class="code">        <span style="color: blue">&lt;</span><span style="color: #a31515">event </span><span style="color: red">type</span><span style="color: blue">=</span>"<span style="color: blue">delete</span>"<span style="color: blue">&gt;<br /><br />            &lt;</span><span style="color: #a31515">listener<br />                </span><span style="color: red">class</span><span style="color: blue">=</span>"<span style="color: blue">DisableAutoDirtyCheck.PreDeleteEventListener, DisableAutoDirtyCheck</span>"<span style="color: blue">/&gt;<br /><br />            &lt;</span><span style="color: #a31515">listener<br />                </span><span style="color: red">class</span><span style="color: blue">=</span>"<span style="color: blue">NHibernate.Event.Default.DefaultDeleteEventListener, NHibernate</span>"<span style="color: blue">/&gt;<br /><br />        &lt;/</span><span style="color: #a31515">event</span><span style="color: blue">&gt;<br /><br />        &lt;</span><span style="color: #a31515">event </span><span style="color: red">type</span><span style="color: blue">=</span>"<span style="color: blue">update</span>"<span style="color: blue">&gt;<br /><br />            &lt;</span><span style="color: #a31515">listener<br />                </span><span style="color: red">class</span><span style="color: blue">=</span>"<span style="color: blue">DisableAutoDirtyCheck.PreUpdateEventListener, DisableAutoDirtyCheck</span>"<span style="color: blue">/&gt;<br /><br />            &lt;</span><span style="color: #a31515">listener<br />                </span><span style="color: red">class</span><span style="color: blue">=</span>"<span style="color: blue">NHibernate.Event.Default.DefaultUpdateEventListener, NHibernate</span>"<span style="color: blue">/&gt;<br />        &lt;/</span><span style="color: #a31515">event</span><span style="color: blue">&gt;<br /><br />        &lt;</span><span style="color: #a31515">listener<br />            </span><span style="color: red">class</span><span style="color: blue">=</span>"<span style="color: blue">DisableAutoDirtyCheck.PostLoadEventListener, DisableAutoDirtyCheck</span>"<br />            <span style="color: red">type</span><span style="color: blue">=</span>"<span style="color: blue">post-load</span>"<span style="color: blue">/&gt;<br /></span></pre>
<p>
<a href="http://11011.net/software/vspaste"></a></p>
<h5>Tricks</h5>
<p>The real Dirty-Check happen in the <span style="color: #2b91af">DefaultFlushEntityEventListener</span> using the <em>session state</em>. All entities loaded, in what is commonly named session-cache, are loaded in the <span style="text-decoration: underline;">Session.PersistenceContext</span>. To be very short the PersistenceContext is a set of <span style="color: #2b91af">EntityEntry</span>. An <span style="color: #2b91af">EntityEntry</span> is the responsible to maintain <strong>the state and the Status</strong> of an entity.</p>
<p>The real trick behind all this matter is this extension:</p>
<pre class="code"><span style="color: blue">public static class </span><span style="color: #2b91af">Extensions<br /></span>{<br /><span style="color: blue">private static readonly </span><span style="color: #2b91af">FieldInfo </span>statusFieldInfo =<br />    <span style="color: blue">typeof </span>(<span style="color: #2b91af">EntityEntry</span>).GetField(<span style="color: #a31515">"status"</span>,<span style="color: #2b91af">BindingFlags</span>.NonPublic | <span style="color: #2b91af">BindingFlags</span>.Instance);<br /><br /><span style="color: blue">public static void </span>BackSetStatus(<span style="color: blue">this </span><span style="color: #2b91af">EntityEntry </span>entry, <span style="color: #2b91af">Status </span>status)<br />{<br />    statusFieldInfo.SetValue(entry, status);<br />}<br />}</pre>
<h5>Listeners implementation</h5>
<pre class="code"><span style="color: blue">public class </span><span style="color: #2b91af">PostLoadEventListener </span>: <span style="color: #2b91af">IPostLoadEventListener<br /></span>{<br /><span style="color: blue">public void </span>OnPostLoad(<span style="color: #2b91af">PostLoadEvent </span>@event)<br />{<br />    <span style="color: #2b91af">EntityEntry </span>entry = @event.Session.PersistenceContext.GetEntry(@event.Entity);<br />    entry.BackSetStatus(<span style="color: #2b91af">Status</span>.ReadOnly);<br />}<br />}</pre>
<p>After load an entity, the instance is marked as <strong>ReadOnly</strong> but maintaining the <em>loaded-state </em>(maintain the loaded state is the reason to use the above trick).</p>
<pre class="code"><span style="color: blue">public class </span><span style="color: #2b91af">PreUpdateEventListener </span>: <span style="color: #2b91af">ISaveOrUpdateEventListener<br /></span>{<br /><span style="color: blue">public static readonly </span><span style="color: #2b91af">CascadingAction </span>ResetReadOnly = <span style="color: blue">new </span><span style="color: #2b91af">ResetReadOnlyCascadeAction</span>();<br /><br /><span style="color: blue">public void </span>OnSaveOrUpdate(<span style="color: #2b91af">SaveOrUpdateEvent </span>@event)<br />{<br />    <span style="color: blue">var </span>session = @event.Session;<br />    <span style="color: #2b91af">EntityEntry </span>entry = session.PersistenceContext.GetEntry(@event.Entity);<br />    <span style="color: blue">if </span>(entry != <span style="color: blue">null </span>&amp;&amp; entry.Persister.IsMutable &amp;&amp; entry.Status == <span style="color: #2b91af">Status</span>.ReadOnly)<br />    {<br />        entry.BackSetStatus(<span style="color: #2b91af">Status</span>.Loaded);<br />        CascadeOnUpdate(@event, entry.Persister, @event.Entity);<br />    }<br />}<br /><br /><span style="color: blue">private static void </span>CascadeOnUpdate(<span style="color: #2b91af">SaveOrUpdateEvent </span>@event, <span style="color: #2b91af">IEntityPersister </span>persister, <span style="color: blue">object </span>entity)<br />{<br />    <span style="color: #2b91af">IEventSource </span>source = @event.Session;<br />    source.PersistenceContext.IncrementCascadeLevel();<br />    <span style="color: blue">try<br />    </span>{<br />        <span style="color: blue">new </span><span style="color: #2b91af">Cascade</span>(ResetReadOnly, <span style="color: #2b91af">CascadePoint</span>.BeforeFlush, source).CascadeOn(persister, entity);<br />    }<br />    <span style="color: blue">finally<br />    </span>{<br />        source.PersistenceContext.DecrementCascadeLevel();<br />    }<br />}<br />}</pre>
<p>When an entity is explicitly updated, before execute the default behavior I&rsquo;m restoring the <strong>Status</strong> of the loaded entity (obviously for all the entities loaded an involved in cascade actions).</p>
<h4>Conclusion</h4>
<p>Can we have full control over NHibernate&rsquo;s updates&nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp; <strong>Yes, we can!! </strong>;-)</p>
<p>Code available <a href="http://code.google.com/p/unhaddins/source/browse/#svn/HunabKu/src/DisableAutoDirtyCheck/DisableAutoDirtyCheck">here</a>.</p>
<p><a target="_blank" href="http://fabiomaulo.blogspot.com/">My blog.</a></p>
