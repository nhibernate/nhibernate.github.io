---
layout:
---
<!doctype html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="canonical" href="http://nhibernate.info/doc/nhibernate-reference/index.html" />
   <title>NHibernate - Relational Persistence for Idiomatic .NET</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="#d0e1" title="NHibernate - Relational Persistence for Idiomatic .NET"><link rel="next" href="#preface" title="Preface"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>NHibernate - Relational Persistence for Idiomatic .NET</h1></div><div><h2 class="subtitle">NHibernate Reference Documentation</h2></div><div><p class="releaseinfo">5.3</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#quickstart">1. Quick-start with IIS and Microsoft SQL Server</a></span></dt><dd><dl><dt><span class="sect1"><a href="#quickstart-intro">1.1. Getting started with NHibernate</a></span></dt><dt><span class="sect1"><a href="#quickstart-persistentclass">1.2. First persistent class</a></span></dt><dt><span class="sect1"><a href="#quickstart-mapping">1.3. Mapping the cat</a></span></dt><dt><span class="sect1"><a href="#quickstart-playingwithcats">1.4. Playing with cats</a></span></dt><dt><span class="sect1"><a href="#quickstart-summary">1.5. Finally</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">2. Architecture</a></span></dt><dd><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. Overview</a></span></dt><dt><span class="sect1"><a href="#architecture-states">2.2. Instance states</a></span></dt><dt><span class="sect1"><a href="#architecture-current-session">2.3. Contextual Sessions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#session-configuration">3. ISessionFactory Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. Programmatic Configuration</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. Obtaining an ISessionFactory</a></span></dt><dt><span class="sect1"><a href="#configuration-userjdbc">3.3. User provided ADO.NET connection</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.4. NHibernate provided ADO.NET connection</a></span></dt><dt><span class="sect1"><a href="#configuration-provider">3.5. Using a custom configuration provider</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.6. Optional configuration properties</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.6.1. SQL Dialects</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.6.2. Outer Join Fetching</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.6.3. Custom ICacheProvider</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.6.4. Query Language Substitution</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-systemlevel">3.6.5. System level optional properties</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.7. Logging</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.8. Implementing an INamingStrategy</a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.9. XML Configuration File</a></span></dt></dl></dd><dt><span class="chapter"><a href="#persistent-classes">4. Persistent Classes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#persistent-classes-poco">4.1. A simple POCO example</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-poco-accessors">4.1.1. Declare properties for persistent fields</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-poco-constructor">4.1.2. Implement a default constructor</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-poco-identifier">4.1.3. Provide an identifier property (optional)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-poco-sealed">4.1.4. Prefer non-sealed classes and virtual methods (optional)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. Implementing inheritance</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. Implementing Equals() and GetHashCode()</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-dynamicmodels">4.4. Dynamic models</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-tuplizers">4.5. Tuplizers</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-lifecycle">4.6. Lifecycle Callbacks</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-validatable">4.7. IValidatable callback</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mapping">5. Basic O/R Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. Mapping declaration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-xmlns">5.1.1. XML Namespace</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subselect">5.1.4. subselect</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.5. id</a></span></dt><dd><dl><dt><span class="sect3"><a href="#mapping-declaration-id-generator">5.1.5.1. generator</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-hilo">5.1.5.2. Hi/Lo Algorithm</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-uuid-hex">5.1.5.3. UUID Hex Algorithm</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-uuid-string">5.1.5.4. UUID String Algorithm</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-guid">5.1.5.5. GUID Algorithms</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-sequences">5.1.5.6. Identity columns and Sequences</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-assigned">5.1.5.7. Assigned Identifiers</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-select">5.1.5.8. Primary keys assigned by triggers</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-enhanced">5.1.5.9. Enhanced identifier generators</a></span></dt></dl></dd><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.6. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.7. discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.8. version (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.9. timestamp (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.10. property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.11. many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.12. one-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-naturalid">5.1.13. natural-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.14. component, dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-properties">5.1.15. properties</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.16. subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.17. joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-unionsubclass">5.1.18. union-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-join">5.1.19. join</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-key">5.1.20. key</a></span></dt><dt><span class="sect2"><a href="#mapping-column">5.1.21. column and formula elements</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-collections">5.1.22. map, set, list, bag</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.23. import</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.1.24. any</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. NHibernate Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. Entities and values</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. Basic value types</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.3. Custom value types</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-entityname">5.3. Mapping a class more than once</a></span></dt><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.4. SQL quoted identifiers</a></span></dt><dt><span class="sect1"><a href="#mapping-modularfiles">5.5. Modular mapping files</a></span></dt><dt><span class="sect1"><a href="#mapping-generated">5.6. Generated Properties</a></span></dt><dt><span class="sect1"><a href="#mapping-database-object">5.7. Auxiliary Database Objects</a></span></dt><dt><span class="sect1"><a href="#mapping-meta">5.8. Meta data</a></span></dt></dl></dd><dt><span class="chapter"><a href="#collections">6. Collection Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. Persistent Collections</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. Mapping a Collection</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-foreignkeys">6.2.1. Collection foreign keys</a></span></dt><dt><span class="sect2"><a href="#collections-elements">6.2.2. Collection elements</a></span></dt><dt><span class="sect2"><a href="#collections-indexed">6.2.3. Indexed collections</a></span></dt><dt><span class="sect2"><a href="#collections-ofvalues">6.2.4. Collections of Values and Many-To-Many Associations</a></span></dt><dt><span class="sect2"><a href="#collections-onetomany">6.2.5. One-To-Many Associations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-advancedmappings">6.3. Advanced collection mappings</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-sorted">6.3.1. Sorted Collections</a></span></dt><dt><span class="sect2"><a href="#collections-bidirectional">6.3.2. Bidirectional Associations</a></span></dt><dt><span class="sect2"><a href="#collections-indexedbidirectional">6.3.3. Bidirectional associations with indexed collections</a></span></dt><dt><span class="sect2"><a href="#collections-ternary">6.3.4. Ternary Associations</a></span></dt><dt><span class="sect2"><a href="#collections-idbag">6.3.5. Using an &lt;idbag&gt;</a></span></dt><dt><span class="sect2"><a href="#collections-heterogeneous">6.3.6. Heterogeneous Associations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-lazy">6.4. Lazy Initialization</a></span></dt><dt><span class="sect1"><a href="#collections-example">6.5. Collection examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#associations">7. Association Mappings</a></span></dt><dd><dl><dt><span class="sect1"><a href="#associations-intro">7.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#associations-unidirectional">7.2. Unidirectional associations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#associations-unidirectional-m21">7.2.1. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#associations-unidirectional-121">7.2.2. One-to-one</a></span></dt><dt><span class="sect2"><a href="#associations-unidirectional-12m">7.2.3. One-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#associations-unidirectional-join">7.3. Unidirectional associations with join tables</a></span></dt><dd><dl><dt><span class="sect2"><a href="#associations-unidirectional-join-12m">7.3.1. One-to-Many</a></span></dt><dt><span class="sect2"><a href="#associations-unidirectional-join-m21">7.3.2. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#associations-unidirectional-join-121">7.3.3. One-to-one</a></span></dt><dt><span class="sect2"><a href="#associations-unidirectional-join-m2m">7.3.4. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#associations-bidirectional">7.4. Bidirectional associations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#associations-bidirectional-m21">7.4.1. One-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#associations-bidirectional-121">7.4.2. One-to-one</a></span></dt></dl></dd><dt><span class="sect1"><a href="#associations-bidirectional-join">7.5. Bidirectional associations with join tables</a></span></dt><dd><dl><dt><span class="sect2"><a href="#associations-bidirectional-join-12m">7.5.1. One-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#associations-bidirectional-join-121">7.5.2. One-to-one</a></span></dt><dt><span class="sect2"><a href="#associations-bidirectional-join-m2m">7.5.3. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#associations-complex">7.6. More complex association mappings</a></span></dt></dl></dd><dt><span class="chapter"><a href="#components">8. Component Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#components-dependentobjects">8.1. Dependent objects</a></span></dt><dt><span class="sect1"><a href="#components-incollections">8.2. Collections of dependent objects</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">8.3. Components as IDictionary indices</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">8.4. Components as composite identifiers</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">8.5. Dynamic components</a></span></dt></dl></dd><dt><span class="chapter"><a href="#inheritance">9. Inheritance Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#inheritance-strategies">9.1. The Three Strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#inheritance-tableperclass">9.1.1. Table per class hierarchy</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass">9.1.2. Table per subclass</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass-discriminator">9.1.3. Table per subclass, using a discriminator</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixing-tableperclass-tablepersubclass">9.1.4. Mixing table per class hierarchy with table per subclass</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcrete">9.1.5. Table per concrete class</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcreate-polymorphism">9.1.6. Table per concrete class, using implicit polymorphism</a></span></dt><dt><span class="sect2"><a href="#inheritace-mixingpolymorphism">9.1.7. Mixing implicit polymorphism with other inheritance mappings</a></span></dt></dl></dd><dt><span class="sect1"><a href="#inheritance-limitations">9.2. Limitations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#manipulatingdata">10. Manipulating Persistent Data</a></span></dt><dd><dl><dt><span class="sect1"><a href="#manipulatingdata-creating">10.1. Creating a persistent object</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-loading">10.2. Loading an object</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-querying">10.3. Querying</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-scalarqueries">10.3.1. Scalar queries</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-queryinterface">10.3.2. The IQuery interface</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-filtering">10.3.3. Filtering collections</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-criteria">10.3.4. Criteria queries</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-nativesql">10.3.5. Queries in native SQL</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-updating">10.4. Updating objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-updating-insession">10.4.1. Updating in the same ISession</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-updating-detached">10.4.2. Updating detached objects</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-update-lock">10.4.3. Reattaching detached objects</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-deleting">10.5. Deleting persistent objects</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-flushing">10.6. Flush</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-dirtiness">10.7. Checking dirtiness</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-endingsession">10.8. Ending a Session</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-endingsession-flushing">10.8.1. Flushing the Session</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-endingsession-commit">10.8.2. Committing the database transaction</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-endingsession-close">10.8.3. Closing the ISession</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-exceptions">10.9. Exception handling</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-graphs">10.10. Lifecycles and object graphs</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-interceptors">10.11. Interceptors</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-metadata">10.12. Metadata API</a></span></dt></dl></dd><dt><span class="chapter"><a href="#readonly">11. Read-only entities</a></span></dt><dd><dl><dt><span class="section"><a href="#readonly-api">11.1. Making persistent entities read-only</a></span></dt><dd><dl><dt><span class="section"><a href="#readonly-api-immutable">11.1.1. Entities of immutable classes</a></span></dt><dt><span class="section"><a href="#readonly-api-loaddefault">11.1.2. Loading persistent entities as read-only</a></span></dt><dt><span class="section"><a href="#readonly-api-querycriteria">11.1.3. Loading read-only entities from an HQL query/criteria</a></span></dt><dt><span class="section"><a href="#readonly-api-entity">11.1.4. Making a persistent entity read-only</a></span></dt></dl></dd><dt><span class="section"><a href="#readonly-proptypes">11.2. Read-only affect on property type</a></span></dt><dd><dl><dt><span class="section"><a href="#readonly-proptypes-simple">11.2.1. Simple properties</a></span></dt><dt><span class="section"><a href="#readonly-prop-types-unidir">11.2.2. Unidirectional associations</a></span></dt><dd><dl><dt><span class="section"><a href="#readonly-proptypes-singleended-unidir">11.2.2.1. Unidirectional one-to-one and many-to-one</a></span></dt><dt><span class="section"><a href="#readonly-proptypes-manyended-unidir">11.2.2.2. Unidirectional one-to-many and many-to-many</a></span></dt></dl></dd><dt><span class="section"><a href="#readonly-proptypes-bidir">11.2.3. Bidirectional associations</a></span></dt><dd><dl><dt><span class="section"><a href="#readonly-proptypes-onetoone-bidir">11.2.3.1. Bidirectional one-to-one</a></span></dt><dt><span class="section"><a href="#readonly-proptypes-onetomany-manytoone">11.2.3.2. Bidirectional one-to-many/many-to-one</a></span></dt><dt><span class="section"><a href="#readonly-proptypes-manytomany-bidir">11.2.3.3. Bidirectional many-to-many</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#transactions">12. Transactions And Concurrency</a></span></dt><dd><dl><dt><span class="sect1"><a href="#transactions-basics">12.1. Configurations, Sessions and Factories</a></span></dt><dt><span class="sect1"><a href="#transactions-threads">12.2. Threads and connections</a></span></dt><dt><span class="sect1"><a href="#transactions-identity">12.3. Considering object identity</a></span></dt><dt><span class="sect1"><a href="#transactions-optimistic">12.4. Optimistic concurrency control</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-longsession">12.4.1. Long session with automatic versioning</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">12.4.2. Many sessions with automatic versioning</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-customizing">12.4.3. Customizing automatic versioning</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-manual">12.4.4. Application version checking</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-disconnection">12.5. Session disconnection</a></span></dt><dt><span class="sect1"><a href="#transactions-locking">12.6. Pessimistic Locking</a></span></dt><dt><span class="sect1"><a href="#transactions-connection-release">12.7. Connection Release Modes</a></span></dt><dt><span class="sect1"><a href="#transactions-scopes">12.8. Transaction scopes (System.Transactions)</a></span></dt></dl></dd><dt><span class="chapter"><a href="#events">13. Interceptors and events</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-interceptors">13.1. Interceptors</a></span></dt><dt><span class="sect1"><a href="#objectstate-events">13.2. Event system</a></span></dt></dl></dd><dt><span class="chapter"><a href="#batch">14. Batch processing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#batch-inserts">14.1. Batch inserts</a></span></dt><dt><span class="sect1"><a href="#batch-statelesssession">14.2. The StatelessSession interface</a></span></dt><dt><span class="sect1"><a href="#batch-direct">14.3. DML-style operations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queryhql">15. HQL: The Hibernate Query Language</a></span></dt><dd><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">15.1. Case Sensitivity</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">15.2. The from clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">15.3. Associations and joins</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">15.4. The select clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">15.5. Aggregate functions</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">15.6. Polymorphic queries</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">15.7. The where clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">15.8. Expressions</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">15.9. The order by clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">15.10. The group by clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">15.11. Sub-queries</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">15.12. HQL examples</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">15.13. Tips &amp; Tricks</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querycriteria">16. Criteria Queries</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querycriteria-creating">16.1. Creating an ICriteria instance</a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">16.2. Narrowing the result set</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">16.3. Ordering the results</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">16.4. Associations</a></span></dt><dt><span class="sect1"><a href="#querycriteria_entityjoin">16.5. Join entities without association (Entity joins or ad hoc joins)</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">16.6. Dynamic association fetching</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">16.7. Example queries</a></span></dt><dt><span class="sect1"><a href="#querycriteria-projection">16.8. Projections, aggregation and grouping</a></span></dt><dt><span class="sect1"><a href="#querycriteria-detachedqueries">16.9. Detached queries and sub-queries</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queryqueryover">17. QueryOver Queries</a></span></dt><dd><dl><dt><span class="sect1"><a href="#queryqueryover-querystructure">17.1. Structure of a Query</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-simpleexpressions">17.2. Simple Expressions</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-additionalrestrictions">17.3. Additional Restrictions</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-associations">17.4. Associations</a></span></dt><dt><span class="sect1"><a href="#queryqueryover_entityjoin">17.5. Join entities without association (Entity joins or ad hoc joins)</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-aliases">17.6. Aliases</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-projections">17.7. Projections</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-projectionfunctions">17.8. Projection Functions</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-projectionentities">17.9. Entities Projection</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-subqueries">17.10. Sub-queries</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querylinq">18. Linq Queries</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querylinq-querystructure">18.1. Structure of a Query</a></span></dt><dt><span class="sect1"><a href="#querylinq-parametertypes">18.2. Parameter types</a></span></dt><dt><span class="sect1"><a href="#querylinq-supportedmethods">18.3. Supported methods and members</a></span></dt><dd><dl><dt><span class="sect2"><a href="#querylinq-supportedmethods-common">18.3.1. Common methods</a></span></dt><dt><span class="sect2"><a href="#querylinq-supportedmethods-datetime">18.3.2. DateTime and DateTimeOffset</a></span></dt><dt><span class="sect2"><a href="#querylinq-supportedmethods-icollection">18.3.3. ICollection, non generic and generic</a></span></dt><dt><span class="sect2"><a href="#querylinq-supportedmethods-idictionary">18.3.4. IDictionary, non generic and generic</a></span></dt><dt><span class="sect2"><a href="#querylinq-supportedmethods-math">18.3.5. Mathematical functions</a></span></dt><dt><span class="sect2"><a href="#querylinq-supportedmethods-nullables">18.3.6. Nullables</a></span></dt><dt><span class="sect2"><a href="#querylinq-supportedmethods-string">18.3.7. Strings</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querylinq-futureresults">18.4. Future results</a></span></dt><dt><span class="sect1"><a href="#querylinq-fetching">18.5. Fetching associations</a></span></dt><dt><span class="sect1"><a href="#querylinq-modifying">18.6. Modifying entities inside the database</a></span></dt><dd><dl><dt><span class="sect2"><a href="#querylinq-modifying-insert">18.6.1. Inserting new entities</a></span></dt><dt><span class="sect2"><a href="#querylinq-modifying-update">18.6.2. Updating entities</a></span></dt><dt><span class="sect2"><a href="#querylinq-modifying-delete">18.6.3. Deleting entities</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querylinq-querycache">18.7. Query cache</a></span></dt><dt><span class="sect1"><a href="#querylinq-extending">18.8. Extending the Linq to NHibernate provider</a></span></dt><dd><dl><dt><span class="sect2"><a href="#querylinq-extending-sqlfunctions">18.8.1. Adding SQL functions</a></span></dt><dt><span class="sect2"><a href="#querylinq-extending-generator">18.8.2. Adding a custom generator</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#querysql">19. Native SQL</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querysql-creating">19.1. Using an ISQLQuery</a></span></dt><dd><dl><dt><span class="sect2"><a href="#querysql-scalar">19.1.1. Scalar queries</a></span></dt><dt><span class="sect2"><a href="#querysql-entity">19.1.2. Entity queries</a></span></dt><dt><span class="sect2"><a href="#querysql-associations-collections">19.1.3. Handling associations and collections</a></span></dt><dt><span class="sect2"><a href="#querysql-multiple-entities">19.1.4. Returning multiple entities</a></span></dt><dd><dl><dt><span class="sect3"><a href="#querysql-aliasreferences">19.1.4.1. Alias and property references</a></span></dt></dl></dd><dt><span class="sect2"><a href="#querysql-non-managed-entities">19.1.5. Returning non-managed entities</a></span></dt><dt><span class="sect2"><a href="#querysql-inheritance">19.1.6. Handling inheritance</a></span></dt><dt><span class="sect2"><a href="#querysql-parameters">19.1.7. Parameters</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-namedqueries">19.2. Named SQL queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#propertyresults">19.2.1. Using return-property to explicitly specify column/alias
      names</a></span></dt><dt><span class="sect2"><a href="#sp_query">19.2.2. Using stored procedures for querying</a></span></dt><dd><dl><dt><span class="sect3"><a href="#querysql-limits-storedprocedures">19.2.2.1. Rules/limitations for using stored procedures</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#querysql-cud">19.3. Custom SQL for create, update and delete</a></span></dt><dt><span class="sect1"><a href="#querysql-load">19.4. Custom SQL for loading</a></span></dt></dl></dd><dt><span class="chapter"><a href="#filters">20. Filtering data</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-filters">20.1. NHibernate filters</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">21. Improving performance</a></span></dt><dd><dl><dt><span class="sect1"><a href="#performance-fetching">21.1. Fetching strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-fetching-lazy">21.1.1. Working with lazy associations</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-custom">21.1.2. Tuning fetch strategies</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-proxies">21.1.3. Single-ended association proxies</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-initialization">21.1.4. Initializing collections and proxies</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-batch">21.1.5. Using batch fetching</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-subselect">21.1.6. Using subselect fetching</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-cache">21.2. The Second Level Cache</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">21.2.1. Cache mappings</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">21.2.2. Strategy: read only</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">21.2.3. Strategy: read/write</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">21.2.4. Strategy: nonstrict read/write</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">21.3. Managing the caches</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">21.4. The Query Cache</a></span></dt><dt><span class="sect1"><a href="#performance-collections">21.5. Understanding Collection performance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">21.5.1. Taxonomy</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">21.5.2. Lists, maps, idbags and sets are the most efficient collections to update</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">21.5.3. Bags and lists are the most efficient inverse collections</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">21.5.4. One shot delete</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-batch-updates">21.6. Batch updates</a></span></dt><dt><span class="sect1"><a href="#performance-multi-query">21.7. Query batch</a></span></dt><dt><span class="sect1"><a href="#performance-future">21.8. Future results</a></span></dt></dl></dd><dt><span class="chapter"><a href="#toolsetguide">22. Toolset Guide</a></span></dt><dd><dl><dt><span class="sect1"><a href="#toolsetguide-s1">22.1. Schema Generation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">22.1.1. Customizing the schema</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">22.1.2. Running the tool</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#example-parentchild">23. Example: Parent/Child</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-parentchild-collections">23.1. A note about collections</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">23.2. Bidirectional one-to-many</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">23.3. Cascading lifecycle</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">23.4. Using cascading Update()</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">23.5. Conclusion</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-weblog">24. Example: Weblog Application</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-weblog-classes">24.1. Persistent Classes</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">24.2. NHibernate Mappings</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">24.3. NHibernate Code</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-mappings">25. Example: Various Mappings</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-mappings-emp">25.1. Employer/Employee</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">25.2. Author/Work</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">25.3. Customer/Order/Product</a></span></dt><dt><span class="sect1"><a href="#example-mappings-miscellaneous">25.4. Miscellaneous example mappings</a></span></dt><dd><dl><dt><span class="sect2"><a href="#example-mappings-miscellaneous-typed121">25.4.1. "Typed" one-to-one association</a></span></dt><dt><span class="sect2"><a href="#example-mappings-miscellaneous-compositekey">25.4.2. Composite key example</a></span></dt><dt><span class="sect2"><a href="#example-mappings-miscellaneous-m2mcomposite">25.4.3. Many-to-many with shared composite key attribute</a></span></dt><dt><span class="sect2"><a href="#example-mappings-miscellaneous-contentdiscriminator">25.4.4. Content based discrimination</a></span></dt><dt><span class="sect2"><a href="#example-mappings-miscellaneous-propertyref">25.4.5. Associations on alternate keys</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#best-practices">26. Best Practices</a></span></dt><dt><span class="part"><a href="#part-contrib">I. NHibernateContrib Documentation</a></span></dt><dd><dl><dt><span class="preface"><a href="#contrib-preface">Preface</a></span></dt><dt><span class="chapter"><a href="#caches">27. NHibernate.Caches</a></span></dt><dd><dl><dt><span class="section"><a href="#NHibernate.Caches-howto">27.1. How to use a cache?</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.ConfigurationProvider">27.2. Using a custom configuration provider</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.Prevalence">27.3. Prevalence Cache Configuration</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.SysCache">27.4. SysCache Configuration</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.SysCache2">27.5. SysCache2 Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#NHibernate.Caches.SysCache2-Table">27.5.1. Table-based Dependency</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.SysCache2-Command">27.5.2. Command-Based Dependencies</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.SysCache2-Aggregate">27.5.3. Aggregate Dependencies</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.SysCache2-AdditionalSettings">27.5.4. Additional Settings</a></span></dt></dl></dd><dt><span class="section"><a href="#NHibernate.Caches.EnyimMemcached">27.6. EnyimMemcached Configuration</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.RtMemoryCache">27.7. RtMemoryCache Configuration</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.StackExchangeRedis">27.8. NHibernate.Caches.StackExchangeRedis Configuration</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.CoreMemoryCache">27.9. CoreMemoryCache Configuration</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.CoreDistributedCache">27.10. CoreDistributedCache Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#NHibernate.Caches.CoreDistributedCache.Memcached">27.10.1. Memcached distributed cache factory</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.CoreDistributedCache.Redis">27.10.2. Redis distributed cache factory</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.CoreDistributedCache.SqlServer">27.10.3. SQL Server distributed cache factory</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.CoreDistributedCache.Memory">27.10.4. Memory distributed cache factory</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#mapping-attributes">28. NHibernate.Mapping.Attributes</a></span></dt><dd><dl><dt><span class="section"><a href="#mapping-attributes-new">28.1. What's new?</a></span></dt><dt><span class="section"><a href="#mapping-attributes-howto">28.2. How to use it?</a></span></dt><dt><span class="section"><a href="#mapping-attributes-tips">28.3. Tips</a></span></dt><dt><span class="section"><a href="#mapping-attributes-todo">28.4. Known issues and TODOs</a></span></dt><dt><span class="section"><a href="#mapping-attributes-devnotes">28.5. Developer Notes</a></span></dt></dl></dd></dl></dd></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div><div></div></div><p>
		Working with object-oriented software and a relational database can be cumbersome
		and time consuming in today's enterprise environments. NHibernate is an object/relational
		mapping tool for .NET environments. The term object/relational mapping (<span class="emphasis"><em>ORM</em></span>) refers to
		the technique of mapping a data representation from an object model to a relational
		data model with a SQL-based schema.
	</p><p>
		NHibernate not only takes care of the mapping from .NET classes to
		database tables (and from .NET data types to SQL data types), but also provides data
		query and retrieval facilities and can significantly reduce development time otherwise
		spent with manual data handling in SQL and ADO.NET.
	</p><p>
		NHibernate's goal is to relieve the developer from 95 percent of common data persistence
		related programming tasks. NHibernate may not be the best solution for data-centric
		applications that only use stored-procedures to implement the business logic in the
		database, it is most useful with object-oriented domain models and business logic in
		the .NET-based middle-tier. However, NHibernate can certainly help you to remove or
		encapsulate vendor-specific SQL code and will help with the common task of result set
		translation from a tabular representation to a graph of objects.
	</p><p>
		If you are new to NHibernate and Object/Relational Mapping or even .NET Framework,
		please follow these steps:
	</p><div class="orderedlist"><ol type="1"><li><p>
				Read <a href="#quickstart" title="Chapter&nbsp;1.&nbsp;Quick-start with IIS and Microsoft SQL Server">Chapter&nbsp;1, <i>Quick-start with IIS and Microsoft SQL Server</i></a> for a 30 minute tutorial,
				using Internet Information Services (IIS) web server.
			</p></li><li><p>
				Read <a href="#architecture" title="Chapter&nbsp;2.&nbsp;Architecture">Chapter&nbsp;2, <i>Architecture</i></a> to understand the environments where
				NHibernate can be used.
			</p></li><li><p>
				Use this reference documentation as your primary source of information.
				Consider reading <span class="emphasis"><em><a href="https://www.manning.com/books/hibernate-in-action" target="_top">Hibernate in Action</a></em></span>
				(java)
				or <span class="emphasis"><em><a href="https://www.manning.com/books/nhibernate-in-action" target="_top">NHibernate in Action</a></em></span>
				or <span class="emphasis"><em><a href="https://www.packtpub.com/application-development/nhibernate-40-cookbook" target="_top">NHibernate
				4.x Cookbook - Second Edition</a></em></span>
				or <span class="emphasis"><em><a href="https://www.packtpub.com/application-development/nhibernate-2-beginners-guide" target="_top">NHibernate 2 Beginner's
				Guide</a></em></span> if you need more help
				with application design or if you prefer a step-by-step tutorial. Also visit
				<a href="http://nhibernate.sourceforge.net/NHibernateEg/" target="_top">http://nhibernate.sourceforge.net/NHibernateEg/</a> for NHibernate
				tutorial with examples.
			</p></li><li><p>
        FAQs are answered on the <a href="https://groups.google.com/forum/#!forum/nhusers" target="_top">NHibernate users group</a>.
      </p></li><li><p>
				The Community Area on the <a href="http://nhibernate.info/" target="_top">NHibernate website</a> is a good source for
				design patterns and various integration solutions (ASP.NET, Windows	Forms).
			</p></li></ol></div><p>
		 If you have questions, use the
		 <a href="https://groups.google.com/forum/#!forum/nhusers" target="_top">NHibernate user forum</a>.
		 We also provide a <a href="https://github.com/nhibernate/nhibernate-core/issues" target="_top">GitHub issue tracking system</a>
		 for bug reports and feature requests.
		 If you are interested in the development of NHibernate, join the developer mailing list.
		 If you are interested in translating this documentation into your language, contact us
		 on the <a href="https://groups.google.com/forum/#!forum/nhibernate-development" target="_top">developer mailing list</a>.
	 </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="quickstart"></a>Chapter&nbsp;1.&nbsp;Quick-start with IIS and Microsoft SQL Server</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-intro"></a>1.1.&nbsp;Getting started with NHibernate</h2></div></div><div></div></div><p>
            This tutorial explains a setup of NHibernate 5.0.0 within a Microsoft
            environment. The tools used in this tutorial are:
        </p><div class="orderedlist"><ol type="1"><li>
                Microsoft Internet Information Services (IIS) - web server supporting
                ASP.NET.
            </li><li>
                Microsoft SQL Server 2012 - the database server. This tutorial uses
                the desktop edition (SQL Express), a free download from Microsoft. Support
                for other databases is only a matter of changing the NHibernate SQL
                dialect and driver configuration.
            </li><li>
                Microsoft Visual Studio .NET (at least 2013) - the development environment.
            </li></ol></div><p>
            First, we have to create a new Web project. We use the name <tt class="literal">QuickStart</tt>.
            In the project, add a NuGet reference to <tt class="literal">NHibernate</tt>. Visual Studio
            will automatically copy the library and its dependencies to the project output directory.
            If you are using a database other than SQL Server, add a reference to its driver assembly
            to your project.
        </p><p>
            We now set up the database connection information for NHibernate. To do this, open
            the file <tt class="literal">Web.config</tt> automatically generated for your project and add
            configuration elements according to the listing below:
        </p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
  &lt;!-- Add this element --&gt;
  &lt;configSections&gt;
    &lt;section
        name="hibernate-configuration"
        type="NHibernate.Cfg.ConfigurationSectionHandler, NHibernate" /&gt;
  &lt;/configSections&gt;

  &lt;!-- Add this element --&gt;
  &lt;hibernate-configuration xmlns="urn:nhibernate-configuration-2.2"&gt;
    &lt;session-factory&gt;
      &lt;property name="dialect"&gt;NHibernate.Dialect.MsSql2012Dialect&lt;/property&gt;
      &lt;property name="connection.connection_string"&gt;
        Server=localhost\SQLEXPRESS;initial catalog=quickstart;Integrated Security=True
      &lt;/property&gt;

      &lt;mapping assembly="QuickStart" /&gt;
    &lt;/session-factory&gt;
  &lt;/hibernate-configuration&gt;

  &lt;!-- Leave the other sections unchanged --&gt;
  &lt;system.web&gt;
    ...
  &lt;/system.web&gt;
&lt;/configuration&gt;</pre><p>
            The <tt class="literal">&lt;configSections&gt;</tt> element contains definitions of
            sections that follow and handlers to use to process their content. We declare
            the handler for the configuration section here. The <tt class="literal">
            &lt;hibernate-configuration&gt;</tt> section contains the configuration
            itself, telling NHibernate that we will use a Microsoft SQL Server 2012
            database and connect to it through the specified connection string.
            The dialect is a required setting, databases differ in their interpretation
            of the SQL "standard". NHibernate will take care of the differences and comes
            bundled with dialects for several major commercial and open source databases.
        </p><p>
            An <tt class="literal">ISessionFactory</tt> is NHibernate's concept of a single
            datastore, multiple databases can be used by creating multiple XML
            configuration files and creating multiple <tt class="literal">Configuration</tt>
            and <tt class="literal">ISessionFactory</tt> objects in your application.
        </p><p>
            The last element of the <tt class="literal">&lt;hibernate-configuration&gt;</tt>
            section declares <tt class="literal">QuickStart</tt> as the name of an assembly
            containing class declarations and mapping files. The mapping files
            contain the metadata for the mapping of the POCO class to a database table
            (or multiple tables). We'll come back to mapping files soon. Let's write the
            POCO class first and then declare the mapping metadata for it.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-persistentclass"></a>1.2.&nbsp;First persistent class</h2></div></div><div></div></div><p>
            NHibernate works best with the Plain Old CLR Objects (POCOs, sometimes
            called Plain Ordinary CLR Objects) programming model for persistent classes.
            A POCO has its data accessible through the standard .NET property mechanisms,
            shielding the internal representation from the publicly visible interface:
        </p><pre class="programlisting">namespace QuickStart
{
    public class Cat
    {
        public virtual string Id { get; set; }

        public virtual string Name { get; set; }

        public virtual char Sex { get; set; }

        public virtual float Weight { get; set; }
    }
}</pre><p>
            NHibernate is not restricted in its usage of property types, all .NET
            types and primitives (like <tt class="literal">string</tt>, <tt class="literal">char</tt>
            and <tt class="literal">DateTime</tt>) can be mapped, including classes from the
            <tt class="literal">System.Collections.Generic</tt> namespace. You can map them as values,
            collections of values, or associations to other entities. The <tt class="literal">Id</tt>
            is a special property that represents the database identifier (primary key) of
            that class, it is highly recommended for entities like a <tt class="literal">Cat</tt>.
            NHibernate can use identifiers only internally, without having to declare them
            on the class, but we would lose some of the flexibility in our application
            architecture.
        </p><p>
            No special interface has to be implemented for persistent classes nor do we have
            to subclass from a special root persistent class. NHibernate also doesn't use any
            build time processing, such as IL manipulation, it relies solely on
            .NET reflection and runtime class enhancement.
            So, without any dependency in the POCO class on NHibernate, we can map it to
            a database table.
        </p><p>
            For the above mentioned runtime class enhancement to work, NHibernate requires that all
            public properties of an entity class are declared as <tt class="literal">virtual</tt>. It also
            requires a parameter-less constructor:  if you add a constructor having parameters,
            make sure to add a parameter-less constructor too.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-mapping"></a>1.3.&nbsp;Mapping the cat</h2></div></div><div></div></div><p>
            This tutorial directly uses xml mapping files. This is just one among many mapping solutions
            NHibernate provides, see <a href="#mapping-declaration" title="5.1.&nbsp;Mapping declaration">Section&nbsp;5.1, &#8220;Mapping declaration&#8221;</a>.
        </p><p>
            The <tt class="literal">Cat.hbm.xml</tt> mapping file contains the metadata
            required for the object/relational mapping. The metadata includes declaration
            of persistent classes and the mapping of properties (to columns and
            foreign key relationships to other entities) to database tables.
        </p><p>
            Please note that the <tt class="literal">Cat.hbm.xml</tt> file should be set to an embedded resource.
        </p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    namespace="QuickStart" assembly="QuickStart"&gt;

    &lt;class name="Cat" table="Cat"&gt;

        &lt;!-- A 32 hex character is our surrogate key. It's automatically
            generated by NHibernate with the UUID pattern. --&gt;
        &lt;id name="Id"&gt;
            &lt;column name="CatId" sql-type="char(32)" not-null="true"/&gt;
            &lt;generator class="uuid.hex" /&gt;
        &lt;/id&gt;

        &lt;!-- A cat has to have a name, but it shouldn't be too long. --&gt;
        &lt;property name="Name"&gt;
            &lt;column name="Name" length="16" not-null="true" /&gt;
        &lt;/property&gt;
        &lt;property name="Sex" /&gt;
        &lt;property name="Weight" /&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Every persistent class should have an identifier attribute (actually, only
            classes representing entities, not dependent value objects, which
            are mapped as components of an entity). This property is used to distinguish
            persistent objects: Two cats are equal if
            <tt class="literal">catA.Id.Equals(catB.Id)</tt> is true, this concept is
            called <span class="emphasis"><em>database identity</em></span>. NHibernate comes bundled with
            various identifier generators for different scenarios (including native generators
            for database sequences, hi/lo identifier tables, and application assigned
            identifiers). We use the UUID generator (only recommended for testing, as integer
            surrogate keys generated by the database should be preferred) and also specify the
            column <tt class="literal">CatId</tt> of the table <tt class="literal">Cat</tt> for the
            NHibernate generated identifier value (as a primary key of the table).
        </p><p>
            All other properties of <tt class="literal">Cat</tt> are mapped to the same table. In
            the case of the <tt class="literal">Name</tt> property, we mapped it with an explicit
            database column declaration. This is especially useful when the database
            schema is automatically generated (as SQL DDL statements) from the mapping
            declaration with NHibernate's <span class="emphasis"><em>SchemaExport</em></span> tool. All other
            properties are mapped using NHibernate's default settings, which is what you
            need most of the time. Here the specification of the table name with the attribute
            <tt class="literal">table</tt> is redundant, it default to the class name when not specified.
            The table <tt class="literal">Cat</tt> in the database looks like this:
        </p><pre class="programlisting"> Column |     Type     | Modifiers
--------+--------------+----------------------
 CatId  | char(32)     | not null, primary key
 Name   | nvarchar(16) | not null
 Sex    | nchar(1)     |
 Weight | real         |</pre><p>
            You should now create the database and this table manually, and later read
            <a href="#toolsetguide" title="Chapter&nbsp;22.&nbsp;Toolset Guide">Chapter&nbsp;22, <i>Toolset Guide</i></a> if you want to automate this step with the
            SchemaExport tool. This tool can create a full SQL DDL, including table
            definition, custom column type constraints, unique constraints and indexes.
            If you are using SQL Server, you should also make sure the <tt class="literal">ASPNET</tt>
            user has permissions to use the database.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-playingwithcats"></a>1.4.&nbsp;Playing with cats</h2></div></div><div></div></div><p>
            We're now ready to start NHibernate's <tt class="literal">ISession</tt>. It is the
            <span class="emphasis"><em>persistence manager</em></span> interface, we use it
            to store and retrieve <tt class="literal">Cat</tt>s to and from the database.
            But first, we've to get an <tt class="literal">ISession</tt> (NHibernate's unit-of-work)
            from the <tt class="literal">ISessionFactory</tt>:
        </p><pre class="programlisting">ISessionFactory sessionFactory =
            new Configuration().Configure().BuildSessionFactory();</pre><p>
            An <tt class="literal">ISessionFactory</tt> is responsible for one database and
            may only use one XML configuration file (<tt class="literal">Web.config</tt> or
            <tt class="literal">hibernate.cfg.xml</tt>).
            You can set other properties (and even change the mapping metadata) by
            accessing the <tt class="literal">Configuration</tt> <span class="emphasis"><em>before</em></span>
            you build the <tt class="literal">ISessionFactory</tt> (it is immutable). Where
            do we create the <tt class="literal">ISessionFactory</tt> and how can we access
            it in our application?
        </p><p>
            An <tt class="literal">ISessionFactory</tt> is usually only built once,
            e.g. at start-up inside <tt class="literal">Application_Start</tt> event handler.
            This also means you should not keep it in an instance variable in your
            ASP.NET pages or MVC controllers, but in some other location. Furthermore,
            we need some kind of <span class="emphasis"><em>Singleton</em></span>, so we can access the
            <tt class="literal">ISessionFactory</tt> easily in application code. The approach
            shown next solves both problems: configuration and easy access to a
            <tt class="literal">ISessionFactory</tt>.
        </p><p>
            We implement a <tt class="literal">NHibernateHelper</tt> helper class:
        </p><pre class="programlisting">using System;
using System.Web;
using NHibernate;
using NHibernate.Cfg;

namespace QuickStart
{
    public sealed class NHibernateHelper
    {
        private const string CurrentSessionKey = "nhibernate.current_session";
        private static readonly ISessionFactory _sessionFactory;

        static NHibernateHelper()
        {
            _sessionFactory = new Configuration().Configure().BuildSessionFactory();
        }

        public static ISession GetCurrentSession()
        {
            var context = HttpContext.Current;
            var currentSession = context.Items[CurrentSessionKey] as ISession;

            if (currentSession == null)
            {
                currentSession = _sessionFactory.OpenSession();
                context.Items[CurrentSessionKey] = currentSession;
            }

            return currentSession;
        }

        public static void CloseSession()
        {
            var context = HttpContext.Current;
            var currentSession = context.Items[CurrentSessionKey] as ISession;

            if (currentSession == null)
            {
                // No current session
                return;
            }

            currentSession.Close();
            context.Items.Remove(CurrentSessionKey);
        }

        public static void CloseSessionFactory()
        {
            if (_sessionFactory != null)
            {
                _sessionFactory.Close();
            }
        }
    }
}</pre><p>
            This class does not only take care of the <tt class="literal">ISessionFactory</tt>
            with its static attribute, but also has code to remember the <tt class="literal">ISession</tt>
            for the current HTTP request.
        </p><p>
            An <tt class="literal">ISessionFactory</tt> is threadsafe, many threads can access
            it concurrently and request <tt class="literal">ISession</tt>s. An <tt class="literal">ISession</tt>
            is a non-threadsafe object that represents a single unit-of-work with the database.
            <tt class="literal">ISession</tt>s are opened by an <tt class="literal">ISessionFactory</tt> and
            are closed when all work is completed:
        </p><pre class="programlisting">ISession session = NHibernateHelper.GetCurrentSession();
try
{
    using (ITransaction tx = session.BeginTransaction())
    {
        var princess = new Cat
        {
            Name = "Princess",
            Sex = 'F',
            Weight = 7.4f
        };

        session.Save(princess);
        tx.Commit();
    }
}
finally
{
    NHibernateHelper.CloseSession();
}</pre><p>
            In an <tt class="literal">ISession</tt>, every database operation occurs inside a
            transaction that isolates the database operations (even read-only operations).
            We use NHibernate's <tt class="literal">ITransaction</tt> API to abstract from the underlying
            transaction strategy (in our case, ADO.NET transactions). Please note that the example
            above does not handle any exceptions.
        </p><p>
            Also note that you may call <tt class="literal">NHibernateHelper.GetCurrentSession();</tt>
            as many times as you like, you will always get the current <tt class="literal">ISession</tt>
            of this HTTP request. You have to make sure the <tt class="literal">ISession</tt> is closed
            after your unit-of-work completes, either in <tt class="literal">Application_EndRequest</tt>
            event handler in your application class, or with a MVC action filter, or in a
            <tt class="literal">HttpModule</tt> before the HTTP response is sent. The nice side effect
            of the latter is easy lazy initialization: the <tt class="literal">ISession</tt> is still
            open when the view is rendered, so NHibernate can load uninitialized objects while you
            navigate the graph.
        </p><p>
            NHibernate has various methods that can be used to retrieve objects from the
            database. Nowadays the most standard way is using Linq:
        </p><pre class="programlisting">using(var tx = session.BeginTransaction())
{
    var females = session
        .Query&lt;Cat&gt;()
        .Where(c =&gt; c.Sex == 'F')
        .ToList();
    foreach (var cat in females)
    {
        Console.Out.WriteLine("Female Cat: " + cat.Name);
    }

    tx.Commit();
}</pre><p>
            If you use an older NHibernate, you may have to import the
            <tt class="literal">NHibernate.Linq</tt> namespace.
        </p><p>
            NHibernate also offers an object-oriented <span class="emphasis"><em>query by criteria</em></span> API
            that can be used to formulate type-safe queries, the Hibernate Query Language (HQL),
            which is an easy to learn and powerful object-oriented extension to SQL, as well as a
            strongly-typed LINQ API which translates internally to HQL.
            NHibernate of course uses <tt class="literal">DbCommand</tt>s and parameter binding for all
            SQL communication with the database. You may also use NHibernate's direct SQL query
            feature or get a plain ADO.NET connection from an <tt class="literal">ISession</tt> in rare
            cases.
        </p><p>
            Since NHibernate 5.0, the session and its queries IO bound methods have async counterparts.
            Each call to an async method must be awaited before further interacting with the session or
            its queries.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-summary"></a>1.5.&nbsp;Finally</h2></div></div><div></div></div><p>
            We only scratched the surface of NHibernate in this small tutorial. Please note that
            we don't include any ASP.NET specific code in our examples. You have to create an
            ASP.NET page yourself and insert the NHibernate code as you see fit.
        </p><p>
            Keep in mind that NHibernate, as a data access layer, is tightly integrated into
            your application. Usually, all other layers depend on the persistence mechanism.
            Make sure you understand the implications of this design.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="architecture"></a>Chapter&nbsp;2.&nbsp;Architecture</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-overview"></a>2.1.&nbsp;Overview</h2></div></div><div></div></div><p>
            A (very) high-level view of the NHibernate architecture:
        </p><div class="mediaobject" align="center"><img src="../shared/images/overview.png" align="middle"></div><p>
            This diagram shows NHibernate using the database and configuration data to
            provide persistence services (and persistent objects) to the application.
        </p><p>
            We would like to show a more detailed view of the runtime architecture.
            Unfortunately, NHibernate is flexible and supports several approaches. We will
            show the two extremes. The "lite" architecture has the application
            provide its own ADO.NET connections and manage its own transactions. This approach
            uses a minimal subset of NHibernate's APIs:
        </p><div class="mediaobject" align="center"><img src="../shared/images/lite.png" align="middle"></div><p>
            The "full cream" architecture abstracts the application away from the
            underlying ADO.NET APIs and lets NHibernate take care of the details.
        </p><div class="mediaobject" align="center"><img src="../shared/images/fullcream.png" align="middle"></div><p>
            Here are some definitions of the objects in the diagrams:

            </p><div class="variablelist"><dl><dt><span class="term">ISessionFactory (<tt class="literal">NHibernate.ISessionFactory</tt>)</span></dt><dd><p>
                            A threadsafe (immutable) cache of compiled mappings for a single database.
                            A factory for <tt class="literal">ISession</tt> and a client of
                            <tt class="literal">IConnectionProvider</tt>. Might hold an optional (second-level)
                            cache of data that is reusable between transactions, at a
                            process- or cluster-level.
                        </p></dd><dt><span class="term">ISession (<tt class="literal">NHibernate.ISession</tt>)</span></dt><dd><p>
                            A single-threaded, short-lived object representing a conversation between
                            the application and the persistent store. Wraps an ADO.NET connection. Factory
                            for <tt class="literal">ITransaction</tt>. Holds a mandatory (first-level) cache
                            of persistent objects, used when navigating the object graph or looking up
                            objects by identifier.
                        </p></dd><dt><span class="term">Persistent Objects and Collections</span></dt><dd><p>
                            Short-lived, single threaded objects containing persistent state and business
                            function. These might be ordinary POCOs, the only special thing about
                            them is that they are currently associated with (exactly one)
                            <tt class="literal">ISession</tt>. As soon as the <tt class="literal">Session</tt> is closed,
                            they will be detached and free to use in any application layer (e.g. directly
                            as data transfer objects to and from presentation).
                        </p></dd><dt><span class="term">Transient Objects and Collections</span></dt><dd><p>
                            Instances of persistent classes that are not currently associated with a
                            <tt class="literal">ISession</tt>. They may have been instantiated by
                            the application and not (yet) persisted or they may have been instantiated by a
                            closed <tt class="literal">ISession</tt>.
                        </p></dd><dt><span class="term">ITransaction (<tt class="literal">NHibernate.ITransaction</tt>)</span></dt><dd><p>
                            (Optional) A single-threaded, short-lived object used by the application to
                            specify atomic units of work. Abstracts application from underlying ADO.NET
                            transaction. An <tt class="literal">ISession</tt> might span several
                            <tt class="literal">ITransaction</tt>s in some cases. Transaction scopes may be used
                            instead.
                        </p></dd><dt><span class="term">IConnectionProvider (<tt class="literal">NHibernate.Connection.IConnectionProvider</tt>)</span></dt><dd><p>
                            (Optional) A factory for ADO.NET connections and commands. Abstracts application
                            from the concrete vendor-specific implementations of <tt class="literal">DbConnection</tt>
                            and <tt class="literal">DbCommand</tt>. Not exposed to application, but can be
                            extended/implemented by the developer.
                        </p></dd><dt><span class="term">IDriver (<tt class="literal">NHibernate.Driver.IDriver</tt>)</span></dt><dd><p>
                            (Optional) An interface encapsulating differences between ADO.NET providers, such
                            as parameter naming conventions and supported ADO.NET features.
                        </p></dd><dt><span class="term">ITransactionFactory (<tt class="literal">NHibernate.Transaction.ITransactionFactory</tt>)</span></dt><dd><p>
                            (Optional) A factory for <tt class="literal">ITransaction</tt> instances. Not exposed to the
                            application, but can be extended/implemented by the developer.
                        </p></dd></dl></div><p>
        </p><p>
            Given a "lite" architecture, the application bypasses the
            <tt class="literal">ITransaction</tt>/<tt class="literal">ITransactionFactory</tt> and/or
            <tt class="literal">IConnectionProvider</tt> APIs to talk to ADO.NET directly.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-states"></a>2.2.&nbsp;Instance states</h2></div></div><div></div></div><p>
            An instance of a persistent classes may be in one of three different states,
            which are defined with respect to a <span class="emphasis"><em>persistence context</em></span>.
            The NHibernate <tt class="literal">ISession</tt> object is the persistence context:
        </p><div class="variablelist"><dl><dt><span class="term">transient</span></dt><dd><p>
                        The instance is not, and has never been associated with
                        any persistence context. It has no persistent identity
                        (primary key value).
                    </p></dd><dt><span class="term">persistent</span></dt><dd><p>
                        The instance is currently associated with a persistence 
                        context. It has a persistent identity (primary key value)
                        and, perhaps, a corresponding row in the database. For a
                        particular persistence context, NHibernate 
                        <span class="emphasis"><em>guarantees</em></span> that persistent identity
                        is equivalent to CLR identity (in-memory location of the
                        object).
                    </p></dd><dt><span class="term">detached</span></dt><dd><p>
                        The instance was once associated with a persistence
                        context, but that context was closed, or the instance
                        was serialized to another process. It has a persistent 
                        identity and, perhaps, a corresponding row in the database.
                        For detached instances, NHibernate makes no guarantees 
                        about the relationship between persistent identity and
                        CLR identity.
                    </p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-current-session"></a>2.3.&nbsp;Contextual Sessions</h2></div></div><div></div></div><p>
            Most applications using NHibernate need some form of "contextual" sessions, where a given
            session is in effect throughout the scope of a given context. However, across applications
            the definition of what constitutes a context is typically different; and different contexts
            define different scopes to the notion of current.
        </p><p>
            Starting with version 1.2, NHibernate added the <tt class="literal">ISessionFactory.GetCurrentSession()</tt>
            method. The processing behind <tt class="literal">ISessionFactory.GetCurrentSession()</tt> is pluggable.
            An extension interface (<tt class="literal">NHibernate.Context.ICurrentSessionContext</tt>) and a new
            configuration parameter (<tt class="literal">current_session_context_class</tt>) have been added
            to allow pluggability of the scope and context of defining current sessions.
        </p><p>
            See the API documentation for the <tt class="literal">NHibernate.Context.ICurrentSessionContext</tt>
            interface for a detailed discussion of its contract.  It defines a single method,
            <tt class="literal">CurrentSession()</tt>, by which the implementation is responsible for
            tracking the current contextual session.  Out-of-the-box, NHibernate comes with several
            implementations of this interface:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <tt class="literal">NHibernate.Context.AsyncLocalSessionContext</tt> - current sessions are tracked
                    by current asynchronous flow. You are responsible to bind and unbind an
                    <tt class="literal">ISession</tt> instance with static methods of class
                    <tt class="literal">CurrentSessionContext</tt>. Binding operations from inner flows will not be
                    propagated to outer or siblings flows. Added in NHibernate 5.0.
                </p></li><li><p>
                    <tt class="literal">NHibernate.Context.CallSessionContext</tt> - current sessions are tracked
                    by <tt class="literal">CallContext</tt>. You are responsible to bind and unbind an
                    <tt class="literal">ISession</tt> instance with static methods of class
                    <tt class="literal">CurrentSessionContext</tt>.
                </p></li><li><p>
                    <tt class="literal">NHibernate.Context.ThreadStaticSessionContext</tt> - current session is
                    stored in a thread-static variable. This context supports multiple session factory only
                    since NHibernate v5.
                    You are responsible to bind and unbind an <tt class="literal">ISession</tt> instance with
                    static methods of class <tt class="literal">CurrentSessionContext</tt>.
                </p></li><li><p>
                    <tt class="literal">NHibernate.Context.WebSessionContext</tt> -
                    stores the current session in <tt class="literal">HttpContext</tt>.
                    You are responsible to bind and unbind an <tt class="literal">ISession</tt>
                    instance with static methods of class <tt class="literal">CurrentSessionContext</tt>.
                </p></li><li><p>
                    <tt class="literal">NHibernate.Context.WcfOperationSessionContext</tt> - current sessions are tracked
                    by WCF <tt class="literal">OperationContext</tt>. You need to register the <tt class="literal">WcfStateExtension</tt>
                    extension in WCF. You are responsible to bind and unbind an <tt class="literal">ISession</tt>
                    instance with static methods of class <tt class="literal">CurrentSessionContext</tt>.
                </p></li><li><p>
                    <tt class="literal">NHibernate.Context.ManagedWebSessionContext</tt> - current
                    sessions are tracked by <tt class="literal">HttpContext</tt>. Removed in NHibernate 4.0
                    - <tt class="literal">NHibernate.Context.WebSessionContext</tt> should be used instead.
                    You are responsible to bind and unbind an <tt class="literal">ISession</tt> instance with static methods
                    on this class, it never opens, flushes, or closes an <tt class="literal">ISession</tt> itself.
                </p></li></ul></div><p>
            The <tt class="literal">current_session_context_class</tt> configuration parameter
            defines which <tt class="literal">NHibernate.Context.ICurrentSessionContext</tt> implementation
            should be used. Typically, the value of this parameter would just name the implementation
            class to use (including the assembly name); for the out-of-the-box implementations, however,
            there are corresponding short names: <tt class="literal">async_local</tt>, <tt class="literal">call</tt>,
            <tt class="literal">thread_static</tt>, <tt class="literal">web</tt> and <tt class="literal">wcf_operation</tt>,
            respectively.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="session-configuration"></a>Chapter&nbsp;3.&nbsp;ISessionFactory Configuration</h2></div></div><div></div></div><p>
        Because NHibernate is designed to operate in many different environments, there
        are a large number of configuration parameters. Fortunately, most have sensible
        default values and NHibernate is distributed with an example 
        <tt class="literal">App.config</tt> file (found in <tt class="literal">src\NHibernate.Test</tt>)
        that shows the various options. You usually only have to put that file in your
        project and customize it.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-programmatic"></a>3.1.&nbsp;Programmatic Configuration</h2></div></div><div></div></div><p>
            An instance of <tt class="literal">NHibernate.Cfg.Configuration</tt>
            represents an entire set of mappings of an application's .NET types to a
            SQL database. The <tt class="literal">Configuration</tt> is used to build an
            (immutable) <tt class="literal">ISessionFactory</tt>. The mappings are compiled
            from various XML mapping files.
        </p><p>
            You may obtain a <tt class="literal">Configuration</tt> instance by
            instantiating it directly. Here is an example of setting up a datastore from 
            mappings defined in two XML configuration files:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .AddFile("Item.hbm.xml")
    .AddFile("Bid.hbm.xml");</pre><p>
            An alternative (sometimes better) way is to let NHibernate load a mapping file
            from an embedded resource:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .AddClass(typeof(NHibernate.Auction.Item))
    .AddClass(typeof(NHibernate.Auction.Bid));</pre><p>
            Then NHibernate will look for mapping files named
            <tt class="literal">NHibernate.Auction.Item.hbm.xml</tt> and
            <tt class="literal">NHibernate.Auction.Bid.hbm.xml</tt> embedded as resources in the
            assembly that the types are contained in. This approach eliminates any hardcoded
            filenames.
        </p><p>
            Another alternative (probably the best) way is to let NHibernate load all of 
            the mapping files contained in an Assembly:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .AddAssembly( "NHibernate.Auction" );</pre><p>
            Then NHibernate will look through the assembly for any resources that
            end with <tt class="literal">.hbm.xml</tt>.  This approach eliminates 
            any hardcoded filenames and ensures the mapping files in the assembly
            get added.
        </p><p>
            If a tool like Visual Studio .NET or NAnt is used to build the assembly,
            then make sure that the <tt class="literal">.hbm.xml</tt> files are compiled
            into the assembly as <tt class="literal">Embedded Resources</tt>.
        </p><p>
            A <tt class="literal">Configuration</tt> also specifies various optional properties:
        </p><pre class="programlisting">var props = new Dictionary&lt;string, string&gt;();
...
Configuration cfg = new Configuration()
    .AddClass(typeof(NHibernate.Auction.Item))
    .AddClass(typeof(NHibernate.Auction.Bind))
    .SetProperties(props);</pre><p>
            A <tt class="literal">Configuration</tt> is intended as a configuration-time object, to be
            discarded once an <tt class="literal">ISessionFactory</tt> is built.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-sessionfactory"></a>3.2.&nbsp;Obtaining an ISessionFactory</h2></div></div><div></div></div><p>
            When all mappings have been parsed by the <tt class="literal">Configuration</tt>, the application
            must obtain a factory for <tt class="literal">ISession</tt> instances. This factory is intended
            to be shared by all application threads:
        </p><pre class="programlisting">ISessionFactory sessions = cfg.BuildSessionFactory();</pre><p>
            However, NHibernate does allow your application to instantiate more than one
            <tt class="literal">ISessionFactory</tt>. This is useful if you are using more than one database.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-userjdbc"></a>3.3.&nbsp;User provided ADO.NET connection</h2></div></div><div></div></div><p>
            An <tt class="literal">ISessionFactory</tt> may open an <tt class="literal">ISession</tt> on 
            a user-provided ADO.NET connection. This design choice frees the application to 
            obtain ADO.NET connections wherever it pleases:
        </p><pre class="programlisting">var conn = myApp.GetOpenConnection();
var session = sessions.OpenSession(conn);

// do some data access work</pre><p>
            The application must be careful not to open two concurrent
            <tt class="literal">ISession</tt>s on the same ADO.NET connection!
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-hibernatejdbc"></a>3.4.&nbsp;NHibernate provided ADO.NET connection</h2></div></div><div></div></div><p>
            Alternatively, you can have the <tt class="literal">ISessionFactory</tt>
            open connections for you. The <tt class="literal">ISessionFactory</tt>
            must be provided with ADO.NET connection properties in one of the
            following ways:
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    Pass an instance of <tt class="literal">IDictionary</tt> mapping
                    property names to property values to
                    <tt class="literal">Configuration.SetProperties()</tt>.
                </p></li><li><p>
                    Include <tt class="literal">&lt;property&gt;</tt> elements in a configuration
                    section in the application configuration file. The section should be named
                    <tt class="literal">hibernate-configuration</tt> and its handler set to
                    <tt class="literal">NHibernate.Cfg.ConfigurationSectionHandler</tt>.
                    The XML namespace of the section should be set to
                    <tt class="literal">urn:nhibernate-configuration-2.2</tt>.
                </p></li><li><p>
                    Include <tt class="literal">&lt;property&gt;</tt> elements in
                    <tt class="literal">hibernate.cfg.xml</tt> (discussed later).
                </p></li></ol></div><p>
            If you take this approach, opening an <tt class="literal">ISession</tt> is as simple as:
        </p><pre class="programlisting">ISession session = sessions.OpenSession(); // open a new Session
// do some data access work, an ADO.NET connection will be used on demand</pre><p>
            All NHibernate property names and semantics are defined on the class 
            <tt class="literal">NHibernate.Cfg.Environment</tt>. We will now describe the most
            important settings for ADO.NET connection configuration.
        </p><p>
            NHibernate will obtain (and pool) connections using an ADO.NET data provider
            if you set the following properties:
        </p><div class="table"><a name="d0e879"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;NHibernate ADO.NET Properties</b></p><table summary="NHibernate ADO.NET Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">connection.provider</tt></td><td>
                    The type of a custom <tt class="literal">IConnectionProvider</tt> implementation.
                    <p>
                        <span class="strong">eg.</span> 
                        <tt class="literal">full.classname.of.ConnectionProvider</tt> if the Provider 
                        is built into NHibernate, or <tt class="literal">full.classname.of.ConnectionProvider, 
                        assembly</tt> if using an implementation of <tt class="literal">IConnectionProvider</tt>
                        not included in NHibernate. The default is 
                        <tt class="literal">NHibernate.Connection.DriverConnectionProvider</tt>.
                    </p></td></tr><tr><td><tt class="literal">connection.driver_class</tt></td><td>
                    The type of a custom <tt class="literal">IDriver</tt>, if using <tt class="literal">DriverConnectionProvider</tt>.
                    <p>
                        <span class="strong">eg.</span>
                        <tt class="literal">full.classname.of.Driver</tt> if the Driver 
                        is built into NHibernate, or <tt class="literal">full.classname.of.Driver, assembly</tt> 
                        if using an implementation of IDriver not included in NHibernate.
                    </p><p>
                        This is usually not needed, most of the time the <tt class="literal">dialect</tt> will
                        take care of setting the <tt class="literal">IDriver</tt> using a sensible default.  See the API
                        documentation of the specific dialect for the defaults.
                    </p></td></tr><tr><td><tt class="literal">connection.connection_string</tt></td><td>
                    Connection string to use to obtain the connection.
                </td></tr><tr><td><tt class="literal">connection.connection_string_name</tt></td><td>
                    The name of the connection string (defined in <tt class="literal">&lt;connectionStrings&gt;</tt>
                    configuration file element) to use to obtain the connection.
                </td></tr><tr><td><tt class="literal">connection.isolation</tt></td><td>
                    Set the ADO.NET transaction isolation level. Check
                    <tt class="literal">System.Data.IsolationLevel</tt> for meaningful values
                    and the database's documentation to ensure that level is supported.
                    <p>
                        <span class="strong">eg.</span>
                        <tt class="literal">Chaos</tt> | <tt class="literal">ReadCommitted</tt> | <tt class="literal">ReadUncommitted</tt> |
                        <tt class="literal">RepeatableRead</tt> | <tt class="literal">Serializable</tt> | <tt class="literal">Unspecified</tt>
                    </p></td></tr><tr><td><tt class="literal">connection.release_mode</tt></td><td>
                    Specify when NHibernate should release ADO.NET connections.
                    See <a href="#transactions-connection-release" title="12.7.&nbsp;Connection Release Modes">Section&nbsp;12.7, &#8220;Connection Release Modes&#8221;</a>.
                    <p>
                        <span class="strong">eg.</span> 
                        <tt class="literal">auto</tt> (default) | <tt class="literal">on_close</tt> |
                        <tt class="literal">after_transaction</tt>
                    </p><p>
                        Note that for <tt class="literal">ISession</tt>s obtained through
                        <tt class="literal">ISessionFactory.GetCurrentSession</tt>, the
                        <tt class="literal">ICurrentSessionContext</tt> implementation configured for use
                        may control the connection release mode for those <tt class="literal">ISession</tt>s.
                        See <a href="#architecture-current-session" title="2.3.&nbsp;Contextual Sessions">Section&nbsp;2.3, &#8220;Contextual Sessions&#8221;</a>.
                    </p></td></tr><tr><td><tt class="literal">prepare_sql</tt></td><td>
                    Specify to prepare <tt class="literal">DbCommand</tt>s generated by NHibernate.
                    Defaults to <tt class="literal">false</tt>.
                    <p>
                        <span class="strong">eg.</span>
                        <tt class="literal">true</tt> | <tt class="literal">false</tt>
                    </p></td></tr><tr><td><tt class="literal">command_timeout</tt></td><td>
                    Specify the default timeout in seconds of <tt class="literal">DbCommand</tt>s
                    generated by NHibernate. Negative values disable it.
                    <p>
                        <span class="strong">eg.</span>
                        <tt class="literal">30</tt>
                    </p></td></tr><tr><td><tt class="literal">adonet.batch_size</tt></td><td>
                    Specify the batch size to use when batching update statements. Setting this to 0
                    (the default) disables the functionality.
                    See <a href="#performance-batch-updates" title="21.6.&nbsp;Batch updates">Section&nbsp;21.6, &#8220;Batch updates&#8221;</a>.
                    <p>
                        <span class="strong">eg.</span>
                        <tt class="literal">20</tt>
                    </p></td></tr><tr><td><tt class="literal">order_inserts</tt></td><td>
                    Enable ordering of insert statements for the purpose of more efficient batching. Defaults
                    to <tt class="literal">true</tt> if batching is enabled, <tt class="literal">false</tt> otherwise.
                    <p>
                        <span class="strong">eg.</span>
                        <tt class="literal">true</tt> | <tt class="literal">false</tt>
                    </p></td></tr><tr><td><tt class="literal">order_updates</tt></td><td>
                    Enable ordering of update statements for the purpose of more efficient batching. Defaults
                    to <tt class="literal">true</tt> if batching is enabled, <tt class="literal">false</tt> otherwise.
                    <p>
                        <span class="strong">eg.</span>
                        <tt class="literal">true</tt> | <tt class="literal">false</tt>
                    </p></td></tr><tr><td><tt class="literal">adonet.batch_versioned_data</tt></td><td>
                    If batching is enabled, specify that versioned data can also be batched. Requires a dialect which
                    batcher correctly returns rows count. Defaults to <tt class="literal">false</tt>.
                    <p>
                        <span class="strong">eg.</span>
                        <tt class="literal">true</tt> | <tt class="literal">false</tt>
                    </p></td></tr><tr><td><tt class="literal">adonet.factory_class</tt></td><td>
                    The class name of a <tt class="literal">IBatcherFactory</tt> implementation.
                    <p>
                        This is usually not needed, most of the time the <tt class="literal">driver</tt> will
                        take care of setting the <tt class="literal">IBatcherFactory</tt> using a sensible default
                        according to the database capabilities.
                    </p><p>
                        <span class="strong">eg.</span>
                        <tt class="literal">classname.of.BatcherFactory, assembly</tt>
                    </p></td></tr><tr><td><tt class="literal">adonet.wrap_result_sets</tt></td><td>
                    Some database vendor data reader implementation have inefficient columnName-to-columnIndex
                    resolution. Enabling this setting allows to wrap them in a data reader that will cache those
                    resolutions. Defaults to <tt class="literal">false</tt>.
                    <p>
                        <span class="strong">eg.</span>
                        <tt class="literal">true</tt> | <tt class="literal">false</tt>
                    </p></td></tr></tbody></table></div><p>
            This is an example of how to specify the database connection properties inside a 
            <tt class="literal">web.config</tt>:
        </p><a name="we-config-configuration"></a><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
  &lt;configSections&gt;
    &lt;section name="hibernate-configuration"
        type="NHibernate.Cfg.ConfigurationSectionHandler, NHibernate" /&gt;
  &lt;/configSections&gt;

  &lt;hibernate-configuration xmlns="urn:nhibernate-configuration-2.2"&gt;
    &lt;session-factory&gt;
      &lt;property name="dialect"&gt;NHibernate.Dialect.MsSql2012Dialect&lt;/property&gt;
      &lt;property name="connection.connection_string"&gt;
        Server=(local);initial catalog=theDb;Integrated Security=SSPI
      &lt;/property&gt;
      &lt;property name="connection.isolation"&gt;ReadCommitted&lt;/property&gt;
    &lt;/session-factory&gt;
  &lt;/hibernate-configuration&gt;

  &lt;!-- other app specific config follows --&gt;
&lt;/configuration&gt;</pre><p>
            NHibernate relies on the ADO.NET data provider implementation of connection pooling.
        </p><p>
            You may define your own plug-in strategy for obtaining ADO.NET connections by implementing the
            interface <tt class="literal">NHibernate.Connection.IConnectionProvider</tt>. You may select
            a custom implementation by setting <tt class="literal">connection.provider</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-provider"></a>3.5.&nbsp;Using a custom configuration provider</h2></div></div><div></div></div><p>
            By default, NHibernate attempts to read the <tt class="literal">hibernate-configuration</tt> section
            through the .Net <tt class="literal">ConfigurationManager</tt>. Some environments do not support it, so
            NHibernate provides a way to set a custom configuration provider, through the
            <tt class="literal">NHibernate.Cfg.ConfigurationProvider.Current</tt> property.
        </p><p>
            To disable the configuration provider, in case you configure NHibernate entirely programmatically,
            set this property to <tt class="literal">null</tt>.
        </p><pre class="programlisting">ConfigurationProvider.Current = null;</pre><p>
            To provide directly the <tt class="literal">System.Configuration.Configuration</tt> instance to use, assign
            the <tt class="literal">Current</tt> property with an instance of
            <tt class="literal">NHibernate.Cfg.SystemConfigurationProvider</tt> built with your
            <tt class="literal">Configuration</tt> instance.
        </p><pre class="programlisting">ConfigurationProvider.Current = new SystemConfigurationProvider(yourConfig);</pre><p>
            You may also derive a custom provider from <tt class="literal">NHibernate.Cfg.ConfigurationProvider</tt>,
            implements its abstract methods, and assign an instance of your custom provider to the
            <tt class="literal">NHibernate.Cfg.ConfigurationProvider.Current</tt> property.
        </p><p>
            Changes of the <tt class="literal">ConfigurationProvider.Current</tt> property value are to be done very
            early in the application lifecycle, before any other call on a NHibernate API. Otherwise they
            may not be taken into account.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-optional"></a>3.6.&nbsp;Optional configuration properties</h2></div></div><div></div></div><p>
            There are a number of other properties that control the behaviour of NHibernate
            at runtime. All are optional and have reasonable default values.
        </p><div class="table"><a name="configuration-optional-properties"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;NHibernate Configuration Properties</b></p><table summary="NHibernate Configuration Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">dialect</tt></td><td>
                            The class name of a NHibernate <tt class="literal">Dialect</tt> - enables
                            certain platform dependent features. See <a href="#configuration-optional-dialects" title="3.6.1.&nbsp;SQL Dialects">Section&nbsp;3.6.1, &#8220;SQL Dialects&#8221;</a>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">full.classname.of.Dialect, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">default_catalog</tt></td><td>
                            Qualify unqualified table names with the given catalog name
                            in generated SQL.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">CATALOG_NAME</tt>
                            </p></td></tr><tr><td><tt class="literal">default_schema</tt></td><td>
                            Qualify unqualified table names with the given schema/table-space
                            in generated SQL.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">SCHEMA_NAME</tt>
                            </p></td></tr><tr><td><tt class="literal">max_fetch_depth</tt></td><td>
                            Set a maximum "depth" for the outer join fetch tree
                            for single-ended associations (one-to-one, many-to-one).
                            A <tt class="literal">0</tt> disables default outer join fetching.
                            <p>
                                <span class="strong">eg.</span> 
                                recommended values between <tt class="literal">0</tt> and <tt class="literal">3</tt>
                            </p></td></tr><tr><td><tt class="literal">cache.use_second_level_cache</tt></td><td>
                            Enable the second level cache. Requires specifying a <tt class="literal">cache.provider_class</tt>.
                            See <a href="#caches" title="Chapter&nbsp;27.&nbsp;NHibernate.Caches">Chapter&nbsp;27, <i>NHibernate.Caches</i></a>. Defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">cache.provider_class</tt></td><td>
                            The class name of a <tt class="literal">ICacheProvider</tt> implementation.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.CacheProvider, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">cache.use_minimal_puts</tt></td><td>
                            Optimize second-level cache operation to minimize writes, at the
                            cost of more frequent reads (useful for clustered caches).
                            Defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">cache.use_query_cache</tt></td><td>
                            Enable the query cache, individual queries still have to be set cacheable.
                            Defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">cache.query_cache_factory</tt></td><td>
                            The class name of a custom <tt class="literal">IQueryCacheFactory</tt> implementation.
                            Defaults to the built-in <tt class="literal">StandardQueryCacheFactory</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.QueryCacheFactory, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">cache.region_prefix</tt></td><td>
                            A prefix to use for second-level cache region names.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">prefix</tt>
                            </p></td></tr><tr><td><tt class="literal">cache.default_expiration</tt></td><td>
                            The default expiration delay in seconds for cached entries, for providers supporting
                            this setting.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">300</tt>
                            </p></td></tr><tr><td><tt class="literal">query.substitutions</tt></td><td>
                            Mapping from tokens in NHibernate queries to SQL tokens
                            (tokens might be function or literal names, for example).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</tt>
                            </p></td></tr><tr><td><tt class="literal">query.default_cast_length</tt></td><td>
                            Set the default length used in casting when the target type is length bound and
                            does not specify it. Defaults to <tt class="literal">4000</tt>, automatically trimmed down
                            according to dialect type registration.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">255</tt>
                            </p></td></tr><tr><td><tt class="literal">query.default_cast_precision</tt></td><td>
                            Set the default precision used in casting when the target type is decimal and
                            does not specify it. Defaults to <tt class="literal">28</tt>, automatically trimmed down
                            according to dialect type registration.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">19</tt>
                            </p></td></tr><tr><td><tt class="literal">query.default_cast_scale</tt></td><td>
                            Set the default scale used in casting when the target type is decimal and
                            does not specify it. Defaults to <tt class="literal">10</tt>, automatically trimmed down
                            according to dialect type registration.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">5</tt>
                            </p></td></tr><tr><td><tt class="literal">query.startup_check</tt></td><td>
                            Should named queries be checked during startup (the default is enabled).
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">query.factory_class</tt></td><td>
                            The class name of a custom <tt class="literal">IQueryTranslatorFactory</tt> implementation
                            (HQL query parser factory). Defaults to the built-in
                            <tt class="literal">ASTQueryTranslatorFactory</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.QueryTranslatorFactory, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">query.linq_provider_class</tt></td><td>
                            The class name of a custom <tt class="literal">INhQueryProvider</tt> implementation
                            (LINQ provider). Defaults to the built-in <tt class="literal">DefaultQueryProvider</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.LinqProvider, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">query.query_model_rewriter_factory</tt></td><td>
                            The class name of a custom <tt class="literal">IQueryModelRewriterFactory</tt> implementation
                            (LINQ query model rewriter factory). Defaults to <tt class="literal">null</tt> (no rewriter).
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.QueryModelRewriterFactory, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">query.pre_transformer_registrar</tt></td><td>
                            The class name of the LINQ query pre-transformer registrar, implementing
                            <tt class="literal">IExpressionTransformerRegistrar</tt>. Defaults to <tt class="literal">null</tt> (no registrar).
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.ExpressionTransformerRegistrar, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">linqtohql.generatorsregistry</tt></td><td>
                            The class name of a custom <tt class="literal">ILinqToHqlGeneratorsRegistry</tt> implementation.
                            Defaults to the built-in <tt class="literal">DefaultLinqToHqlGeneratorsRegistry</tt>. See
                            <a href="#querylinq-extending-generator" title="18.8.2.&nbsp;Adding a custom generator">Section&nbsp;18.8.2, &#8220;Adding a custom generator&#8221;</a>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.LinqToHqlGeneratorsRegistry, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">linqtohql.legacy_preevaluation</tt></td><td>
                            Whether to use the legacy pre-evaluation or not in Linq queries. Defaults to <tt class="literal">true</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p><p>
                                Legacy pre-evaluation is causing special properties or functions like <tt class="literal">DateTime.Now</tt>
                                or <tt class="literal">Guid.NewGuid()</tt> to be always evaluated with the .Net runtime and replaced in the
                                query by parameter values.
                            </p><p>
                                The new pre-evaluation allows them to be converted to HQL function calls which will be run on the db
                                side. This allows for example to retrieve the server time instead of the client time, or to generate
                                UUIDs for each row instead of an unique one for all rows.
                            </p><p>
                                The new pre-evaluation will likely be enabled by default in the next major version (6.0).
                            </p></td></tr><tr><td><tt class="literal">linqtohql.fallback_on_preevaluation</tt></td><td>
                            When the new pre-evaluation is enabled, should methods which translation is not supported by the current
                            dialect fallback to pre-evaluation? Defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p><p>
                                When this fallback option is enabled while legacy pre-evaluation is disabled, properties or functions
                                like <tt class="literal">DateTime.Now</tt> or <tt class="literal">Guid.NewGuid()</tt> used in Linq expressions
                                will not fail when the dialect does not support them, but will instead be pre-evaluated.
                            </p><p>
                                When this fallback option is disabled while legacy pre-evaluation is disabled, properties or functions
                                like <tt class="literal">DateTime.Now</tt> or <tt class="literal">Guid.NewGuid()</tt> used in Linq expressions
                                will fail when the dialect does not support them.
                            </p><p>
                                This option has no effect if the legacy pre-evaluation is enabled.
                            </p></td></tr><tr><td><tt class="literal">sql_exception_converter</tt></td><td>
                            The class name of a custom <tt class="literal">ISQLExceptionConverter</tt> implementation.
                            Defaults to <tt class="literal">Dialect.BuildSQLExceptionConverter()</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.SQLExceptionConverter, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">show_sql</tt></td><td>
                            Write all SQL statements to console. Defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">format_sql</tt></td><td>
                            Log formatted SQL. Defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">use_sql_comments</tt></td><td>
                            Generate SQL with comments. Defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hbm2ddl.auto</tt></td><td>
                            Automatically export schema DDL to the database when the
                            <tt class="literal">ISessionFactory</tt> is created. With
                            <tt class="literal">create-drop</tt>, the database schema
                            will be dropped when the <tt class="literal">ISessionFactory</tt>
                            is closed explicitly.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">create</tt> | <tt class="literal">create-drop</tt> | <tt class="literal">update</tt> | <tt class="literal">validate</tt>
                            </p></td></tr><tr><td><tt class="literal">hbm2ddl.keywords</tt></td><td>
                            Automatically import <tt class="literal">reserved/keywords</tt> from the database when the
                            <tt class="literal">ISessionFactory</tt> is created.
                            <p>
                                <span class="strong">none :</span>
                                disable any operation regarding RDBMS KeyWords (the default).
                            </p><p>
                                <span class="strong">keywords :</span>
                                imports all RDBMS KeyWords where the <tt class="literal">Dialect</tt> can provide the implementation of <tt class="literal">IDataBaseSchema</tt>.
                            </p><p>
                                <span class="strong">auto-quote :</span>
                                imports all RDBMS KeyWords and auto-quote all table-names/column-names.
                            </p><p>
                                <span class="strong">eg.</span>
                                <tt class="literal">none</tt> | <tt class="literal">keywords</tt> | <tt class="literal">auto-quote</tt>
                            </p></td></tr><tr><td><tt class="literal">hbm2ddl.throw_on_update</tt></td><td>
                            When <tt class="literal">hbm2ddl.auto</tt> is <tt class="literal">update</tt>, whether to throw or not on schema auto-update failures.
                            
                            Disabled by default.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">use_proxy_validator</tt></td><td>
                            Enables or disables validation of interfaces or classes specified
                            as proxies. Enabled by default.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">proxyfactory.factory_class</tt></td><td>
                            The class name of a custom <tt class="literal">IProxyFactoryFactory</tt> implementation.
                            Defaults to the built-in <tt class="literal">StaticProxyFactoryFactory</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.ProxyFactoryFactory, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">collectiontype.factory_class</tt></td><td>
                            The class name of a custom <tt class="literal">ICollectionTypeFactory</tt> implementation.
                            Defaults to the built-in <tt class="literal">DefaultCollectionTypeFactory</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.CollectionTypeFactory, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">transaction.factory_class</tt></td><td>
                            The class name of a custom <tt class="literal">ITransactionFactory</tt> implementation.
                            Defaults to the built-in <tt class="literal">AdoNetWithSystemTransactionFactory</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.TransactionFactory, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">transaction.use_connection_on_system_prepare</tt></td><td>
                            When a system transaction is being prepared, is using connection during this process enabled?
                            <p>
                              Default is <tt class="literal">true</tt>, for supporting <tt class="literal">FlushMode.Commit</tt> with transaction factories
                              supporting system transactions. But this requires enlisting additional connections, retaining disposed
                              sessions and their connections until transaction end, and may trigger undesired transaction promotions to
                              distributed.
                            </p><p>
                              Set to <tt class="literal">false</tt> for disabling using connections from system
                              transaction preparation, while still benefiting from <tt class="literal">FlushMode.Auto</tt> on querying.
                            </p><p>
                              See <a href="#transactions-scopes" title="12.8.&nbsp;Transaction scopes (System.Transactions)">Section&nbsp;12.8, &#8220;Transaction scopes (System.Transactions)&#8221;</a>.
                            </p><p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">transaction.system_completion_lock_timeout</tt></td><td>
                            Timeout duration in milliseconds for the system transaction completion lock.
                            <p>
                                When a system transaction completes, it may have its completion events running on concurrent threads,
                                after scope disposal. This occurs when the transaction is distributed.
                                This notably concerns <tt class="literal">ISessionImplementor.AfterTransactionCompletion(bool, ITransaction)</tt>.
                                NHibernate protects the session from being concurrently used by the code following the scope disposal
                                with a lock. To prevent any application freeze, this lock has a default timeout of five seconds. If the
                                application appears to require longer (!) running transaction completion events, this setting allows to
                                raise this timeout. <tt class="literal">-1</tt> disables the timeout.
                            </p><p>
                                <span class="strong">eg.</span>
                                <tt class="literal">10000</tt>
                            </p></td></tr><tr><td><tt class="literal">transaction.auto_join</tt></td><td>
                            Should sessions check on every operation whether there is an ongoing system transaction or not, and enlist
                            into it if any?
                            <p>
                                Default is <tt class="literal">true</tt>. It can also be controlled at session opening, with
                                <tt class="literal">ISessionFactory.WithOptions</tt>. A session can also be instructed to explicitly join the current
                                transaction by calling <tt class="literal">ISession.JoinTransaction</tt>. This setting has no effect when using a
                                transaction factory that is not system transactions aware.
                            </p><p>
                                <span class="strong">eg.</span>
                                <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">default_flush_mode</tt></td><td>
                            The default <tt class="literal">FlushMode</tt>, <tt class="literal">Auto</tt> when not specified.
                            See <a href="#manipulatingdata-flushing" title="10.6.&nbsp;Flush">Section&nbsp;10.6, &#8220;Flush&#8221;</a>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">Manual</tt> | <tt class="literal">Commit</tt> | <tt class="literal">Auto</tt> | <tt class="literal">Always</tt>
                            </p></td></tr><tr><td><tt class="literal">default_batch_fetch_size</tt></td><td>
                            The default batch fetch size to use when lazily loading an entity or collection.
                            Defaults to <tt class="literal">1</tt>. See <a href="#performance-fetching-batch" title="21.1.5.&nbsp;Using batch fetching">Section&nbsp;21.1.5, &#8220;Using batch fetching&#8221;</a>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">20</tt>
                            </p></td></tr><tr><td><tt class="literal">current_session_context_class</tt></td><td>
                            The class name of an <tt class="literal">ICurrentSessionContext</tt> implementation.
                            See <a href="#architecture-current-session" title="2.3.&nbsp;Contextual Sessions">Section&nbsp;2.3, &#8220;Contextual Sessions&#8221;</a>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.CurrentSessionContext, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">id.optimizer.pooled.prefer_lo</tt></td><td>
                            When using an enhanced id generator and pooled optimizers (see
                            <a href="#mapping-declaration-id-enhanced" title="5.1.5.9.&nbsp;Enhanced identifier generators">Section&nbsp;5.1.5.9, &#8220;Enhanced identifier generators&#8221;</a>), prefer interpreting the database
                            value as the lower (lo) boundary. The default is to interpret it as the high boundary.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">generate_statistics</tt></td><td>
                            Enable statistics collection within <tt class="literal">ISessionFactory.Statistics</tt> property.
                            Defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">track_session_id</tt></td><td>
                            Set whether the session id should be tracked in logs or not. When <tt class="literal">true</tt>, each
                            session will have an unique <tt class="literal">Guid</tt> that can be retrieved with
                            <tt class="literal">ISessionImplementor.SessionId</tt>, otherwise <tt class="literal">ISessionImplementor.SessionId</tt>
                            will be <tt class="literal">Guid.Empty</tt>.
                            <p>
                                Session id is used for logging purpose and can also be retrieved on the static property
                                <tt class="literal">NHibernate.Impl.SessionIdLoggingContext.SessionId</tt>, when tracking is enabled.
                            </p><p>
                                Disabling tracking by setting <tt class="literal">track_session_id</tt> to <tt class="literal">false</tt>
                                increases performances. Default is <tt class="literal">true</tt>.
                            </p><p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">sql_types.keep_datetime</tt></td><td>
                            Since NHibernate v5.0 and if the dialect supports it, <tt class="literal">DbType.DateTime2</tt>
                            is used instead of <tt class="literal">DbType.DateTime</tt>. This may be disabled by setting
                            <tt class="literal">sql_types.keep_datetime</tt> to <tt class="literal">true</tt>.
                            Defaults to <tt class="literal">false</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">firebird.disable_parameter_casting</tt></td><td><p>
                                Firebird with FirebirdSql.Data.FirebirdClient may be unable to determine the type
                                of parameters in many circumstances, unless they are explicitly casted in the SQL
                                query. To avoid this trouble, the NHibernate <tt class="literal">FirebirdClientDriver</tt> parses SQL
                                commands for detecting parameters in them and adding an explicit SQL cast around
                                parameters which may trigger the issue.
                            </p><p>
                                Defaults to <tt class="literal">false</tt>.
                                For disabling this behavior, set this setting to true.
                            </p><p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">oracle.use_n_prefixed_types_for_unicode</tt></td><td><p>Oracle has a dual Unicode support model.</p><p>
                                Either the whole database use an Unicode encoding, and then all string types
                                will be Unicode. In such case, Unicode strings should be mapped to non <tt class="literal">N</tt> prefixed
                                types, such as <tt class="literal">Varchar2</tt>. This is the default.
                            </p><p>
                                Or <tt class="literal">N</tt> prefixed types such as <tt class="literal">NVarchar2</tt> are to be used for Unicode strings, the
                                others type are using a non Unicode encoding. In such case this setting needs to be set to
                                <tt class="literal">true</tt>.
                            </p><p>
                                See
                                <a href="https://docs.oracle.com/cd/B19306_01/server.102/b14225/ch6unicode.htm#CACHCAHF" target="_top">Implementing
                                a Unicode Solution in the Database</a>.
                                This setting applies only to Oracle dialects and ODP.Net managed or unmanaged driver.
                            </p><p>
                                <span class="strong">eg.</span>
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">odbc.explicit_datetime_scale</tt></td><td>
                            This may need to be set to <tt class="literal">3</tt> if you are using the <tt class="literal">OdbcDriver</tt>
                            with MS SQL Server 2008+.
                            <p>
                                This is intended to work around issues like:
                                </p><pre class="programlisting">System.Data.Odbc.OdbcException :
ERROR [22008]
[Microsoft][SQL Server Native Client 11.0]
Datetime field overflow. Fractional second
precision exceeds the scale specified
in the parameter binding.</pre><p>
                            </p><p>
                                <span class="strong">eg.</span>
                                <tt class="literal">3</tt>
                            </p></td></tr><tr><td><tt class="literal">sqlite.binaryguid</tt></td><td>
                            SQLite can store GUIDs in binary or text form, controlled by the BinaryGuid
                            connection string parameter (default is 'true'). The BinaryGuid setting will affect
                            how to cast GUID to string in SQL. NHibernate will attempt to detect this
                            setting automatically from the connection string, but if the connection
                            or connection string is being handled by the application instead of by NHibernate,
                            you can use the <tt class="literal">sqlite.binaryguid</tt> NHibernate setting to override the behavior.
                            The value can be <tt class="literal">true</tt> or <tt class="literal">false</tt>.
                        </td></tr><tr><td><tt class="literal">nhibernate-logger</tt></td><td>
                            The class name of an <tt class="literal">ILoggerFactory</tt> implementation. It allows using another
                            logger than log4net.
                            <p>
                                The default is not defined, which causes NHibernate to search for log4net assembly. If this
                                search succeeds, NHibernate will log with log4net. Otherwise, its internal logging will
                                be disabled.
                            </p><p>
                                This is a very special system-level property. It can only be set through an
                                <a href="https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/appsettings/" target="_top">appSetting</a>
                                named <tt class="literal">nhibernate-logger</tt> in the application configuration file. It cannot
                                be set neither with <tt class="literal">NHibernate.Cfg.Environment</tt> class, nor be defined in the
                                <tt class="literal">&lt;hibernate-configuration&gt;</tt> section of the application
                                configuration file, nor supplied by using <tt class="literal">Configuration.SetProperties</tt>, nor
                                set in the <tt class="literal">hibernate.cfg.xml</tt> configuration file.
                            </p><p>
                                Alternatively to using the setting, a logger factory can be programmatically supplied by using
                                <tt class="literal">NHibernateLogger.SetLoggersFactory</tt>.
                            </p><p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.LoggerFactory, assembly</tt>
                            </p></td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-dialects"></a>3.6.1.&nbsp;SQL Dialects</h3></div></div><div></div></div><p>
                You should always set the <tt class="literal">dialect</tt> property to the correct
                <tt class="literal">NHibernate.Dialect.Dialect</tt> subclass for your database. This is not
                strictly essential unless you wish to use <tt class="literal">native</tt> or
                <tt class="literal">sequence</tt> primary key generation or pessimistic locking (with, eg.
                <tt class="literal">ISession.Lock()</tt> or <tt class="literal">IQuery.SetLockMode()</tt>).
                However, if you specify a dialect, NHibernate will use sensible defaults for some of the
                other properties listed above, saving you the effort of specifying them manually.
            </p><div class="table"><a name="sql-dialects"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;NHibernate SQL Dialects (<tt class="literal">dialect</tt>)</b></p><table summary="NHibernate SQL Dialects (dialect)" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>RDBMS</th><th>Dialect</th><th>Remarks</th></tr></thead><tbody><tr><td>DB2</td><td><tt class="literal">NHibernate.Dialect.DB2Dialect</tt></td><td>&nbsp;</td></tr><tr><td>DB2 for iSeries (OS/400)</td><td><tt class="literal">NHibernate.Dialect.DB2400Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Firebird</td><td><tt class="literal">NHibernate.Dialect.FirebirdDialect</tt></td><td>
                                Set <tt class="literal">driver_class</tt> to
                                <tt class="literal">NHibernate.Driver.FirebirdClientDriver</tt>
                                for Firebird ADO.NET provider 2.0.
                            </td></tr><tr><td>Informix</td><td><tt class="literal">NHibernate.Dialect.InformixDialect</tt></td><td>&nbsp;</td></tr><tr><td>Informix 9.40</td><td><tt class="literal">NHibernate.Dialect.InformixDialect0940</tt></td><td>&nbsp;</td></tr><tr><td>Informix 10.00</td><td><tt class="literal">NHibernate.Dialect.InformixDialect1000</tt></td><td>&nbsp;</td></tr><tr><td>Ingres</td><td><tt class="literal">NHibernate.Dialect.IngresDialect</tt></td><td>&nbsp;</td></tr><tr><td>Ingres 9</td><td><tt class="literal">NHibernate.Dialect.Ingres9Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Microsoft SQL Server 7</td><td><tt class="literal">NHibernate.Dialect.MsSql7Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Microsoft SQL Server 2000</td><td><tt class="literal">NHibernate.Dialect.MsSql2000Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Microsoft SQL Server 2005</td><td><tt class="literal">NHibernate.Dialect.MsSql2005Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Microsoft SQL Server 2008</td><td><tt class="literal">NHibernate.Dialect.MsSql2008Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Microsoft SQL Azure Server 2008</td><td><tt class="literal">NHibernate.Dialect.MsSqlAzure2008Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Microsoft SQL Server 2012</td><td><tt class="literal">NHibernate.Dialect.MsSql2012Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Microsoft SQL Server Compact Edition</td><td><tt class="literal">NHibernate.Dialect.MsSqlCeDialect</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>Microsoft SQL Server Compact Edition 4.0</td><td><tt class="literal">NHibernate.Dialect.MsSqlCe40Dialect</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>MySQL 3 or 4</td><td><tt class="literal">NHibernate.Dialect.MySQLDialect</tt></td><td>&nbsp;</td></tr><tr><td>MySQL 5</td><td><tt class="literal">NHibernate.Dialect.MySQL5Dialect</tt></td><td>&nbsp;</td></tr><tr><td>MySQL 5 Inno DB</td><td><tt class="literal">NHibernate.Dialect.MySQL5InnoDBDialect</tt></td><td>&nbsp;</td></tr><tr><td>MySQL 5.5</td><td><tt class="literal">NHibernate.Dialect.MySQL55Dialect</tt></td><td>&nbsp;</td></tr><tr><td>MySQL 5.5 Inno DB</td><td><tt class="literal">NHibernate.Dialect.MySQL55InnoDBDialect</tt></td><td>&nbsp;</td></tr><tr><td>Oracle</td><td><tt class="literal">NHibernate.Dialect.Oracle8iDialect</tt></td><td>&nbsp;</td></tr><tr><td>Oracle 9i</td><td><tt class="literal">NHibernate.Dialect.Oracle9iDialect</tt></td><td>&nbsp;</td></tr><tr><td>Oracle 10g, Oracle 11g</td><td><tt class="literal">NHibernate.Dialect.Oracle10gDialect</tt></td><td>&nbsp;</td></tr><tr><td>Oracle 12c</td><td><tt class="literal">NHibernate.Dialect.Oracle12cDialect</tt></td><td>&nbsp;</td></tr><tr><td>PostgreSQL</td><td><tt class="literal">NHibernate.Dialect.PostgreSQLDialect</tt></td><td>&nbsp;</td></tr><tr><td>PostgreSQL</td><td><tt class="literal">NHibernate.Dialect.PostgreSQLDialect</tt></td><td>&nbsp;</td></tr><tr><td>PostgreSQL 8.1</td><td><tt class="literal">NHibernate.Dialect.PostgreSQL81Dialect</tt></td><td>
                                This dialect supports <tt class="literal">FOR UPDATE NOWAIT</tt>
                                available in PostgreSQL 8.1.
                            </td></tr><tr><td>PostgreSQL 8.2</td><td><tt class="literal">NHibernate.Dialect.PostgreSQL82Dialect</tt></td><td>
                                This dialect supports <tt class="literal">IF EXISTS</tt> keyword in
                                <tt class="literal">DROP TABLE</tt> and <tt class="literal">DROP SEQUENCE</tt>
                                available in PostgreSQL 8.2.
                            </td></tr><tr><td>PostgreSQL 8.3</td><td><tt class="literal">NHibernate.Dialect.PostgreSQL83Dialect</tt></td><td>
                                This dialect supports <tt class="literal">XML</tt> type.
                            </td></tr><tr><td>SQLite</td><td><tt class="literal">NHibernate.Dialect.SQLiteDialect</tt></td><td>
                                Set <tt class="literal">driver_class</tt> to
                                <tt class="literal">NHibernate.Driver.SQLite20Driver</tt>
                                for System.Data.SQLite provider for .NET 2.0.
                                <p>
                                    Due to
                                    <a href="https://system.data.sqlite.org/index.html/tktview/44a0955ea344a777ffdbcc077831e1adc8b77a36" target="_top">the
                                    behavior of System.Data.SQLite</a> with <tt class="literal">DateTime</tt>, consider using
                                    <tt class="literal">DateTimeFormatString=yyyy-MM-dd HH:mm:ss.FFFFFFF;</tt> in the SQLite
                                    connection string for preventing undesired time shifts with its default configuration.
                                </p></td></tr><tr><td>Sybase Adaptive Server Anywhere 9</td><td><tt class="literal">NHibernate.Dialect.SybaseASA9Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Sybase Adaptive Server Enterprise 15</td><td><tt class="literal">NHibernate.Dialect.SybaseASE15Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Sybase SQL Anywhere 10</td><td><tt class="literal">NHibernate.Dialect.SybaseSQLAnywhere10Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Sybase SQL Anywhere 11</td><td><tt class="literal">NHibernate.Dialect.SybaseSQLAnywhere11Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Sybase SQL Anywhere 12</td><td><tt class="literal">NHibernate.Dialect.SybaseSQLAnywhere12Dialect</tt></td><td>&nbsp;</td></tr></tbody></table></div><p>
                Additional dialects may be available in the NHibernate.Dialect namespace.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-outerjoin"></a>3.6.2.&nbsp;Outer Join Fetching</h3></div></div><div></div></div><p>
                If your database supports ANSI or Oracle style outer joins, <span class="emphasis"><em>outer join
                fetching</em></span> might increase performance by limiting the number of round
                trips to and from the database (at the cost of possibly more work performed by
                the database itself). Outer join fetching allows a graph of objects connected
                by many-to-one, one-to-many or one-to-one associations to be retrieved in a single
                SQL <tt class="literal">SELECT</tt>.
            </p><p>
                By default, the fetched graph when loading an objects ends at leaf objects,
                collections, objects with proxies, or where circularities occur.
            </p><p>
                For a <span class="emphasis"><em>particular  association</em></span>, fetching may be configured
                (and the default behaviour overridden) by setting the <tt class="literal">fetch</tt>
                attribute in the XML mapping.
            </p><p>
                Outer join fetching may be disabled <span class="emphasis"><em>globally</em></span> by setting
                the property <tt class="literal">max_fetch_depth</tt> to <tt class="literal">0</tt>.
                A setting of <tt class="literal">1</tt> or higher enables outer join fetching for
                one-to-one and many-to-one associations which have been mapped with
                <tt class="literal">fetch="join"</tt>.
            </p><p>
                See <a href="#performance-fetching" title="21.1.&nbsp;Fetching strategies">Section&nbsp;21.1, &#8220;Fetching strategies&#8221;</a> for more information.
            </p><p>
                In NHibernate 1.0, <tt class="literal">outer-join</tt> attribute could be used to achieve
                a similar effect. This attribute is now deprecated in favor of <tt class="literal">fetch</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-cacheprovider"></a>3.6.3.&nbsp;Custom <tt class="literal">ICacheProvider</tt></h3></div></div><div></div></div><p>
                You may integrate a process-level (or clustered) second-level cache system by
                implementing the interface <tt class="literal">NHibernate.Cache.ICacheProvider</tt>.
                You may select the custom implementation by setting
                <tt class="literal">cache.provider_class</tt>. See the 
                <a href="#performance-cache" title="21.2.&nbsp;The Second Level Cache">Section&nbsp;21.2, &#8220;The Second Level Cache&#8221;</a> for more details.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-querysubstitution"></a>3.6.4.&nbsp;Query Language Substitution</h3></div></div><div></div></div><p>
                You may define new NHibernate query tokens using <tt class="literal">query.substitutions</tt>.
                For example:
            </p><pre class="programlisting">query.substitutions true=1, false=0</pre><p>
                would cause the tokens <tt class="literal">true</tt> and <tt class="literal">false</tt> to be translated to
                integer literals in the generated SQL.
            </p><pre class="programlisting">query.substitutions toLowercase=LOWER</pre><p>
                would allow you to rename the SQL <tt class="literal">LOWER</tt> function.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-systemlevel"></a>3.6.5.&nbsp;System level optional properties</h3></div></div><div></div></div><p>
                Some properties are system-level properties. They can only be set manually by setting static
                properties of <tt class="literal">NHibernate.Cfg.Environment</tt> class or be defined in the
                <tt class="literal">&lt;hibernate-configuration&gt;</tt> section of the application configuration
                file, as direct sub-elements. These properties can neither be set using
                <tt class="literal">Configuration.SetProperties</tt> or the <tt class="literal">hibernate.cfg.xml</tt>
                configuration file, nor be set as <tt class="literal">&lt;session-factory&gt;</tt> properties.
            </p><div class="table"><a name="configuration-systemlevel-properties"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;NHibernate system level properties</b></p><table summary="NHibernate system level properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">bytecode-provider</tt></td><td><p>
                                    Specifies the bytecode provider to use to optimize the use of reflection in NHibernate.
                                    Use <tt class="literal">null</tt> to disable the optimization completely, <tt class="literal">lcg</tt>
                                    to use built-in lightweight code generation, or the assembly qualified class name of a custom
                                    <tt class="literal">IBytecodeProvider</tt> implementation. Defaults to <tt class="literal">lcg</tt>.
                                </p><pre class="programlisting">&lt;bytecode-provider
    type="lcg|null|className" /&gt;</pre><p>
                                    You can also set this property by code by setting
                                    <tt class="literal">NHibernate.Cfg.Environment.BytecodeProvider</tt>
                                    before creating any <tt class="literal">NHibernate.Cfg.Configuration</tt> instance.
                                </p></td></tr><tr><td><tt class="literal">objects-factory</tt></td><td><p>
                                    Specifies a custom objects factory to use for instantiating NHibernate dependencies.
                                    Use the assembly qualified class name of a custom <tt class="literal">IObjectsFactory</tt>
                                    implementation.
                                </p><pre class="programlisting">&lt;bytecode-provider
    type="className" /&gt;</pre><p>
                                    You can also set this property by code by setting
                                    <tt class="literal">NHibernate.Cfg.Environment.ObjectsFactory</tt>
                                    before creating any <tt class="literal">NHibernate.Cfg.Configuration</tt> instance.
                                </p></td></tr><tr><td><tt class="literal">reflection-optimizer</tt></td><td><p>
                                    Enables use of a runtime-generated class to set or get properties of an entity
                                    or component instead of using runtime reflection. The use of the reflection
                                    optimizer inflicts a certain startup cost on the application but should lead to
                                    better performance in the long run. Defaults to <tt class="literal">true</tt>.
                                </p><pre class="programlisting">&lt;reflection-optimizer
    use="true|false"/&gt;</pre><p>
                                    You can also set this property by code by setting
                                    <tt class="literal">NHibernate.Cfg.Environment.UseReflectionOptimizer</tt>
                                    before creating any <tt class="literal">NHibernate.Cfg.Configuration</tt> instance.
                                </p></td></tr></tbody></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-logging"></a>3.7.&nbsp;Logging</h2></div></div><div></div></div><p>
            NHibernate logs various events using Apache log4net.
        </p><p>
            You may download log4net from <a href="https://logging.apache.org/log4net/" target="_top">https://logging.apache.org/log4net/</a>,
            or install it with NuGet.
            To use log4net you will need a <tt class="literal">log4net</tt> configuration section in
            the application configuration file.  An example of the configuration section is
            distributed with NHibernate in the <tt class="literal">src/NHibernate.Test</tt> project.
        </p><p>
            We strongly recommend that you familiarize yourself with NHibernate's log
            messages. A lot of work has been put into making the NHibernate log as
            detailed as possible, without making it unreadable. It is an essential
            troubleshooting device. Also don't forget to enable SQL logging as
            described above (<tt class="literal">show_sql</tt>), it is your first
            step when looking for performance problems.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-namingstrategy"></a>3.8.&nbsp;Implementing an <tt class="literal">INamingStrategy</tt></h2></div></div><div></div></div><p>
            The interface <tt class="literal">NHibernate.Cfg.INamingStrategy</tt> allows you
            to specify a "naming standard" for database objects and schema elements.
        </p><p>
            You may provide rules for automatically generating database identifiers from
            .NET identifiers or for processing "logical" column and table names given in
            the mapping file into  "physical" table and column names. This feature helps
            reduce the verbosity of the mapping document, eliminating repetitive noise
            (<tt class="literal">TBL_</tt> prefixes, for example). The default strategy used by
            NHibernate is quite minimal.
        </p><p>
            You may specify a different strategy by calling
            <tt class="literal">Configuration.SetNamingStrategy()</tt> before adding mappings:
        </p><pre class="programlisting">ISessionFactory sf = new Configuration()
    .SetNamingStrategy(ImprovedNamingStrategy.Instance)
    .AddFile("Item.hbm.xml")
    .AddFile("Bid.hbm.xml")
    .BuildSessionFactory();</pre><p>
            <tt class="literal">NHibernate.Cfg.ImprovedNamingStrategy</tt> is a built-in
            strategy that might be a useful starting point for some applications.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-xmlconfig"></a>3.9.&nbsp;XML Configuration File</h2></div></div><div></div></div><p>
            An alternative approach is to specify a full configuration in a file named
            <tt class="literal">hibernate.cfg.xml</tt>. This file can be used as a replacement
            for the <tt class="literal">&lt;hibernate-configuration&gt;</tt>
            sections of the application configuration file.
        </p><p>
            The XML configuration file is by default expected to be in your application directory.
            Here is an example:
        </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;hibernate-configuration xmlns="urn:nhibernate-configuration-2.2"&gt;

  &lt;!-- an ISessionFactory instance --&gt;
  &lt;session-factory&gt;

    &lt;!-- properties --&gt;
    &lt;property name="connection.connection_string"&gt;
      Server=localhost;initial catalog=nhibernate;User Id=;Password=
    &lt;/property&gt;
    &lt;property name="show_sql"&gt;false&lt;/property&gt;
    &lt;property name="dialect"&gt;NHibernate.Dialect.MsSql2012Dialect&lt;/property&gt;

    &lt;!-- mapping files --&gt;
    &lt;mapping resource="NHibernate.Auction.Item.hbm.xml" assembly="NHibernate.Auction" /&gt;
    &lt;mapping resource="NHibernate.Auction.Bid.hbm.xml" assembly="NHibernate.Auction" /&gt;

  &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
           Configuring NHibernate is then as simple as
       </p><pre class="programlisting">ISessionFactory sf = new Configuration().Configure().BuildSessionFactory();</pre><p>
           You can pick a different XML configuration file using
       </p><a name="configuration-xmlconfig-ex3"></a><pre class="programlisting">ISessionFactory sf = new Configuration()
    .Configure("/path/to/config.cfg.xml")
    .BuildSessionFactory();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="persistent-classes"></a>Chapter&nbsp;4.&nbsp;Persistent Classes</h2></div></div><div></div></div><p>
        Persistent classes are classes in an application that implement the entities
        of the business problem (e.g. Customer and Order in an E-commerce application).
        Persistent classes have, as the name implies, transient and also persistent
        instance stored in the database.
    </p><p>
        NHibernate works best if these classes follow some simple rules, also known
        as the Plain Old CLR Object (POCO) programming model.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-poco"></a>4.1.&nbsp;A simple POCO example</h2></div></div><div></div></div><p>
            Most .NET applications require a persistent class representing felines.
        </p><pre class="programlisting">using System;
using System.Collections.Generic;

namespace Eg
{
    public class Cat
    {
        long _id;
        // identifier

        public virtual long Id
        {
            get { return _id; }
            protected set { _id = value; }
        }

        public virtual string Name { get; set; }
        public virtual Cat Mate { get; set; }
        public virtual DateTime Birthdate { get; set; }
        public virtual float Weight { get; set; }
        public virtual Color Color { get; set; }
        public virtual ISet&lt;Cat&gt; Kittens { get; set; }
        public virtual char Sex { get; set; }

        // AddKitten not needed by NHibernate
        public virtual void AddKitten(Cat kitten)
        {
            kittens.Add(kitten);
        }
    }
}</pre><p>
            There are four main rules to follow here:
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-poco-accessors"></a>4.1.1.&nbsp;Declare properties for persistent fields</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> declares properties for all the persistent fields.
                Many other <span class="emphasis"><em>ORM tools</em></span> directly persist instance variables. We believe 
                it is far better to decouple this implementation detail from the persistence 
                mechanism. NHibernate persists properties, using their getter and setter methods.
            </p><p>
                Properties need <span class="emphasis"><em>not</em></span> be declared public - NHibernate can
                persist a property with an <tt class="literal">internal</tt>, <tt class="literal">protected</tt>,
                <tt class="literal">protected internal</tt> or <tt class="literal">private</tt> visibility.
            </p><p>
                As shown in the example, both automatic properties and properties with a
                backing field are supported.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-poco-constructor"></a>4.1.2.&nbsp;Implement a default constructor</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> has an implicit default (no-argument) constructor. All 
                persistent classes must have a default constructor (which may be non-public) so 
                NHibernate can instantiate them using <tt class="literal">Activator.CreateInstance()</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-poco-identifier"></a>4.1.3.&nbsp;Provide an identifier property (optional)</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> has a property called <tt class="literal">Id</tt>. This property 
                holds the primary key column of a database table. The property might have been called 
                anything, and its type might have been any primitive type, <tt class="literal">string</tt>
                or <tt class="literal">System.DateTime</tt>. (If your legacy database table has composite
                keys, you can even use a user-defined class with properties of these types - see the
                section on composite identifiers below.)
            </p><p>
                The identifier property is optional. You can leave it off and let NHibernate keep track 
                of object identifiers internally. However, for many applications it is still
                a good (and very popular) design decision.
            </p><p>
                What's more, some functionality is available only to classes which declare an
                identifier property:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        Cascaded updates (see <a href="#manipulatingdata-graphs" title="10.10.&nbsp;Lifecycles and object graphs">Section&nbsp;10.10, &#8220;Lifecycles and object graphs&#8221;</a>)
                    </p></li><li><p>
                        <tt class="literal">ISession.SaveOrUpdate()</tt>
                    </p></li></ul></div><p>
                We recommend you declare consistently-named identifier properties on persistent
                classes.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-poco-sealed"></a>4.1.4.&nbsp;Prefer non-sealed classes and virtual methods (optional)</h3></div></div><div></div></div><p>
                A central feature of NHibernate, <span class="emphasis"><em>proxies</em></span>, depends upon the
                persistent class being non-sealed and all its public methods, properties and
                events declared as virtual. Another possibility is for the class to implement
                an interface that declares all public members.
            </p><p>
                You can persist <tt class="literal">sealed</tt> classes that do not implement an interface
                and don't have virtual members with NHibernate, but you won't be able to use proxies
                - which will limit your options for performance tuning.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-inheritance"></a>4.2.&nbsp;Implementing inheritance</h2></div></div><div></div></div><p>
            A subclass must also observe the first and second rules. It inherits its
            identifier property from <tt class="literal">Cat</tt>.
        </p><pre class="programlisting">using System;
namespace Eg
{
    public class DomesticCat : Cat
    {
        public virtual string Name { get; set; }
    }
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-equalshashcode"></a>4.3.&nbsp;Implementing <tt class="literal">Equals()</tt> and <tt class="literal">GetHashCode()</tt></h2></div></div><div></div></div><p>
            You have to override the <tt class="literal">Equals()</tt> and <tt class="literal">GetHashCode()</tt>
            methods if you intend to mix objects of persistent classes (e.g. in an <tt class="literal">ISet</tt>).
        </p><p>
            <span class="emphasis"><em>This only applies if these objects are loaded in two different
            <tt class="literal">ISession</tt>s, as NHibernate only guarantees identity (<tt class="literal"> a == b </tt>,
            the default implementation of <tt class="literal">Equals()</tt>) inside a single
            <tt class="literal">ISession</tt>!</em></span>
        </p><p>
            Even if both objects <tt class="literal">a</tt> and <tt class="literal">b</tt> are the same database row
            (they have the same primary key value as their identifier), we can't guarantee that they are
            the same object instance outside of a particular <tt class="literal">ISession</tt> context.
        </p><p>
            The most obvious way is to implement <tt class="literal">Equals()</tt>/<tt class="literal">GetHashCode()</tt>
            by comparing the identifier value of both objects. If the value is the same, both must
            be the same database row, they are therefore equal (if both are added to an <tt class="literal">ISet</tt>,
            we will only have one element in the <tt class="literal">ISet</tt>). Unfortunately, we can't use that
            approach. NHibernate will only assign identifier values to objects that are persistent,
            a newly created instance will not have any identifier value! We recommend implementing
            <tt class="literal">Equals()</tt> and <tt class="literal">GetHashCode()</tt> using
            <span class="emphasis"><em>Business key equality</em></span>.
        </p><p>
            Business key equality means that the <tt class="literal">Equals()</tt>
            method compares only the properties that form the business key, a key that would
            identify our instance in the real world (a <span class="emphasis"><em>natural</em></span> candidate key):
        </p><pre class="programlisting">public class Cat
{

    ...
    public override bool Equals(object other)
    {
        if (this == other) return true;
        
        Cat cat = other as Cat;
        if (cat == null) return false; // null or not a cat

        if (Name != cat.Name) return false;
        if (!Birthday.Equals(cat.Birthday)) return false;

        return true;
    }

    public override int GetHashCode()
    {
        unchecked
        {
            int result;
            result = Name.GetHashCode();
            result = 29 * result + Birthday.GetHashCode();
            return result;
        }
    }

}</pre><p>
            Keep in mind that our candidate key (in this case a composite of name and birthday)
            has to be only valid for a particular comparison operation (maybe even only in a
            single use case). We don't need the stability criteria we usually apply to a real
            primary key!
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-dynamicmodels"></a>4.4.&nbsp;Dynamic models</h2></div></div><div></div></div><p>
            <span class="emphasis"><em>Note that the following features are currently considered
                experimental and may change in the near future.</em></span>
        </p><p>
            Persistent entities don't necessarily have to be represented as POCO classes
            at runtime. NHibernate also supports dynamic models
            (using <tt class="literal">Dictionaries</tt> or C# <tt class="literal">dynamic</tt>). With this approach,
            you don't write persistent classes, only mapping files.
        </p><p>
            The following examples demonstrates the dynamic model feature.
            First, in the mapping file, an <tt class="literal">entity-name</tt> has to be declared
            instead of a class name:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    &lt;class entity-name="Customer"&gt;
        &lt;id name="Id"
            type="long"
            column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;property name="Name"
            column="NAME"
            type="string"/&gt;

        &lt;property name="Address"
            column="ADDRESS"
            type="string"/&gt;

        &lt;many-to-one name="Organization"
            column="ORGANIZATION_ID"
            class="Organization"/&gt;

        &lt;bag name="Orders"
            inverse="true"
            lazy="false"
            cascade="all"&gt;
            &lt;key column="CUSTOMER_ID"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/bag&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;</pre><p>
            Note that even though associations are declared using target class names,
            the target type of an associations may also be a dynamic entity instead
            of a POCO.
        </p><p>
            At runtime we can work with <tt class="literal">Dictionaries</tt>:
        </p><pre class="programlisting">using(ISession s = OpenSession())
using(ITransaction tx = s.BeginTransaction())
{
    // Create a customer
    var frank = new Dictionary&lt;string, object&gt;();
    frank["name"] = "Frank";

    // Create an organization
    var foobar = new Dictionary&lt;string, object&gt;();
    foobar["name"] = "Foobar Inc.";

    // Link both
    frank["organization"] =  foobar;

    // Save both
    s.Save("Customer", frank);
    s.Save("Organization", foobar);

    tx.Commit();
}</pre><p>
           Or we can work with <tt class="literal">dynamic</tt>:
        </p><pre class="programlisting">using(var s = OpenSession())
using(var tx = s.BeginTransaction())
{
    // Create a customer
    dynamic frank = new ExpandoObject();
    frank.Name = "Frank";

    // Create an organization
    dynamic foobar = new ExpandoObject();
    foobar.Name = "Foobar Inc.";

    // Link both
    frank.Organization = foobar;

    // Save both
    s.Save("Customer", frank);
    s.Save("Organization", foobar);

    tx.Commit();
}</pre><p>
            The advantages of a dynamic mapping are quick turnaround time for prototyping
            without the need for entity class implementation. However, you lose compile-time
            type checking and will very likely deal with many exceptions at runtime. Thanks
            to the NHibernate mapping, the database schema can easily be normalized and sound,
            allowing to add a proper domain model implementation on top later on.
        </p><p>
            A loaded dynamic entity can be manipulated as an <tt class="literal">IDictionary</tt>,
            an <tt class="literal">IDictionary&lt;string, object&gt;</tt> or a C#
            <tt class="literal">dynamic</tt>.
        </p><pre class="programlisting">using(ISession s = OpenSession())
using(ITransaction tx = s.BeginTransaction())
{
    var customers = s
        .CreateQuery("from Customer")
        .List&lt;IDictionary&lt;string, object&gt;&gt;();
    ...
}</pre><pre class="programlisting">using System.Linq.Dynamic.Core;

...

using(ISession s = OpenSession())
using(ITransaction tx = s.BeginTransaction())
{
    var customers = s
        .Query&lt;dynamic&gt;("Customer")
        .OrderBy("Name")
        .ToList();
    ...
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-tuplizers"></a>4.5.&nbsp;Tuplizers</h2></div></div><div></div></div><p>
            <tt class="literal">NHibernate.Tuple.Tuplizer</tt>, and its sub-interfaces, are responsible
            for managing a particular representation of a piece of data, given that representation's
            <tt class="literal">NHibernate.EntityMode</tt>.  If a given piece of data is thought of as
            a data structure, then a tuplizer is the thing which knows how to create such a data structure
            and how to extract values from and inject values into such a data structure.  For example,
            for the POCO entity mode, the corresponding tuplizer knows how create the POCO through its
            constructor and how to access the POCO properties using the defined property accessors.
            There are two high-level types of Tuplizers, represented by the
            <tt class="literal">NHibernate.Tuple.Entity.IEntityTuplizer</tt> and <tt class="literal">NHibernate.Tuple.Component.IComponentTuplizer</tt>
            interfaces.  <tt class="literal">IEntityTuplizer</tt>s are responsible for managing the above mentioned
            contracts in regards to entities, while <tt class="literal">IComponentTuplizer</tt>s do the same for
            components.
        </p><p>
            Users may also plug in their own tuplizers.  Perhaps you require that a <tt class="literal">IDictionary</tt> /
            <tt class="literal">DynamicObject</tt> implementation other than NHibernate own implementation is used while
            in the dynamic-map entity-mode; or perhaps you need to define a different proxy generation strategy
            than the one used by default.  Both would be achieved by defining a custom tuplizer
            implementation.  Tuplizers definitions are attached to the entity or component mapping they
            are meant to manage.  Going back to the example of our customer entity:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    &lt;class entity-name="Customer"&gt;
        &lt;!--
            Override the dynamic-map entity-mode
            tuplizer for the customer entity
        --&gt;
        &lt;tuplizer entity-mode="dynamic-map"
                class="CustomMapTuplizerImpl"/&gt;

        &lt;id name="id" type="long" column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;!-- other properties --&gt;
        ...
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;


public class CustomMapTuplizerImpl : NHibernate.Tuple.Entity.DynamicMapEntityTuplizer
{
    // override the BuildInstantiator() method to plug in our custom map...
    protected override IInstantiator BuildInstantiator(
        NHibernate.Mapping.PersistentClass mappingInfo)
    {
        return new CustomMapInstantiator(mappingInfo);
    }

    private sealed class CustomMapInstantiator : NHibernate.Tuple.DynamicMapInstantiator
    {
        // override the generateMap() method to return our custom map...
        protected override IDictionary GenerateMap()
        {
            return new CustomMap();
        }
    }
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-lifecycle"></a>4.6.&nbsp;Lifecycle Callbacks</h2></div></div><div></div></div><p>
            Optionally, a persistent class might implement the interface 
            <tt class="literal">ILifecycle</tt> which provides some callbacks that allow
            the persistent object to perform necessary initialization/cleanup after
            save or load and before deletion or update.
        </p><p>
            The NHibernate <a href="#objectstate-interceptors" title="13.1.&nbsp;Interceptors"><tt class="literal">IInterceptor</tt></a>
            offers a less intrusive alternative, however.
        </p><div class="programlistingco"><pre class="programlisting">public interface ILifecycle
{                                                                    <span class="co">(1)</span>
        LifecycleVeto OnSave(ISession s);                            <span class="co">(2)</span>
        LifecycleVeto OnUpdate(ISession s);                          <span class="co">(3)</span>
        LifecycleVeto OnDelete(ISession s);                          <span class="co">(4)</span>
        void OnLoad(ISession s, object id);
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">OnSave</tt> - called just before the object is saved or
                        inserted
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">OnUpdate</tt> - called just before an object is updated 
                        (when the object is passed to <tt class="literal">ISession.Update()</tt>)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">OnDelete</tt> - called just before an object is deleted
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">OnLoad</tt> - called just after an object is loaded
                    </p></td></tr></table></div></div><p>
            <tt class="literal">OnSave()</tt>, <tt class="literal">OnDelete()</tt> and
            <tt class="literal">OnUpdate()</tt> may be used to cascade saves and
            deletions of dependent objects. This is an alternative to declaring cascaded
            operations in the mapping file. <tt class="literal">OnLoad()</tt> may
            be used to initialize transient properties of the object from its persistent
            state. It may not be used to load dependent objects since the
            <tt class="literal">ISession</tt> interface may not be invoked from
            inside this method. A further intended usage of <tt class="literal">OnLoad()</tt>, 
            <tt class="literal">OnSave()</tt> and <tt class="literal">OnUpdate()</tt> is to store a 
            reference to the current <tt class="literal">ISession</tt> for later use.
        </p><p>
            Note that <tt class="literal">OnUpdate()</tt> is not called every time the object's
            persistent state is updated. It is called only when a transient object is passed
            to <tt class="literal">ISession.Update()</tt>.
        </p><p>
            If <tt class="literal">OnSave()</tt>, <tt class="literal">OnUpdate()</tt> or
            <tt class="literal">OnDelete()</tt> return <tt class="literal">LifecycleVeto.Veto</tt>, the operation is 
            silently vetoed. If a <tt class="literal">CallbackException</tt> is thrown, the operation 
            is vetoed and the exception is passed back to the application.
        </p><p>
            Note that <tt class="literal">OnSave()</tt> is called after an identifier is assigned to 
            the object, except when native key generation is used.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-validatable"></a>4.7.&nbsp;IValidatable callback</h2></div></div><div></div></div><p>
            If the persistent class needs to check invariants before its state is
            persisted, it may implement the following interface:
        </p><pre class="programlisting">public interface IValidatable
{
        void Validate();
}</pre><p>
            The object should throw a <tt class="literal">ValidationFailure</tt> if an invariant 
            was violated. An instance of <tt class="literal">Validatable</tt> should not change 
            its state from inside <tt class="literal">Validate()</tt>.
        </p><p>
            Unlike the callback methods of the <tt class="literal">ILifecycle</tt> interface, 
            <tt class="literal">Validate()</tt> might be called at unpredictable times. The
            application should not rely upon calls to <tt class="literal">Validate()</tt> for
            business functionality.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mapping"></a>Chapter&nbsp;5.&nbsp;Basic O/R Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-declaration"></a>5.1.&nbsp;Mapping declaration</h2></div></div><div></div></div><p>
            Object/relational mappings are defined in an XML document. The mapping document
            is designed to be readable and hand-editable. The mapping language is object-centric,
            meaning that mappings are constructed around persistent class declarations, not
            table declarations.
        </p><p>
            Note that, even though many NHibernate users choose to define XML mappings by hand,
            a number of tools exist to generate the mapping document, even transparently at runtime.
            This includes the <a href="#mapping-attributes" title="Chapter&nbsp;28.&nbsp;NHibernate.Mapping.Attributes">NHibernate.Mapping.Attributes
            library</a> which allows to directly annotate your entities with mapping declarations,
            various template-based code generators (CodeSmith, MyGeneration), the built-in
            <tt class="literal">NHibernate.Mapping.ByCode</tt> API available since NHibernate 3.2, or
            the <a href="https://github.com/jagregory/fluent-nhibernate" target="_top">Fluent NHibernate</a>
            independent library.
        </p><p>
            Let's kick off with an example mapping:
        </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2" assembly="Eg"
    namespace="Eg"&gt;

    &lt;class name="Cat" table="CATS" discriminator-value="C"&gt;
        &lt;id name="Id" column="uid" type="Int64"&gt;
            &lt;generator class="hilo"/&gt;
        &lt;/id&gt;
        &lt;discriminator column="subclass" type="Char"/&gt;
        &lt;property name="BirthDate" type="Date"/&gt;
        &lt;property name="Color" not-null="true"/&gt;
        &lt;property name="Sex" not-null="true" update="false"/&gt;
        &lt;property name="Weight"/&gt;
        &lt;many-to-one name="Mate" column="mate_id"/&gt;
        &lt;set name="Kittens"&gt;
            &lt;key column="mother_id"/&gt;
            &lt;one-to-many class="Cat"/&gt;
        &lt;/set&gt;
        &lt;subclass name="DomesticCat" discriminator-value="D"&gt;
            &lt;property name="Name" type="String"/&gt;
        &lt;/subclass&gt;
    &lt;/class&gt;

    &lt;class name="Dog"&gt;
        &lt;!-- mapping for Dog could go here --&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
             We will now discuss the content of the mapping document. We will mainly describe the
             document elements and attributes that are used by NHibernate at runtime. The mapping
             document also contains some extra optional attributes and elements that affect the
             database schemas exported by the schema export tool, for example, the
             <tt class="literal">column</tt> sub-element of a property.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-xmlns"></a>5.1.1.&nbsp;XML Namespace</h3></div></div><div></div></div><p>
                All XML mappings should declare the XML namespace shown. The actual schema definition
                may be found in the <tt class="literal">src\nhibernate-mapping.xsd</tt> file in the
                NHibernate distribution.
            </p><p><span class="emphasis"><em>
                Tip: to enable IntelliSense for mapping and configuration files, copy the appropriate
                <tt class="literal">.xsd</tt> files as part of any project in your solution,
                (<tt class="literal">Build Action</tt> can be "None") or as "Solution Files" or in your
              <tt class="literal">"Lib"</tt> folder and then add it to the <tt class="literal">Schemas</tt> property of the xml file.
              You can copy it in <tt class="literal">&lt;VS installation directory&gt;\Xml\Schemas</tt>, take care because you will have to deal
              with different version of the xsd for different versions of NHibernate.
            </em></span>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-mapping"></a>5.1.2.&nbsp;hibernate-mapping</h3></div></div><div></div></div><p>
                This element has several optional attributes. The <tt class="literal">schema</tt> and <tt class="literal">catalog</tt> attributes
                specify that tables referred to by this mapping belong to the named schema and/or catalog. If they are specified,
                table names will be qualified by the given schema and/or catalog name. If they are missing, table names will be
                unqualified. The <tt class="literal">default-cascade</tt> attribute specifies what cascade style
                should be assumed for properties and collections which do not specify a
                <tt class="literal">cascade</tt> attribute. The <tt class="literal">auto-import</tt> attribute lets us
                use unqualified class names in the query language, by default. The <tt class="literal">assembly</tt>
                and <tt class="literal">namespace</tt> attributes specify the assembly where persistent classes
                are located and the namespace they are declared in.
            </p><div class="programlistingco"><pre class="programlisting">&lt;hibernate-mapping
    schema="schemaName"                               <span class="co">(1)</span>
    catalog="catalogName"                             <span class="co">(2)</span>
    default-cascade="none|save-update..."             <span class="co">(3)</span>
    auto-import="true|false"                          <span class="co">(4)</span>
    assembly="Eg"                                     <span class="co">(5)</span>
    namespace="Eg"                                    <span class="co">(6)</span>
    default-access="field|property|field.camelcase..."<span class="co">(7)</span>
    default-lazy="true|false"                         <span class="co">(8)</span>
 /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (optional): The name of a database schema.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">catalog</tt> (optional): The name of a database catalog.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">default-cascade</tt> (optional - defaults to <tt class="literal">none</tt>):
                            A default cascade style.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">auto-import</tt> (optional - defaults to <tt class="literal">true</tt>):
                            Specifies whether we can use unqualified class names of classes in this mapping
                            in the query language.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">assembly</tt> and <tt class="literal">namespace</tt> (optional): Specify
                            assembly and namespace to use for unqualified class names in the mapping document.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">default-access</tt> (optional - defaults to property):
                            The strategy NHibernate should use for accessing a property value. It can be a custom
                            implementation of <tt class="literal">IPropertyAccessor</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">default-lazy</tt> (optional - defaults to <tt class="literal">true</tt>):
                            The default value for unspecified <tt class="literal">lazy</tt> attributes of class and collection mappings.
                        </p></td></tr></table></div></div><p>
                If you are not using <tt class="literal">assembly</tt> and <tt class="literal">namespace</tt>
                attributes, you have to specify fully-qualified class names, including the name
                of the assembly that classes are declared in.
            </p><p>
                If you have two persistent classes with the same (unqualified) name, you should set
                <tt class="literal">auto-import="false"</tt>. NHibernate will throw an exception if you attempt
                to assign two classes to the same "imported" name.
            </p><p>
                The <tt class="literal">hibernate-mapping</tt> element allows you to nest several persistent <tt class="literal">&lt;class&gt;</tt>
                mappings, as shown above. It is, however, good practice to map only a single persistent class, or a single class
                hierarchy, in one mapping file and name it after the persistent super-class. For example, <tt class="literal">Cat.hbm.xml</tt>,
                <tt class="literal">Dog.hbm.xml</tt>, or if using inheritance, <tt class="literal">Animal.hbm.xml</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-class"></a>5.1.3.&nbsp;class</h3></div></div><div></div></div><p>
                You may declare a persistent class using the <tt class="literal">class</tt> element:
            </p><div class="programlistingco"><pre class="programlisting">&lt;class
    name="className"                                  <span class="co">(1)</span>
    table="tableName"                                 <span class="co">(2)</span>
    discriminator-value="discriminatorValue"          <span class="co">(3)</span>
    mutable="true|false"                              <span class="co">(4)</span>
    schema="owner"                                    <span class="co">(5)</span>
    catalog="catalog"                                 <span class="co">(6)</span>
    proxy="proxyInterface"                            <span class="co">(7)</span>
    dynamic-update="true|false"                       <span class="co">(8)</span>
    dynamic-insert="true|false"                       <span class="co">(9)</span>
    select-before-update="true|false"                 <span class="co">(10)</span>
    polymorphism="implicit|explicit"                  <span class="co">(11)</span>
    where="arbitrary sql where condition"             <span class="co">(12)</span>
    persister="persisterClass"                        <span class="co">(13)</span>
    batch-size="N"                                    <span class="co">(14)</span>
    optimistic-lock="none|version|dirty|all"          <span class="co">(15)</span>
    lazy="true|false"                                 <span class="co">(16)</span>
    abstract="true|false"                             <span class="co">(17)</span>
    entity-name="entityName"                          <span class="co">(18)</span>
    check="arbitrary sql check condition"             <span class="co">(19)</span>
    subselect="SQL expression"                        <span class="co">(20)</span>
    schema-action="none|drop|update|export|validate|all|commaSeparatedValues"  <span class="co">(21)</span>
    rowid="unused"                                    <span class="co">(22)</span>
    node="unused"                                     <span class="co">(23)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified .NET class name of the persistent class
                            (or interface), including its assembly name.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt>(optional - defaults to the unqualified class name): The name of its database table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (optional, defaults to the class name): A value
                            that distinguishes individual subclasses, used for polymorphic behaviour. Acceptable
                            values include <tt class="literal">null</tt> and <tt class="literal">not null</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">mutable</tt> (optional - defaults to <tt class="literal">true</tt>): Specifies
                            that instances of the class are (not) mutable.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (optional): Overrides the schema name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">catalog</tt> (optional): Overrides the catalog name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies an interface to use for lazy
                            initializing proxies. You may specify the name of the class itself.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-update</tt> (optional - defaults to <tt class="literal">false</tt>):
                            Specifies that <tt class="literal">UPDATE</tt> SQL should be generated at runtime and
                            can contain only those columns whose values have changed.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-insert</tt> (optional - defaults to <tt class="literal">false</tt>):
                            Specifies that <tt class="literal">INSERT</tt> SQL should be generated at runtime and
                            contain only the columns whose values are not null.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">select-before-update</tt> (optional - defaults to <tt class="literal">false</tt>):
                            Specifies that NHibernate should <span class="emphasis"><em>never</em></span> perform an SQL <tt class="literal">UPDATE</tt>
                            unless it is certain that an object is actually modified. In certain cases (actually, only
                            when a transient object has been associated with a new session using <tt class="literal">update()</tt>),
                            this means that NHibernate will perform an extra SQL <tt class="literal">SELECT</tt> to determine
                            if an <tt class="literal">UPDATE</tt> is actually required.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">polymorphism</tt> (optional - defaults to <tt class="literal">implicit</tt>):
                            Determines whether implicit or explicit query polymorphism is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                            <tt class="literal">where</tt> (optional) specify an arbitrary SQL <tt class="literal">WHERE</tt>
                            condition to be used when retrieving objects of this class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                            <tt class="literal">persister</tt> (optional): Specifies a custom <tt class="literal">IClassPersister</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                            <tt class="literal">batch-size</tt> (optional - defaults to <tt class="literal">1</tt>): Specifies a "batch size"
                            for fetching instances of this class by identifier. See <a href="#performance-fetching-batch" title="21.1.5.&nbsp;Using batch fetching">Section&nbsp;21.1.5, &#8220;Using batch fetching&#8221;</a>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(15)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">version</tt>):
                            Determines the optimistic locking strategy.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(16)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">true</tt>): Lazy fetching can be
                            disabled by setting <tt class="literal">lazy="false"</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(17)</td><td valign="top" align="left"><p>
                            <tt class="literal">abstract</tt> (optional - defaults to <tt class="literal">false</tt>): Used to mark abstract
                            super-classes in <tt class="literal">&lt;union-subclass&gt;</tt> hierarchies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(18)</td><td valign="top" align="left"><p>
                            <tt class="literal">entity-name</tt> (optional - defaults to the class name): NHibernate allows a class to
                            be mapped multiple times, potentially to different tables. See <a href="#mapping-entityname" title="5.3.&nbsp;Mapping a class more than once">Section&nbsp;5.3, &#8220;Mapping a class more than once&#8221;</a>.
                            It also allows entity mappings that are represented by dictionaries at the .Net level. In these cases,
                            you should provide an explicit arbitrary name for the entity. See
                            <a href="#persistent-classes-dynamicmodels" title="4.4.&nbsp;Dynamic models">Section&nbsp;4.4, &#8220;Dynamic models&#8221;</a> for more information.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(19)</td><td valign="top" align="left"><p>
                            <tt class="literal">check</tt> (optional): An SQL expression used to generate a multi-row check constraint
                            for automatic schema generation.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(20)</td><td valign="top" align="left"><p>
                            <tt class="literal">subselect</tt> (optional): Maps an immutable and read-only entity to a database sub-select.
                            This is useful if you want to have a view instead of a base table. See
                            <a href="#mapping-declaration-subselect" title="5.1.4.&nbsp;subselect">Section&nbsp;5.1.4, &#8220;subselect&#8221;</a> for more information.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(21)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema-action</tt> (optional): Specifies which schema actions should be generated for the
                            class table by the schema export tool. Valid values are <tt class="literal">none</tt>, <tt class="literal">drop</tt>,
                            <tt class="literal">update</tt>, <tt class="literal">export</tt>, <tt class="literal">validate</tt>,
                            <tt class="literal">all</tt> and any combination of them separated by commas (<tt class="literal">,</tt>).
                            Not specifying it is treated as <tt class="literal">all</tt>. See <a href="#toolsetguide-s1" title="22.1.&nbsp;Schema Generation">Section&nbsp;22.1, &#8220;Schema Generation&#8221;</a>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(22)(23)</td><td valign="top" align="left"><p>
                            <tt class="literal">rowid</tt> and <tt class="literal">node</tt> (optional): These attributes have no
                            usage in NHibernate. The <tt class="literal">node</tt> attribute is present on many more mapping elements, and
                            has no usage on them too. It will be omitted from the documentation of these other elements.
                        </p></td></tr></table></div></div><p>
                It is perfectly acceptable for the named persistent class to be an interface. You would then
                declare implementing classes of that interface using the <tt class="literal">&lt;subclass&gt;</tt>
                element. You may persist any inner class. You should specify the
                class name using the standard form ie. <tt class="literal">Eg.Foo+Bar, Eg</tt>.
                Due to an HQL parser limitation inner classes can not be used in queries in NHibernate, unless
                assigning to them an <tt class="literal">entity-name</tt> without the <tt class="literal">+</tt> character.
            </p><p>
                Changes to immutable classes, <tt class="literal">mutable="false"</tt>, will not be
                persisted. This allows NHibernate to make some minor performance optimizations.
            </p><p>
                The optional <tt class="literal">proxy</tt> attribute enables customization of the generated proxy
                for lazy initialization of persistent instances of the class: by default, the proxy derives
                from the class. Specifying an interface causes the proxy to implement it and to use
                <tt class="literal">System.Object</tt> as its base class. This enables proxifying a sealed class
                or a class having non virtual members. The specified interface should declare all the public
                members of the persistent class. On <tt class="literal">ISession.Load</tt> and on
                <tt class="literal">many-to-one</tt> associations, NHibernate will initially return proxies. The
                actual persistent object will be loaded when a method or property of the proxy is invoked.
                See <a href="#performance-fetching-initialization" title="21.1.4.&nbsp;Initializing collections and proxies">Section&nbsp;21.1.4, &#8220;Initializing collections and proxies&#8221;</a>.
            </p><p><span class="emphasis"><em>Implicit</em></span> polymorphism means that instances of the class will be returned
                by a query that names any superclass or implemented interface or the class and that instances
                of any subclass of the class will be returned by a query that names the class itself.
                <span class="emphasis"><em>Explicit</em></span> polymorphism means that class instances will be returned only
                be queries that explicitly name that class and that queries that name the class will return
                only instances of subclasses mapped inside this <tt class="literal">&lt;class&gt;</tt> declaration
                as a <tt class="literal">&lt;subclass&gt;</tt> or <tt class="literal">&lt;joined-subclass&gt;</tt>. For
                most purposes the default, <tt class="literal">polymorphism="implicit"</tt>, is appropriate.
                Explicit polymorphism is useful when two different classes are mapped to the same table
                (this allows a "lightweight" class that contains a subset of the table columns).
            </p><p>
                The <tt class="literal">persister</tt> attribute lets you customize the persistence strategy used for
                the class. You may, for example, specify your own subclass of
                <tt class="literal">NHibernate.Persister.EntityPersister</tt> or you might even provide a
                completely new implementation of the interface
                <tt class="literal">NHibernate.Persister.IClassPersister</tt> that implements persistence via,
                for example, stored procedure calls, serialization to flat files or LDAP. See
                <tt class="literal">NHibernate.DomainModel.CustomPersister</tt> for a simple example (of "persistence"
                to a <tt class="literal">Hashtable</tt>).
            </p><p>
                Note that the <tt class="literal">dynamic-update</tt> and <tt class="literal">dynamic-insert</tt>
                settings are not inherited by subclasses and so may also be specified on the
                <tt class="literal">&lt;subclass&gt;</tt> or <tt class="literal">&lt;joined-subclass&gt;</tt> elements.
                These settings may increase performance in some cases, but might actually decrease
                performance in others. Use judiciously.
            </p><p>
                Use of <tt class="literal">select-before-update</tt> will usually decrease performance. It is very
                useful to prevent a database update trigger being called unnecessarily if you reattach a graph
                of detached instances to an <tt class="literal">ISession</tt>.
            </p><p>
                If you enable <tt class="literal">dynamic-update</tt>, you will have a choice of optimistic
                locking strategies:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">version</tt> check the version/timestamp columns
                    </p></li><li><p>
                        <tt class="literal">all</tt> check all columns
                    </p></li><li><p>
                        <tt class="literal">dirty</tt> check the changed columns
                    </p></li><li><p>
                        <tt class="literal">none</tt> do not use optimistic locking
                    </p></li></ul></div><p>
                We <span class="emphasis"><em>very</em></span> strongly recommend that you use version/timestamp
                columns for optimistic locking with NHibernate. This is the optimal strategy with
                respect to performance and is the only strategy that correctly handles modifications
                made outside of the session (ie. when <tt class="literal">ISession.Update()</tt> is used).
            </p><p>
                Beginning with NHibernate 1.2.0, version numbers start with 1, not 0 as in previous
                versions. This was done to allow using 0 as <tt class="literal">unsaved-value</tt> for the
                version property.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-subselect"></a>5.1.4.&nbsp;subselect</h3></div></div><div></div></div><p>
                An alternative to mapping a class to table or view columns is to map a <span class="emphasis"><em>query</em></span>.
                For that, we use the <tt class="literal">&lt;subselect&gt;</tt> element, which is mutually
                exclusive with <tt class="literal">&lt;subclass&gt;</tt>, <tt class="literal">&lt;joined-subclass&gt;</tt>
                and <tt class="literal">&lt;union-subclass&gt;</tt>. The subselect may also be specified as a
                <tt class="literal">&lt;class&gt;</tt> attribute.
                The content of the <tt class="literal">subselect</tt> element is a SQL query:
            </p><pre class="programlisting">&lt;subselect&gt;
    &lt;![CDATA[
    SELECT cat.ID, cat.NAME, cat.SEX, cat.MATE FROM cat
    ]]&gt;
&lt;/subselect&gt;</pre><p>
                Usually, when mapping a query using <tt class="literal">subselect</tt> you will want to mark
                the class as not mutable (<tt class="literal">mutable="false"</tt>), unless you specify custom
                SQL for performing the UPDATE, DELETE and INSERT operations.
            </p><p>
                Also, it makes sense to force synchronization of the tables affected by the query, using
                one or more <tt class="literal">&lt;synchronize&gt;</tt> entries:
            </p><pre class="programlisting">&lt;subselect&gt;
    &lt;![CDATA[
    SELECT cat.ID, cat.NAME, cat.SEX, cat.MATE FROM cat
    ]]&gt;
&lt;/subselect&gt;
&lt;synchronize table="cat"/&gt;</pre><p>
                This ensures that auto-flush happens correctly and that queries against the derived entity
                do not return stale data.
            </p><p>
                You then still have to declare the class id and properties.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-id"></a>5.1.5.&nbsp;id</h3></div></div><div></div></div><p>
                Mapped classes <span class="emphasis"><em>must</em></span> declare the primary key column of the database
                table. Most classes will also have a property holding the unique identifier
                of an instance. The <tt class="literal">&lt;id&gt;</tt> element defines the mapping from that
                property to the primary key column.
            </p><div class="programlistingco"><pre class="programlisting">&lt;id
    name="propertyName"                               <span class="co">(1)</span>
    type="typeName"                                   <span class="co">(2)</span>
    length="typeLength"                               <span class="co">(3)</span>
    column="columnName"                               <span class="co">(4)</span>
    unsaved-value="any|none|null|undefined|idValue"   <span class="co">(5)</span>
    access="field|property|nosetter|className"        <span class="co">(6)</span>
    generator="generatorClass"&gt;                       <span class="co">(7)</span>

    &lt;generator class="generatorClass"/&gt;
&lt;/id&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> (optional): The name of the identifier property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional): A name that indicates the NHibernate type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">length</tt> (optional): If the type takes a length and does not
                            already specify it, its length.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The
                            name of the primary key column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to a "sensible" value):
                            An identifier property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">generator</tt>: The name of a generator class to use for generating
                            unique identifiers for instances of the persistent class. See the
                            <a href="#mapping-declaration-id-generator" title="5.1.5.1.&nbsp;generator">generator element</a>. Specifying
                            either the attribute or the element is required. The attribute takes precedence over
                            the element.
                        </p></td></tr></table></div></div><p>
                If the <tt class="literal">name</tt> attribute is missing, it is assumed that the class has no
                identifier property.
            </p><p>
                The <tt class="literal">unsaved-value</tt> attribute is almost never needed in NHibernate.
            </p><p>
                There is an alternative <tt class="literal">&lt;composite-id&gt;</tt> declaration to allow access to
                legacy data with composite keys. We strongly discourage its use for anything else.
            </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-generator"></a>5.1.5.1.&nbsp;generator</h4></div></div><div></div></div><p>
                    The required <tt class="literal">generator</tt> names a .NET class used to generate unique identifiers
                    for instances of the persistent class.
                </p><p>
                  The generator can be declared using the <tt class="literal">&lt;generator&gt;</tt> child element. If
                  any parameters are required to configure or initialize the generator instance, they are passed
                  using <tt class="literal">&lt;param&gt;</tt> elements.
                </p><pre class="programlisting">&lt;id name="Id" type="Int64" column="uid"&gt;
    &lt;generator class="NHibernate.Id.TableHiLoGenerator"&gt;
        &lt;param name="table"&gt;uid_table&lt;/param&gt;
        &lt;param name="column"&gt;next_hi_value_column&lt;/param&gt;
    &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    If no parameters are required, the generator can be declared using a <tt class="literal">generator</tt>
                    attribute directly on the <tt class="literal">&lt;id&gt;</tt> element, as follows:
                </p><pre class="programlisting">&lt;id name="Id" type="Int64" column="uid" generator="native" /&gt;</pre><p>
                    All generators implement the interface <tt class="literal">NHibernate.Id.IIdentifierGenerator</tt>.
                    This is a very simple interface; some applications may choose to provide their own specialized
                    implementations. However, NHibernate provides a range of built-in implementations. There are shortcut
                    names for the built-in generators:

                    </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">increment</tt></span></dt><dd><p>
                                generates identifiers of any integral type that are unique only when
                                no other process is inserting data into the same table.
                                <span class="emphasis"><em>Do not use in a cluster.</em></span>
                            </p></dd><dt><span class="term"><tt class="literal">counter</tt>, <tt class="literal">vm</tt></span></dt><dd><p>
                                generates identifiers of 64bits integral type constructed from the system
                                time and a counter value.
                                <span class="emphasis"><em>Do not use in a cluster.  May generate colliding identifiers in
                                a bit less than one year.</em></span>
                            </p></dd><dt><span class="term"><tt class="literal">identity</tt></span></dt><dd><p>
                                supports identity columns in DB2, MySQL, MS SQL Server, Sybase and some other systems.
                                The identifier returned by the database is converted to the property type using
                                <tt class="literal">Convert.ChangeType</tt>. Any integral property type is thus supported.
                                See <a href="#mapping-declaration-id-sequences" title="5.1.5.6.&nbsp;Identity columns and Sequences">Section&nbsp;5.1.5.6, &#8220;Identity columns and Sequences&#8221;</a>.
                            </p></dd><dt><span class="term"><tt class="literal">sequence</tt></span></dt><dd><p>
                                uses a sequence in DB2, PostgreSQL, Oracle and some other systems, or a generator
                                in Firebird. The identifier returned by the database is converted to the property
                                type using <tt class="literal">Convert.ChangeType</tt>. Any integral property type is
                                thus supported.
                                See <a href="#mapping-declaration-id-sequences" title="5.1.5.6.&nbsp;Identity columns and Sequences">Section&nbsp;5.1.5.6, &#8220;Identity columns and Sequences&#8221;</a>.
                            </p></dd><dt><span class="term"><tt class="literal">hilo</tt></span></dt><dd><p><a name="mapping-declaration-id-hilodescription"></a>
                                uses a hi/lo algorithm to efficiently generate identifiers of any integral type,
                                given a table and column (by default <tt class="literal">hibernate_unique_key</tt> and
                                <tt class="literal">next_hi</tt> respectively) as a source of hi values. The hi/lo algorithm
                                generates identifiers that are unique only for a particular database. <span class="emphasis"><em>Do not
                                use this generator with an user-supplied connection.</em></span> See
                                <a href="#mapping-declaration-id-hilo" title="5.1.5.2.&nbsp;Hi/Lo Algorithm">Section&nbsp;5.1.5.2, &#8220;Hi/Lo Algorithm&#8221;</a>.
                            </p></dd><dt><span class="term"><tt class="literal">seqhilo</tt></span></dt><dd><p>
                                uses a hi/lo algorithm to efficiently generate identifiers of any integral type,
                                given a named database sequence. See <a href="#mapping-declaration-id-hilo" title="5.1.5.2.&nbsp;Hi/Lo Algorithm">Section&nbsp;5.1.5.2, &#8220;Hi/Lo Algorithm&#8221;</a>.
                            </p></dd><dt><span class="term"><tt class="literal">uuid.hex</tt></span></dt><dd><p>
                                uses <tt class="literal">System.Guid</tt> and its <tt class="literal">ToString(string format)</tt> method
                                to generate identifiers of type string.  The length of the string returned depends on the 
                                configured <tt class="literal">format</tt>. See <a href="#mapping-declaration-id-uuid-hex" title="5.1.5.3.&nbsp;UUID Hex Algorithm">Section&nbsp;5.1.5.3, &#8220;UUID Hex Algorithm&#8221;</a>.
                            </p></dd><dt><span class="term"><tt class="literal">uuid.string</tt></span></dt><dd><p>
                                uses a new <tt class="literal">System.Guid</tt> to create a <tt class="literal">byte[]</tt> that is
                                converted to a string. See <a href="#mapping-declaration-id-uuid-string" title="5.1.5.4.&nbsp;UUID String Algorithm">Section&nbsp;5.1.5.4, &#8220;UUID String Algorithm&#8221;</a>.
                            </p></dd><dt><span class="term"><tt class="literal">guid</tt></span></dt><dd><p>
                                uses a new <tt class="literal">System.Guid</tt> as the identifier. It is <span class="emphasis"><em>not equivalent</em></span>
                                to the Hibernate <tt class="literal">guid</tt> generator. See <a href="#mapping-declaration-id-guid" title="5.1.5.5.&nbsp;GUID Algorithms">Section&nbsp;5.1.5.5, &#8220;GUID Algorithms&#8221;</a>.
                            </p></dd><dt><span class="term"><tt class="literal">guid.comb</tt></span></dt><dd><p>
                                uses the algorithm to generate a new <tt class="literal">System.Guid</tt>
                                described by Jimmy Nilsson in
                                <a href="https://www.informit.com/articles/article.aspx?p=25862" target="_top">this
                                article</a>. See also <a href="#mapping-declaration-id-guid" title="5.1.5.5.&nbsp;GUID Algorithms">Section&nbsp;5.1.5.5, &#8220;GUID Algorithms&#8221;</a>.
                            </p></dd><dt><span class="term"><tt class="literal">guid.native</tt></span></dt><dd><p>
                                uses the database server side Guid function.
                            </p></dd><dt><span class="term"><tt class="literal">native</tt></span></dt><dd><p>
                                picks <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> or
                                <tt class="literal">hilo</tt> depending upon the capabilities of the
                                underlying database.
                                See <a href="#mapping-declaration-id-sequences" title="5.1.5.6.&nbsp;Identity columns and Sequences">Section&nbsp;5.1.5.6, &#8220;Identity columns and Sequences&#8221;</a>.
                            </p></dd><dt><span class="term"><tt class="literal">assigned</tt></span></dt><dd><p>
                                lets the application to assign an identifier to the object before
                                <tt class="literal">Save()</tt> is called.
                                See <a href="#mapping-declaration-id-assigned" title="5.1.5.7.&nbsp;Assigned Identifiers">Section&nbsp;5.1.5.7, &#8220;Assigned Identifiers&#8221;</a>.
                            </p></dd><dt><span class="term"><tt class="literal">select</tt></span></dt><dd><p>
                                retrieves a primary key, assigned by a database trigger, by selecting the row by some
                                unique key and retrieving the primary key value.
                                See <a href="#mapping-declaration-id-select" title="5.1.5.8.&nbsp;Primary keys assigned by triggers">Section&nbsp;5.1.5.8, &#8220;Primary keys assigned by triggers&#8221;</a>.
                            </p></dd><dt><span class="term"><tt class="literal">foreign</tt></span></dt><dd><p>
                                uses the identifier of another associated object. It is usually used in conjunction
                                with a <tt class="literal">&lt;one-to-one&gt;</tt> primary key association.
                            </p></dd><dt><span class="term"><tt class="literal">sequence-identity</tt></span></dt><dd><p>
                                a generator which combines sequence generation with immediate retrieval
                                by attaching an output parameter to the SQL command.
                                In this respect it works much like ANSI-SQL identity generation.
                            </p></dd><dt><span class="term"><tt class="literal">trigger-identity</tt></span></dt><dd><p>
                                a generator which uses an output parameter to return the identifier generated by the insert
                                on database server side.
                            </p></dd><dt><span class="term"><tt class="literal">enhanced-sequence</tt></span></dt><dd><p>
                                uses a sequence with database supporting them, otherwise uses a table for emulating the sequence.
                                See <a href="#mapping-declaration-id-enhanced" title="5.1.5.9.&nbsp;Enhanced identifier generators">Section&nbsp;5.1.5.9, &#8220;Enhanced identifier generators&#8221;</a>. Supports
                                <a href="#mapping-declaration-id-enhanced-optimizers" title="5.1.5.9.1.&nbsp;Identifier generator optimization">Section&nbsp;5.1.5.9.1, &#8220;Identifier generator optimization&#8221;</a>.
                            </p></dd><dt><span class="term"><tt class="literal">enhanced-table</tt></span></dt><dd><p>
                                uses a table like the <tt class="literal">hilo</tt> generator, but can handle multiple increment values
                                per table. See <a href="#mapping-declaration-id-enhanced" title="5.1.5.9.&nbsp;Enhanced identifier generators">Section&nbsp;5.1.5.9, &#8220;Enhanced identifier generators&#8221;</a>. Supports
                                <a href="#mapping-declaration-id-enhanced-optimizers" title="5.1.5.9.1.&nbsp;Identifier generator optimization">Section&nbsp;5.1.5.9.1, &#8220;Identifier generator optimization&#8221;</a>.
                            </p></dd></dl></div><p>

                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-hilo"></a>5.1.5.2.&nbsp;Hi/Lo Algorithm</h4></div></div><div></div></div><p>
                    The <tt class="literal">hilo</tt> and <tt class="literal">seqhilo</tt> generators provide two alternate
                    implementations of the hi/lo algorithm, a favorite approach to identifier generation. The
                    first implementation requires a "special" database table to hold the next available "hi" value.
                    The second uses an Oracle-style sequence (where supported).
                </p><p>
                    Unfortunately, you can't use <tt class="literal">hilo</tt> when supplying your own
                    <tt class="literal">DbConnection</tt> to NHibernate. NHibernate must be able to
                    fetch the "hi" value in a new transaction.
                </p><pre class="programlisting">&lt;id name="Id" type="Int64" column="cat_id"&gt;
    &lt;generator class="hilo"&gt;
        &lt;param name="table"&gt;tableName&lt;/param&gt;
        &lt;param name="column"&gt;columnName&lt;/param&gt;
        &lt;param name="schema"&gt;schemaName&lt;/param&gt;
        &lt;param name="catalog"&gt;catalogName&lt;/param&gt;
        &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;param name="where"&gt;arbitraryWhereClause&lt;/param&gt;
    &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    <tt class="literal">table</tt> defaults to <tt class="literal">hibernate_unique_key</tt>,
                    <tt class="literal">column</tt> defaults to <tt class="literal">next_hi</tt>,
                    and <tt class="literal">max_lo</tt> defaults to <tt class="literal">32767</tt>.
                    <tt class="literal">schema</tt>, <tt class="literal">catalog</tt> and <tt class="literal">where</tt>
                    are optional and have no default value.
                </p><p>
                    You can use the optional <tt class="literal">where</tt> parameter to specify the row to use in a table. This is
                    useful if you want to use a single table for your identifiers, with different rows for each table. Do not
                    include the <tt class="literal">where</tt> keyword in its value.
                    This is not handled by NHibernate schema generation tooling.
                </p><pre class="programlisting">&lt;id name="Id" type="Int64" column="cat_id"&gt;
    &lt;generator class="seqhilo"&gt;
        &lt;param name="sequence"&gt;hi_value&lt;/param&gt;hibernate_sequence
        &lt;param name="schema"&gt;schemaName&lt;/param&gt;
        &lt;param name="catalog"&gt;catalogName&lt;/param&gt;
        &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;param name="parameters"&gt;arbitrarySqlFragment&lt;/param&gt;
    &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    <tt class="literal">sequence</tt> defaults to <tt class="literal">hibernate_sequence</tt>,
                    and <tt class="literal">max_lo</tt> defaults to <tt class="literal">9</tt>.
                    <tt class="literal">schema</tt>, <tt class="literal">catalog</tt> and <tt class="literal">parameters</tt>
                    are optional and have no default value.
                </p><p>
                    You can use the optional <tt class="literal">parameters</tt> parameter to specify some SQL to be
                    appended to the create sequence DDL.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-uuid-hex"></a>5.1.5.3.&nbsp;UUID Hex Algorithm</h4></div></div><div></div></div><pre class="programlisting">&lt;id name="Id" type="String" column="cat_id"&gt;
    &lt;generator class="uuid.hex"&gt;
        &lt;param name="format"&gt;format_value&lt;/param&gt;
        &lt;param name="separator"&gt;separator_value&lt;/param&gt;
    &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    The UUID is generated by calling <tt class="literal">Guid.NewGuid().ToString(format)</tt>.
                    The valid values for <tt class="literal">format</tt> are described in the MSDN documentation.
                    The default <tt class="literal">separator</tt> is <tt class="literal">-</tt> and should rarely be
                    modified.  The <tt class="literal">format</tt> determines if the configured
                    <tt class="literal">separator</tt> can replace the default separator used by
                    the <tt class="literal">format</tt>.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-uuid-string"></a>5.1.5.4.&nbsp;UUID String Algorithm</h4></div></div><div></div></div><p>
                    The UUID is generated by calling <tt class="literal">Guid.NewGuid().ToByteArray()</tt> and
                    then converting the <tt class="literal">byte[]</tt> into a <tt class="literal">char[]</tt>.  The
                    <tt class="literal">char[]</tt> is returned as a <tt class="literal">String</tt> consisting of
                    16 characters.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-guid"></a>5.1.5.5.&nbsp;GUID Algorithms</h4></div></div><div></div></div><p>
                    The <tt class="literal">guid</tt> identifier is generated by calling <tt class="literal">Guid.NewGuid()</tt>.
                    To address some of the performance concerns with using Guids as primary keys, foreign keys, and
                    as part of indexes with MS SQL the <tt class="literal">guid.comb</tt> can be used.  The benefit of using
                    the <tt class="literal">guid.comb</tt> with other databases that support GUIDs has not been measured.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-sequences"></a>5.1.5.6.&nbsp;Identity columns and Sequences</h4></div></div><div></div></div><p>
                    For databases which support identity columns (DB2, MySQL, Sybase, MS SQL), you
                    may use <tt class="literal">identity</tt> key generation. For databases that support
                    sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you may use
                    <tt class="literal">sequence</tt> style key generation. Both these strategies require
                    two SQL queries to insert a new object.
                </p><pre class="programlisting">&lt;id name="Id" type="Int64" column="uid"&gt;
    &lt;generator class="sequence"&gt;
        &lt;param name="sequence"&gt;uid_sequence&lt;/param&gt;
    &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="Id" type="Int64" column="uid"&gt;
    &lt;generator class="identity"/&gt;
&lt;/id&gt;</pre><p>
                    For cross-platform development, the <tt class="literal">native</tt> strategy will
                    choose from the <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> and
                    <tt class="literal">hilo</tt> strategies, dependent upon the capabilities of the
                    underlying database.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-assigned"></a>5.1.5.7.&nbsp;Assigned Identifiers</h4></div></div><div></div></div><p>
                    If you want the application to assign identifiers (as opposed to having
                    NHibernate generate them), you may use the <tt class="literal">assigned</tt> generator.
                    This special generator will use the identifier value already assigned to the
                    object's identifier property. Be very careful when using this feature to assign
                    keys with business meaning (almost always a terrible design decision).
                </p><p>
                    Due to its inherent nature, entities that use this generator may, when saved via
                    the ISession's SaveOrUpdate() method, cause NHibernate to query the database for
                    checking if the entity exist or not.
                </p><p>
                    To avoid this, either:
                </p><div class="itemizedlist"><ul type="disc"><li><p>
                            ensure that the identifier <tt class="literal">unsaved-value</tt> is not defined or is set
                            to <tt class="literal">undefined</tt>, and define an <tt class="literal">unsaved-value</tt> on
                            a <tt class="literal">&lt;version&gt;</tt> or <tt class="literal">&lt;timestamp&gt;</tt> property
                            mapping for the class. (Depending on the version type, its default
                            <tt class="literal">unsaved-value</tt> will generally already be suitable.)
                        </p></li><li><p>
                            specify to NHibernate if the object should be saved or updated by calling either the
                            <tt class="literal">Save()</tt> or <tt class="literal">Update()</tt> method of the ISession.
                        </p></li><li><p>
                            set <tt class="literal">unsaved-value="none"</tt> and explicitly <tt class="literal">Save()</tt>
                            newly instantiated objects.
                        </p></li><li><p>
                            set <tt class="literal">unsaved-value="any"</tt> and explicitly <tt class="literal">Update()</tt>
                            previously persistent objects.
                        </p></li><li><p>
                            implement <tt class="literal">IInterceptor.IsTransient()</tt> for providing your own strategy
                            for distinguishing newly instantiated objects. See
                            <a href="#objectstate-interceptors" title="13.1.&nbsp;Interceptors">Section&nbsp;13.1, &#8220;Interceptors&#8221;</a>.
                        </p></li></ul></div><p>
                    For assigned identifiers, <tt class="literal">unsaved-value</tt> default value is
                    <tt class="literal">undefined</tt>.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-select"></a>5.1.5.8.&nbsp;Primary keys assigned by triggers</h4></div></div><div></div></div><p>
                    NHibernate does not generate DDL with triggers. It is for legacy schemas only.
                </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
    &lt;generator class="select"&gt;
        &lt;param name="key"&gt;socialSecurityNumber&lt;/param&gt;
    &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    In the above example, there is a unique valued property named
                    <tt class="literal">socialSecurityNumber</tt>. It is defined by the class, as a property.
                    And a surrogate key named person_id has its value generated by a trigger. Its value
                    will be retrieved by querying the entity table filtered by the <tt class="literal">key</tt>
                    property.
                </p><p>
                    If the class maps a <a href="#mapping-declaration-naturalid" title="5.1.13.&nbsp;natural-id">natural id</a>,
                    <tt class="literal">key</tt> can be omitted. The natural id will be used when
                    <tt class="literal">key</tt> is omitted.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-enhanced"></a>5.1.5.9.&nbsp;Enhanced identifier generators</h4></div></div><div></div></div><p>Starting with NHibernate release 3.3.0, there are two new generators which
                represent a re-thinking of two different aspects of identifier
                generation. The first aspect is database portability; the second is
                optimization. Optimization means that you do not have to query the
                database for every request for a new identifier value. These two new
                generators are intended to take the place of some of the named
                generators described above.</p><p>The first of these new generators is
                <tt class="literal">NHibernate.Id.Enhanced.SequenceStyleGenerator</tt>
                (short name <tt class="literal">enhanced-sequence</tt>)
                which is intended, firstly, as a replacement for the
                <tt class="literal">sequence</tt> generator and, secondly, as a better
                portability generator than <tt class="literal">native</tt>. This is because
                <tt class="literal">native</tt> generally chooses between
                <tt class="literal">identity</tt> and <tt class="literal">sequence</tt> which have
                largely different semantics that can cause subtle issues in
                applications eyeing portability.
                <tt class="literal">NHibernate.Id.Enhanced.SequenceStyleGenerator</tt>,
                however, achieves portability in a different manner. It chooses
                between a table or a sequence in the database to store its
                incrementing values, depending on the capabilities of the dialect
                being used. The difference between this and <tt class="literal">native</tt>
                is that table-based and sequence-based storage have the same exact
                semantic. In fact, sequences are exactly what NHibernate tries to
                emulate with its table-based generators. This generator has a number
                of configuration parameters: </p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">sequence_name</tt> (optional - defaults to
                      <tt class="literal">hibernate_sequence</tt>): the name of the sequence
                      or table to be used. <tt class="literal">schema</tt> and
                      <tt class="literal">catalog</tt> parameters can be additionally used
                      to qualify the sequence name.</p></li><li><p><tt class="literal">initial_value</tt> (optional - defaults to
                      <tt class="literal">1</tt>): the initial value to be retrieved from
                      the sequence/table. In sequence creation terms, this is
                      analogous to the clause typically named "STARTS WITH".</p></li><li><p><tt class="literal">increment_size</tt> (optional - defaults to
                      <tt class="literal">1</tt>): the value by which subsequent calls to
                      the sequence/table should differ. In sequence creation terms,
                      this is analogous to the clause typically named "INCREMENT
                      BY".</p></li><li><p><tt class="literal">force_table_use</tt> (optional - defaults to
                      <tt class="literal">false</tt>): should we force the use of a table as
                      the backing structure even though the dialect might support
                      sequence?</p></li><li><p><tt class="literal">value_column</tt> (optional - defaults to
                      <tt class="literal">next_val</tt>): only relevant for table
                      structures, it is the name of the column on the table which is
                      used to hold the value.</p></li><li><p><tt class="literal">optimizer</tt> (optional - defaults to
                      <tt class="literal">none</tt> if <tt class="literal">increment_size</tt> is <tt class="literal">1</tt>):
                       See <a href="#mapping-declaration-id-enhanced-optimizers" title="5.1.5.9.1.&nbsp;Identifier generator optimization">Section&nbsp;5.1.5.9.1, &#8220;Identifier generator optimization&#8221;</a></p></li></ul></div><p>The second of these new generators is
                <tt class="literal">NHibernate.Id.Enhanced.TableGenerator</tt> (short name <tt class="literal">enhanced-table</tt>), which is
                intended, firstly, as a replacement for the <tt class="literal">table</tt>
                generator, even though it actually functions much more like
                <tt class="literal">org.hibernate.id.MultipleHiLoPerTableGenerator</tt> (not available in NHibernate), and
                secondly, as a re-implementation of
                <tt class="literal">org.hibernate.id.MultipleHiLoPerTableGenerator</tt> (not available in NHibernate) that
                utilizes the notion of pluggable optimizers. Essentially this
                generator defines a table capable of holding a number of different
                increment values simultaneously by using multiple distinctly keyed
                rows. This generator has a number of configuration parameters:
                </p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">table_name</tt> (optional - defaults to
                      <tt class="literal">hibernate_sequences</tt>): the name of the table
                      to be used. <tt class="literal">schema</tt> and
                      <tt class="literal">catalog</tt> parameters can be additionally used
                      to qualify the sequence name.</p></li><li><p><tt class="literal">value_column_name</tt> (optional - defaults
                      to <tt class="literal">next_val</tt>): the name of the column on the
                      table that is used to hold the value.</p></li><li><p><tt class="literal">segment_column_name</tt> (optional -
                      defaults to <tt class="literal">sequence_name</tt>): the name of the
                      column on the table that is used to hold the "segment key". This
                      is the value which identifies which increment value to
                      use.</p></li><li><p><tt class="literal">segment_value</tt> (optional - defaults to
                      <tt class="literal">default</tt> unless
                      <tt class="literal">prefer_entity_table_as_segment_value</tt> is
                      <tt class="literal">true</tt>): The "segment key" value for the
                      segment from which we want to pull increment values for this
                      generator.</p></li><li><p><tt class="literal">segment_value_length</tt> (optional -
                      defaults to <tt class="literal">255</tt>): Used for schema generation;
                      the column size to create this segment key column.</p></li><li><p><tt class="literal">prefer_entity_table_as_segment_value</tt>
                      (optional - defaults to <tt class="literal">false</tt>): If
                      <tt class="literal">segment_value</tt> is not specified, whether it
                      should defaults to the entity table name or to
                      <tt class="literal">default</tt>.</p></li><li><p><tt class="literal">initial_value</tt> (optional - defaults to
                      <tt class="literal">1</tt>): The initial value to be retrieved from
                      the table.</p></li><li><p><tt class="literal">increment_size</tt> (optional - defaults to
                      <tt class="literal">1</tt>): The value by which subsequent calls to
                      the table should differ.</p></li><li><p><tt class="literal">optimizer</tt> (optional - defaults to
                      <tt class="literal">none</tt> if <tt class="literal">increment_size</tt> is <tt class="literal">1</tt>): See <a href="#mapping-declaration-id-enhanced-optimizers" title="5.1.5.9.1.&nbsp;Identifier generator optimization">Section&nbsp;5.1.5.9.1, &#8220;Identifier generator optimization&#8221;</a>.</p></li></ul></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="mapping-declaration-id-enhanced-optimizers"></a>5.1.5.9.1.&nbsp;Identifier generator optimization</h5></div></div><div></div></div><p>For identifier generators that store values in the database,
                  it is inefficient for them to hit the database on each and every
                  call to generate a new identifier value. Instead, you can group a
                  bunch of them in memory and only hit the database when you have
                  exhausted your in-memory value group. This is the role of the
                  pluggable optimizers. Currently only the two enhanced generators
                  (<a href="#mapping-declaration-id-enhanced" title="5.1.5.9.&nbsp;Enhanced identifier generators">Section&nbsp;5.1.5.9, &#8220;Enhanced identifier generators&#8221;</a> support this
                  operation.</p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">none</tt> (generally this is the default if
                      no optimizer was specified): this will not perform any
                      optimizations and hit the database for each and every
                      request.</p></li><li><p><tt class="literal">hilo</tt>: applies a hi/lo algorithm around
                      the database retrieved values. The values from the database for
                      this optimizer are expected to be sequential. The values
                      retrieved from the database structure for this optimizer
                      indicates the "group number". The
                      <tt class="literal">increment_size</tt> is multiplied by that value in
                      memory to define a group "hi value".</p></li><li><p><tt class="literal">pooled</tt>: as with the case of
                      <tt class="literal">hilo</tt>, this optimizer attempts to minimize the
                      number of hits to the database. Here, however, we simply store
                      the starting value for the "next group" into the database
                      structure rather than a sequential value in combination with an
                      in-memory grouping algorithm. Here,
                      <tt class="literal">increment_size</tt> refers to the values coming
                      from the database.</p></li><li><p><tt class="literal">pooled-lo</tt>: similar to
                      <tt class="literal">pooled</tt>, except that it's the starting value of
                      the "current group" that is stored into the database structure.
                      Here,
                      <tt class="literal">increment_size</tt> refers to the values coming
                      from the database.</p></li></ul></div></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-compositeid"></a>5.1.6.&nbsp;composite-id</h3></div></div><div></div></div><pre class="programlisting">&lt;composite-id
    name="propertyName"
    class="className"
    unsaved-value="any|none"
    access="field|property|nosetter|className"
    mapped="true|false"&gt;

    &lt;key-property name="propertyName" type="typeName" column="columnName"/&gt;
    &lt;key-many-to-one name="propertyName class="className" column="columnName"/&gt;
    ...
&lt;/composite-id&gt;</pre><p>
                For a table with a composite key, you may map multiple properties of the class
                as identifier properties. The <tt class="literal">&lt;composite-id&gt;</tt> element
                accepts <tt class="literal">&lt;key-property&gt;</tt> property mappings and
                <tt class="literal">&lt;key-many-to-one&gt;</tt> mappings as child elements.
            </p><pre class="programlisting">&lt;composite-id&gt;
    &lt;key-property name="MedicareNumber"/&gt;
    &lt;key-property name="Dependent"/&gt;
&lt;/composite-id&gt;</pre><p>
                Your persistent class <span class="emphasis"><em>must</em></span> override <tt class="literal">Equals()</tt>
                and <tt class="literal">GetHashCode()</tt> to implement composite identifier equality. It must
                also be marked with the <tt class="literal">Serializable</tt> attribute.
            </p><p>
                Unfortunately, this approach to composite identifiers means that a persistent object
                is its own identifier. There is no convenient "handle" other than the object itself.
                You must instantiate an instance of the persistent class itself and populate its
                identifier properties before you can <tt class="literal">Load()</tt> the persistent state
                associated with a composite key. We call this approach an embedded composite identifier,
                and discourage it for serious applications.
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">unsaved-value</tt> (optional - default to <tt class="literal">undefined</tt>):
                        controls how transient instances are considered. <tt class="literal">any</tt> assumes
                        any transient instance is newly instantiated. In other words, the instance will be
                        saved (inserted in the database). <tt class="literal">none</tt> assumes any transient instance
                        is already persisted. In other words, the instance will be updated.
                        <tt class="literal">undefined</tt> does not assume anything: NHibernate may query the database
                        for determining if the entity is already persisted or not.
                    </p></li><li><p>
                        <tt class="literal">mapped</tt> (optional - defaults to <tt class="literal">false</tt>):
                        This attribute has no usage in NHibernate.
                    </p></li></ul></div><p>
                A much more convenient approach is to implement the composite identifier as a separate class,
                as in <a href="#components-compositeid" title="8.4.&nbsp;Components as composite identifiers">Section&nbsp;8.4, &#8220;Components as composite identifiers&#8221;</a>. The attributes described below apply only
                to this alternative approach:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">name</tt> (optional, required for this approach): A property of
                        component type that holds the composite identifier (see <a href="#components-compositeid" title="8.4.&nbsp;Components as composite identifiers">Section&nbsp;8.4, &#8220;Components as composite identifiers&#8221;</a>).
                    </p></li><li><p>
                        <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>):
                        The strategy NHibernate should use for accessing the property value.
                    </p></li><li><p>
                        <tt class="literal">class</tt> (optional - defaults to the property type determined by
                        reflection): The component class used as a composite identifier.
                    </p></li></ul></div><p>
                The second approach, an identifier component, is recommended for almost all applications.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-discriminator"></a>5.1.7.&nbsp;discriminator</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;discriminator&gt;</tt> element is required for polymorphic persistence
                using the table-per-class-hierarchy mapping strategy and declares a discriminator column of the
                table. The discriminator column contains marker values that tell the persistence layer what
                subclass to instantiate for a particular row. A restricted set of types may be used:
                <tt class="literal">String</tt>, <tt class="literal">Char</tt>, <tt class="literal">Int32</tt>,
                <tt class="literal">Byte</tt>, <tt class="literal">Short</tt>, <tt class="literal">Boolean</tt>,
                <tt class="literal">YesNo</tt>, <tt class="literal">TrueFalse</tt>.
            </p><div class="programlistingco"><pre class="programlisting">&lt;discriminator
    column="discriminatorColumn"                      <span class="co">(1)</span>
    type="discriminatorType"                          <span class="co">(2)</span>
    length="typeLength"                               <span class="co">(3)</span>
    not-null="true|false"                             <span class="co">(4)</span>
    force="true|false"                                <span class="co">(5)</span>
    insert="true|false"                               <span class="co">(6)</span>
    formula="arbitrary SQL expression"                <span class="co">(7)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to <tt class="literal">class</tt>): the
                            name of the discriminator column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional - defaults to <tt class="literal">String</tt>): a
                            name that indicates the NHibernate type
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">length</tt> (optional): if the type takes a length and does not
                            already specify it, its length.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-null</tt> (optional - defaults to <tt class="literal">true</tt>):
                            sets the column nullability for DDL generation.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">force</tt> (optional - defaults to <tt class="literal">false</tt>):
                            "force" NHibernate to specify allowed discriminator values even when retrieving 
                            all instances of the root class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> (optional - defaults to <tt class="literal">true</tt>):
                            set this to <tt class="literal">false</tt> if your discriminator column is also part
                            of a mapped composite identifier.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional): an arbitrary SQL expression that is
                            executed when a type has to be evaluated. Allows content-based discrimination.
                        </p></td></tr></table></div></div><p>
                Actual values of the discriminator column are specified by the
                <tt class="literal">discriminator-value</tt> attribute of the <tt class="literal">&lt;class&gt;</tt> and
                <tt class="literal">&lt;subclass&gt;</tt> elements.
            </p><p>
                The <tt class="literal">force</tt> attribute is only useful if the table contains rows with
                "extra" discriminator values that are not mapped to a persistent class. This will not
                usually be the case.
            </p><p>
                Using the <tt class="literal">formula</tt> attribute, you can declare an arbitrary SQL expression
                that will be used to evaluate the type of a row:
            </p><pre class="programlisting">&lt;discriminator
    formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
    type="Int32"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-version"></a>5.1.8.&nbsp;version (optional)</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;version&gt;</tt> element is optional and indicates that
                the table contains versioned data. This is particularly useful if you plan to
                use <span class="emphasis"><em>long transactions</em></span> (see <a href="#transactions-optimistic" title="12.4.&nbsp;Optimistic concurrency control">Section&nbsp;12.4, &#8220;Optimistic concurrency control&#8221;</a>).
            </p><div class="programlistingco"><pre class="programlisting">&lt;version
    column="versionColumn"                            <span class="co">(1)</span>
    name="propertyName"                               <span class="co">(2)</span>
    type="typeName"                                   <span class="co">(3)</span>
    access="field|property|nosetter|className"        <span class="co">(4)</span>
    unsaved-value="null|negative|undefined|value"     <span class="co">(5)</span>
    generated="never|always"                          <span class="co">(6)</span>
    insert="false|true"                               <span class="co">(7)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The name
                            of the column holding the version number.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of a property  of the persistent class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional - defaults to <tt class="literal">Int32</tt>):
                            The type of the version number.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to a "sensible" value):
                            A version property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session. <tt class="literal">undefined</tt> specifies that nothing
                            should be assumed from the version property. The identifier check on its own
                            <tt class="literal">unsaved-value</tt> will take precedence, unless its own value is
                            <tt class="literal">undefined</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">generated</tt> (optional - defaults to <tt class="literal">never</tt>):
                            Specifies that this version property value is actually generated by the database.
                            See the discussion of <a href="#mapping-generated" title="5.6.&nbsp;Generated Properties">generated properties</a>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> (optional - defaults to <tt class="literal">false</tt>):
                            This attribute has no usage in NHibernate.
                        </p></td></tr></table></div></div><p>
                Version may be of type <tt class="literal">Int64</tt>, <tt class="literal">Int32</tt>,
                <tt class="literal">Int16</tt>, <tt class="literal">Ticks</tt>, <tt class="literal">Timestamp</tt>,
                <tt class="literal">TimeSpan</tt>, <tt class="literal">datetimeoffset</tt>, ... (or their nullable
                counterparts in .NET 2.0 and higher). Any type implementing <tt class="literal">IVersionType</tt> is
                usable as a version.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-timestamp"></a>5.1.9.&nbsp;timestamp (optional)</h3></div></div><div></div></div><p>
                The optional <tt class="literal">&lt;timestamp&gt;</tt> element indicates that the table contains 
                timestamped data. This is intended as an alternative to versioning. Timestamps are by nature
                a less safe implementation of optimistic locking. However, sometimes the application might
                use the timestamps in other ways.
            </p><div class="programlistingco"><pre class="programlisting">&lt;timestamp
    column="timestampColumn"                          <span class="co">(1)</span>
    name="propertyName"                               <span class="co">(2)</span>
    access="field|property|nosetter|className"        <span class="co">(3)</span>
    unsaved-value="null|undefined"                    <span class="co">(4)</span>
    generated="never|always"                          <span class="co">(5)</span>
    source="vm|db"                                    <span class="co">(6)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The name
                            of a column holding the timestamp.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of a property of .NET type
                            <tt class="literal">DateTime</tt> of the persistent class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to <tt class="literal">null</tt>):
                            A timestamp property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session. <tt class="literal">undefined</tt> specifies that nothing
                            should be assumed from the timestamp value. The identifier check on its own
                            <tt class="literal">unsaved-value</tt> will take precedence, unless its own value is
                            <tt class="literal">undefined</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">generated</tt> (optional - defaults to <tt class="literal">never</tt>):
                            Specifies that this timestamp property value is actually generated by the database
                            on insert and updates.
                            See the discussion of <a href="#mapping-generated" title="5.6.&nbsp;Generated Properties">generated properties</a>.
                            It should not to be confused with <tt class="literal">source</tt> value
                            <tt class="literal">db</tt>, which mandates NHibernate to retrieve the timestamp from the
                            database in a dedicated query, in order to get the new value to set in the next insert
                            or update.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">source</tt> (optional - defaults to <tt class="literal">vm</tt>): Where should
                            NHibernate retrieve the timestamp value from? From the database, or from the current
                            runtime? Database-based timestamps incur an overhead because NHibernate must hit the
                            database in order to determine the "next value". It is safer to use in clustered
                            environments. Not all dialects are known to support the retrieval of the database's
                            current timestamp. Others may also be unsafe for usage in locking due to lack of
                            precision.
                        </p></td></tr></table></div></div><p>
                Note that <tt class="literal">&lt;timestamp&gt;</tt> is equivalent to
                <tt class="literal">&lt;version type="datetime"&gt;</tt>, and <tt class="literal">&lt;timestamp source="db"&gt;</tt>
                is equivalent to <tt class="literal">&lt;version type="dbtimestamp"&gt;</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-property"></a>5.1.10.&nbsp;property</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;property&gt;</tt> element declares a persistent property
                of the class.
            </p><div class="programlistingco"><pre class="programlisting">&lt;property
    name="propertyName"                               <span class="co">(1)</span>
    column="columnName"                               <span class="co">(2)</span>
    type="typeName"                                   <span class="co">(3)</span>
    update="true|false"                               <span class="co">(4)</span>
    insert="true|false"                               <span class="co">(4)</span>
    formula="arbitrary SQL expression"                <span class="co">(5)</span>
    access="field|property|className"                 <span class="co">(6)</span>
    optimistic-lock="true|false"                      <span class="co">(7)</span>
    generated="never|insert|always"                   <span class="co">(8)</span>
    lazy="true|false"                                 <span class="co">(9)</span>
    lazy-group="groupName"                            <span class="co">(10)</span>
    not-null="true|false"                             <span class="co">(11)</span>
    unique="true|false"                               <span class="co">(12)</span>
    unique-key="uniqueKeyName"                        <span class="co">(13)</span>
    index="indexName"                                 <span class="co">(14)</span>
    length="L"                                        <span class="co">(15)</span>
    precision="P"                                     <span class="co">(16)</span>
    scale="S"                                         <span class="co">(17)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: the name of the property of your class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): the name
                            of the mapped database table column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional): a name that indicates the NHibernate type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (optional - defaults to <tt class="literal">true</tt>):
                            specifies that the mapped columns should be included in SQL <tt class="literal">UPDATE</tt>
                            and/or <tt class="literal">INSERT</tt> statements. Setting both to <tt class="literal">false</tt>
                            allows a pure "derived" property whose value is initialized from some other
                            property that maps to the same column(s) or by a trigger or other application.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional): an SQL expression that defines the value for a
                            <span class="emphasis"><em>computed</em></span> property. Computed properties do not have a column
                            mapping of their own.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): the
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>):
                            specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, determines if a version increment should occur when
                            this property is dirty.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">generated</tt> (optional - defaults to <tt class="literal">never</tt>):
                            specifies that this property value is actually generated by the database.
                            See the discussion of <a href="#mapping-generated" title="5.6.&nbsp;Generated Properties">generated properties</a>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">false</tt>):
                            specifies that this property is lazy. A lazy property is not loaded when
                            the object is initially loaded, unless the fetch mode has been overridden
                            in a specific query. Values for lazy properties are loaded per lazy-group.
                        </p><p>
                            Having lazy properties causes instances of the entity to be loaded as proxies.
                            Theses proxies ignore the class <tt class="literal">proxy</tt> setting and always
                            derives from the persistent class, requiring its members to be overridable.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy-group</tt> (optional - defaults to <tt class="literal">DEFAULT</tt>):
                            if the property is lazy, its lazy-loading group. When a lazy property is accessed,
                            the other lazy properties of the lazy group are also loaded with it.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-null</tt> (optional - defaults to <tt class="literal">false</tt>):
                            sets the column nullability for DDL generation.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optional - defaults to <tt class="literal">false</tt>):
                            sets the column uniqueness for DDL generation. Use <tt class="literal">unique-key</tt>
                            instead if the value is unique only in combination with other properties.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique-key</tt> (optional):
                            a logical name for an unique index for DDL generation. The column will be included in
                            the index, along with other columns sharing the same <tt class="literal">unique-key</tt>
                            logical name. The actual index name depends on the dialect.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                            <tt class="literal">index</tt> (optional):
                            a logical name for an index for DDL generation. The column will be included in
                            the index, along with other columns sharing the same <tt class="literal">index</tt> logical
                            name. The actual index name depends on the dialect.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(15)</td><td valign="top" align="left"><p>
                            <tt class="literal">length</tt> (optional): if the type takes a length and does not
                            already specify it, its length.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(16)</td><td valign="top" align="left"><p>
                            <tt class="literal">precision</tt> (optional): if the type takes a precision and does not
                            already specify it, its precision.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(17)</td><td valign="top" align="left"><p>
                            <tt class="literal">scale</tt> (optional): if the type takes a scale and does not
                            already specify it, its scale.
                        </p></td></tr></table></div></div><p>
                <span class="emphasis"><em>typeName</em></span> could be:
            </p><div class="orderedlist"><ol type="1" compact><li><p>
                        The name of a NHibernate basic type (eg. <tt class="literal">Int32, String, Char,
                        DateTime, Timestamp, Single, Byte[], Object, ...</tt>).
                    </p></li><li><p>
                        The name of a .NET type with a default basic type (eg. <tt class="literal">System.Int16, System.Single,
                        System.Char, System.String, System.DateTime, System.Byte[], ...</tt>).
                    </p></li><li><p>
                        The name of an enumeration type (eg. <tt class="literal">Eg.Color, Eg</tt>).
                    </p></li><li><p>
                        The name of a serializable .NET type.
                    </p></li><li><p>
                        The class name of a custom type (eg. <tt class="literal">Illflow.Type.MyCustomType</tt>).
                    </p></li></ol></div><p>
                Note that you have to specify full <span class="emphasis"><em>assembly-qualified</em></span> names for all
                except basic NHibernate types (unless you set <tt class="literal">assembly</tt>
                and/or <tt class="literal">namespace</tt> attributes of the
                <tt class="literal">&lt;hibernate-mapping&gt;</tt> element).
            </p><p>
                NHibernate supports .NET 2.0 <tt class="literal">Nullable</tt> types. These types are
                mostly treated the same as plain non-<tt class="literal">Nullable</tt> types internally.
                For example, a property of type <tt class="literal">Nullable&lt;Int32&gt;</tt> can be mapped
                using <tt class="literal">type="Int32"</tt> or <tt class="literal">type="System.Int32"</tt>.
            </p><p>
                If you do not specify a type, NHibernate will use reflection upon the named
                property to take a guess at the correct NHibernate type. NHibernate will try to
                interpret the name of the return class of the property getter using rules 2, 3,
                4 in that order. However, this is not always enough.
                In certain cases you will still need the <tt class="literal">type</tt>
                attribute. (For example, to distinguish between <tt class="literal">NHibernateUtil.DateTime</tt> and
                <tt class="literal">NHibernateUtil.UtcDateTime</tt>, or to specify a custom type.)
            </p><p>
                See also <a href="#mapping-types" title="5.2.&nbsp;NHibernate Types">Section&nbsp;5.2, &#8220;NHibernate Types&#8221;</a>.
            </p><p>
                The <tt class="literal">access</tt> attribute lets you control how NHibernate will access
                the value of the property at runtime.  The value of the <tt class="literal">access</tt> attribute should
                be text formatted as <tt class="literal">access-strategy.naming-strategy</tt>.  The
                <tt class="literal">.naming-strategy</tt> is not always required.
                </p><div class="table"><a name="d0e5712"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;Access Strategies</b></p><table summary="Access Strategies" border="1"><colgroup><col><col></colgroup><thead><tr><th>Access Strategy Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">property</tt></td><td><p>
                                        The default implementation.  NHibernate uses the get/set accessors of
                                        the property.  No naming strategy should be used with this access strategy
                                        because the value of the <tt class="literal">name</tt> attribute is the name
                                        of the property.
                                    </p></td></tr><tr><td><tt class="literal">field</tt></td><td><p>
                                        NHibernate will access the field directly.  NHibernate uses the value
                                        of the <tt class="literal">name</tt> attribute as the name of the field.
                                        This can be used when a property's getter and setter contain extra actions
                                        that you don't want to occur when NHibernate is populating or reading
                                        the object. If you want the name of the property and not the field to
                                        be what the consumers of your API use with HQL, then a naming strategy
                                        is needed.
                                    </p></td></tr><tr><td><tt class="literal">backfield</tt></td><td><p>
                                        NHibernate will access the field of an auto-property directly.
                                        This can be used when a property's setter is not accessible.
                                    </p></td></tr><tr><td><tt class="literal">nosetter</tt></td><td><p>
                                        NHibernate will access the field directly when setting the value and will use the
                                        Property when getting the value.  This can be used when a property only exposes
                                        a get accessor because the consumers of your API can't change the value directly.
                                        A naming strategy is required because NHibernate uses the value of the
                                        <tt class="literal">name</tt> attribute as the property name and needs to
                                        be told what the name of the field is.
                                    </p></td></tr><tr><td><tt class="literal">readonly</tt></td><td><p>
                                        Access the mapped property through a Property <tt class="literal">get</tt> to get the value
                                        and do nothing to set the value. This is useful to allow calculated properties in the
                                        domain that will never be recovered from the DB but can be used for querying.
                                    </p></td></tr><tr><td><tt class="literal">noop</tt> / <tt class="literal">none</tt></td><td><p>
                                        Used to declare properties not represented at the poco level.
                                    </p></td></tr><tr><td><tt class="literal">className</tt></td><td><p>
                                        If NHibernate's built in access strategies are not what is needed for your situation
                                        then you can build your own by implementing the interface 
                                        <tt class="literal">NHibernate.Property.IPropertyAccessor</tt>.  The value of the 
                                        <tt class="literal">access</tt> attribute should be an assembly-qualified name that can be
                                        loaded with <tt class="literal">Activator.CreateInstance(string assemblyQualifiedName)</tt>.
                                    </p></td></tr></tbody></table></div><p>
            </p><p>
                </p><div class="table"><a name="d0e5799"></a><p class="title"><b>Table&nbsp;5.2.&nbsp;Naming Strategies</b></p><table summary="Naming Strategies" border="1"><colgroup><col><col></colgroup><thead><tr><th>Naming Strategy Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">camelcase</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is converted to camel case to find the field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">fooBar</tt>.
                                    </p></td></tr><tr><td><tt class="literal">camelcase-underscore</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is converted to camel case and prefixed with an
                                        underscore to find the field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">_fooBar</tt>.
                                    </p></td></tr><tr><td><tt class="literal">camelcase-m-underscore</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is converted to camel case and prefixed with
                                        the character <tt class="literal">m</tt> and an underscore to find the field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">m_fooBar</tt>.
                                    </p></td></tr><tr><td><tt class="literal">lowercase</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is converted to lower case to find the Field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">foobar</tt>.
                                    </p></td></tr><tr><td><tt class="literal">lowercase-underscore</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is converted to lower case and prefixed with an
                                        underscore to find the Field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">_foobar</tt>.
                                    </p></td></tr><tr><td><tt class="literal">pascalcase-underscore</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is prefixed with an underscore to find the field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">_FooBar</tt>.
                                    </p></td></tr><tr><td><tt class="literal">pascalcase-m</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is prefixed with the character
                                        <tt class="literal">m</tt> to find the field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">mFooBar</tt>.
                                    </p></td></tr><tr><td><tt class="literal">pascalcase-m-underscore</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is prefixed with the character
                                        <tt class="literal">m</tt> and an underscore to find the field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">m_FooBar</tt>.
                                    </p></td></tr></tbody></table></div><p>
            </p><p>
                A powerful feature is derived properties. These properties are by definition read-only. The property value is computed at
                load time. You declare the computation as an SQL expression. This then translates to a <tt class="literal">SELECT</tt> clause
                subquery in the SQL query that loads an instance:
            </p><pre class="programlisting">&lt;property name="totalPrice"
    formula="( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p
                WHERE li.productId = p.productId
                AND li.customerId = customerId
                AND li.orderNumber = orderNumber )"/&gt;</pre><p>
                You can reference the entity table by not declaring an alias on a particular column. This would be
                <tt class="literal">customerId</tt> in the given example. You can also use the nested <tt class="literal">&lt;formula&gt;</tt> mapping
                element if you do not want to use the attribute.
            </p><p>
                The nested <tt class="literal">&lt;column&gt;</tt> mapping element can also be used instead of the <tt class="literal">column</tt>
                attribute.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-manytoone"></a>5.1.11.&nbsp;many-to-one</h3></div></div><div></div></div><p>
                An ordinary association to another persistent class is declared using a
                <tt class="literal">many-to-one</tt> element. The relational model is a
                many-to-one association. (It is really just an object reference.)
            </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-one
    name="propertyName"                                    <span class="co">(1)</span>
    column="columnName"                                    <span class="co">(2)</span>
    class="className"                                      <span class="co">(3)</span>
    cascade="all|none|save-update|delete|delete-orphan|all-<span class="co">(4)</span>delete-orphan"
    fetch="join|select"                                    <span class="co">(5)</span>
    lazy="proxy|no-proxy|false"                            <span class="co">(6)</span>
    update="true|false"                                    <span class="co">(7)</span>
    insert="true|false"                                    <span class="co">(7)</span>
    property-ref="propertyNameFromAssociatedClass"         <span class="co">(8)</span>
    access="field|property|nosetter|className"             <span class="co">(9)</span>
    optimistic-lock="true|false"                           <span class="co">(10)</span>
    not-found="ignore|exception"                           <span class="co">(11)</span>
    entity-name="entityName"                               <span class="co">(12)</span>
    formula="arbitrary SQL expression"                     <span class="co">(13)</span>
    not-null="true|false"                                  <span class="co">(14)</span>
    unique="true|false"                                    <span class="co">(15)</span>
    unique-key="uniqueKeyName"                             <span class="co">(16)</span>
    index="indexName"                                      <span class="co">(17)</span>
    foreign-key="foreignKeyName"                           <span class="co">(18)</span>
    outer-join="auto|true|false"                           <span class="co">(19)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional): The name of the column. This can also be
                            specified by nested <tt class="literal">&lt;column&gt;</tt> element(s).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional): Specifies which operations should
                            be cascaded from the parent object to the associated object.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optional - defaults to <tt class="literal">select</tt>):
                            Chooses between outer-join fetching or sequential select fetching.
                            <tt class="literal">join</tt> takes precedence over the <tt class="literal">lazy</tt>
                            attribute and causes the association to be eagerly fetched.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">proxy</tt>):
                            By default, single point associations are proxied. <tt class="literal">lazy="no-proxy"</tt>
                            specifies that the property should be fetched lazily when the instance property is first
                            accessed. It works similarly to lazy properties, and causes the entity owning the
                            association to be proxied instead of the association. <tt class="literal">lazy="false"</tt>
                            specifies that the association will be eagerly fetched.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (optional - defaults to <tt class="literal">true</tt>):
                            Specifies that the mapped columns should be included in SQL <tt class="literal">UPDATE</tt>
                            and/or <tt class="literal">INSERT</tt> statements. Setting both to <tt class="literal">false</tt>
                            allows a pure "derived" association whose value is initialized from some other
                            property that maps to the same column(s) or by a trigger or other application.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt> (optional): The name of a property of the associated
                            class that is joined to this foreign key. If not specified, the primary key of
                            the associated class is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>):
                            Specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, determines if a version increment should occur when
                            this property is dirty.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-found</tt> (optional - defaults to <tt class="literal">exception</tt>):
                            Specifies how foreign keys that reference missing rows will be handled.
                            <tt class="literal">ignore</tt> will treat a missing row as a null association.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                            <tt class="literal">entity-name</tt> (optional): The entity name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional): An SQL expression that defines the value for
                            a <span class="emphasis"><em>computed</em></span> foreign key.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-null</tt> (optional - defaults to <tt class="literal">false</tt>): Enables
                            the DDL generation of a nullability constraint for the foreign key column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(15)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optional - defaults to <tt class="literal">false</tt>): Enables
                            the DDL generation of an unique constraint for the foreign-key column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(16)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique-key</tt> (optional):
                            A logical name for an unique index for DDL generation. The column will be included in
                            the index, along with other columns sharing the same <tt class="literal">unique-key</tt>
                            logical name. The actual index name depends on the dialect.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(17)</td><td valign="top" align="left"><p>
                            <tt class="literal">index</tt> (optional):
                            A logical name for an index for DDL generation. The column will be included in
                            the index, along with other columns sharing the same <tt class="literal">index</tt> logical
                            name. The actual index name depends on the dialect.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(18)</td><td valign="top" align="left"><p>
                            <tt class="literal">foreign-key</tt> (optional): Specifies the name of the foreign key
                            constraint for DDL generation.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(19)</td><td valign="top" align="left"><p>
                            <tt class="literal">outer-join</tt> (optional): This attribute is obsoleted in favor of
                            <tt class="literal">fetch</tt>. <tt class="literal">auto</tt> is equivalent to not specifying
                            <tt class="literal">fetch</tt>, <tt class="literal">true</tt> is equivalent to
                            <tt class="literal">join</tt> and <tt class="literal">false</tt> is equivalent to
                            <tt class="literal">select</tt>. This obsolete attribute also appears on other elements,
                            with the same usage. It will be omitted from the documentation of these other
                            elements.
                        </p></td></tr></table></div></div><p>
                 Setting a value of the <tt class="literal">cascade</tt> attribute to any meaningful value other than
                 <tt class="literal">none</tt> will propagate certain operations to the associated object. The
                 meaningful values are divided into three categories. First, basic operations, which include:
                 <tt class="literal">persist</tt>, <tt class="literal">merge</tt>, <tt class="literal">delete</tt>,
                 <tt class="literal">save-update</tt>, <tt class="literal">evict</tt>, <tt class="literal">replicate</tt>,
                 <tt class="literal">lock</tt> and <tt class="literal">refresh</tt>; second, special values:
                 <tt class="literal">delete-orphan</tt>; and third, all comma-separated combinations of operation names:
                 <tt class="literal">cascade="persist,merge,evict"</tt> or <tt class="literal">cascade="all,delete-orphan"</tt>.
                 See <a href="#manipulatingdata-graphs" title="10.10.&nbsp;Lifecycles and object graphs">Section&nbsp;10.10, &#8220;Lifecycles and object graphs&#8221;</a>.
            </p><p>
                Here is an example of a typical many-to-one declaration:
            </p><pre class="programlisting">&lt;many-to-one name="product" class="Product" column="PRODUCT_ID"/&gt;</pre><p>
                The <tt class="literal">property-ref</tt> attribute should only be used for mapping legacy data where a
                foreign key refers to a unique key of the associated table other than the primary key. This is a
                complicated and confusing relational model. For example, if the Product class had a unique serial
                number that is not the primary key, mapped as below:
            </p><pre class="programlisting">&lt;property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/&gt;</pre><p>
                The unique attribute controls NHibernate's DDL generation with the SchemaExport tool. Then the
                mapping for OrderItem might use:
            </p><pre class="programlisting">&lt;many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/&gt;</pre><p>
                This is not encouraged, however.
            </p><p>
                If the referenced unique key comprises multiple properties of the associated entity, you should map
                the referenced properties inside a named <tt class="literal">&lt;properties&gt;</tt> element.
            </p><p>
                If the referenced unique key is the property of a component, you can specify a property path:
            </p><pre class="programlisting">&lt;many-to-one name="owner" property-ref="Identity.Ssn" column="OWNER_SSN"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-onetoone"></a>5.1.12.&nbsp;one-to-one</h3></div></div><div></div></div><p>
                A one-to-one association to another persistent class is declared using a
                <tt class="literal">one-to-one</tt> element.
            </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-one
    name="propertyName"                                    <span class="co">(1)</span>
    class="className"                                      <span class="co">(2)</span>
    cascade="all|none|save-update|delete|delete-orphan|all-<span class="co">(3)</span>delete-orphan"
    constrained="true|false"                               <span class="co">(4)</span>
    fetch="join|select"                                    <span class="co">(5)</span>
    lazy="proxy|no-proxy|false"                            <span class="co">(6)</span>
    property-ref="propertyNameFromAssociatedClass"         <span class="co">(7)</span>
    access="field|property|nosetter|className"             <span class="co">(8)</span>
    formula="any SQL expression"                           <span class="co">(9)</span>
    entity-name="entityName"                               <span class="co">(10)</span>
    foreign-key="foreignKeyName"                           <span class="co">(11)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional): Specifies which operations should
                            be cascaded from the parent object to the associated object.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">constrained</tt> (optional - default to <tt class="literal">false</tt>):
                            Specifies that a foreign key constraint on the primary key of the mapped table
                            references the table of the associated class. This option affects the order in
                            which <tt class="literal">Save()</tt> and <tt class="literal">Delete()</tt> are cascaded,
                            and determines whether the association can be proxied. It is also used by the
                            schema export tool.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optional - defaults to <tt class="literal">select</tt>):
                            Chooses between outer-join fetching or sequential select fetching.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">proxy</tt>):
                            By default, single point associations are proxied. <tt class="literal">lazy="no-proxy"</tt>
                            specifies that the property should be fetched lazily when the instance property is first
                            accessed. It works similarly to lazy properties, and causes the entity owning the
                            association to be proxied instead of the association. <tt class="literal">lazy="false"</tt>
                            specifies that the association will be eagerly fetched. <span class="emphasis"><em>Note that if
                            <tt class="literal">constrained="false"</tt>, proxying the association is impossible and
                            NHibernate will eagerly fetch the association.</em></span>
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt>: (optional): The name of a property of the associated class
                            that is joined to the primary key of this class (or to the <tt class="literal">formula</tt> of
                            this association). If not specified, the primary key of the associated class is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional): Almost all one-to-one associations map to the primary
                            key of the owning entity. If this is not the case, you can specify another column or expression
                            to join on using an SQL formula. This can also be specified by nested
                            <tt class="literal">&lt;formula&gt;</tt> element(s).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">entity-name</tt> (optional): The entity name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">foreign-key</tt> (optional): Specifies the name of the foreign key
                            constraint for DDL generation.
                        </p></td></tr></table></div></div><p>
                There are two varieties of one-to-one association:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                primary key associations
            </p></li><li><p>
                unique foreign key associations
            </p></li></ul></div><p>
                Primary key associations don't need an extra table column; if two rows are related by
                the association then the two table rows share the same primary key value. So if you want 
                two objects to be related by a primary key association, you must make sure that they
                are assigned the same identifier value!
            </p><p>
                For a primary key association, add the following mappings to <tt class="literal">Employee</tt> and 
                <tt class="literal">Person</tt>, respectively.
            </p><pre class="programlisting">&lt;one-to-one name="Person" class="Person"/&gt;</pre><pre class="programlisting">&lt;one-to-one name="Employee" class="Employee" constrained="true"/&gt;</pre><p>
                Now we must ensure that the primary keys of related rows in the PERSON and
                EMPLOYEE tables are equal. We use a special NHibernate identifier generation strategy
                called <tt class="literal">foreign</tt>:
            </p><pre class="programlisting">&lt;class name="Person" table="PERSON"&gt;
    &lt;id name="Id" column="PERSON_ID"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;Employee&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    ...
    &lt;one-to-one name="Employee"
        class="Employee"
        constrained="true"/&gt;
&lt;/class&gt;</pre><p>
                A newly saved instance of <tt class="literal">Person</tt> is then assigned the same primary
                key value as the <tt class="literal">Employee</tt> instance referred with the <tt class="literal">Employee</tt>
                property of that <tt class="literal">Person</tt>.
            </p><p>
                Alternatively, a foreign key with a unique constraint, from <tt class="literal">Employee</tt> to 
                <tt class="literal">Person</tt>, may be expressed as:
            </p><pre class="programlisting">&lt;many-to-one name="Person" class="Person" column="PERSON_ID" unique="true"/&gt;</pre><p>
                And this association may be made bidirectional by adding the following to the 
                <tt class="literal">Person</tt> mapping:
            </p><pre class="programlisting">&lt;one-to-one name="Employee" class="Employee" property-ref="Person"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-naturalid"></a>5.1.13.&nbsp;natural-id</h3></div></div><div></div></div><pre class="programlisting">&lt;natural-id mutable="true|false"/&gt;
    &lt;property ... /&gt;
    &lt;many-to-one ... /&gt;
    ...
&lt;/natural-id&gt;</pre><p>
                Even though we recommend the use of surrogate keys as primary keys, you should still try
                to identify natural keys for all entities. A natural key is a property or combination of
                properties that is unique and non-null. If it is also immutable, even better. Map the
                properties of the natural key inside the <tt class="literal">&lt;natural-id&gt;</tt> element.
                NHibernate will generate the necessary unique key and nullability constraints, and your
                mapping will be more self-documenting.
            </p><p>
                The <tt class="literal">&lt;natural-id&gt;</tt> element can only appear before the other
                properties, including version.
            </p><p>
                We strongly recommend that you implement <tt class="literal">Equals()</tt> and
                <tt class="literal">GetHashCode()</tt> to compare the natural key properties of the entity.
            </p><p>
                This mapping is not intended for use with entities with natural primary keys.
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">mutable</tt> (optional, defaults to <tt class="literal">false</tt>):
                        By default, natural identifier properties as assumed to be immutable (constant).
                    </p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-component"></a>5.1.14.&nbsp;component, dynamic-component</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;component&gt;</tt> element maps properties of a
                child object to columns of the table of a parent class. Components may, in
                turn, declare their own properties, components or collections. See
                <a href="#components" title="Chapter&nbsp;8.&nbsp;Component Mapping">Chapter&nbsp;8, <i>Component Mapping</i></a>.
            </p><div class="programlistingco"><pre class="programlisting">&lt;component
    name="propertyName"                                    <span class="co">(1)</span>
    class="className"                                      <span class="co">(2)</span>
    insert="true|false"                                    <span class="co">(3)</span>
    update="true|false"                                    <span class="co">(4)</span>
    access="field|property|nosetter|className"             <span class="co">(5)</span>
    optimistic-lock="true|false"                           <span class="co">(6)</span>
    lazy="true|false"                                      <span class="co">(7)</span>
    lazy-group="groupName"                                 <span class="co">(8)</span>
    unique="true|false"&gt;                                   <span class="co">(9)</span>

        &lt;property ... /&gt;
        &lt;many-to-one ... /&gt;
        ...
&lt;/component&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the component (child) class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> (optional - defaults to <tt class="literal">true</tt>):
                            Do the mapped columns appear in SQL <tt class="literal">INSERT</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt> (optional - defaults to <tt class="literal">true</tt>):
                            Do the mapped columns appear in SQL <tt class="literal">UPDATE</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>):
                            Specifies that updates to this component do or do not require acquisition of the
                            optimistic lock. In other words, determines if a version increment should occur when
                            this property is dirty.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">false</tt>): Specifies
                            that this component should be fetched lazily when the instance property is first
                            accessed. For more informations, see <tt class="literal">lazy</tt> on
                            <a href="#mapping-declaration-property" title="5.1.10.&nbsp;property"><tt class="literal">property</tt> element</a>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy-group</tt> (optional - defaults to <tt class="literal">DEFAULT</tt>):
                            If the component is lazy, its lazy-loading group. When a lazy property is accessed
                            on an object, included when the property is a component, the other lazy properties
                            of the lazy group are also loaded with it.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optional - defaults to <tt class="literal">false</tt>): Specifies
                            that an unique constraint exists upon all mapped columns of the component.
                        </p></td></tr></table></div></div><p>
                The child <tt class="literal">&lt;property&gt;</tt> tags map properties of the
                child class to table columns.
            </p><p>
                The <tt class="literal">&lt;component&gt;</tt> element allows a <tt class="literal">&lt;parent&gt;</tt>
                sub-element that maps a property of the component class as a reference back to the
                containing entity.
            </p><p>
                The <tt class="literal">&lt;dynamic-component&gt;</tt> element allows an <tt class="literal">IDictionary</tt>,
                <tt class="literal">IDictionary&lt;string, object&gt;</tt>, or a C# <tt class="literal">dynamic</tt> to be mapped
                as a component. When using dictionaries, the property names refer to keys of the dictionary. See
                <a href="#components-dynamic" title="8.5.&nbsp;Dynamic components">Section&nbsp;8.5, &#8220;Dynamic components&#8221;</a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-properties"></a>5.1.15.&nbsp;properties</h3></div></div><div></div></div><p>
            The <tt class="literal">&lt;properties&gt;</tt> element allows the
            definition of a named, logical grouping of the properties of a class.
            The most important use of the construct is that it allows a combination
            of properties to be the target of a <tt class="literal">property-ref</tt>. It
            is also a convenient way to define a multi-column unique constraint. For
            example:
          </p><div class="programlistingco"><pre class="programlisting">&lt;properties
    name="logicalName"                                     <span class="co">(1)</span>
    insert="true|false"                                    <span class="co">(2)</span>
    update="true|false"                                    <span class="co">(3)</span>
    optimistic-lock="true|false"                           <span class="co">(4)</span>
    unique="true|false"&gt;                                   <span class="co">(5)</span>

    &lt;property .../&gt;
    &lt;many-to-one .../&gt;
    ...
&lt;/properties&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                  <tt class="literal">name</tt>: the logical name of the grouping.
                  It is <span class="emphasis"><em>not</em></span> an actual property name.
                </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                  <tt class="literal">insert</tt> (optional - defaults to <tt class="literal">true</tt>):
                  do the mapped columns appear in SQL <tt class="literal">INSERTs</tt>?
                </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                  <tt class="literal">update</tt> (optional - defaults to <tt class="literal">true</tt>):
                  do the mapped columns appear in SQL <tt class="literal">UPDATEs</tt>?
                </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                  <tt class="literal">optimistic-lock</tt> (optional - defaults to
                  <tt class="literal">true</tt>): specifies that updates to these
                  properties either do or do not require acquisition of the
                  optimistic lock. It determines if a version increment should occur
                  when these properties are dirty.
                </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                  <tt class="literal">unique</tt> (optional - defaults to
                  <tt class="literal">false</tt>): specifies that a unique constraint
                  exists upon all mapped columns of the component.
                </p></td></tr></table></div></div><p>
            For example, if we have the following
            <tt class="literal">&lt;properties&gt;</tt> mapping:
          </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="personNumber" /&gt;
    &lt;properties name="name" unique="true" update="false"&gt;
        &lt;property name="firstName" /&gt;
        &lt;property name="lastName" /&gt;
        &lt;property name="initial" /&gt;
    &lt;/properties&gt;
&lt;/class&gt;</pre><p>
            You might have some legacy data association that refers to this
            unique key of the <tt class="literal">Person</tt> table, instead of to the
            primary key:
          </p><pre class="programlisting">&lt;many-to-one name="owner" class="Person" property-ref="name"&gt;
    &lt;column name="firstName" /&gt;
    &lt;column name="lastName" /&gt;
    &lt;column name="initial" /&gt;
&lt;/many-to-one&gt;</pre><p>
            The use of this outside the context of mapping legacy data is not
            recommended.
          </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-subclass"></a>5.1.16.&nbsp;subclass</h3></div></div><div></div></div><p>
                Polymorphic persistence requires the declaration of each subclass of
                the root persistent class. For the (recommended) table-per-class-hierarchy
                mapping strategy, the <tt class="literal">&lt;subclass&gt;</tt> declaration is used.
            </p><div class="programlistingco"><pre class="programlisting">&lt;subclass
    name="className"                                  <span class="co">(1)</span>
    discriminator-value="discriminatorValue"          <span class="co">(2)</span>
    extends="superclassName"                          <span class="co">(3)</span>
    ...&gt;                                              <span class="co">(4)</span>

    &lt;property ... /&gt;
    &lt;properties ... /&gt;
    ...
&lt;/subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified .NET class name of the
                            subclass, including its assembly name.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (optional - defaults to the class name): A
                            value that distinguishes individual subclasses.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">extends</tt> (optional if the <tt class="literal">&lt;subclass&gt;</tt>
                            element is nested into its superclass mapping declaration): Specifies the name of
                            a mapped class as the superclass for the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            Many attributes available on the <tt class="literal">&lt;class&gt;</tt> mapping element
                            are also available on <tt class="literal">&lt;subclass&gt;</tt> with the same usage:
                            <tt class="literal">proxy</tt>, <tt class="literal">dynamic-update</tt>,
                            <tt class="literal">dynamic-insert</tt>, <tt class="literal">select-before-update</tt>,
                            <tt class="literal">persister</tt>, <tt class="literal">batch-size</tt>, <tt class="literal">lazy</tt>,
                            <tt class="literal">entity-name</tt>, <tt class="literal">abstract</tt>. See
                            <a href="#mapping-declaration-class" title="5.1.3.&nbsp;class">Section&nbsp;5.1.3, &#8220;class&#8221;</a>.
                        </p></td></tr></table></div></div><p>
                Each subclass should declare its own persistent properties and subclasses.
                <tt class="literal">&lt;version&gt;</tt> and <tt class="literal">&lt;id&gt;</tt> properties
                are assumed to be inherited from the root class. Each subclass in a hierarchy must
                define a unique <tt class="literal">discriminator-value</tt>. If none is specified, the
                fully qualified .NET class name is used.
            </p><p>
                For information about inheritance mappings, see <a href="#inheritance" title="Chapter&nbsp;9.&nbsp;Inheritance Mapping">Chapter&nbsp;9, <i>Inheritance Mapping</i></a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-joinedsubclass"></a>5.1.17.&nbsp;joined-subclass</h3></div></div><div></div></div><p>
                Each subclass can also be mapped to its own table. This is called the table-per-subclass
                mapping strategy. An inherited state is retrieved by joining with the table of the
                superclass. To do this you use the <tt class="literal">&lt;joined-subclass&gt;</tt> element.
            </p><div class="programlistingco"><pre class="programlisting">&lt;joined-subclass
    name="className"                                  <span class="co">(1)</span>
    table="tableName"                                 <span class="co">(2)</span>
    extends="superclassName"                          <span class="co">(3)</span>
    ...&gt;                                              <span class="co">(4)</span>

    &lt;key ... /&gt;

    &lt;property ... /&gt;
    &lt;properties ... /&gt;
    ...
&lt;/joined-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified class name of the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt> (optional - defaults to the unqualified subclass name):
                            The name of the subclass table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">extends</tt> (optional if the <tt class="literal">&lt;joined-subclass&gt;</tt>
                            element is nested into its superclass mapping declaration): Specifies the name of
                            a mapped class as the superclass for the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            Many attributes available on the <tt class="literal">&lt;class&gt;</tt> mapping element
                            are also available on <tt class="literal">&lt;joined-subclass&gt;</tt> with the same usage:
                            <tt class="literal">schema</tt>, <tt class="literal">catalog</tt>, <tt class="literal">proxy</tt>,
                            <tt class="literal">subselect</tt>, <tt class="literal">dynamic-update</tt>,
                            <tt class="literal">dynamic-insert</tt>, <tt class="literal">select-before-update</tt>,
                            <tt class="literal">persister</tt>, <tt class="literal">batch-size</tt>, <tt class="literal">lazy</tt>,
                            <tt class="literal">entity-name</tt>, <tt class="literal">abstract</tt>, <tt class="literal">check</tt>,
                            <tt class="literal">schema-action</tt>. See <a href="#mapping-declaration-class" title="5.1.3.&nbsp;class">Section&nbsp;5.1.3, &#8220;class&#8221;</a>.
                        </p></td></tr></table></div></div><p>
                No discriminator column is required for this mapping strategy. Each subclass must,
                however, declare a table column holding the object identifier using the
                <tt class="literal">&lt;key&gt;</tt> element. The mapping at the start of the chapter
                would be re-written as:
            </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2" assembly="Eg"
    namespace="Eg"&gt;

    &lt;class name="Cat" table="CATS"&gt;
        &lt;id name="Id" column="uid" type="Int64"&gt;
            &lt;generator class="hilo"/&gt;
        &lt;/id&gt;
        &lt;property name="BirthDate" type="Date"/&gt;
        &lt;property name="Color" not-null="true"/&gt;
        &lt;property name="Sex" not-null="true"/&gt;
        &lt;property name="Weight"/&gt;
        &lt;many-to-one name="Mate"/&gt;
        &lt;set name="Kittens"&gt;
            &lt;key column="MOTHER"/&gt;
            &lt;one-to-many class="Cat"/&gt;
        &lt;/set&gt;
        &lt;joined-subclass name="DomesticCat" table="DOMESTIC_CATS"&gt;
            &lt;key column="CAT"/&gt;
            &lt;property name="Name" type="String"/&gt;
        &lt;/joined-subclass&gt;
    &lt;/class&gt;

    &lt;class name="Dog"&gt;
        &lt;!-- mapping for Dog could go here --&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
                For information about inheritance mappings, see <a href="#inheritance" title="Chapter&nbsp;9.&nbsp;Inheritance Mapping">Chapter&nbsp;9, <i>Inheritance Mapping</i></a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-unionsubclass"></a>5.1.18.&nbsp;union-subclass</h3></div></div><div></div></div><p>
               A third option is to map only the concrete classes of an inheritance hierarchy
               to tables, (the table-per-concrete-class strategy) where each table defines all
               persistent state of the class, including inherited state. In NHibernate, it is
               not absolutely necessary to explicitly map such inheritance hierarchies. You
               can simply map each class with a separate <tt class="literal">&lt;class&gt;</tt>
               declaration. However, if you wish use polymorphic associations (e.g. an association
               to the superclass of your hierarchy), you need to
               use the <tt class="literal">&lt;union-subclass&gt;</tt> mapping.
           </p><div class="programlistingco"><pre class="programlisting">&lt;union-subclass
    name="className"                                  <span class="co">(1)</span>
    table="tableName"                                 <span class="co">(2)</span>
    extends="superclassName"                          <span class="co">(3)</span>
    ...&gt;                                              <span class="co">(4)</span>

    &lt;property ... /&gt;
    &lt;properties ... /&gt;
    ...
&lt;/union-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified class name of the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt> (optional - defaults to the unqualified subclass name):
                            The name of the subclass table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">extends</tt> (optional if the <tt class="literal">&lt;union-subclass&gt;</tt>
                            element is nested into its superclass mapping declaration): Specifies the name of
                            a mapped class as the superclass for the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            Many attributes available on the <tt class="literal">&lt;class&gt;</tt> mapping element
                            are also available on <tt class="literal">&lt;union-subclass&gt;</tt> with the same usage:
                            <tt class="literal">schema</tt>, <tt class="literal">catalog</tt>, <tt class="literal">proxy</tt>,
                            <tt class="literal">subselect</tt>, <tt class="literal">dynamic-update</tt>,
                            <tt class="literal">dynamic-insert</tt>, <tt class="literal">select-before-update</tt>,
                            <tt class="literal">persister</tt>, <tt class="literal">batch-size</tt>, <tt class="literal">lazy</tt>,
                            <tt class="literal">entity-name</tt>, <tt class="literal">abstract</tt>, <tt class="literal">check</tt>.
                            See <a href="#mapping-declaration-class" title="5.1.3.&nbsp;class">Section&nbsp;5.1.3, &#8220;class&#8221;</a>.
                         </p></td></tr></table></div></div><p>
                No discriminator column or key column is required for this mapping strategy.
            </p><p>
                For information about inheritance mappings, see <a href="#inheritance" title="Chapter&nbsp;9.&nbsp;Inheritance Mapping">Chapter&nbsp;9, <i>Inheritance Mapping</i></a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-join"></a>5.1.19.&nbsp;join</h3></div></div><div></div></div><p>
                Using the <tt class="literal">&lt;join&gt;</tt> element, it is possible to map
                properties of one class to several tables, when there's a 1-to-1 relationship between the tables.
            </p><div class="programlistingco"><pre class="programlisting">&lt;join
    table="tableName"                            <span class="co">(1)</span>
    schema="owner"                               <span class="co">(2)</span>
    catalog="catalog"                            <span class="co">(3)</span>
    fetch="join|select"                          <span class="co">(4)</span>
    inverse="true|false"                         <span class="co">(5)</span>
    optional="true|false"                        <span class="co">(6)</span>
    subselect="SQL expression"&gt;                  <span class="co">(7)</span>

    &lt;key ... /&gt;

    &lt;property ... /&gt;
    ...
&lt;/join&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt>: The name of the joined table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (optional): Overrides the schema name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">catalog</tt> (optional): Overrides the catalog name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optional - defaults to <tt class="literal">join</tt>):
                            If set to <tt class="literal">join</tt>, the default, NHibernate will use an inner join
                            to retrieve a <tt class="literal">&lt;join&gt;</tt> defined by a class or its superclasses
                            and an outer join for a <tt class="literal">&lt;join&gt;</tt> defined by a subclass.
                            If set to <tt class="literal">select</tt> then NHibernate will use a sequential select for
                            a <tt class="literal">&lt;join&gt;</tt> defined on a subclass, which will be issued only
                            if a row turns out to represent an instance of the subclass. Inner joins will still
                            be used to retrieve a <tt class="literal">&lt;join&gt;</tt> defined by the class and its
                            superclasses.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">inverse</tt> (optional - defaults to <tt class="literal">false</tt>):
                            If enabled, NHibernate will not try to insert or update the properties defined
                            by this join.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">optional</tt> (optional - defaults to <tt class="literal">false</tt>):
                            If enabled, NHibernate will insert a row only if the properties defined by this
                            join are non-null and will always use an outer join to retrieve the properties.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">subselect</tt> (optional): Maps an immutable and read-only join to
                            a database sub-select. This is useful if you want to have a view instead of a
                            table. See <a href="#mapping-declaration-subselect" title="5.1.4.&nbsp;subselect">Section&nbsp;5.1.4, &#8220;subselect&#8221;</a> for more information.
                        </p></td></tr></table></div></div><p>
                For example, the address information for a person can be mapped to a separate
                table (while preserving value type semantics for all properties):
            </p><pre class="programlisting">&lt;class name="Person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;...&lt;/id&gt;

    &lt;join table="ADDRESS"&gt;
        &lt;key column="ADDRESS_ID"/&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/join&gt;
    ...</pre><p>
                This feature is often only useful for legacy data models, we recommend fewer
                tables than classes and a fine-grained domain model. However, it is useful
                for switching between inheritance mapping strategies in a single hierarchy, as
                explained later.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-key"></a>5.1.20.&nbsp;key</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;key&gt;</tt> element has featured a few times within this guide. It appears
                anywhere the parent mapping element defines a join to a new table that references the primary key
                of the original table. It also defines the foreign key in the joined table:
            </p><div class="programlistingco"><pre class="programlisting">&lt;key
        column="columnName"                      <span class="co">(1)</span>
        on-delete="noaction|cascade"             <span class="co">(2)</span>
        property-ref="propertyName"              <span class="co">(3)</span>
        not-null="true|false"                    <span class="co">(4)</span>
        update="true|false"                      <span class="co">(5)</span>
        unique="true|false"                      <span class="co">(6)</span>
        foreign-key="foreignKeyName"             <span class="co">(7)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt>: the name of the foreign key column. This can also be specified
                            by nested <tt class="literal">&lt;column&gt;</tt> element(s).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">on-delete</tt> (optional - defaults to <tt class="literal">noaction</tt>): specifies
                            whether the foreign key constraint has database-level cascade delete enabled.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt> (optional): specifies that the foreign key refers to columns
                            that are not the primary key of the original table. It is provided for legacy data.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-null</tt> (optional): specifies that the foreign key columns are not nullable.
                            This is implied whenever the foreign key is also part of the primary key.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt> (optional): specifies that the foreign key should never be updated.
                            This is implied whenever the foreign key is also part of the primary key.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optional): specifies that the foreign key should have a unique
                            constraint. This is implied whenever the foreign key is also the primary key.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">foreign-key</tt> (optional): specifies the name of the foreign key
                            constraint for DDL generation.
                        </p></td></tr></table></div></div><p>
                For systems where delete performance is important, we recommend that all keys should be defined
                <tt class="literal">on-delete="cascade"</tt>. NHibernate uses a database-level
                <tt class="literal">ON CASCADE DELETE</tt> constraint, instead of many individual <tt class="literal">DELETE</tt>
                statements. Be aware that this feature bypasses NHibernate's usual optimistic locking strategy for
                versioned data.
            </p><p>
                The <tt class="literal">not-null</tt> and <tt class="literal">update</tt> attributes are useful when mapping an
                unidirectional one-to-many association. If you map an unidirectional one-to-many association to a
                non-nullable foreign key, you <span class="emphasis"><em>must</em></span> declare the key column using
                <tt class="literal">&lt;key not-null="true"&gt;</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-column"></a>5.1.21.&nbsp;column and formula elements</h3></div></div><div></div></div><p>
                Mapping elements which accept a <tt class="literal">column</tt> attribute will alternatively accept a
                <tt class="literal">&lt;column&gt;</tt> subelement. Likewise, <tt class="literal">&lt;formula&gt;</tt> is an
                alternative to the <tt class="literal">formula</tt> attribute. For example:
            </p><pre class="programlisting">&lt;column
        name="columnName"
        length="N"
        precision="N"
        scale="N"
        not-null="true|false"
        unique="true|false"
        unique-key="multicolumnUniqueKeyName"
        index="indexName"
        sql-type="sqlTypeName"
        check="SQL expression"
        default="SQL expression"/&gt;</pre><pre class="programlisting">&lt;formula&gt;SQL expression&lt;/formula&gt;</pre><p>
                Most of the attributes on <tt class="literal">column</tt> provide a means of tailoring the DDL during
                automatic schema generation. See <a href="#toolsetguide-s1-2" title="22.1.1.&nbsp;Customizing the schema">Section&nbsp;22.1.1, &#8220;Customizing the schema&#8221;</a>.
            </p><p>
                The <tt class="literal">column</tt> and <tt class="literal">formula</tt> elements can even be combined within
                the same property or association mapping to express, for example, exotic join conditions.
            </p><pre class="programlisting">&lt;many-to-one name="HomeAddress" class="Address"
        insert="false" update="false"&gt;
    &lt;column name="person_id" not-null="true" length="10"/&gt;
    &lt;formula&gt;'MAILING'&lt;/formula&gt;
&lt;/many-to-one&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-collections"></a>5.1.22.&nbsp;map, set, list, bag</h3></div></div><div></div></div><p>
                Collections are discussed in <a href="#collections" title="Chapter&nbsp;6.&nbsp;Collection Mapping">Chapter&nbsp;6, <i>Collection Mapping</i></a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-import"></a>5.1.23.&nbsp;import</h3></div></div><div></div></div><p>
                Suppose your application has two persistent classes with the same name, and you don't want to
                specify the fully qualified name in NHibernate queries. Classes may be "imported" 
                explicitly, rather than relying upon <tt class="literal">auto-import="true"</tt>. You may even import 
                classes and interfaces that are not explicitly mapped.
            </p><pre class="programlisting">&lt;import class="System.Object" rename="Universe"/&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;import
    class="className"                  <span class="co">(1)</span>
    rename="shortName"                 <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt>: The fully qualified class name of any .NET class, including
                            its assembly name.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">rename</tt> (optional - defaults to the unqualified class name):
                            A name that may be used in the query language.
                        </p></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-anymapping"></a>5.1.24.&nbsp;any</h3></div></div><div></div></div><p>
                There is one more type of property mapping. The <tt class="literal">&lt;any&gt;</tt> mapping element defines a
                polymorphic association to classes from multiple tables. This type of mapping requires more than one
                column. The first column contains the type of the associated entity. The remaining columns contain the
                identifier. It is impossible to specify a foreign key constraint for this kind of association. This is
                not the usual way of mapping polymorphic associations and you should use this only in special cases. For
                example, for audit logs, user session data, etc.
            </p><pre class="programlisting">&lt;any name="AnyEntity" id-type="long" meta-type="class"&gt;
    &lt;column name="type"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><p>
                The <tt class="literal">meta-type</tt> attribute allows the application to specify a custom type that maps
                database column values to persistent classes that have identifier properties of the type specified by
                <tt class="literal">id-type</tt>. If the meta-type is <tt class="literal">class</tt>, nothing else is required.
                The class full name will be persisted in the database as the type of the associated entity.
                On the other hand, if it is a basic type like <tt class="literal">int</tt> or <tt class="literal">char</tt>, you
                must specify the mapping from values to classes. Here is an example with <tt class="literal">string</tt>.
            </p><pre class="programlisting">&lt;any name="being" id-type="long" meta-type="string"&gt;
    &lt;meta-value value="ANIMAL_TYPE" class="Animal"/&gt;
    &lt;meta-value value="HUMAN_TYPE" class="Human"/&gt;
    &lt;meta-value value="ALIEN_TYPE" class="Alien"/&gt;
    &lt;column name="type"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><p>
                String types are a special case: they can be used without meta-values, in which case they will behave
                much like the <tt class="literal">class</tt> meta-type.
            </p><div class="programlistingco"><pre class="programlisting">&lt;any
    name="propertyName"                               <span class="co">(1)</span>
    id-type="idTypeName"                              <span class="co">(2)</span>
    meta-type="metaTypeName"                          <span class="co">(3)</span>
    cascade="cascadeStyle"                            <span class="co">(4)</span>
    access="field|property|className"                 <span class="co">(5)</span>
    optimistic-lock="true|false"                      <span class="co">(6)</span>
    lazy="true|false"                                 <span class="co">(7)</span>
    update="true|false"                               <span class="co">(8)</span>
    insert="true|false"                               <span class="co">(9)</span>
    index="indexName"&gt;                                <span class="co">(10)</span>

    &lt;meta-value ... /&gt;
    &lt;meta-value ... /&gt;
    ...
    &lt;column ... /&gt;
    &lt;column ... /&gt;
    ...
&lt;/any&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: the property name.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">id-type</tt>: the identifier type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">meta-type</tt> (optional - defaults to <tt class="literal">string</tt>): a type
                            that is allowed for a discriminator mapping, or <tt class="literal">class</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional - defaults to <tt class="literal">none</tt>): the cascade style.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): the strategy
                            Hibernate uses for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>): specifies
                            that updates to this property either do or do not require acquisition of the optimistic lock.
                            It defines whether a version increment should occur if this property is dirty.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">false</tt>): specifies that this
                            property should be fetched lazily when the it is first accessed. For more informations, see
                            <tt class="literal">lazy</tt> on
                            <a href="#mapping-declaration-property" title="5.1.10.&nbsp;property"><tt class="literal">property</tt> element</a>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt> (optional - defaults to <tt class="literal">true</tt>):
                            Do the mapped columns appear in SQL <tt class="literal">UPDATE</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> (optional - defaults to <tt class="literal">true</tt>):
                            Do the mapped columns appear in SQL <tt class="literal">INSERT</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">index</tt> (optional):
                            a logical name for an index for DDL generation. The column will be included in
                            the index, along with other columns sharing the same <tt class="literal">index</tt> logical
                            name. The actual index name depends on the dialect.
                        </p></td></tr></table></div></div><p>
                Do not confuse <tt class="literal">&lt;meta-value&gt;</tt> elements with <tt class="literal">&lt;meta&gt;</tt>
                elements. <tt class="literal">&lt;meta&gt;</tt> elements have no functionnal impact on
                <tt class="literal">&lt;any&gt;</tt>, see <a href="#mapping-meta" title="5.8.&nbsp;Meta data">Section&nbsp;5.8, &#8220;Meta data&#8221;</a> for more information on them.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-types"></a>5.2.&nbsp;NHibernate Types</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-entitiesvalues"></a>5.2.1.&nbsp;Entities and values</h3></div></div><div></div></div><p>
                To understand the behaviour of various .NET language-level objects with respect
                to the persistence service, we need to classify them into two groups:
            </p><p>
                An <span class="emphasis"><em>entity</em></span> exists independently of any other objects holding
                references to the entity. Contrast this with the usual .NET model where an
                unreferenced object is garbage collected. Entities must be explicitly saved and
                deleted (except that saves and deletions may be <span class="emphasis"><em>cascaded</em></span>
                from a parent entity to its children). This is different from the ODMG model of
                object persistence by reachability - and corresponds more closely to how
                application objects are usually used in large systems. Entities support
                circular and shared references. They may also be versioned.
            </p><p>
                An entity's persistent state consists of references to other entities and
                instances of <span class="emphasis"><em>value</em></span> types. Values are primitives,
                collections, components and certain immutable objects. Unlike entities, values
                (in particular collections and components) <span class="emphasis"><em>are</em></span>
                persisted and deleted by reachability. Since value objects (and primitives) are
                persisted and deleted along with their containing entity they may not be
                independently versioned. Values have no independent identity, so they cannot be
                shared by two entities or collections.
            </p><p>
                All NHibernate types except collections support null semantics if the .NET type
                is nullable (i.e. not derived from <tt class="literal">System.ValueType</tt>).
            </p><p>
                Up until now, we've been using the term "persistent class" to refer to
                entities. We will continue to do that. Strictly speaking, however, not all
                user-defined classes with persistent state are entities. A
                <span class="emphasis"><em>component</em></span> is a user defined class with value semantics.
            </p><p>
                The challenge is to map the .Net type system, and the developers' definition of
                entities and value types, to the SQL/database type system. The bridge between both
                systems is provided by NHibernate. For entities, <tt class="literal">&lt;class&gt;</tt>,
                <tt class="literal">&lt;subclass&gt;</tt> and so on are used. For value types we use
                <tt class="literal">&lt;property&gt;</tt>, <tt class="literal">&lt;component&gt;</tt>, etc.,
                that usually have a type attribute. The value of this attribute is the name of a
                NHibernate mapping type. NHibernate provides a range of mappings for standard .Net
                value types out of the box. You can write your own mapping types and implement
                your own custom conversion strategies.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-basictypes"></a>5.2.2.&nbsp;Basic value types</h3></div></div><div></div></div><p>
                The <span class="emphasis"><em>basic types</em></span> may be roughly categorized into three groups - <tt class="literal">System.ValueType</tt>
                types, <tt class="literal">System.Object</tt> types, and <tt class="literal">System.Object</tt> types for large objects.  Just like
                Columns for System.ValueType types can handle <tt class="literal">null</tt> values only if the entity property is properly
                typed with a <tt class="literal">Nullable&lt;T&gt;</tt>. Otherwise <tt class="literal">null</tt> will be replaced by the default
                value for the type when reading, and then will be overwritten by it when persisting the entity, potentially leading to
                phantom updates.
            </p><div class="table"><a name="d0e7524"></a><p class="title"><b>Table&nbsp;5.3.&nbsp;System.ValueType Mapping Types</b></p><table summary="System.ValueType Mapping Types" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>NHibernate Type</th><th>.NET Type</th><th>Database Type</th><th>Remarks</th></tr></thead><tbody><tr><td><tt class="literal">AnsiChar</tt></td><td><tt class="literal">System.Char</tt></td><td><tt class="literal">DbType.AnsiStringFixedLength - 1 char</tt></td><td><tt class="literal">type="AnsiChar"</tt> must be specified.</td></tr><tr><td><tt class="literal">Boolean</tt></td><td><tt class="literal">System.Boolean</tt></td><td><tt class="literal">DbType.Boolean</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Byte</tt></td><td><tt class="literal">System.Byte</tt></td><td><tt class="literal">DbType.Byte</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Char</tt></td><td><tt class="literal">System.Char</tt></td><td><tt class="literal">DbType.StringFixedLength - 1 char</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Currency</tt></td><td><tt class="literal">System.Decimal</tt></td><td><tt class="literal">DbType.Currency</tt></td><td><tt class="literal">type="Currency"</tt> must be specified.</td></tr><tr><td><tt class="literal">Date</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.Date</tt></td><td><tt class="literal">type="Date"</tt> must be specified.</td></tr><tr><td><tt class="literal">DateTime</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime</tt> / <tt class="literal">DbType.DateTime2</tt><a name="basic_mapping.datetime-co" href="#basic_mapping.datetime">(1)</a></td><td>
                                Default when no <tt class="literal">type</tt> attribute specified. Does no
                                longer ignore fractional seconds since NHibernate v5.0.
                            </td></tr><tr><td><tt class="literal">DateTimeNoMs</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime</tt> / <tt class="literal">DbType.DateTime2</tt><a name="basic_mapping.datetime-co" href="#basic_mapping.datetime">(1)</a></td><td><tt class="literal">type="DateTimeNoMs"</tt> must be specified. Ignores fractional seconds.
                                Available since NHibernate v5.0.
                            </td></tr><tr><td><tt class="literal">DateTime2</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime2</tt></td><td><tt class="literal">type="DateTime2"</tt> must be specified. Obsolete since
                                NHibernate v5.0, use <tt class="literal">DateTime</tt> instead.
                            </td></tr><tr><td><tt class="literal">DateTimeOffset</tt></td><td><tt class="literal">System.DateTimeOffset</tt></td><td><tt class="literal">DbType.DateTimeOffset</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">DbTimestamp</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime</tt> / <tt class="literal">DbType.DateTime2</tt><a name="basic_mapping.datetime-co" href="#basic_mapping.datetime">(1)</a></td><td><tt class="literal">type="DbTimestamp"</tt> must be specified. When used as a
                                <tt class="literal">version</tt> field, uses the database's current time retrieved
                                in dedicated queries, rather than the client's current time. In case of lack of
                                database support, it falls back on the client's current time.
                            </td></tr><tr><td><tt class="literal">Decimal</tt></td><td><tt class="literal">System.Decimal</tt></td><td><tt class="literal">DbType.Decimal</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Double</tt></td><td><tt class="literal">System.Double</tt></td><td><tt class="literal">DbType.Double</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Guid</tt></td><td><tt class="literal">System.Guid</tt></td><td><tt class="literal">DbType.Guid</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Int16</tt></td><td><tt class="literal">System.Int16</tt></td><td><tt class="literal">DbType.Int16</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Int32</tt></td><td><tt class="literal">System.Int32</tt></td><td><tt class="literal">DbType.Int32</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Int64</tt></td><td><tt class="literal">System.Int64</tt></td><td><tt class="literal">DbType.Int64</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">LocalDateTime</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime</tt> / <tt class="literal">DbType.DateTime2</tt><a name="basic_mapping.datetime-co" href="#basic_mapping.datetime">(1)</a></td><td><tt class="literal">type="LocalDateTime"</tt> must be specified. Ensures the
                                <tt class="literal">DateTimeKind</tt> is set to <tt class="literal">DateTimeKind.Local</tt>.
                                Throws if set with a date having another kind.
                                Does no longer ignore fractional seconds since NHibernate v5.0.
                            </td></tr><tr><td><tt class="literal">LocalDateTimeNoMs</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime</tt> / <tt class="literal">DbType.DateTime2</tt><a name="basic_mapping.datetime-co" href="#basic_mapping.datetime">(1)</a></td><td><tt class="literal">type="LocalDateTimeNoMs"</tt> must be specified. Similar to
                                <tt class="literal">LocalDateTime</tt> but ignores fractional seconds.
                                Available since NHibernate v5.0.
                            </td></tr><tr><td><tt class="literal">PersistentEnum</tt></td><td>A <tt class="literal">System.Enum</tt></td><td>The <tt class="literal">DbType</tt> for the underlying value.</td><td>Do not specify <tt class="literal">type="PersistentEnum"</tt> in the mapping.  Instead 
                            specify the Assembly Qualified Name of the Enum or let NHibernate use Reflection to "guess" the Type.
                            The UnderlyingType of the Enum is used to determine the correct <tt class="literal">DbType</tt>.</td></tr><tr><td><tt class="literal">SByte</tt></td><td><tt class="literal">System.SByte</tt></td><td><tt class="literal">DbType.SByte</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Single</tt></td><td><tt class="literal">System.Single</tt></td><td><tt class="literal">DbType.Single</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Ticks</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.Int64</tt></td><td><tt class="literal">type="Ticks"</tt> must be specified. This is the recommended way to "timestamp" a
                                column, along with <tt class="literal">UtcTicks</tt>.
                            </td></tr><tr><td><tt class="literal">Time</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.Time</tt></td><td><tt class="literal">type="Time"</tt> must be specified.</td></tr><tr><td><tt class="literal">TimeAsTimeSpan</tt></td><td><tt class="literal">System.TimeSpan</tt></td><td><tt class="literal">DbType.Time</tt></td><td><tt class="literal">type="TimeAsTimeSpan"</tt> must be specified.</td></tr><tr><td><tt class="literal">TimeSpan</tt></td><td><tt class="literal">System.TimeSpan</tt></td><td><tt class="literal">DbType.Int64</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Timestamp</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime</tt> / <tt class="literal">DbType.DateTime2</tt><a name="basic_mapping.datetime-co" href="#basic_mapping.datetime">(1)</a></td><td>
                                Obsolete, its <tt class="literal">Timestamp</tt> alias will be remapped to
                                <tt class="literal">DateTime</tt> in a future version.
                            </td></tr><tr><td><tt class="literal">TrueFalse</tt></td><td><tt class="literal">System.Boolean</tt></td><td><tt class="literal">DbType.AnsiStringFixedLength</tt> - 1 char either 'T' or 'F'</td><td><tt class="literal">type="TrueFalse"</tt> must be specified.</td></tr><tr><td><tt class="literal">UInt16</tt></td><td><tt class="literal">System.UInt16</tt></td><td><tt class="literal">DbType.UInt16</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">UInt32</tt></td><td><tt class="literal">System.UInt32</tt></td><td><tt class="literal">DbType.UInt32</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">UInt64</tt></td><td><tt class="literal">System.UInt64</tt></td><td><tt class="literal">DbType.UInt64</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">UtcDateTime</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime</tt> / <tt class="literal">DbType.DateTime2</tt><a name="basic_mapping.datetime-co" href="#basic_mapping.datetime">(1)</a></td><td>
                                Ensures the <tt class="literal">DateTimeKind</tt> is set to <tt class="literal">DateTimeKind.Utc</tt>.
                                Throws if set with a date having another kind.
                                Does no longer ignore fractional seconds since NHibernate v5.0.
                            </td></tr><tr><td><tt class="literal">UtcDateTimeNoMs</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime</tt> / <tt class="literal">DbType.DateTime2</tt><a name="basic_mapping.datetime-co" href="#basic_mapping.datetime">(1)</a></td><td><tt class="literal">type="UtcDateTimeNoMs"</tt> must be specified. Similar to
                                <tt class="literal">UtcDateTime</tt> but ignores fractional seconds.
                                Available since NHibernate v5.0.
                            </td></tr><tr><td><tt class="literal">UtcDbTimestamp</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime</tt> / <tt class="literal">DbType.DateTime2</tt><a name="basic_mapping.datetime-co" href="#basic_mapping.datetime">(1)</a></td><td><tt class="literal">type="UtcDbTimestamp"</tt> must be specified. When used as a
                                <tt class="literal">version</tt> field, uses the database's current UTC time retrieved
                                in dedicated queries, rather than the client's current time. In case of lack of
                                database support, it falls back on the client's current time.
                            </td></tr><tr><td><tt class="literal">UtcTicks</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.Int64</tt></td><td><tt class="literal">type="UtcTicks"</tt> must be specified. This is the recommended way to "timestamp" a
                                column, along with <tt class="literal">Ticks</tt>.
                                Ensures the <tt class="literal">DateTimeKind</tt> is set to <tt class="literal">DateTimeKind.Utc</tt>.
                                Throws if set with a date having another kind.
                            </td></tr><tr><td><tt class="literal">YesNo</tt></td><td><tt class="literal">System.Boolean</tt></td><td><tt class="literal">DbType.AnsiStringFixedLength</tt> - 1 char either 'Y' or 'N'</td><td><tt class="literal">type="YesNo"</tt> must be specified.</td></tr></tbody></table></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><a name="basic_mapping.datetime"></a><a href="#basic_mapping.datetime-co">(1)</a> </td><td valign="top" align="left"><p>
                  Since NHibernate v5.0 and if the dialect supports it, <tt class="literal">DbType.DateTime2</tt>
                  is used instead of <tt class="literal">DbType.DateTime</tt>. This may be disabled by setting
                  <tt class="literal">sql_types.keep_datetime</tt> to <tt class="literal">true</tt>.
                </p></td></tr></table></div><div class="table"><a name="d0e8162"></a><p class="title"><b>Table&nbsp;5.4.&nbsp;System.Object Mapping Types</b></p><table summary="System.Object Mapping Types" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>NHibernate Type</th><th>.NET Type</th><th>Database Type</th><th>Remarks</th></tr></thead><tbody><tr><td><tt class="literal">AnsiString</tt></td><td><tt class="literal">System.String</tt></td><td><tt class="literal">DbType.AnsiString</tt></td><td><tt class="literal">type="AnsiString"</tt> must be specified.</td></tr><tr><td><tt class="literal">CultureInfo</tt></td><td><tt class="literal">System.Globalization.CultureInfo</tt></td><td><tt class="literal">DbType.String</tt> - 5 chars for culture</td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Binary</tt></td><td><tt class="literal">System.Byte[]</tt></td><td><tt class="literal">DbType.Binary</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Type</tt></td><td><tt class="literal">System.Type</tt></td><td><tt class="literal">DbType.String</tt> holding Assembly Qualified Name.</td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">String</tt></td><td><tt class="literal">System.String</tt></td><td><tt class="literal">DbType.String</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Uri</tt></td><td><tt class="literal">System.Uri</tt></td><td><tt class="literal">DbType.String</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr></tbody></table></div><p>
                String types use by default .Net default string equality, which is case sensitive and culture
                insensitive. When a string type is used as an identifier, if the underlying database string
                equality semantic differs, it may cause issues. For example, loading a children collection by
                a string parent key stored in a case insensitive column may cause matching children having
                their parent key differing by the case to be ignored by NHibernate by default.
            </p><p>
                String types comparer can be set for matching the database or column behavior. To set the
                default comparer for all string types, affect by code a <tt class="literal">StringComparer</tt> to
                <tt class="literal">AbstractStringType.DefaultComparer</tt> static property. To set the comparer used
                only for a specific <tt class="literal">&lt;property&gt;</tt> or <tt class="literal">&lt;id&gt;</tt>,
                specify its type as a sub-element and supply <tt class="literal">IgnoreCase</tt> and/or
                <tt class="literal">ComparerCulture</tt> parameters.
            </p><div class="programlistingco"><pre class="programlisting">&lt;id name="Id" generator="assigned"&gt;
    &lt;type name="string"&gt;
        &lt;param name="ComparerCulture"&gt;en-US&lt;/param&gt;   <span class="co">(1)</span>
        &lt;param name="IgnoreCase"&gt;true&lt;/param&gt;         <span class="co">(2)</span>
    &lt;/type&gt;
&lt;/id&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">IgnoreCase</tt>: <tt class="literal">true</tt> for case insensitive comparisons.
                            Any other value will result in case sensitive comparisons.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">ComparerCulture</tt>: <tt class="literal">Current</tt> for using the application
                            current culture, <tt class="literal">Invariant</tt> for using the invariant culture,
                            <tt class="literal">Ordinal</tt> for using ordinal comparison, or any valid culture name for
                            using another culture. By default, ordinal comparisons are used.
                        </p></td></tr></table></div></div><p>
                If you have many properties to map with these parameters, consider using <tt class="literal">&lt;typedef&gt;</tt>.
                See <a href="#mapping-types-custom" title="5.2.3.&nbsp;Custom value types">Section&nbsp;5.2.3, &#8220;Custom value types&#8221;</a> for more information.
            </p><p>
                These settings should be used in order to match the database or column behavior. They are not taken into
                account by the hbm2ddl tool for generating the database schema. (In other words, it will not generate
                matching <tt class="literal">collate</tt> statements for SQL-Server.)
            </p><div class="table"><a name="d0e8333"></a><p class="title"><b>Table&nbsp;5.5.&nbsp;Large Object Mapping Types</b></p><table summary="Large Object Mapping Types" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>NHibernate Type</th><th>.NET Type</th><th>Database Type</th><th>Remarks</th></tr></thead><tbody><tr><td><tt class="literal">StringClob</tt></td><td><tt class="literal">System.String</tt></td><td><tt class="literal">DbType.String</tt></td><td><tt class="literal">type="StringClob"</tt> must be specified.  Entire field is read into memory.</td></tr><tr><td><tt class="literal">BinaryBlob</tt></td><td><tt class="literal">System.Byte[]</tt></td><td><tt class="literal">DbType.Binary</tt></td><td><tt class="literal">type="BinaryBlob"</tt> must be specified.  Entire field is read into memory.</td></tr><tr><td><tt class="literal">Serializable</tt></td><td>Any <tt class="literal">System.Object</tt> that is marked with SerializableAttribute.</td><td><tt class="literal">DbType.Binary</tt></td><td><tt class="literal">type="Serializable"</tt> should be specified.  This is the fallback type
                            if no NHibernate Type can be found for the Property.</td></tr><tr><td><tt class="literal">XDoc</tt></td><td><tt class="literal">System.Xml.Linq.XDocument</tt></td><td><tt class="literal">DbType.Xml</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.  Entire field is read into memory.</td></tr><tr><td><tt class="literal">XmlDoc</tt></td><td><tt class="literal">System.Xml.XmlDocument</tt></td><td><tt class="literal">DbType.Xml</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.  Entire field is read into memory.</td></tr></tbody></table></div><p>
                NHibernate supports some additional type names for compatibility with Java's Hibernate (useful for those coming over from
                Hibernate or using some of the tools to generate <tt class="literal">hbm.xml</tt> files).
                A <tt class="literal">type="integer"</tt> or <tt class="literal">type="int"</tt> will map to an <tt class="literal">Int32</tt>
                NHibernate type, <tt class="literal">type="short"</tt> to an <tt class="literal">Int16</tt> NHibernateType.
                To see all of the conversions you can view the source of static constructor of the class
                <tt class="literal">NHibernate.Type.TypeFactory</tt>.
            </p><p>
                Default NHibernate types used when no <tt class="literal">type</tt> attribute is specified can be overridden by using
                the <tt class="literal">NHibernate.Type.TypeFactory.RegisterType</tt> static method before configuring and building
                session factories.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-custom"></a>5.2.3.&nbsp;Custom value types</h3></div></div><div></div></div><p>
                It is relatively easy for developers to create their own value types. For example,
                you might want to persist properties of type <tt class="literal">Int64</tt>
                to <tt class="literal">VARCHAR</tt> columns. NHibernate does not provide a built-in type
                for this. But custom types are not limited to mapping a property (or collection element)
                to a single table column. So, for example, you might have a property
                <tt class="literal">Name { get; set; }</tt> of type
                <tt class="literal">String</tt> that is persisted to the columns
                <tt class="literal">FIRST_NAME</tt>, <tt class="literal">INITIAL</tt>, <tt class="literal">SURNAME</tt>.
            </p><p>
                To implement a custom type, implement either <tt class="literal">NHibernate.UserTypes.IUserType</tt>
                or <tt class="literal">NHibernate.UserTypes.ICompositeUserType</tt> and declare properties using the
                fully qualified name of the type. Check out
                <tt class="literal">NHibernate.DomainModel.DoubleStringType</tt> to see the kind of things that
                are possible.
            </p><pre class="programlisting">&lt;property name="TwoStrings"
    type="NHibernate.DomainModel.DoubleStringType, NHibernate.DomainModel"&gt;
    &lt;column name="first_string"/&gt;
    &lt;column name="second_string"/&gt;
&lt;/property&gt;</pre><p>
                Notice the use of <tt class="literal">&lt;column&gt;</tt> tags to map a property to multiple
                columns.
            </p><p>
                The <tt class="literal">IEnhancedUserType</tt>, <tt class="literal">IUserVersionType</tt>,
                and <tt class="literal">IUserCollectionType</tt> interfaces provide support for more specialized
                uses. The later is to be used with collections, see <a href="#collections-persistent" title="6.1.&nbsp;Persistent Collections">Section&nbsp;6.1, &#8220;Persistent Collections&#8221;</a>.
            </p><p>
                You may even supply parameters to an <tt class="literal">IUserType</tt> in the mapping file. To
                do this, your <tt class="literal">IUserType</tt> must implement the
                <tt class="literal">NHibernate.UserTypes.IParameterizedType</tt> interface. To supply parameters
                to your custom type, you can use the <tt class="literal">&lt;type&gt;</tt> element in your mapping
                files.
            </p><pre class="programlisting">&lt;property name="priority"&gt;
    &lt;type name="MyCompany.UserTypes.DefaultValueIntegerType"&gt;
        &lt;param name="default"&gt;0&lt;/param&gt;
    &lt;/type&gt;
&lt;/property&gt;</pre><p>
                The <tt class="literal">IUserType</tt> can now retrieve the value for the parameter named 
                <tt class="literal">default</tt> from the <tt class="literal">IDictionary</tt> object passed to it.
            </p><p>
                If you use a certain <tt class="literal">UserType</tt> very often, it may be useful to define a
                shorter name for it. You can do this using the <tt class="literal">&lt;typedef&gt;</tt> element.
                Typedefs assign a name to a custom type, and may also contain a list of default
                parameter values if the type is parameterized.
            </p><pre class="programlisting">&lt;typedef class="MyCompany.UserTypes.DefaultValueIntegerType" name="default_zero"&gt;
    &lt;param name="default"&gt;0&lt;/param&gt;
&lt;/typedef&gt;</pre><pre class="programlisting">&lt;property name="priority" type="default_zero"/&gt;</pre><p>
                It is also possible to override the parameters supplied in a typedef on a case-by-case basis
                by using type parameters on the property mapping.
            </p><p>
                Even though NHibernate's rich range of built-in types and support for components means you
                will very rarely <span class="emphasis"><em>need</em></span> to use a custom type, it is nevertheless
                considered good form to use custom types for (non-entity) classes that occur frequently
                in your application. For example, a <tt class="literal">MonetaryAmount</tt> class is a good
                candidate for an <tt class="literal">ICompositeUserType</tt>, even though it could easily be mapped
                as a component. One motivation for this is abstraction. With a custom type, your mapping
                documents would be future-proofed against possible changes in your way of representing
                monetary values.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-entityname"></a>5.3.&nbsp;Mapping a class more than once</h2></div></div><div></div></div><p>
            It is possible to provide more than one mapping for a particular persistent class. In this case,
            you must specify an <span class="emphasis"><em>entity name</em></span> to disambiguate between instances of the two
            mapped entities. By default, the entity name is the same as the class name. NHibernate lets you
            specify the entity name when working with persistent objects, when writing queries, or when
            mapping associations to the named entity. 
        </p><pre class="programlisting">&lt;class name="Contract" table="Contracts"
        entity-name="CurrentContract"&gt;
    ...
    &lt;set name="History" inverse="true"
            order-by="effectiveEndDate desc"&gt;
        &lt;key column="currentContractId"/&gt;
        &lt;one-to-many entity-name="HistoricalContract"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Contract" table="ContractHistory"
        entity-name="HistoricalContract"&gt;
    ...
    &lt;many-to-one name="CurrentContract"
            column="currentContractId"
            entity-name="CurrentContract"/&gt;
&lt;/class&gt;</pre><p>
            Associations are now specified using <tt class="literal">entity-name</tt> instead of
            <tt class="literal">class</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-quotedidentifiers"></a>5.4.&nbsp;SQL quoted identifiers</h2></div></div><div></div></div><p>
            You may force NHibernate to quote an identifier in the generated SQL by enclosing the table or
            column name in back-ticks in the mapping document. NHibernate will use the correct quotation
            style for the SQL <tt class="literal">Dialect</tt> (usually double quotes, but brackets for SQL
            Server and back-ticks for MySQL).
        </p><pre class="programlisting">&lt;class name="LineItem" table="`Line Item`"&gt;
    &lt;id name="Id" column="`Item Id`"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;
    &lt;property name="ItemNumber" column="`Item #`"/&gt;
    ...
&lt;/class&gt;</pre><p>
            Quoting column identifiers is required if a table contains two columns differing only by case.
            Ensure you use consistent casing when quoting identifiers.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-modularfiles"></a>5.5.&nbsp;Modular mapping files</h2></div></div><div></div></div><p>
            It is possible to define <tt class="literal">subclass</tt> and <tt class="literal">joined-subclass</tt>
            mappings in separate mapping documents, directly beneath <tt class="literal">hibernate-mapping</tt>.
            This allows you to extend a class hierarchy just by adding a new mapping file. You must
            specify an <tt class="literal">extends</tt> attribute in the subclass mapping, naming a previously
            mapped superclass.
        </p><pre class="programlisting">
&lt;hibernate-mapping&gt;
    &lt;subclass name="Eg.Subclass.DomesticCat, Eg"
        extends="Eg.Cat, Eg" discriminator-value="D"&gt;

        &lt;property name="name" type="string"/&gt;
    &lt;/subclass&gt;
&lt;/hibernate-mapping&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-generated"></a>5.6.&nbsp;Generated Properties</h2></div></div><div></div></div><p>
            Generated properties are properties which have their values generated by the
            database.  Typically, NHibernate applications needed to <tt class="literal">Refresh</tt>
            objects which contain any properties for which the database was generating values.
            Marking properties as generated, however, lets the application delegate this
            responsibility to NHibernate.  Essentially, whenever NHibernate issues an SQL INSERT
            or UPDATE for an entity which has defined generated properties, it immediately
            issues a select afterwards to retrieve the generated values.
        </p><p>
            Properties marked as generated must additionally be non-insertable and non-updatable.
            Only <a href="#mapping-declaration-version" title="5.1.8.&nbsp;version (optional)">versions</a>,
            <a href="#mapping-declaration-timestamp" title="5.1.9.&nbsp;timestamp (optional)">timestamps</a>, and
            <a href="#mapping-declaration-property" title="5.1.10.&nbsp;property">simple properties</a> can be marked as
            generated.
        </p><p>
            <tt class="literal">never</tt> (the default) - means that the given property value
            is not generated within the database.
        </p><p>
            <tt class="literal">insert</tt> - states that the given property value is generated on
            insert, but is not regenerated on subsequent updates.  Things like created-date would
            fall into this category.  Note that even though
            <a href="#mapping-declaration-version" title="5.1.8.&nbsp;version (optional)">version</a> and
            <a href="#mapping-declaration-timestamp" title="5.1.9.&nbsp;timestamp (optional)">timestamp</a> properties can
            be marked as generated, this option is not available for them.
        </p><p>
            <tt class="literal">always</tt> - states that the property value is generated both
            on insert and on update.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-database-object"></a>5.7.&nbsp;Auxiliary Database Objects</h2></div></div><div></div></div><p>
            Auxiliary database objects allow CREATE and DROP of arbitrary database objects. In
            conjunction with NHibernate's schema evolution tools, they have the ability to fully
            define a user schema within the NHibernate mapping files. Although designed specifically
            for creating and dropping things like triggers or stored procedures, any SQL command
            that can be run via a <tt class="literal">DbCommand.ExecuteNonQuery()</tt> method is valid
            (for example, ALTERs, INSERTS, etc.). There are essentially two modes for defining
            auxiliary database objects:
        </p><p>
            The first mode is to explicitly list the CREATE and DROP commands in the mapping file:
        </p><pre class="programlisting">&lt;nhibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;create&gt;CREATE TRIGGER my_trigger ...&lt;/create&gt;
        &lt;drop&gt;DROP TRIGGER my_trigger&lt;/drop&gt;
    &lt;/database-object&gt;
&lt;/nhibernate-mapping&gt;</pre><p>
            The second mode is to supply a custom class that constructs the
            CREATE and DROP commands.  This custom class must implement the
            <tt class="literal">NHibernate.Mapping.IAuxiliaryDatabaseObject</tt> interface.
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition, MyAssembly"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre><p>
            You may also specify parameters to be passed to the database object:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition, MyAssembly"&gt;
            &lt;param name="parameterName"&gt;parameterValue&lt;/param&gt;
        &lt;/definition&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre><p>
            NHibernate will call <tt class="literal">IAuxiliaryDatabaseObject.SetParameterValues</tt>
            passing it a dictionary of parameter names and values.
        </p><p>
            Additionally, these database objects can be optionally scoped such that they only
            apply when certain dialects are used.
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition"/&gt;
        &lt;dialect-scope name="NHibernate.Dialect.Oracle9iDialect"/&gt;
        &lt;dialect-scope name="NHibernate.Dialect.Oracle8iDialect"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-meta"></a>5.8.&nbsp;Meta data</h2></div></div><div></div></div><p>
            You may declare additional metadata in your mappings by using the <tt class="literal">meta</tt> element. This element
            can be added to the main mapping elements.
        </p><div class="programlistingco"><pre class="programlisting">&lt;meta
    attribute="metaName"                              <span class="co">(1)</span>
    inherit="true|false"                              <span class="co">(2)</span>
    &gt;metaData&lt;/meta&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">attribute</tt>: The name of the metadata.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">inherit</tt> (optional - defaults to <tt class="literal">true</tt>):
                        Whether the metadata is inherited by mapping sub-elements or not.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        The text content of the meta element is its data.
                    </p></td></tr></table></div></div><p>
            The metadata can be retrieved at runtime from the <a href="#manipulatingdata-metadata" title="10.12.&nbsp;Metadata API">Section&nbsp;10.12, &#8220;Metadata API&#8221;</a>.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="collections"></a>Chapter&nbsp;6.&nbsp;Collection Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-persistent"></a>6.1.&nbsp;Persistent Collections</h2></div></div><div></div></div><p>
            NHibernate requires that persistent collection-valued fields be declared
            as a generic interface type, for example:
        </p><pre class="programlisting">public class Product
{
    public virtual ISet&lt;Part&gt; Parts { get; set; } = new HashSet&lt;Part&gt;();

    public virtual string SerialNumber { get; set; }
}</pre><p>
            The actual interface might be
            <tt class="literal">System.Collections.Generic.ICollection&lt;T&gt;</tt>,
            <tt class="literal">System.Collections.Generic.IList&lt;T&gt;</tt>,
            <tt class="literal">System.Collections.Generic.IDictionary&lt;K, V&gt;</tt>,
            <tt class="literal">System.Collections.Generic.ISet&lt;T&gt;</tt>
            or ... anything you like! (Where "anything you like" means you will
            have to write an implementation of <tt class="literal">NHibernate.UserType.IUserCollectionType</tt>.)
        </p><p>
            Notice how we initialized the instance variable with an instance of
            <tt class="literal">HashSet&lt;T&gt;</tt>. This is the best way to initialize collection
            valued properties of newly instantiated (non-persistent) instances. When
            you make the instance persistent - by calling <tt class="literal">Save()</tt>,
            for example - NHibernate will actually replace the <tt class="literal">HashSet&lt;T&gt;</tt>
            with an instance of NHibernate's own implementation of <tt class="literal">ISet&lt;T&gt;</tt>.
            Watch out for errors like this:
        </p><pre class="programlisting">Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
...
ISet&lt;Cat&gt; kittens = new HashSet&lt;Cat&gt;();
kittens.Add(kitten);
cat.Kittens = kittens;
session.Save(cat);
kittens = cat.Kittens; //Okay, kittens collection is an ISet
HashSet&lt;Cat&gt; hs = (HashSet&lt;Cat&gt;) cat.Kittens; //Error!</pre><p>
            Collection instances have the usual behavior of value types. They are automatically
            persisted when referenced by a persistent object and automatically deleted when
            unreferenced. If a collection is passed from one persistent object to another,
            its elements might be moved from one table to another. Two entities may not share
            a reference to the same collection instance. Due to the underlying relational model,
            collection-valued properties do not support null value semantics; NHibernate does
            not distinguish between a null collection reference and an empty collection.
        </p><p>
            You shouldn't have to worry much about any of this. Just use NHibernate's collections
            the same way you use ordinary .NET collections, but make sure you understand the
            semantics of bidirectional associations (discussed later) before using them.
        </p><p>
            Collection instances are distinguished in the database by a foreign key to
            the owning entity. The collection key is mapped by
            the <a href="#collections-foreignkeys" title="6.2.1.&nbsp;Collection foreign keys"><tt class="literal">&lt;key&gt;</tt> element</a>.
        </p><p>
            Collections may contain almost any other NHibernate type, including all basic types,
            custom types, entity types and components. See <a href="#collections-elements" title="6.2.2.&nbsp;Collection elements">Section&nbsp;6.2.2, &#8220;Collection elements&#8221;</a>.
        </p><p>
            All collection types except <tt class="literal">ISet</tt> and bag have an <span class="emphasis"><em>index</em></span>
            column - a column that maps to an array or <tt class="literal">IList</tt> index or
            <tt class="literal">IDictionary</tt> key. See <a href="#collections-indexed" title="6.2.3.&nbsp;Indexed collections">Section&nbsp;6.2.3, &#8220;Indexed collections&#8221;</a> for more
            information.
        </p><p>
            There are quite a range of mappings that can be generated for collections,
            covering many common relational models. We suggest you experiment with the
            schema generation tool to get a feeling for how various mapping declarations
            translate to database tables.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-mapping"></a>6.2.&nbsp;Mapping a Collection</h2></div></div><div></div></div><p>
            The NHibernate mapping element used for mapping a collection depends upon the type of interface.
            By example, a <tt class="literal">&lt;set&gt;</tt> element is used for mapping properties of type
            <tt class="literal">ISet</tt>.
        </p><pre class="programlisting">&lt;class name="Product"&gt;
    &lt;id name="SerialNumber" column="productSerialNumber"/&gt;
    &lt;set name="Parts"&gt;
        &lt;key column="productSerialNumber" not-null="true"/&gt;
        &lt;one-to-many class="Part"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Apart from
            <tt class="literal">&lt;set&gt;</tt>, there is also
            <tt class="literal">&lt;list&gt;</tt>,
            <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt>,
            <tt class="literal">&lt;array&gt;</tt> and
            <tt class="literal">&lt;primitive-array&gt;</tt> mapping elements.
            The <tt class="literal">&lt;map&gt;</tt> element is representative:
        </p><div class="programlistingco"><pre class="programlisting">&lt;map
    name="propertyName"                                         <span class="co">(1)</span>
    table="tableName"                                           <span class="co">(2)</span>
    schema="schemaName"                                         <span class="co">(3)</span>
    catalog="catalogName"                                       <span class="co">(4)</span>
    lazy="true|false|extra"                                     <span class="co">(5)</span>
    inverse="true|false"                                        <span class="co">(6)</span>
    cascade="all|none|save-update|delete|all-delete-orphan"     <span class="co">(7)</span>
    sort="unsorted|natural|comparatorClass"                     <span class="co">(8)</span>
    order-by="columnName asc|desc"                              <span class="co">(9)</span>
    where="arbitrary sql where condition"                       <span class="co">(10)</span>
    fetch="select|join|subselect"                               <span class="co">(11)</span>
    batch-size="N"                                              <span class="co">(12)</span>
    access="field|property|className"                           <span class="co">(13)</span>
    optimistic-lock="true|false"                                <span class="co">(14)</span>
    mutable="true|false"                                        <span class="co">(15)</span>
    subselect="SQL expression"                                  <span class="co">(16)</span>
    check="arbitrary sql check condition"                       <span class="co">(17)</span>
    persister="persisterClass"                                  <span class="co">(18)</span>
    collection-type="collectionClass"                           <span class="co">(19)</span>
    outer-join="auto|true|false"                                <span class="co">(20)</span>
    generic="true|false"&gt;                                       <span class="co">(21)</span>

    &lt;key ... /&gt;
    &lt;map-key ... /&gt;
    &lt;element ... /&gt;
&lt;/map&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">name</tt>: the collection property name.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">table</tt> (optional - defaults to property name): the
                        name of the collection table. It is not used for one-to-many associations.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">schema</tt> (optional): overrides the schema name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">catalog</tt> (optional): overrides the catalog name specified by
                        the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                        <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">true</tt>):
                        may be used to disable lazy fetching and specify that the association
                        is always eagerly fetched. Using <tt class="literal">extra</tt> fetches only the
                        elements that are needed - see <a href="#performance-fetching" title="21.1.&nbsp;Fetching strategies">Section&nbsp;21.1, &#8220;Fetching strategies&#8221;</a> for more information.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                        <tt class="literal">inverse</tt> (optional - defaults to <tt class="literal">false</tt>):
                        marks this collection as the "inverse" end of a bidirectional association.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                        <tt class="literal">cascade</tt> (optional - defaults to <tt class="literal">none</tt>):
                        enables operations to cascade to child entities.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                        <tt class="literal">sort</tt> (optional): specifies a sorted collection with a
                        <tt class="literal">natural</tt> sort order, or a given comparator class. See
                        <a href="#collections-sorted" title="6.3.1.&nbsp;Sorted Collections">Section&nbsp;6.3.1, &#8220;Sorted Collections&#8221;</a>.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                        <tt class="literal">order-by</tt> (optional): specifies a table column (or columns)
                        that defines the iteration order of the <tt class="literal">IDictionary</tt>, <tt class="literal">ISet</tt>
                        or bag, together with an optional <tt class="literal">asc</tt> or <tt class="literal">desc</tt>.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                        <tt class="literal">where</tt> (optional): specifies an arbitrary SQL <tt class="literal">WHERE</tt>
                        condition to be used when retrieving or removing the collection. It is useful if the
                        collection should contain only a subset of the available data.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                        <tt class="literal">fetch</tt> (optional, defaults to <tt class="literal">select</tt>): chooses between
                        outer-join fetching, fetching by sequential select, and fetching by sequential subselect -
                        see <a href="#performance-fetching-subselect" title="21.1.6.&nbsp;Using subselect fetching">Section&nbsp;21.1.6, &#8220;Using subselect fetching&#8221;</a>. <tt class="literal">join</tt> takes
                        precedence over the <tt class="literal">lazy</tt> attribute and causes the association to be
                        eagerly fetched.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                        <tt class="literal">batch-size</tt> (optional, defaults to <tt class="literal">1</tt>): specifies a
                        "batch size" for lazily fetching instances of this collection. See
                        <a href="#performance-fetching-batch" title="21.1.5.&nbsp;Using batch fetching">Section&nbsp;21.1.5, &#8220;Using batch fetching&#8221;</a>.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                        <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): the
                        strategy NHibernate should use for accessing the property value.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                        <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>):
                        specifies that changes to the state of the collection results in increment of the
                        owning entity's version. For one to many associations, you may want to disable this
                        setting.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(15)</td><td valign="top" align="left"><p>
                        <tt class="literal">mutable</tt> (optional - defaults to <tt class="literal">true</tt>): a value of
                        <tt class="literal">false</tt> specifies that the elements of the collection never change.
                        This allows for minor performance optimization in some cases.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(16)</td><td valign="top" align="left"><p>
                        <tt class="literal">subselect</tt> (optional): maps an immutable and read-only collection to a
                        database sub-select. This is useful if you want to have a view instead of a base table.
                        It is not used for one-to-many associations.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(17)</td><td valign="top" align="left"><p>
                        <tt class="literal">check</tt> (optional): an SQL expression used to generate a multi-row check
                        constraint for automatic schema generation. It is not used for one-to-many associations.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(18)</td><td valign="top" align="left"><p>
                        <tt class="literal">persister</tt> (optional&gt;): specifies a custom
                        <tt class="literal">ICollectionPersister</tt>.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(19)</td><td valign="top" align="left"><p>
                        <tt class="literal">collection-type</tt> (optional): the fully qualified type name of a class
                        implementing <tt class="literal">IUserCollectionType</tt>.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(20)</td><td valign="top" align="left"><p>
                        <tt class="literal">outer-join</tt> (optional): This attribute is obsoleted in favor of
                        <tt class="literal">fetch</tt>. <tt class="literal">auto</tt> is equivalent to not specifying
                        <tt class="literal">fetch</tt>, <tt class="literal">true</tt> is equivalent to
                        <tt class="literal">join</tt> and <tt class="literal">false</tt> is equivalent to
                        <tt class="literal">select</tt>. It has no value matching the <tt class="literal">subselect</tt>
                        <tt class="literal">fetch</tt> value.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(21)</td><td valign="top" align="left"><p>
                        <tt class="literal">generic</tt> (optional, defaults according to the reflected property type):
                        if <tt class="literal">false</tt>, NHibernate will type the collection elements as
                        <tt class="literal">object</tt>. Otherwise NHibernate will use reflection to determine the
                        element type to use.
                    </p></td></tr></table></div></div><p>
            The mapping of an <tt class="literal">IList</tt> or array requires a separate table column holding the array
            or list index (the <tt class="literal">i</tt> in <tt class="literal">foo[i]</tt>). If your relational model doesn't
            have an index column, use an unordered <tt class="literal">ISet</tt> instead. This seems to put people off
            who assume that <tt class="literal">IList</tt> should just be a more
            convenient way of accessing an unordered collection. NHibernate collections strictly obey the actual
            semantics attached to the <tt class="literal">ISet</tt>, <tt class="literal">IList</tt> and <tt class="literal">IDictionary</tt>
            interfaces. <tt class="literal">IList</tt> elements don't just spontaneously rearrange themselves!
        </p><p>
            On the other hand, people who planned to use the <tt class="literal">IList</tt> to emulate
            <span class="emphasis"><em>bag</em></span> semantics have a legitimate grievance here.
            A bag is an unordered, unindexed collection which may contain the same element multiple times.
            The .NET collections framework lacks an <tt class="literal">IBag</tt> interface, hence you have to emulate
            it with an <tt class="literal">IList</tt>. NHibernate lets you map properties of type <tt class="literal">IList</tt>
            or <tt class="literal">ICollection</tt> with the <tt class="literal">&lt;bag&gt;</tt> element. Note that bag
            semantics are not really part of the <tt class="literal">ICollection</tt> contract and they actually
            conflict with the semantics of the <tt class="literal">IList</tt> contract (however, you can sort
            the bag arbitrarily, discussed later in this chapter).
        </p><p>
            Note: large NHibernate bags mapped with <tt class="literal">inverse="false"</tt> are inefficient and
            should be avoided. NHibernate can't create, delete or update rows individually, because there is
            no key that may be used to identify an individual row.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-foreignkeys"></a>6.2.1.&nbsp;Collection foreign keys</h3></div></div><div></div></div><p>
                Collection instances are distinguished in the database by the foreign key of the entity that owns the
                collection. This foreign key is referred to as the <span class="emphasis"><em>collection key column</em></span>, or
                columns, of the collection table. The collection key column is mapped by the
                <tt class="literal">&lt;key&gt;</tt> element.
            </p><p>
                There can be a nullability constraint on the foreign key column. For most collections, this is implied.
                For unidirectional one-to-many associations, the foreign key column is nullable by default, so you may
                need to specify <tt class="literal">not-null="true"</tt>.
            </p><pre class="programlisting">&lt;key column="productSerialNumber" not-null="true"/&gt;</pre><p>
                The foreign key constraint can use <tt class="literal">ON DELETE CASCADE</tt>.
            </p><pre class="programlisting">&lt;key column="productSerialNumber" on-delete="cascade"/&gt;</pre><p>
                See <a href="#mapping-declaration-key" title="5.1.20.&nbsp;key">Section&nbsp;5.1.20, &#8220;key&#8221;</a> for a full definition of the
                <tt class="literal">&lt;key&gt;</tt> element.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-elements"></a>6.2.2.&nbsp;Collection elements</h3></div></div><div></div></div><p>
                Collections can contain almost any other NHibernate type, including: basic types, custom types, components
                and references to other entities. This is an important distinction. An object in a collection might be
                handled with "value" semantics (its life cycle fully depends on the collection owner), or it might be a
                reference to another entity with its own life cycle. In the latter case, only the "link" between the two
                objects is considered to be a state held by the collection.
            </p><p>
                The contained type is referred to as the collection element type. Collection elements are mapped by
                <tt class="literal">&lt;element&gt;</tt> or <tt class="literal">&lt;composite-element&gt;</tt>, or in the case of entity
                references, with <tt class="literal">&lt;one-to-many&gt;</tt> or <tt class="literal">&lt;many-to-many&gt;</tt>. The
                first two map elements with value semantics, the next two are used to map entity associations. A last one
                exist for exotic entity associations, <tt class="literal">&lt;many-to-any&gt;</tt>, similar to
                <a href="#mapping-types-anymapping" title="5.1.24.&nbsp;any">the <tt class="literal">&lt;any&gt;</tt> mapping element</a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-indexed"></a>6.2.3.&nbsp;Indexed collections</h3></div></div><div></div></div><p>
                All collection mappings, except those with set and bag semantics, need an <span class="emphasis"><em>index column</em></span>
                in the collection table. An index column is a column that maps to an array index, or <tt class="literal">IList</tt>
                index, or <tt class="literal">IDictionary</tt> key. The index of an <tt class="literal">IDictionary</tt> may be of any
                basic type, mapped with <tt class="literal">&lt;map-key&gt;</tt>. It can be an entity reference mapped with
                <tt class="literal">&lt;map-key-many-to-many&gt;</tt> (or in exotic cases <tt class="literal">&lt;index-many-to-any&gt;</tt>,
                similar to <a href="#mapping-types-anymapping" title="5.1.24.&nbsp;any">the <tt class="literal">&lt;any&gt;</tt> mapping element</a>),
                or it can be a composite type mapped with <tt class="literal">&lt;composite-map-key&gt;</tt>. The index of an array or
                list is always of type <tt class="literal">Int32</tt> and is mapped using the &lt;list-index&gt; element. The mapped
                column contains sequential integers that are numbered from zero by default.
            </p><div class="programlistingco"><pre class="programlisting">&lt;list-index
    column="columnName"                               <span class="co">(1)</span>
    base="0|1|..."                                    <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (required): the name of the column holding the collection index values.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">base</tt> (optional - defaults to <tt class="literal">0</tt>): the value of the index column
                            that corresponds to the first element of the list or array.
                        </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key
    column="columnName"                               <span class="co">(1)</span>
    formula="any SQL expression"                      <span class="co">(2)</span>
    type="typeName"                                   <span class="co">(3)</span>
    length="N"                                        <span class="co">(4)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (required unless <tt class="literal">formula</tt> is used): the name of the column
                            holding the map key values.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional): a SQL formula used to evaluate the key of the map.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (required): the type of the map keys.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">length</tt> (optional): If the type takes a length and does not
                            already specify it, its length.
                        </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key-many-to-many
    column="columnName"                               <span class="co">(1)</span>
    formula="any SQL expression"                      <span class="co">(2)</span>
    class="className"                                 <span class="co">(3)</span>
    entity-name="entityName"                          <span class="co">(4)</span>
    foreign-key="foreignKeyName"                      <span class="co">(5)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (required unless <tt class="literal">formula</tt> is used): the name of the column
                            holding the map key values.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional): a SQL formula used to evaluate the key of the map.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (required): the entity class used as the map key.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">entity-name</tt> (optional): the entity name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">foreign-key</tt> (optional): specifies the name of the foreign key
                            constraint for DDL generation.
                        </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;composite-map-key
    class="className"&gt;                                <span class="co">(1)</span>

    &lt;key-property .../&gt;                               <span class="co">(2)</span>
    &lt;key-many-to-one .../&gt;                            <span class="co">(3)</span>
    ...
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (required): the component class used as the map key. Make sure
                            you override <tt class="literal">GetHashCode()</tt> and <tt class="literal">Equals()</tt>
                            correctly on the component class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">&lt;key-property&gt;</tt>: maps a component property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">&lt;key-many-to-one&gt;</tt>: maps a component many-to-one association.
                        </p></td></tr></table></div></div><p>
                If your table does not have an index column, and you still wish to use <tt class="literal">IList</tt> as the
                property type, you can map the property as a NHibernate <tt class="literal">&lt;bag&gt;</tt>. A bag does not
                retain its order when it is retrieved from the database, but it can be optionally sorted or ordered.
                Also consider using an <tt class="literal">ISet</tt> as the property type.
            </p><p>
                 The <tt class="literal">&lt;index&gt;</tt>, <tt class="literal">&lt;index-many-to-many&gt;</tt> and
                <tt class="literal">&lt;composite-index&gt;</tt> elements are obsoleted predecessors to
                <tt class="literal">&lt;map-key&gt;</tt>/<tt class="literal">&lt;list-index&gt;</tt>,
                <tt class="literal">&lt;map-key-many-to-many&gt;</tt> and <tt class="literal">&lt;composite-map-key&gt;</tt> respectively.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-ofvalues"></a>6.2.4.&nbsp;Collections of Values and Many-To-Many Associations</h3></div></div><div></div></div><p>
                Any collection of values or many-to-many associations requires a dedicated
                <span class="emphasis"><em>collection table</em></span> with a <a href="#collections-foreignkeys" title="6.2.1.&nbsp;Collection foreign keys">foreign
                key column or columns</a>, <span class="emphasis"><em>collection element column</em></span> or columns, and
                possibly an <a href="#collections-indexed" title="6.2.3.&nbsp;Indexed collections">index column or columns</a>.
            </p><p>
                For a collection of values, use the <tt class="literal">&lt;element&gt;</tt> tag.
            </p><div class="programlistingco"><pre class="programlisting">&lt;element
    column="columnName"                               <span class="co">(1)</span>
    formula="any SQL expression"                      <span class="co">(2)</span>
    type="typeName"                                   <span class="co">(3)</span>
    length="L"                                        <span class="co">(4)</span>
    precision="P"                                     <span class="co">(5)</span>
    scale="S"                                         <span class="co">(6)</span>
    not-null="true|false"                             <span class="co">(7)</span>
    unique="true|false"                               <span class="co">(8)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (required unless <tt class="literal">formula</tt> is used): the
                            name of the column holding the collection element values.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional): an SQL formula used to evaluate the element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (required): the type of the collection element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">length</tt> (optional): if the type takes a length and does not
                            already specify it, its length.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">precision</tt> (optional): if the type takes a precision and does not
                            already specify it, its precision.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">scale</tt> (optional): if the type takes a scale and does not
                            already specify it, its scale.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-null</tt> (optional - defaults to <tt class="literal">false</tt>):
                            sets the column nullability for DDL generation.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optional - defaults to <tt class="literal">false</tt>):
                            sets the column uniqueness for DDL generation.
                        </p></td></tr></table></div></div><p>
                A <span class="emphasis"><em>many-to-many association</em></span> is specified using the
                <tt class="literal">&lt;many-to-many&gt;</tt> element.
            </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-many
    column="columnName"                                    <span class="co">(1)</span>
    formula="any SQL expression"                           <span class="co">(2)</span>
    class="className"                                      <span class="co">(3)</span>
    fetch="join|select"                                    <span class="co">(4)</span>
    lazy="false|proxy"                                     <span class="co">(5)</span>
    not-found="ignore|exception"                           <span class="co">(6)</span>
    entity-name="entityName"                               <span class="co">(7)</span>
    property-ref="propertyNameFromAssociatedClass"         <span class="co">(8)</span>
    order-by="columnName asc|desc"                         <span class="co">(9)</span>
    where="arbitrary sql where condition"                  <span class="co">(10)</span>
    unique="true|false"                                    <span class="co">(11)</span>
    foreign-key="foreignKeyName"                           <span class="co">(12)</span>
    outer-join="auto|true|false"                           <span class="co">(13)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (required unless <tt class="literal">formula</tt> is used): the
                            name of the element foreign key column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional): an SQL formula used to evaluate the element
                            foreign key value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (required): the name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optional, defaults to <tt class="literal">join</tt>):
                            enables outer-join or sequential select fetching for this association. This is a
                            special case; for full eager fetching (in a single SELECT) of an entity and its
                            many-to-many relationships to other entities, you would enable join fetching not
                            only of the collection itself, but also with this attribute on the
                            <tt class="literal">&lt;many-to-many&gt;</tt> nested element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional, defaults to <tt class="literal">proxy</tt>):
                            may be used to disable lazy fetching and specify that the associated entities
                            are always eagerly fetched. This is a special case; disabling laziness of the
                            collection itself only would only eagerly load the list of ids of the associated
                            entities. For fully loading the associated entities instead, while keeping
                            <tt class="literal">fetch</tt> value as <tt class="literal">select</tt>, you would also
                            disable laziness with this attribute on the <tt class="literal">&lt;many-to-many&gt;</tt>
                            nested element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-found</tt> (optional - defaults to <tt class="literal">exception</tt>):
                            specifies how foreign keys that reference missing rows will be handled.
                            <tt class="literal">ignore</tt> will treat a missing row as a null association.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">entity-name</tt> (optional): the entity name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt> (optional): the name of a property of the associated
                            class that is joined to this foreign key. If not specified, the primary key of the
                            associated class is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">order-by</tt> (optional): specifies a table column (or columns) that
                            defines the iteration order of the collection. This is a special case; the
                            <tt class="literal">order-by</tt> on the collection could order only by the foreign key.
                            The <tt class="literal">order-by</tt> on the <tt class="literal">&lt;many-to-many&gt;</tt>
                            nested element allows to order by the associated entity columns.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">where</tt> (optional): specifies an arbitrary SQL <tt class="literal">WHERE</tt>
                        condition to be used when retrieving or removing the collection. This is a special case; the
                            <tt class="literal">where</tt> on the collection could filter only by the foreign key.
                            The <tt class="literal">where</tt> on the <tt class="literal">&lt;many-to-many&gt;</tt>
                            nested element allows to filter by the associated entity columns.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optional): enables the DDL generation of a unique constraint
                            for the foreign-key column. This makes the association multiplicity effectively
                            one-to-many.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                            <tt class="literal">foreign-key</tt> (optional): specifies the name of the foreign key
                            constraint for DDL generation.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                            <tt class="literal">outer-join</tt> (optional): This attribute is obsoleted in favor of
                            <tt class="literal">fetch</tt>. <tt class="literal">auto</tt> is equivalent to not specifying
                            <tt class="literal">fetch</tt>, <tt class="literal">true</tt> is equivalent to
                            <tt class="literal">join</tt> and <tt class="literal">false</tt> is equivalent to
                            <tt class="literal">select</tt>.
                        </p></td></tr></table></div></div><p>
                Here are some examples.
            </p><p>
                A set of strings:
            </p><pre class="programlisting">&lt;set name="Names" table="NAMES"&gt;
    &lt;key column="GROUPID"/&gt;
    &lt;element column="NAME" type="String"/&gt;
&lt;/set&gt;</pre><p>
                A bag containing integers with an iteration order determined by the
                <tt class="literal">order-by</tt> attribute:
            </p><pre class="programlisting">&lt;bag name="Sizes" table="SIZES" order-by="SIZE ASC"&gt;
    &lt;key column="OWNER"/&gt;
    &lt;element column="SIZE" type="Int32"/&gt;
&lt;/bag&gt;</pre><p>
                An array of entities, in this case, a many-to-many association (note that
                the entities are lifecycle objects, <tt class="literal">cascade="all"</tt>, see
                <a href="#manipulatingdata-graphs" title="10.10.&nbsp;Lifecycles and object graphs">Section&nbsp;10.10, &#8220;Lifecycles and object graphs&#8221;</a>):
            </p><pre class="programlisting">&lt;array name="Addresses" table="PersonAddress" cascade="all"&gt;
    &lt;key column="personId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;many-to-many column="addressId" class="Address"/&gt;
&lt;/array&gt;</pre><p>
                A map from string indices to dates:
            </p><pre class="programlisting">&lt;map name="Holidays" table="holidays" schema="dbo" order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="Date"/&gt;
&lt;/map&gt;</pre><p>
                A list of components (discussed in <a href="#components" title="Chapter&nbsp;8.&nbsp;Component Mapping">Chapter&nbsp;8, <i>Component Mapping</i></a>):
            </p><pre class="programlisting">&lt;list name="CarComponents" table="car_components"&gt;
    &lt;key column="car_id"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;composite-element class="Eg.Car.CarComponent"&gt;
        &lt;property name="Price"/&gt;
        &lt;property name="Type"/&gt;
        &lt;property name="SerialNumber" column="serial_no"/&gt;
    &lt;/composite-element&gt;
&lt;/list&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-onetomany"></a>6.2.5.&nbsp;One-To-Many Associations</h3></div></div><div></div></div><p>
                A <span class="emphasis"><em>one-to-many association</em></span> links the tables of two classes via a
                foreign key with no intervening collection table. This mapping loses certain semantics
                of normal .NET collections:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        No null values may be contained in a dictionary, set or list (unless
                        using <tt class="literal">not-found</tt> value <tt class="literal">ignore</tt>).
                    </p></li><li><p>
                        An instance of the contained entity class cannot belong to more than
                        one instance of the collection.
                    </p></li><li><p>
                        An instance of the contained entity class cannot appear at more than
                        one value of the collection index.
                    </p></li></ul></div><p>
                An association from <tt class="literal">Product</tt> to <tt class="literal">Part</tt> requires the
                existence of a foreign key column and possibly an index column into the Part table. A
                <tt class="literal">&lt;one-to-many&gt;</tt> tag indicates that this is a one-to-many
                association.
            </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-many
    class="className"                                      <span class="co">(1)</span>
    not-found="ignore|exception"                           <span class="co">(2)</span>
    entity-name="entityName"                               <span class="co">(3)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (required): the name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-found</tt> (optional - defaults to <tt class="literal">exception</tt>):
                            specifies how foreign keys that reference missing rows will be handled.
                            <tt class="literal">ignore</tt> will treat a missing row as a null association.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">entity-name</tt> (optional): the entity name of the associated class.
                        </p></td></tr></table></div></div><p>
                The <tt class="literal">&lt;one-to-many&gt;</tt> element does not need to declare any columns. Nor is
                it necessary to specify the table name anywhere. 
            </p><p>
                <span class="emphasis"><em>Very Important Note:</em></span> If the foreign key column of an
                <tt class="literal">&lt;one-to-many&gt;</tt> association is declared <tt class="literal">NOT NULL</tt>, you
                must declare the <tt class="literal">&lt;key&gt;</tt> mapping <tt class="literal">not-null="true"</tt> or
                <span class="emphasis"><em>use a bidirectional association</em></span> with the collection mapping marked
                <tt class="literal">inverse="true"</tt>. See <a href="#collections-bidirectional" title="6.3.2.&nbsp;Bidirectional Associations">Section&nbsp;6.3.2, &#8220;Bidirectional Associations&#8221;</a> for more
                information.
            </p><p>
                Example:
            </p><pre class="programlisting">&lt;set name="Parts"&gt;
    &lt;key column="product_id"/&gt;
    &lt;one-to-many class="Eg.Part, Eg"/&gt;
&lt;/set&gt;</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-advancedmappings"></a>6.3.&nbsp;Advanced collection mappings</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-sorted"></a>6.3.1.&nbsp;Sorted Collections</h3></div></div><div></div></div><p>
                NHibernate supports collections implemented by <tt class="literal">System.Collections.Generic.SortedList&lt;T&gt;</tt> and
                <tt class="literal">System.Collections.Generic.SortedSet&lt;T&gt;</tt>. You must specify a comparer in the mapping file:
            </p><pre class="programlisting">&lt;set name="Aliases" table="person_aliases" sort="natural"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="String"/&gt;
&lt;/set&gt;

&lt;map name="Holidays" sort="My.Custom.HolidayComparer, MyAssembly"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="String"/&gt;
    &lt;element column="hol_date" type="Date"/&gt;
&lt;/map&gt;</pre><p>
                Allowed values of the <tt class="literal">sort</tt> attribute are <tt class="literal">unsorted</tt>,
                <tt class="literal">natural</tt> and the name of a class implementing
                <tt class="literal">System.Collections.Generic.IComparer&lt;T&gt;</tt>.
            </p><p>
                If you want the database itself to order the collection elements use the
                <tt class="literal">order-by</tt> attribute of <tt class="literal">set</tt>, <tt class="literal">bag</tt>
                or <tt class="literal">map</tt> mappings. This performs the ordering in the SQL query, not in
                memory.
            </p><p>
                Setting the <tt class="literal">order-by</tt> attribute tells NHibernate to use
                <tt class="literal">Iesi.Collections.Generic.LinkedHashSet</tt> class
                internally for sets, maintaining the order of the elements. It is not supported on maps,
                unless specifying also a custom <tt class="literal">collection-type</tt> implementing
                <tt class="literal">IUserCollectionType</tt>.
            </p><pre class="programlisting">&lt;set name="Aliases" table="person_aliases" order-by="name asc"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="String"/&gt;
&lt;/set&gt;

&lt;map name="Holidays" order-by="hol_date, hol_name" collection-type="..."&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="String"/&gt;
    &lt;element column="hol_date type="Date"/&gt;
&lt;/map&gt;</pre><p>
                Note that the value of the <tt class="literal">order-by</tt> attribute is an SQL ordering, not
                a HQL ordering!
            </p><p>
                Associations can even be sorted by some arbitrary criteria at runtime using a
                <tt class="literal">CreateFilter()</tt>.
            </p><pre class="programlisting">sortedUsers = s
    .CreateFilter(group.Users, "order by this.Name")
    .List&lt;User&gt;();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-bidirectional"></a>6.3.2.&nbsp;Bidirectional Associations</h3></div></div><div></div></div><p>
                A <span class="emphasis"><em>bidirectional association</em></span> allows navigation from both
                "ends" of the association. Two kinds of bidirectional association are
                supported:

                </p><div class="variablelist"><dl><dt><span class="term">one-to-many</span></dt><dd><p>
                                set or bag valued at one end, single-valued at the other
                            </p></dd><dt><span class="term">many-to-many</span></dt><dd><p>
                                set or bag valued at both ends
                            </p></dd></dl></div><p>

            </p><p>
                You can specify a bidirectional many-to-many association simply by mapping two
                many-to-many associations to the same database table and declaring one end as
                <span class="emphasis"><em>inverse</em></span>. You cannot select an indexed collection.
            </p><p>
                Here is an example of a bidirectional many-to-many association that illustrates how each
                category can have many items and each item can be in many categories: 
            </p><pre class="programlisting">&lt;class name="Category"&gt;
    &lt;id name="Id" column="CATEGORY_ID"/&gt;
    ...
    &lt;bag name="Items" table="CATEGORY_ITEM"&gt;
        &lt;key column="CATEGORY_ID"/&gt;
        &lt;many-to-many class="Item" column="ITEM_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="Item"&gt;
    &lt;id name="Id" column="ITEM_ID"/&gt;
    ...

    &lt;!-- inverse end --&gt;
    &lt;bag name="Categories" table="CATEGORY_ITEM" inverse="true"&gt;
        &lt;key column="ITEM_ID"/&gt;
        &lt;many-to-many class="Category" column="CATEGORY_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;</pre><p>
                Changes made only to the inverse end of the association are <span class="emphasis"><em>not</em></span>
                persisted. This means that NHibernate has two representations in memory for every
                bidirectional association, one link from A to B and another link from B to A. This
                is easier to understand if you think about the .NET object model and how we create
                a many-to-many relationship in C#:
            </p><pre class="programlisting">category.Items.Add(item);      // The category now "knows" about the relationship
item.Categories.Add(category); // The item now "knows" about the relationship

session.Update(item);          // No effect, nothing will be saved!
session.Update(category);      // The relationship will be saved</pre><p>
                The non-inverse side is used to save the in-memory representation to the database.
                We would get an unnecessary INSERT/UPDATE and probably even a foreign key violation
                if both would trigger changes! The same is of course also true for bidirectional
                one-to-many associations.
            </p><p>
                You can map a bidirectional one-to-many association by mapping a one-to-many association
                to the same table column(s) as a many-to-one association and declaring the many-valued
                end <tt class="literal">inverse="true"</tt>.
            </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="Id" column="id"/&gt;
    ...
    &lt;set name="Children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="Id" column="id"/&gt;
    ...
    &lt;many-to-one name="Parent" class="Parent" column="parent_id"/&gt;
&lt;/class&gt;</pre><p>
                Mapping one end of an association with <tt class="literal">inverse="true"</tt> doesn't
                affect the operation of cascades as these are orthogonal concepts.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-indexedbidirectional"></a>6.3.3.&nbsp;Bidirectional associations with indexed collections</h3></div></div><div></div></div><p>
                A bidirectional association where one end is represented as a <tt class="literal">&lt;list&gt;</tt>
                or <tt class="literal">&lt;map&gt;</tt>, requires special consideration. If there is a property of
                the child class that maps to the index column you can use <tt class="literal">inverse="true"</tt>
                on the collection mapping:
            </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="Id" column="parent_id"/&gt;
    ...
    &lt;map name="Children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;map-key column="name"
            type="string"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/map&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="Id" column="child_id"/&gt;
    ...
    &lt;property name="Name" column="name"
        not-null="true"/&gt;
    &lt;many-to-one name="Parent"
        class="Parent"
        column="parent_id"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>
                If there is no such property on the child class, the association cannot be considered truly
                bidirectional. That is, there is information available at one end of the association that is not
                available at the other end. In this case, you cannot map the collection
                <tt class="literal">inverse="true"</tt>. Instead, you could use the following mapping:
            </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="Id" column="parent_id"/&gt;
    ...
    &lt;map name="Children"&gt;
        &lt;key column="parent_id"
            not-null="true"/&gt;
        &lt;map-key column="name"
            type="string"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/map&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="Id" column="child_id"/&gt;
    ...
    &lt;many-to-one name="Parent"
        class="Parent"
        column="parent_id"
        insert="false"
        update="false"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>
                Note that in this mapping, the collection-valued end of the association is responsible for
                updates to the foreign key.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-ternary"></a>6.3.4.&nbsp;Ternary Associations</h3></div></div><div></div></div><p>
                There are three possible approaches to mapping a ternary association. One approach is to use
                an <tt class="literal">IDictionary</tt> with an association as its index:
            </p><pre class="programlisting">&lt;map name="Contracts"&gt;
    &lt;key column="employer_id"/&gt;
    &lt;map-key-many-to-many column="employee_id" class="Employee"/&gt;
    &lt;one-to-many class="Contract"/&gt;
&lt;/map&gt;</pre><pre class="programlisting">&lt;map name="Connections"&gt;
    &lt;key column="incoming_node_id"/&gt;
    &lt;map-key-many-to-many column="outgoing_node_id" class="Node"/&gt;
    &lt;many-to-many column="connection_id" class="Connection"/&gt;
&lt;/map&gt;</pre><p>
                A second approach is to remodel the association as an entity class. This is the most common
                approach.
            </p><p>
                A final alternative is to use composite elements, see <a href="#components-incollections" title="8.2.&nbsp;Collections of dependent objects">Section&nbsp;8.2, &#8220;Collections of dependent objects&#8221;</a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-idbag"></a>6.3.5.&nbsp;Using an <tt class="literal">&lt;idbag&gt;</tt></h3></div></div><div></div></div><p>
                If you've fully embraced our view that composite keys are a bad thing and that
                entities should have synthetic identifiers (surrogate keys), then you might
                find it a bit odd that the many to many associations and collections of values
                that we've shown so far all map to tables with composite keys! Now, this point
                is quite arguable; a pure association table doesn't seem to benefit much from
                a surrogate key (though a collection of composite values <span class="emphasis"><em>might</em></span>).
                Nevertheless, NHibernate provides a feature that allows you to map many-to-many
                associations and collections of values to a table with a surrogate key.
            </p><p>
                The <tt class="literal">&lt;idbag&gt;</tt> element lets you map a <tt class="literal">List</tt>
                (or <tt class="literal">Collection</tt>) with bag semantics.
            </p><pre class="programlisting">&lt;idbag name="Lovers" table="LOVERS"&gt;
    &lt;collection-id column="ID" type="Int64"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/collection-id&gt;
    &lt;key column="PERSON1"/&gt;
    &lt;many-to-many column="PERSON2" class="Person" fetch="join"/&gt;
&lt;/idbag&gt;</pre><p>
                An <tt class="literal">&lt;idbag&gt;</tt> has a synthetic id generator,
                just like an entity class. A different surrogate key is assigned to each collection
                row. NHibernate does not, however, provide any mechanism to discover the surrogate key value
                of a particular row.
            </p><p>
                The update performance of an <tt class="literal">&lt;idbag&gt;</tt> supersedes a regular
                <tt class="literal">&lt;bag&gt;</tt>. NHibernate can locate individual rows efficiently and update
                or delete them individually, similar to a <tt class="literal">&lt;list&gt;</tt>,
                <tt class="literal">&lt;map&gt;</tt> or <tt class="literal">&lt;set&gt;</tt>.
            </p><p>
                As of version 2.0, the <tt class="literal">native</tt> identifier generation
                strategy is supported for <tt class="literal">&lt;idbag&gt;</tt> collection identifiers.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="collections-heterogeneous"></a>6.3.6.&nbsp;Heterogeneous Associations</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;many-to-any&gt;</tt> and <tt class="literal">&lt;index-many-to-any&gt;</tt>
                elements provide for true heterogeneous associations. These mapping elements work in the
                same way than the <a href="#mapping-types-anymapping" title="5.1.24.&nbsp;any"><tt class="literal">&lt;any&gt;</tt>
                element</a> - and should also be used rarely, if ever.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-lazy"></a>6.4.&nbsp;Lazy Initialization</h2></div></div><div></div></div><p>
            Collections (other than arrays) may be lazily initialized, meaning they load
            their state from the database only when the application needs to access it.
            Initialization happens transparently to the user so the application would not
            normally need to worry about this (in fact, transparent lazy initialization is
            the main reason why NHibernate needs its own collection implementations).
            However, if the application tries something like this:
        </p><pre class="programlisting">IDictionary&lt;string, int&gt; permissions;
using (s = sessions.OpenSession())
using (ITransaction tx = sessions.BeginTransaction())
{
    var u = s.Load&lt;User&gt;(userId);
    permissions = u.Permissions;
    tx.Commit();
}

int accessLevel = permissions["accounts"];  // Error!</pre><p>
            It could be in for a nasty surprise. Since the permissions collection was not
            initialized when the <tt class="literal">ISession</tt> was committed,
            the collection will never be able to load its state. The fix is to move the
            line that reads from the collection to just before the commit. (There are
            other more advanced ways to solve this problem, however.)
        </p><p>
            Alternatively, use a non-lazy collection. However, it is intended that
            lazy initialization be used for almost all collections, especially for
            collections of entities (for reasons of efficiency).
        </p><p>
            Exceptions that occur while lazily initializing a collection are wrapped in a
            <tt class="literal">LazyInitializationException</tt>.
        </p><p>
            Disable lazy initialization of collection by using the optional <tt class="literal">lazy</tt>
            attribute:
        </p><pre class="programlisting">&lt;set name="Names" table="NAMES" lazy="false"&gt;
    &lt;key column="group_id"/&gt;
    &lt;element column="NAME" type="String"/&gt;
&lt;/set&gt;</pre><p>
            In some application architectures, particularly where the code that accesses data
            using NHibernate, and the code that uses it are in different application layers, it
            can be a problem to ensure that the <tt class="literal">ISession</tt> is open when a
            collection is initialized. There are two basic ways to deal with this issue:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    In a web-based application, an event handler can be used to close the
                    <tt class="literal">ISession</tt> only at the very end of a user request, once
                    the rendering of the view is complete. Of course, this places heavy
                    demands upon the correctness of the exception handling of your application
                    infrastructure. It is vitally important that the <tt class="literal">ISession</tt>
                    is closed and the transaction ended before returning to the user, even
                    when an exception occurs during rendering of the view. The event handler
                    has to be able to access the <tt class="literal">ISession</tt> for this approach.
                    We recommend that the current <tt class="literal">ISession</tt> is stored in the
                    <tt class="literal">HttpContext.Items</tt> collection (see chapter 1,
                    <a href="#quickstart-playingwithcats" title="1.4.&nbsp;Playing with cats">Section&nbsp;1.4, &#8220;Playing with cats&#8221;</a>, for an example implementation).
                </p></li><li><p>
                    In an application with a separate business tier, the business logic must
                    "prepare" all collections that will be needed by the web tier before
                    returning. This means that the business tier should load all the data and
                    return all the data already initialized to the presentation/web tier that
                    is required for a particular use case. Usually, the application calls
                    <tt class="literal">NHibernateUtil.Initialize()</tt> for each collection that will
                    be needed in the web tier (this call must occur before the session is closed)
                    or retrieves the collection eagerly using a NHibernate query with a
                    <tt class="literal">FETCH</tt> clause.
                </p></li><li><p>
                    You may also attach a previously loaded object to a new <tt class="literal">ISession</tt>
                    with <tt class="literal">Update()</tt> or <tt class="literal">Lock()</tt> before
                    accessing uninitialized collections (or other proxies). NHibernate can not
                    do this automatically, as it would introduce ad hoc transaction semantics!
                </p></li></ul></div><p>
            You can use the <tt class="literal">CreateFilter()</tt> method of the NHibernate ISession API to
            get the size of a collection without initializing it:
        </p><pre class="programlisting">var count = s
    .CreateFilter(collection, "select count(*)")
    .UniqueResult&lt;long&gt;();</pre><p>
            <tt class="literal">CreateFilter()</tt> is also used to
            efficiently retrieve subsets of a collection without needing to initialize the whole
            collection.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-example"></a>6.5.&nbsp;Collection examples</h2></div></div><div></div></div><p>
            This section covers collection examples.
        </p><p>
            The following class has a collection of <tt class="literal">Child</tt> instances: 
        </p><pre class="programlisting">using System;
using System.Collections.Generic;

namespace Eg

    public class Parent
    {
        public virtual long Id { get; set; }

        public virtual ISet&lt;Child&gt; Children { get; set; }

        ...
    }
}</pre><p>
            If each child has at most one parent, the most natural mapping is a one-to-many
            association:
        </p><pre class="programlisting">&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg"&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="Children"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="Name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            This maps to the following table definitions:
        </p><pre class="programlisting">create table parent (Id bigint not null primary key)
create table child (Id bigint not null primary key, Name varchar(255), parent_id bigint)
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            The <tt class="literal">Child</tt> class has no property referencing its parent.
        </p><p>
            If the parent is <span class="emphasis"><em>required</em></span>, use a bidirectional one-to-many
            association:
        </p><pre class="programlisting">&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg"&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="Children" inverse="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="Name"/&gt;
        &lt;many-to-one name="Parent" class="Parent" column="parent_id" not-null="true"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Notice the <tt class="literal">NOT NULL</tt> constraint:
        </p><pre class="programlisting">create table parent ( Id bigint not null primary key )
create table child ( Id bigint not null
                     primary key,
                     Name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            Here, the <tt class="literal">Child</tt> class has a <tt class="literal">Parent</tt> property.
        </p><p>
            Alternatively, if this association must be unidirectional you can declare the
            <tt class="literal">NOT NULL</tt> constraint on the <tt class="literal">&lt;key&gt;</tt>
            mapping:
        </p><pre class="programlisting">&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg"&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="Children"&gt;
            &lt;key column="parent_id" not-null="true"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="Name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            On the other hand, if a child might have multiple parents, a many-to-many
            association is appropriate:
        </p><pre class="programlisting">&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg"&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="Children" table="childset"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;many-to-many class="Child" column="child_id"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="Name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Table definitions:
        </p><pre class="programlisting">create table parent ( Id bigint not null primary key )
create table child ( Id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child</pre><p>
            For more examples and a complete explanation of a parent/child relationship mapping,
            see <a href="#associations" title="Chapter&nbsp;7.&nbsp;Association Mappings">Chapter&nbsp;7, <i>Association Mappings</i></a> and <a href="#example-parentchild" title="Chapter&nbsp;23.&nbsp;Example: Parent/Child">Chapter&nbsp;23, <i>Example: Parent/Child</i></a>.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="associations"></a>Chapter&nbsp;7.&nbsp;Association Mappings</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="associations-intro"></a>7.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
            Association mappings are often the most difficult thing to implement correctly. In this section
            we examine some canonical cases one by one, starting with unidirectional mappings and then
            bidirectional cases. We will use <tt class="literal">Person</tt> and <tt class="literal">Address</tt> in all
            the examples.
        </p><p>
            Associations will be classified by multiplicity and whether or not they map to an intervening join table.
        </p><p>
            Nullable foreign keys are not considered to be good practice in traditional data modelling, so our
            examples do not use nullable foreign keys. This is not a requirement of NHibernate, and the mappings
            will work if you drop the nullability constraints.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="associations-unidirectional"></a>7.2.&nbsp;Unidirectional associations</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="associations-unidirectional-m21"></a>7.2.1.&nbsp;Many-to-one</h3></div></div><div></div></div><p>
                An <span class="emphasis"><em>unidirectional many-to-one association</em></span> is the most common kind of
                unidirectional association.
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="Address"
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person (
    personId bigint not null primary key, addressId bigint not null
)
create table Address ( addressId bigint not null primary key )</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="associations-unidirectional-121"></a>7.2.2.&nbsp;One-to-one</h3></div></div><div></div></div><p>
                An <span class="emphasis"><em>unidirectional one-to-one association on a foreign key</em></span> is almost
                identical to a many-to-one. The only difference is the column unique constraint.
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="Address"
        column="addressId"
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person (
    personId bigint not null primary key, addressId bigint not null unique
)
create table Address ( addressId bigint not null primary key )</pre><p>
                An <span class="emphasis"><em>unidirectional one-to-one association on a primary key</em></span> usually uses
                a special id generator In this example, however, we have reversed the direction of the
                association:
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;Person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="Person" constrained="true"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="associations-unidirectional-12m"></a>7.2.3.&nbsp;One-to-many</h3></div></div><div></div></div><p>
                An <span class="emphasis"><em>unidirectional one-to-many association on a foreign key</em></span> is an
                unusual case, and is not recommended.
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="Addresses"&gt;
        &lt;key column="personId"
            not-null="true"/&gt;
        &lt;one-to-many class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person ( personId bigint not null primary key )
create table Address (
    addressId bigint not null primary key, personId bigint not null
)</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="associations-unidirectional-join"></a>7.3.&nbsp;Unidirectional associations with join tables</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="associations-unidirectional-join-12m"></a>7.3.1.&nbsp;One-to-Many</h3></div></div><div></div></div><p>
                An <span class="emphasis"><em>unidirectional one-to-many association on a join table</em></span> is the
                preferred option. Specifying <tt class="literal">unique="true"</tt> changes the multiplicity
                from many-to-many to one-to-many.
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="Addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person ( personId bigint not null primary key )
create table PersonAddress (
    personId not null, addressId bigint not null primary key
)
create table Address ( addressId bigint not null primary key )</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="associations-unidirectional-join-m21"></a>7.3.2.&nbsp;Many-to-one</h3></div></div><div></div></div><p>
                An <span class="emphasis"><em>unidirectional many-to-one association on a join table</em></span> is common
                when the association is optional (while avoiding nullable foreign key).
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress"
        optional="true"&gt;
        &lt;key column="personId" unique="true"/&gt;
        &lt;many-to-one name="Address"
            column="addressId"
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person ( personId bigint not null primary key )
create table PersonAddress (
    personId bigint not null primary key, addressId bigint not null
)
create table Address ( addressId bigint not null primary key )</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="associations-unidirectional-join-121"></a>7.3.3.&nbsp;One-to-one</h3></div></div><div></div></div><p>
                An <span class="emphasis"><em>unidirectional one-to-one association on a join table</em></span> is possible,
                but extremely unusual.
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress"
        optional="true"&gt;
        &lt;key column="personId"
            unique="true"/&gt;
        &lt;many-to-one name="Address"
            column="addressId"
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person ( personId bigint not null primary key )
create table PersonAddress (
    personId bigint not null primary key, addressId bigint not null unique
)
create table Address ( addressId bigint not null primary key )</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="associations-unidirectional-join-m2m"></a>7.3.4.&nbsp;Many-to-many</h3></div></div><div></div></div><p>
                Finally, here is an example of an <span class="emphasis"><em>unidirectional many-to-many association</em></span>.
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="Addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person ( personId bigint not null primary key )
create table PersonAddress (
    personId bigint not null, addressId bigint not null,
    primary key (personId, addressId)
)
create table Address ( addressId bigint not null primary key )</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="associations-bidirectional"></a>7.4.&nbsp;Bidirectional associations</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="associations-bidirectional-m21"></a>7.4.1.&nbsp;One-to-many / many-to-one</h3></div></div><div></div></div><p>
                A <span class="emphasis"><em>bidirectional many-to-one association</em></span> is the most common kind of
                association. The following example illustrates the standard parent/child relationship.
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="Address"
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="People" inverse="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;one-to-many class="Person"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person (
    personId bigint not null primary key, addressId bigint not null
)
create table Address ( addressId bigint not null primary key )</pre><p>
                If you use an <tt class="literal">IList</tt>, or other indexed collection, set the
                <tt class="literal">key</tt> column of the foreign key to <tt class="literal">not null</tt>. NHibernate
                will manage the association from the collections side to maintain the index of each element,
                making the other side virtually inverse by setting <tt class="literal">update="false"</tt> and
                <tt class="literal">insert="false"</tt>:
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
   &lt;many-to-one name="Address"
      column="addressId"
      not-null="true"
      insert="false"
      update="false"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
   &lt;list name="People"&gt;
      &lt;key column="addressId" not-null="true"/&gt;
      &lt;list-index column="peopleIdx"/&gt;
      &lt;one-to-many class="Person"/&gt;
   &lt;/list&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person (
    personId bigint not null primary key,
    addressId bigint not null,
    peopleIdx int not null
)
create table Address ( addressId bigint not null primary key )</pre><p>
                When the underlying foreign key column is <tt class="literal">NOT NULL</tt>, it is important
                that you define <tt class="literal">not-null="true"</tt> on the <tt class="literal">&lt;key&gt;</tt>
                element of the collection mapping. Do not only declare <tt class="literal">not-null="true"</tt>
                on a possible nested <tt class="literal">&lt;column&gt;</tt> element, but always declare it on
                the <tt class="literal">&lt;key&gt;</tt> element too.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="associations-bidirectional-121"></a>7.4.2.&nbsp;One-to-one</h3></div></div><div></div></div><p>
                A <span class="emphasis"><em>bidirectional one-to-one association on a foreign key</em></span> is common.
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="Address"
        column="addressId"
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
   &lt;one-to-one name="Person"
        property-ref="Address"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person (
    personId bigint not null primary key, addressId bigint not null unique
)
create table Address ( addressId bigint not null primary key )</pre><p>
                A <span class="emphasis"><em>bidirectional one-to-one association on a primary key</em></span> uses the
                special <tt class="literal">foreign</tt> id generator.
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;one-to-one name="Address"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;Person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="Person"
        constrained="true"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="associations-bidirectional-join"></a>7.5.&nbsp;Bidirectional associations with join tables</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="associations-bidirectional-join-12m"></a>7.5.1.&nbsp;One-to-many / many-to-one</h3></div></div><div></div></div><p>
                The following is an example of a <span class="emphasis"><em>bidirectional one-to-many association on a
                join table</em></span>. The <tt class="literal">inverse="true"</tt> can go on either end of
                the association, on the collection, or on the join.
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="Addresses"
        table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress"
        inverse="true"
        optional="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-one name="Person"
            column="personId"
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person ( personId bigint not null primary key )
create table PersonAddress (
    personId bigint not null, addressId bigint not null primary key
)
create table Address ( addressId bigint not null primary key )</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="associations-bidirectional-join-121"></a>7.5.2.&nbsp;One-to-one</h3></div></div><div></div></div><p>
                A <span class="emphasis"><em>bidirectional one-to-one association on a join table</em></span> is possible,
                but extremely unusual.
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress"
        optional="true"&gt;
        &lt;key column="personId"
            unique="true"/&gt;
        &lt;many-to-one name="Address"
            column="addressId"
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress"
        optional="true"
        inverse="true"&gt;
        &lt;key column="addressId"
            unique="true"/&gt;
        &lt;many-to-one name="Person"
            column="personId"
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person ( personId bigint not null primary key )
create table PersonAddress (
    personId bigint not null primary key, addressId bigint not null unique
)
create table Address ( addressId bigint not null primary key )</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="associations-bidirectional-join-m2m"></a>7.5.3.&nbsp;Many-to-many</h3></div></div><div></div></div><p>
                Here is an example of a <span class="emphasis"><em>bidirectional many-to-many association</em></span>.
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="Addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="People" inverse="true" table="PersonAddress"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-many column="personId"
            class="Person"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><pre class="programlisting">create table Person ( personId bigint not null primary key )
create table PersonAddress (
    personId bigint not null, addressId bigint not null,
    primary key (personId, addressId)
)
create table Address ( addressId bigint not null primary key )</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="associations-complex"></a>7.6.&nbsp;More complex association mappings</h2></div></div><div></div></div><p>
            More complex association joins are <span class="emphasis"><em>extremely</em></span> rare. NHibernate handles
            more complex situations by using SQL fragments embedded in the mapping document. For example,
            if a table with historical account information data defines <tt class="literal">AccountNumber</tt>,
            <tt class="literal">EffectiveEndDate</tt> and <tt class="literal">EffectiveStartDatecolumns</tt>, it would
            be mapped as follows:
        </p><pre class="programlisting">&lt;properties name="CurrentAccountKey"&gt;
    &lt;property name="AccountNumber" type="string" not-null="true"/&gt;
    &lt;property name="CurrentAccount" type="boolean"&gt;
        &lt;formula&gt;case when EffectiveEndDate is null then 1 else 0 end&lt;/formula&gt;
    &lt;/property&gt;
&lt;/properties&gt;
&lt;property name="EffectiveEndDate" type="date"/&gt;
&lt;property name="EffectiveStateDate" type="date" not-null="true"/&gt;</pre><p>
            You can then map an association to the <span class="emphasis"><em>current</em></span> instance, the one with null
            <tt class="literal">EffectiveEndDate</tt>, by using:
        </p><pre class="programlisting">&lt;many-to-one name="CurrentAccountInfo"
        property-ref="CurrentAccountKey"
        class="AccountInfo"&gt;
    &lt;column name="AccountNumber"/&gt;
    &lt;formula&gt;'1'&lt;/formula&gt;
&lt;/many-to-one&gt;</pre><p>
            In a more complex example, imagine that the association between <tt class="literal">Employee</tt> and
            <tt class="literal">Organization</tt> is maintained in an <tt class="literal">Employment</tt> table full of
            historical employment data. An association to the employee's <span class="emphasis"><em>most recent</em></span>
            employer, the one with the most recent <tt class="literal">startDate</tt>, could be mapped in the
            following way:
        </p><pre class="programlisting">&lt;join&gt;
    &lt;key column="employeeId"/&gt;
    &lt;subselect&gt;
        select employeeId, orgId
        from Employments
        group by orgId
        having startDate = max(startDate)
    &lt;/subselect&gt;
    &lt;many-to-one name="MostRecentEmployer"
            class="Organization"
            column="orgId"/&gt;
&lt;/join&gt;</pre><p>
            This functionality allows a degree of creativity and flexibility, but it is more practical to
            handle these kinds of cases by using queries.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="components"></a>Chapter&nbsp;8.&nbsp;Component Mapping</h2></div></div><div></div></div><p>
        The notion of a <span class="emphasis"><em>component</em></span> is re-used in several different contexts,
        for different purposes, throughout NHibernate.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dependentobjects"></a>8.1.&nbsp;Dependent objects</h2></div></div><div></div></div><p>
            A component is a contained object that is persisted as a value type and not an entity
            reference. The term "component" refers to the object-oriented notion of composition and
            not to architecture-level components. For example, you can model a person like this:
        </p><pre class="programlisting">public class Person
{
    public virtual string Key { get; set; }

    public virtual DateTime Birthday { get; set; }

    public virtual Name Name { get; set; }

    ...
}</pre><pre class="programlisting">public class Name
{
    public string First { get; set; }

    public string Last { get; set; }

    public char Initial { get; set; }
}</pre><p>
            Now <tt class="literal">Name</tt> may be persisted as a component of
            <tt class="literal">Person</tt>. <tt class="literal">Name</tt> defines getter
            and setter methods for its persistent properties, but it does not need to declare
            any interfaces or identifier properties.
        </p><p>
            Our NHibernate mapping would look like:
        </p><pre class="programlisting">&lt;class name="Eg.Person, Eg" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="Birthday" type="date"/&gt;
    &lt;component name="Name" class="Eg.Name, Eg"&gt; &lt;!-- class attribute optional --&gt;
        &lt;property name="Initial"/&gt;
        &lt;property name="First"/&gt;
        &lt;property name="Last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre><p>
            The person table would have the columns <tt class="literal">pid</tt>,
            <tt class="literal">Birthday</tt>,
            <tt class="literal">Initial</tt>,
            <tt class="literal">First</tt> and
            <tt class="literal">Last</tt>.
        </p><p>
            Like value types, components do not support shared references. In other words, two
            persons could have the same name, but the two person objects would contain two
            independent name objects that were only "the same" by value. The null
            value semantics of a component are <span class="emphasis"><em>ad hoc</em></span>. When reloading the
            containing object, NHibernate will assume that if all component columns are
            null, then the entire component is null. This is suitable for most purposes.
        </p><p>
            The properties of a component can be of any NHibernate type (collections, many-to-one 
            associations, other components, etc). Nested components should <span class="emphasis"><em>not</em></span> 
            be considered an exotic usage. NHibernate is intended to support a fine-grained 
            object model.
        </p><p>
            The <tt class="literal">&lt;component&gt;</tt> element allows a <tt class="literal">&lt;parent&gt;</tt>
            sub-element that maps a property of the component class as a reference back to the
            containing entity.
        </p><pre class="programlisting">&lt;class name="Eg.Person, Eg" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="Birthday" type="date"/&gt;
    &lt;component name="Name" class="Eg.Name, Eg"&gt;
        &lt;parent name="NamedPerson"/&gt; &lt;!-- reference back to the Person --&gt;
        &lt;property name="Initial"/&gt;
        &lt;property name="First"/&gt;
        &lt;property name="Last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-incollections"></a>8.2.&nbsp;Collections of dependent objects</h2></div></div><div></div></div><p>
            Collections of components are supported (eg. an array of type
            <tt class="literal">Name</tt>). Declare your component collection by
            replacing the <tt class="literal">&lt;element&gt;</tt> tag with a
            <tt class="literal">&lt;composite-element&gt;</tt> tag.
        </p><pre class="programlisting">&lt;set name="SomeNames" table="some_names"&gt;
    &lt;key column="id"/&gt;
    &lt;composite-element class="Eg.Name, Eg"&gt; &lt;!-- class attribute required --&gt;
        &lt;property name="Initial"/&gt;
        &lt;property name="First"/&gt;
        &lt;property name="Last"/&gt;
    &lt;/composite-element&gt;
&lt;/set&gt;</pre><p>
            Note: if you define an <tt class="literal">ISet</tt> of composite elements, it is 
            very important to implement <tt class="literal">Equals()</tt> and 
            <tt class="literal">GetHashCode()</tt> correctly.
        </p><p>
            Composite elements can contain components but not collections. If your composite
            element contains components, use the
            <tt class="literal">&lt;nested-composite-element&gt;</tt> tag. This case is a collection
            of components which themselves have components. You may want to consider if a
            one-to-many association is more appropriate. Remodel the composite element as an
            entity, but be aware that even though the .Net model is the same, the relational
            model and persistence semantics are still slightly different.
        </p><p>
            A special case of a composite element is a composite element with a nested
            <tt class="literal">&lt;many-to-one&gt;</tt> element. This mapping allows you to map extra
            columns of a many-to-many association table to the composite element class. The
            following is a many-to-many association from
            <tt class="literal">Order</tt> to <tt class="literal">Item</tt> where
            <tt class="literal">PurchaseDate</tt>, <tt class="literal">Price</tt> and
            <tt class="literal">Quantity</tt> are properties of the association:
        </p><pre class="programlisting">&lt;class name="Order" ... &gt;
    ...
    &lt;set name="PurchasedItems" table="purchase_items"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="Purchase"&gt;
            &lt;property name="PurchaseDate"/&gt;
            &lt;property name="Price"/&gt;
            &lt;property name="Quantity"/&gt;
            &lt;many-to-one name="Item" class="Item"/&gt; &lt;!-- class attribute is optional --&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            There cannot be a reference to the purchase on the other side for bidirectional association
            navigation. Components are value types and do not allow shared references. A single
            <tt class="literal">Purchase</tt> can be in the set of an <tt class="literal">Order</tt>, but it cannot
            be referenced by the <tt class="literal">Item</tt> at the same time.
        </p><p>Even ternary (or quaternary, etc) associations are possible:</p><pre class="programlisting">&lt;class name="Order" ... &gt;
    ...
    &lt;set name="PurchasedItems" table="purchase_items"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="OrderLine"&gt;
            &lt;many-to-one name="PurchaseDetails class="Purchase"/&gt;
            &lt;many-to-one name="Item" class="Item"/&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Composite elements can appear in queries using the same syntax as
            associations to other entities.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-asmapindex"></a>8.3.&nbsp;Components as IDictionary indices</h2></div></div><div></div></div><p>
            The <tt class="literal">&lt;composite-map-key&gt;</tt> element lets you map a
            component class as the key of an <tt class="literal">IDictionary</tt>. Make sure
            you override <tt class="literal">GetHashCode()</tt> and <tt class="literal">Equals()</tt>
            correctly on the component class. See <a href="#collections-indexed" title="6.2.3.&nbsp;Indexed collections">Section&nbsp;6.2.3, &#8220;Indexed collections&#8221;</a>
            for more information on the <tt class="literal">&lt;composite-map-key&gt;</tt>
            element.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-compositeid"></a>8.4.&nbsp;Components as composite identifiers</h2></div></div><div></div></div><p>
            You can use a component as an identifier of an entity class. Your component
            class must satisfy certain requirements:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    It must be marked with the <tt class="literal">Serializable</tt> attribute.
                </p></li><li><p>
                    It must re-implement <tt class="literal">Equals()</tt> and
                    <tt class="literal">GetHashCode()</tt>, consistently with the database's 
                    notion of composite key equality.
                </p></li><li><p>
                    It should re-implement <tt class="literal">ToString()</tt> if you consider
                    using the second level cache. See <a href="#NHibernate.Caches-howto" title="27.1.&nbsp;How to use a cache?">Section&nbsp;27.1, &#8220;How to use a cache?&#8221;</a>.
                </p></li></ul></div><p>
            You cannot use an <tt class="literal">IIdentifierGenerator</tt> to generate composite keys.
            Instead the application must assign its own identifiers.
        </p><p>
            Since a composite identifier must be assigned to the object before saving it,
            you cannot use <tt class="literal">unsaved-value</tt> of the identifier to distinguish
            between newly instantiated instances and instances saved in a previous session.
            See <a href="#mapping-declaration-id-assigned" title="5.1.5.7.&nbsp;Assigned Identifiers">Section&nbsp;5.1.5.7, &#8220;Assigned Identifiers&#8221;</a> for more information.
        </p><p>
            Use the <tt class="literal">&lt;composite-id&gt;</tt> tag, with nested
            <tt class="literal">&lt;key-property&gt;</tt> or <tt class="literal">&lt;key-many-to-one&gt;</tt>
            elements, in place of the usual <tt class="literal">&lt;id&gt;</tt> declaration. For example,
            the following <tt class="literal">OrderLine</tt> class has a primary key that depends upon
            the (composite) primary key of <tt class="literal">Order</tt>.
        </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    &lt;composite-id name="Id" class="OrderLineId"&gt;
        &lt;key-property name="lineId"/&gt;
        &lt;key-property name="orderId"/&gt;
        &lt;key-property name="customerId"/&gt;
    &lt;/composite-id&gt;

    &lt;property name="Name"/&gt;

    &lt;many-to-one name="Order" class="Order"
            insert="false" update="false"&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-one&gt;
    ...
&lt;/class&gt;</pre><p>
            Any foreign keys referencing the <tt class="literal">OrderLine</tt> table are now composite.
            Declare this in your mappings for other classes. An association to
            <tt class="literal">OrderLine</tt> is mapped like this:
        </p><pre class="programlisting">&lt;many-to-one name="OrderLine" class="OrderLine"&gt;
&lt;!-- the "class" attribute is optional, as usual --&gt;
    &lt;column name="lineId"/&gt;
    &lt;column name="orderId"/&gt;
    &lt;column name="customerId"/&gt;
&lt;/many-to-one&gt;</pre><p>
            The <tt class="literal">&lt;column&gt;</tt> element is an alternative to the <tt class="literal">column</tt>
            attribute everywhere. Using the <tt class="literal">&lt;column&gt;</tt> element is required for
            composite keys, but also gives more declaration options, which are mostly useful when using
            <tt class="literal">hbm2ddl</tt>. See <a href="#mapping-column" title="5.1.21.&nbsp;column and formula elements">Section&nbsp;5.1.21, &#8220;column and formula elements&#8221;</a>.
        </p><p>
            A many-to-many association to <tt class="literal">OrderLine</tt> also uses the composite foreign key:
        </p><pre class="programlisting">&lt;set name="UndeliveredOrderLines"&gt;
    &lt;key column name="warehouseId"/&gt;
    &lt;many-to-many class="OrderLine"&gt;
        &lt;column name="lineId"/&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-many&gt;
&lt;/set&gt;</pre><p>
            The collection of <tt class="literal">OrderLine</tt> in <tt class="literal">Order</tt> would use:
        </p><pre class="programlisting">&lt;set name="OrderLines" inverse="true"&gt;
    &lt;key&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/key&gt;
    &lt;one-to-many class="OrderLine"/&gt;
&lt;/set&gt;</pre><p>
            The <tt class="literal">&lt;one-to-many&gt;</tt> element declares no columns.
        </p><p>
            If <tt class="literal">OrderLine</tt> itself owns a collection, it also has a composite foreign key.
        </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    ...
    &lt;list name="DeliveryAttempts"&gt;
        &lt;key&gt;   &lt;!-- a collection inherits the composite key type --&gt;
            &lt;column name="lineId"/&gt;
            &lt;column name="orderId"/&gt;
            &lt;column name="customerId"/&gt;
        &lt;/key&gt;
        &lt;list-index column="attemptId" base="1"/&gt;
        &lt;composite-element class="DeliveryAttempt"&gt;
            ...
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dynamic"></a>8.5.&nbsp;Dynamic components</h2></div></div><div></div></div><p>
            You can also map a property of type <tt class="literal">IDictionary</tt> or
            <tt class="literal">IDictionary&lt;string, object&gt;</tt>, or declared as a C#
            <tt class="literal">dynamic</tt>:
        </p><pre class="programlisting">&lt;dynamic-component name="UserAttributes"&gt;
    &lt;property name="Foo" column="FOO"/&gt;
    &lt;property name="Bar" column="BAR"/&gt;
    &lt;many-to-one name="Baz" class="Baz" column="BAZ_ID"/&gt;
&lt;/dynamic-component&gt;</pre><p>
            The semantics of a <tt class="literal">&lt;dynamic-component&gt;</tt> mapping are identical
            to <tt class="literal">&lt;component&gt;</tt>. The advantage of this kind of mapping is
            the ability to determine the actual properties of the component at deployment time, just
            by editing the mapping document. Runtime manipulation of the mapping document is also
            possible, using a DOM parser. You can also access, and change, NHibernate's
            configuration-time metamodel via the <tt class="literal">Configuration</tt> object.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="inheritance"></a>Chapter&nbsp;9.&nbsp;Inheritance Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-strategies"></a>9.1.&nbsp;The Three Strategies</h2></div></div><div></div></div><p>
            NHibernate supports the three basic inheritance mapping strategies:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    table per class hierarchy
                </p></li><li><p>
                    table per subclass
                </p></li><li><p>
                    table per concrete class
                </p></li></ul></div><p>
            In addition, NHibernate supports a fourth, slightly different kind of polymorphism:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    implicit polymorphism
                </p></li></ul></div><p>
            It is possible to use different mapping strategies for different branches of the same
            inheritance hierarchy. You can then make use of implicit polymorphism to achieve polymorphism
            across the whole hierarchy. However,  NHibernate does not support mixing
            <tt class="literal">&lt;subclass&gt;</tt>, and <tt class="literal">&lt;joined-subclass&gt;</tt> and
            <tt class="literal">&lt;union-subclass&gt;</tt> mappings under the same root
            <tt class="literal">&lt;class&gt;</tt> element. It is possible to mix together the table per
            hierarchy and table per subclass strategies, under the the same
            <tt class="literal">&lt;class&gt;</tt> element, by combining the <tt class="literal">&lt;subclass&gt;</tt>
            and <tt class="literal">&lt;join&gt;</tt> elements (see
            <a href="#inheritance-mixing-tableperclass-tablepersubclass" title="9.1.4.&nbsp;Mixing table per class hierarchy with table per subclass">Section&nbsp;9.1.4, &#8220;Mixing table per class hierarchy with table per subclass&#8221;</a>).
        </p><p>
            It is possible to define <tt class="literal">subclass</tt>, <tt class="literal">union-subclass</tt>,
            and <tt class="literal">joined-subclass</tt> mappings in separate mapping documents directly beneath
            <tt class="literal">hibernate-mapping</tt>. This allows you to extend a class hierarchy by adding
            a new mapping file. You must specify an <tt class="literal">extends</tt> attribute in the subclass
            mapping, naming a previously mapped superclass.
        </p><pre class="programlisting">
 &lt;hibernate-mapping&gt;
     &lt;subclass name="DomesticCat" extends="Cat" discriminator-value="D"&gt;
          &lt;property name="name" type="string"/&gt;
     &lt;/subclass&gt;
 &lt;/hibernate-mapping&gt;</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperclass"></a>9.1.1.&nbsp;Table per class hierarchy</h3></div></div><div></div></div><p>
                Suppose we have an interface <tt class="literal">IPayment</tt>, with implementors
                <tt class="literal">CreditCardPayment</tt>, <tt class="literal">CashPayment</tt>,
                <tt class="literal">ChequePayment</tt>. The table-per-hierarchy mapping would display in the
                following way:
            </p><pre class="programlisting">&lt;class name="IPayment" table="PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="String"/&gt;
    &lt;property name="Amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;property name="CreditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                Exactly one table is required. There is a limitation of this mapping strategy: columns
                declared by the subclasses, such as <tt class="literal">CCTYPE</tt>, cannot have
                <tt class="literal">NOT NULL</tt> constraints.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tablepersubclass"></a>9.1.2.&nbsp;Table per subclass</h3></div></div><div></div></div><p>
                A table-per-subclass mapping would look like:
            </p><pre class="programlisting">&lt;class name="IPayment" table="PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="Amount" column="AMOUNT"/&gt;
    ...
    &lt;joined-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="CreditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
                Four tables are required. The three subclass tables have primary key associations to the
                superclass table so the relational model is actually a one-to-one association.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tablepersubclass-discriminator"></a>9.1.3.&nbsp;Table per subclass, using a discriminator</h3></div></div><div></div></div><p>
                NHibernate's implementation of table per subclass does not require a discriminator column.
                Other object/relational mappers use a different implementation of table per subclass that
                requires a type discriminator column in the superclass table. The approach taken by
                NHibernate is much more difficult to implement, but arguably more correct from a relational
                point of view. If you want to use a discriminator column with the table per subclass
                strategy, you can combine the use of <tt class="literal">&lt;subclass&gt;</tt> and
                <tt class="literal">&lt;join&gt;</tt>, as follows:
            </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="Amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            &lt;property name="CreditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        &lt;join table="CASH_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        &lt;join table="CHEQUE_PAYMENT" fetch="select"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                The optional <tt class="literal">fetch="select"</tt> declaration tells NHibernate 
                not to fetch the <tt class="literal">ChequePayment</tt> subclass data using an
                outer join when querying the superclass.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-mixing-tableperclass-tablepersubclass"></a>9.1.4.&nbsp;Mixing table per class hierarchy with table per subclass</h3></div></div><div></div></div><p>
                You can even mix the table per hierarchy and table per subclass strategies
                using the following approach:
            </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="Amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;property name="CreditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                For any of these mapping strategies, a polymorphic
                association to <tt class="literal">IPayment</tt> is mapped using
                <tt class="literal">&lt;many-to-one&gt;</tt>.
            </p><pre class="programlisting">&lt;many-to-one name="Payment" column="PAYMENT" class="IPayment"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperconcrete"></a>9.1.5.&nbsp;Table per concrete class</h3></div></div><div></div></div><p>
                There are two ways we can map the table per concrete class strategy. First, you can use
                <tt class="literal">&lt;union-subclass&gt;</tt>.
            </p><pre class="programlisting">&lt;class name="Payment"&gt;
    &lt;id name="Id" type="Int64" column="PAYMENT_ID"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/id&gt;
    &lt;property name="Amount" column="AMOUNT"/&gt;
    ...
    &lt;union-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;property name="CreditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
&lt;/class&gt;</pre><p>
                Three tables are involved for the subclasses. Each table defines columns for
                all properties of the class, including inherited properties.
            </p><p>
                The limitation of this approach is that if a property is mapped on the superclass, the
                column name must be the same on all subclass tables. The identity generator strategy is
                not allowed in union subclass inheritance. The primary key seed has to be shared across
                all unioned subclasses of a hierarchy.
            </p><p>
                If your superclass is abstract, map it with <tt class="literal">abstract="true"</tt>.
                If it is not abstract, an additional table (it defaults to
                <tt class="literal">PAYMENT</tt> in the example above), is needed to hold instances
                of the superclass.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperconcreate-polymorphism"></a>9.1.6.&nbsp;Table per concrete class, using implicit polymorphism</h3></div></div><div></div></div><p>
                An alternative approach is to make use of implicit polymorphism:
            </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="Amount" column="CREDIT_AMOUNT"/&gt;
    &lt;property name="CreditCardType" column="CCTYPE"/&gt;
    ...
&lt;/class&gt;

&lt;class name="CashPayment" table="CASH_PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="CASH_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="Amount" column="CASH_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="CHEQUE_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="Amount" column="CHEQUE_AMOUNT"/&gt;
    ...
&lt;/class&gt;</pre><p>
                Notice that the <tt class="literal">IPayment</tt> interface is not mentioned
                explicitly. Also notice that properties of <tt class="literal">IPayment</tt> are
                mapped in each of the subclasses. If you want to avoid duplication, consider
                using XML entities (by example
                <tt class="literal">[ &lt;!ENTITY allproperties SYSTEM "allproperties.xml"&gt; ]</tt>
                in the <tt class="literal">DOCTYPE</tt> declaration and
                <tt class="literal">&amp;allproperties;</tt> in the mapping).
            </p><p>
                The disadvantage of this approach is that NHibernate does not generate SQL
                <tt class="literal">UNION</tt>s when performing polymorphic queries.
            </p><p>
                For this mapping strategy, a polymorphic association to <tt class="literal">IPayment</tt> 
                is usually mapped using <tt class="literal">&lt;any&gt;</tt>.
            </p><pre class="programlisting">&lt;any name="Payment" meta-type="string" id-type="Int64"&gt;
    &lt;meta-value value="CREDIT" class="CreditCardPayment"/&gt;
    &lt;meta-value value="CASH" class="CashPayment"/&gt;
    &lt;meta-value value="CHEQUE" class="ChequePayment"/&gt;
    &lt;column name="PAYMENT_CLASS"/&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritace-mixingpolymorphism"></a>9.1.7.&nbsp;Mixing implicit polymorphism with other inheritance mappings</h3></div></div><div></div></div><p>
                Since the subclasses are each mapped in their own
                <tt class="literal">&lt;class&gt;</tt> element and since
                <tt class="literal">IPayment</tt> is just an interface, each of
                the subclasses could easily be part of another inheritance hierarchy. You can
                still use polymorphic queries against the <tt class="literal">IPayment</tt> interface.
            </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="CREDIT_CARD" type="String"/&gt;
    &lt;property name="Amount" column="CREDIT_AMOUNT"/&gt;
    ...
    &lt;subclass name="MasterCardPayment" discriminator-value="MDC"/&gt;
    &lt;subclass name="VisaPayment" discriminator-value="VISA"/&gt;
&lt;/class&gt;

&lt;class name="NonelectronicTransaction" table="NONELECTRONIC_TXN"&gt;
    &lt;id name="Id" type="Int64" column="TXN_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    ...
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="Amount" column="CASH_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="Amount" column="CHEQUE_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
                Once again, <tt class="literal">IPayment</tt> is not mentioned explicitly. If we
                execute a query against the <tt class="literal">IPayment</tt> interface - for
                example, <tt class="literal">from IPayment</tt> - NHibernate
                automatically returns instances of <tt class="literal">CreditCardPayment</tt>
                (and its subclasses, since they also implement <tt class="literal">IPayment</tt>),
                <tt class="literal">CashPayment</tt> and <tt class="literal">ChequePayment</tt> but
                not instances of <tt class="literal">NonelectronicTransaction</tt> (provided it does
                not implement <tt class="literal">IPayment</tt>).
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-limitations"></a>9.2.&nbsp;Limitations</h2></div></div><div></div></div><p>
            There are limitations to the "implicit polymorphism" approach to the table per concrete-class
            mapping strategy. There are somewhat less restrictive limitations to
            <tt class="literal">&lt;union-subclass&gt;</tt> mappings.
        </p><p>
            The following table shows the limitations of table per concrete-class
            mappings, and of implicit polymorphism, in NHibernate.
        </p><div class="table"><a name="d0e11067"></a><p class="title"><b>Table&nbsp;9.1.&nbsp;Features of inheritance mappings</b></p><table summary="Features of inheritance mappings" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Inheritance strategy</th><th align="left">Polymorphic many-to-one</th><th align="left">Polymorphic one-to-one</th><th align="left">Polymorphic one-to-many</th><th align="left">Polymorphic many-to-many</th><th align="left">Polymorphic <tt class="literal">Load()/Get()</tt></th><th align="left">Polymorphic queries</th><th align="left">Polymorphic joins</th><th align="left">Outer join fetching</th></tr></thead><tbody><tr><td align="left">table per class-hierarchy</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.Get&lt;IPayment&gt;(id)</tt></td><td align="left"><tt class="literal">from IPayment p</tt></td><td align="left"><tt class="literal">from Order o join o.Payment p</tt></td><td align="left"><span class="emphasis"><em>supported</em></span></td></tr><tr><td align="left">table per subclass</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.Get&lt;IPayment&gt;(id)</tt></td><td align="left"><tt class="literal">from IPayment p</tt></td><td align="left"><tt class="literal">from Order o join o.Payment p</tt></td><td align="left"><span class="emphasis"><em>supported</em></span></td></tr><tr><td align="left">table per concrete-class (union-subclass)</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt> (for <tt class="literal">inverse="true"</tt> only)</td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.Get&lt;IPayment&gt;(id)</tt></td><td align="left"><tt class="literal">from IPayment p</tt></td><td align="left"><tt class="literal">from Order o join o.Payment p</tt></td><td align="left"><span class="emphasis"><em>supported</em></span></td></tr><tr><td align="left">table per concrete class (implicit polymorphism)</td><td align="left"><tt class="literal">&lt;any&gt;</tt></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><tt class="literal">&lt;many-to-any&gt;</tt></td><td align="left"><span class="emphasis"><em>use a query</em></span></td><td align="left"><tt class="literal">from IPayment p</tt></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><span class="emphasis"><em>not supported</em></span></td></tr></tbody></table></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="manipulatingdata"></a>Chapter&nbsp;10.&nbsp;Manipulating Persistent Data</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-creating"></a>10.1.&nbsp;Creating a persistent object</h2></div></div><div></div></div><p>
            An object (entity instance) is either <span class="emphasis"><em>transient</em></span> or
            <span class="emphasis"><em>persistent</em></span> with respect to a particular
            <tt class="literal">ISession</tt>. Newly instantiated objects are, of course, transient. 
            The session offers services for saving (ie. persisting) transient instances:
        </p><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.Color = Color.Ginger;
fritz.Sex = 'M';
fritz.Name = "Fritz";
long generatedId = (long) sess.Save(fritz);</pre><pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.Color = Color.Tabby;
pk.Sex = 'F';
pk.Name = "PK";
pk.Kittens = new HashSet&lt;Cat&gt;();
pk.AddKitten(fritz);
sess.Save( pk, 1234L );</pre><p>
            The single-argument <tt class="literal">Save()</tt> generates and assigns a unique
            identifier to <tt class="literal">fritz</tt>. The two-argument form attempts to persist
            <tt class="literal">pk</tt> using the given identifier. We generally discourage the use of 
            the two-argument form since it may be used to create primary keys with business meaning.
        </p><p>
            Associated objects may be made persistent in any order you like unless you 
            have a <tt class="literal">NOT NULL</tt> constraint upon a foreign key column.
            There is never a risk of violating foreign key constraints. However, you 
            might violate a <tt class="literal">NOT NULL</tt> constraint if you
            <tt class="literal">Save()</tt> the objects in the wrong order.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-loading"></a>10.2.&nbsp;Loading an object</h2></div></div><div></div></div><p>
            The <tt class="literal">Load()</tt> methods of <tt class="literal">ISession</tt> give you 
            a way to retrieve a persistent instance if you already know its identifier. 
            One version takes a class object and will load the state into a newly instantiated 
            object. The second version allows you to supply an instance into which the state 
            will be loaded. The form which takes an instance is only useful in special
            circumstances (DIY instance pooling etc.)
        </p><pre class="programlisting">Cat fritz = sess.Load&lt;Cat&gt;(generatedId);</pre><pre class="programlisting">long pkId = 1234;
DomesticCat pk = sess.Load&lt;DomesticCat&gt;(pkId);</pre><pre class="programlisting">Cat cat = new DomesticCat();
// load pk's state into cat
sess.Load( cat, pkId );
var kittens = cat.Kittens;</pre><p>
            Note that <tt class="literal">Load()</tt> will throw an unrecoverable exception if there is no matching 
            database row. If the class is mapped with a proxy, <tt class="literal">Load()</tt> returns an object
            that is an uninitialized proxy and does not actually hit the database until you invoke a method of 
            the object. This behaviour is very useful if you wish to create an association to an object
            without actually loading it from the database.
        </p><p>
            If you are not certain that a matching row exists, you should use the <tt class="literal">Get()</tt>
            method, which hits the database immediately and returns null if there is no matching row.
        </p><pre class="programlisting">Cat cat = sess.Get&lt;Cat&gt;(id);
if (cat==null) {
    cat = new Cat();
    sess.Save(cat, id);
}
return cat;</pre><p>
            You may also load an objects using an SQL <tt class="literal">SELECT ... FOR UPDATE</tt>. See the next
            section for a discussion of NHibernate <tt class="literal">LockMode</tt>s.
        </p><pre class="programlisting">Cat cat = sess.Get&lt;Cat&gt;(id, LockMode.Upgrade);</pre><p>
            Note that any associated instances or contained collections are <span class="emphasis"><em>not</em></span> selected 
            <tt class="literal">FOR UPDATE</tt>.
        </p><p>
            It is possible to re-load an object and all its collections at any time, using the 
            <tt class="literal">Refresh()</tt> method. This is useful when database triggers are used to
            initialize some of the properties of the object.
        </p><pre class="programlisting">sess.Save(cat);
sess.Flush(); //force the SQL INSERT
sess.Refresh(cat); //re-read the state (after the trigger executes)</pre><p>
            An important question usually appears at this point: How much does NHibernate load
            from the database and how many SQL <tt class="literal">SELECT</tt>s will it use? This
            depends on the <span class="emphasis"><em>fetching strategy</em></span> and is explained in
            <a href="#performance-fetching" title="21.1.&nbsp;Fetching strategies">Section&nbsp;21.1, &#8220;Fetching strategies&#8221;</a>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-querying"></a>10.3.&nbsp;Querying</h2></div></div><div></div></div><p>
            If you don't know the identifier(s) of the object(s) you are looking for, use the
            <tt class="literal">CreateQuery()</tt> method of <tt class="literal">ISession</tt>. NHibernate
            supports a simple but powerful object oriented query language.
        </p><pre class="programlisting">IList&lt;Cat&gt; cats = sess
    .CreateQuery("from Cat as cat where cat.Birthdate = ?")
    .SetDateTime(0, date)
    .List&lt;Cat&gt;();

var mates = sess
    .CreateQuery("select mate from Cat as cat join cat.Mate as mate " +
        "where cat.name = ?")
    .SetString(0, name)
    .List&lt;Cat&gt;();

var cats = sess
    .CreateQuery("from Cat as cat where cat.Mate.Birthdate is null")
    .List&lt;Cat&gt;();

var moreCats = sess
    .CreateQuery("from Cat as cat where " +
        "cat.Name = 'Fritz' or cat.id = ? or cat.id = ?")
    .SetInt64(0, id1)
    .SetParameter(1, id2, NHibernateUtil.Int64)
    .List&lt;Cat&gt;();

var mates = sess
    .CreateQuery("from Cat as cat where cat.Mate = ?")
    .SetEntity(0, izi)
    .List&lt;Cat&gt;();
);

var problems = sess
    .CreateQuery("from GoldFish as fish " +
        "where fish.Birthday &gt; fish.Deceased or fish.Birthday is null")
    .List&lt;GoldFish&gt;();</pre><p>
            These given <tt class="literal">Set</tt> parameters are used to bind the given values to the
            <tt class="literal">?</tt> query placeholders (which map to input
            parameters of an ADO.NET <tt class="literal">DbCommand</tt>). Just
            as in ADO.NET, you should use this binding mechanism in preference to string
            manipulation.
        </p><p>
            The <tt class="literal">NHibernateUtil</tt> class defines a number of static methods
            and constants, providing access to most of the built-in types, as instances
            of <tt class="literal">NHibernate.Type.IType</tt>.
        </p><p>
            If you expect your query to return a very large number of objects, but you 
            don't expect to use them all, you might get better performance from the
            <tt class="literal">Enumerable()</tt> method, which return a
            <tt class="literal">IEnumerable</tt>. The iterator will load objects
            on demand, using the identifiers returned by an initial SQL query (n+1 selects
            total).
        </p><pre class="programlisting">// fetch ids
IEnumerable&lt;Qux&gt; en = sess
    .CreateQuery("from eg.Qux q order by q.Likeliness")
    .Enumerable&lt;Qux&gt;();
foreach (Qux qux in en)
{
    // something we couldnt express in the query
    if ( qux.CalculateComplicatedAlgorithm() ) {
        // dont need to process the rest
        break;
    }
}</pre><p>
            The <tt class="literal">Enumerable()</tt> method also performs better if
            you expect that many of the objects are already loaded and cached by 
            the session, or if the query results contain the same objects many
            times. (When no data is cached or repeated, <tt class="literal">CreateQuery()</tt>
            is almost always faster.) Here is an example of a query that should be
            called using <tt class="literal">Enumerable()</tt>:
        </p><pre class="programlisting">
var en = sess
    .CreateQuery(
        "select customer, product " +
        "from Customer customer, " +
        "Product product " +
        "join customer.Purchases purchase " +
        "where product = purchase.Product")
    .Enumerable&lt;object[]&gt;();</pre><p>
            Calling the previous query using <tt class="literal">CreateQuery()</tt> would return a very
            large ADO.NET result set containing the same data many times.
        </p><p>
            NHibernate queries sometimes return tuples of objects, in which case each tuple
            is returned as an array:
        </p><pre class="programlisting">var foosAndBars = sess
    .CreateQuery(
        "select foo, bar from Foo foo, Bar bar " +
        "where bar.Date = foo.Date")
    .Enumerable&lt;object[]&gt;();
foreach (object[] tuple in foosAndBars)
{
    Foo foo = tuple[0]; Bar bar = tuple[1];
    ....
}</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-scalarqueries"></a>10.3.1.&nbsp;Scalar queries</h3></div></div><div></div></div><p>
                Queries may specify a property of a class in the <tt class="literal">select</tt> clause.
                They may even call SQL aggregate functions. Properties or aggregates are considered
                "scalar" results.
            </p><pre class="programlisting">var results = sess
    .CreateQuery(
        "select cat.Color, min(cat.Birthdate), count(cat) from Cat cat " +
        "group by cat.Color")
    .Enumerable&lt;object[]&gt;();
foreach (object[] row in results)
{
    Color type = (Color) row[0];
    DateTime oldest = (DateTime) row[1];
    int count = (int) row[2];
    .....
}</pre><pre class="programlisting">var en = sess
    .CreateQuery(
        "select cat.Type, cat.Birthdate, cat.Name from DomesticCat cat")
    .Enumerable&lt;object[]&gt;();</pre><pre class="programlisting">IList&lt;object[]&gt; list = sess
    .CreateQuery("select cat, cat.Mate.Name from DomesticCat cat")
    .List&lt;object[]&gt;();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-queryinterface"></a>10.3.2.&nbsp;The IQuery interface</h3></div></div><div></div></div><p>
                If you need to specify bounds upon your result set (the maximum number of rows
                you want to retrieve and / or the first row you want to retrieve) you should
                obtain an instance of <tt class="literal">NHibernate.IQuery</tt>:
            </p><pre class="programlisting">IQuery q = sess.CreateQuery("from DomesticCat cat");
q.SetFirstResult(20);
q.SetMaxResults(10);
var cats = q.List&lt;Cat&gt;();</pre><p>
                You may even define a named query in the mapping document. (Remember to use a
                <tt class="literal">CDATA</tt> section if your query contains characters that could
                be interpreted as markup.)
            </p><pre class="programlisting">&lt;query name="Eg.DomesticCat.by.name.and.minimum.weight"&gt;&lt;![CDATA[
    from Eg.DomesticCat as cat
        where cat.Name = ?
        and cat.Weight &gt; ?
] ]&gt;&lt;/query&gt;</pre><pre class="programlisting">IQuery q = sess.GetNamedQuery("Eg.DomesticCat.by.name.and.minimum.weight");
q.SetString(0, name);
q.SetInt32(1, minWeight);
var cats = q.List&lt;Cat&gt;();</pre><p>
                Named queries are by default validated at startup time, allowing to catch errors
                more easily than having to test all the application features using HQL queries. In
                case of validation errors, the details of failing queries are logged and a
                validation error is raised.
            </p><p>
                Named queries accepts a number of attributes matching settings available on the
                <tt class="literal">IQuery</tt> interface.
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">flush-mode</tt> - override the session flush mode just for this query.
                    </p></li><li><p>
                    <tt class="literal">cacheable</tt> - allow the query results to be cached by the second level cache.
                    See <a href="#caches" title="Chapter&nbsp;27.&nbsp;NHibernate.Caches">Chapter&nbsp;27, <i>NHibernate.Caches</i></a>.
                    </p></li><li><p>
                    <tt class="literal">cache-region</tt> - specify the cache region of the query.
                    </p></li><li><p>
                    <tt class="literal">cache-mode</tt> - specify the cache mode of the query.
                    </p></li><li><p>
                    <tt class="literal">fetch-size</tt> - set a fetch size for the underlying ADO query.
                    </p></li><li><p>
                    <tt class="literal">timeout</tt> - set the query timeout in seconds.
                    </p></li><li><p>
                    <tt class="literal">read-only</tt> - <tt class="literal">true</tt> switches yielded entities to read-only.
                    See <a href="#readonly" title="Chapter&nbsp;11.&nbsp;Read-only entities">Chapter&nbsp;11, <i>Read-only entities</i></a>.
                    </p></li><li><p>
                    <tt class="literal">comment</tt> - add a custom comment to the generated SQL.
                    </p></li></ul></div><p>
                The query interface supports the use of named parameters. Named parameters
                are identifiers of the form <tt class="literal">:name</tt> in the query string.
                There are methods on <tt class="literal">IQuery</tt> for binding values to named
                or positional parameters. NHibernate numbers parameters from zero.
                The advantages of named parameters are:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        named parameters are insensitive to the order they occur in the
                        query string
                    </p></li><li><p>
                        they may occur multiple times in the same query
                    </p></li><li><p>
                        they are self-documenting
                    </p></li></ul></div><pre class="programlisting">//named parameter (preferred)
IQuery q = sess.CreateQuery("from DomesticCat cat where cat.Name = :name");
q.SetString("name", "Fritz");
var cats = q.Enumerable&lt;DomesticCat&gt;();</pre><pre class="programlisting">//positional parameter
IQuery q = sess.CreateQuery("from DomesticCat cat where cat.Name = ?");
q.SetString(0, "Izi");
var cats = q.Enumerable&lt;DomesticCat&gt;();</pre><pre class="programlisting">//named parameter list
var names = new List&lt;string&gt;();
names.Add("Izi");
names.Add("Fritz");
IQuery q = sess.CreateQuery("from DomesticCat cat where cat.Name in (:namesList)");
q.SetParameterList("namesList", names);
var cats = q.List&lt;DomesticCat&gt;();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-filtering"></a>10.3.3.&nbsp;Filtering collections</h3></div></div><div></div></div><p>
                A collection <span class="emphasis"><em>filter</em></span> is a special type of query that may be applied to
                a persistent collection or array. The query string may refer to <tt class="literal">this</tt>,
                meaning the current collection element.
            </p><pre class="programlisting">var blackKittens = session
    .CreateFilter(pk.Kittens, "where this.Color = ?")
    .SetEnum(0, Color.Black)
    .List&lt;Cat&gt;();</pre><p>
                The returned collection is considered a bag.
            </p><p>
                Observe that filters do not require a <tt class="literal">from</tt> clause (though they may have
                one if required). Filters are not limited to returning the collection elements themselves.
            </p><pre class="programlisting">var blackKittenMates = session
    .CreateFilter(pk.Kittens,
        "select this.Mate where this.Color = Eg.Color.Black")
    .List&lt;Cat&gt;();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-criteria"></a>10.3.4.&nbsp;Criteria queries</h3></div></div><div></div></div><p>
                HQL is extremely powerful but some people prefer to build queries dynamically, using an
                object oriented API, rather than embedding strings in their .NET code. For these people,
                NHibernate provides an intuitive <tt class="literal">ICriteria</tt> query API.
            </p><pre class="programlisting">ICriteria crit = session.CreateCriteria&lt;Cat&gt;();
crit.Add(Expression.Eq("color", Eg.Color.Black));
crit.SetMaxResults(10);
var cats = crit.List&lt;Cat&gt;();</pre><p>
                If you are uncomfortable with SQL-like syntax, this is perhaps the easiest way to get started
                with NHibernate. This API is also more extensible than HQL. Applications might provide their
                own implementations of the <tt class="literal">ICriterion</tt> interface.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-nativesql"></a>10.3.5.&nbsp;Queries in native SQL</h3></div></div><div></div></div><p>
                You may express a query in SQL, using <tt class="literal">CreateSQLQuery()</tt>. You must enclose
                SQL aliases in braces.
            </p><pre class="programlisting">var cats = session
    .CreateSQLQuery("SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM&lt;10")
    .AddEntity("cat", typeof(Cat))
    .List&lt;Cat&gt;();</pre><pre class="programlisting">var cats = session
    .CreateSQLQuery(
        "SELECT {cat}.ID AS {cat.Id}, {cat}.SEX AS {cat.Sex}, " +
           "{cat}.MATE AS {cat.Mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
        "FROM CAT {cat} WHERE ROWNUM&lt;10")
    .AddEntity("cat", typeof(Cat))
    .List&lt;Cat&gt;()</pre><p>
                SQL queries may contain named and positional parameters, just like NHibernate queries.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-updating"></a>10.4.&nbsp;Updating objects</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-updating-insession"></a>10.4.1.&nbsp;Updating in the same ISession</h3></div></div><div></div></div><p>
                <span class="emphasis"><em>Transactional persistent instances</em></span> (ie. objects loaded, saved, created or
                queried by the <tt class="literal">ISession</tt>) may be manipulated by the application
                and any changes to persistent state will be persisted when the <tt class="literal">ISession</tt>
                is <span class="emphasis"><em>flushed</em></span> (discussed later in this chapter). So the most
                straightforward way to update the state of an object is to <tt class="literal">Load()</tt> it,
                and then manipulate it directly, while the <tt class="literal">ISession</tt> is open:
            </p><pre class="programlisting">DomesticCat cat = sess.Load&lt;DomesticCat&gt;(69L);
cat.Name = "PK";
sess.Flush();  // changes to cat are automatically detected and persisted</pre><p>
                Sometimes this programming model is inefficient since it would require both an SQL
                <tt class="literal">SELECT</tt> (to load an object) and an SQL <tt class="literal">UPDATE</tt>
                (to persist its updated state) in the same session. Therefore NHibernate offers an
                alternate approach.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-updating-detached"></a>10.4.2.&nbsp;Updating detached objects</h3></div></div><div></div></div><p>
                Many applications need to retrieve an object in one transaction, send it to the
                UI layer for manipulation, then save the changes in a new transaction.
                (Applications  that use this kind of approach in a high-concurrency environment
                usually use versioned  data to ensure transaction isolation.) This approach
                requires a slightly different  programming model to the one described in the
                last section. NHibernate supports this model by providing the
                method <tt class="literal">ISession.Update()</tt>.
            </p><pre class="programlisting">// in the first session
Cat cat = firstSession.Load&lt;Cat&gt;(catId);
Cat potentialMate = new Cat();
firstSession.Save(potentialMate);

// in a higher tier of the application
cat.Mate = potentialMate;

// later, in a new session
secondSession.Update(cat);  // update cat</pre><p>
                If the <tt class="literal">Cat</tt> with identifier <tt class="literal">catId</tt> had already
                been loaded  by <tt class="literal">secondSession</tt> when the application tried to
                update it, an exception would have been thrown.
            </p><p>
                The application should individually <tt class="literal">Update()</tt> transient instances
                reachable from the given transient instance if and <span class="emphasis"><em>only</em></span> if it wants
                their state also updated. (Except for lifecycle objects, see
                <a href="#manipulatingdata-graphs" title="10.10.&nbsp;Lifecycles and object graphs">Section&nbsp;10.10, &#8220;Lifecycles and object graphs&#8221;</a>.)
            </p><p>
                NHibernate users have requested a general purpose method that either saves a
                transient instance by generating a new identifier or update the persistent
                state associated with its current identifier. The <tt class="literal">SaveOrUpdate()</tt>
                method now implements this functionality.
            </p><p>
                NHibernate distinguishes "new" (unsaved) instances from "existing" (saved or
                loaded in a previous session) instances by the value of their identifier
                (or version, or timestamp) property. The <tt class="literal">unsaved-value</tt>
                attribute of the <tt class="literal">&lt;id&gt;</tt> (or <tt class="literal">&lt;version&gt;</tt>,
                or <tt class="literal">&lt;timestamp&gt;</tt>) mapping specifies which values should
                be interpreted as representing a "new" instance.
            </p><pre class="programlisting">&lt;id name="Id" type="Int64" column="uid" unsaved-value="0"&gt;
    &lt;generator class="hilo"/&gt;
&lt;/id&gt;</pre><p>
                The allowed values of <tt class="literal">unsaved-value</tt> are:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">any</tt> - always save
                    </p></li><li><p>
                    <tt class="literal">none</tt> - always update
                    </p></li><li><p>
                    <tt class="literal">null</tt> - save when identifier is null
                    </p></li><li><p>
                    valid identifier value - save when identifier is null or the given value
                    </p></li><li><p>
                        <tt class="literal">undefined</tt> - do not infer the operation from the identifier
                        (or <tt class="literal">version</tt>, or <tt class="literal">timestamp</tt>). Ultimately,
                        NHibernate may query the database for determining the operation it has to
                        perform.
                    </p></li></ul></div><p>
                If <tt class="literal">unsaved-value</tt> is not specified for a class, NHibernate
                will attempt to guess it by creating an instance of the class using the no-argument
                constructor and reading the property value from the instance.
            </p><pre class="programlisting">// in the first session
Cat cat = firstSession.Load&lt;Cat&gt;(catID);

// in a higher tier of the application
Cat mate = new Cat();
cat.Mate = mate;

// later, in a new session
secondSession.SaveOrUpdate(cat);   // update existing state (cat has a non-null id)
secondSession.SaveOrUpdate(mate);  // save the new instance (mate has a null id)</pre><p>
                The usage and semantics of <tt class="literal">SaveOrUpdate()</tt> seems to be confusing
                for new users. Firstly, so long as you are not trying to use instances from one session
                in another new session, you should not need to use <tt class="literal">Update()</tt> or
                <tt class="literal">SaveOrUpdate()</tt>. Some whole applications will never use either of
                these methods.
            </p><p>
                Usually <tt class="literal">Update()</tt> or <tt class="literal">SaveOrUpdate()</tt> are used in
                the following scenario:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        the application loads an object in the first session
                    </p></li><li><p>
                        the object is passed up to the UI tier
                    </p></li><li><p>
                        some modifications are made to the object
                    </p></li><li><p>
                        the object is passed back down to the business logic tier
                    </p></li><li><p>
                        the application persists these modifications by calling
                        <tt class="literal">Update()</tt> in a second session
                    </p></li></ul></div><p>
                <tt class="literal">SaveOrUpdate()</tt> does the following:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        if the object is already persistent in this session, do nothing
                    </p></li><li><p>
                        if the object has no identifier property, <tt class="literal">Save()</tt> it
                    </p></li><li><p>
                        if the object's identifier matches the criteria specified by
                        <tt class="literal">unsaved-value</tt>, <tt class="literal">Save()</tt> it
                    </p></li><li><p>
                        if the object is versioned (<tt class="literal">version</tt> or
                        <tt class="literal">timestamp</tt>), and its version matches the criteria
                        specified by <tt class="literal">unsaved-value</tt>, <tt class="literal">Save()</tt>
                        it
                    </p></li><li><p>
                        if another object associated with the session has the same
                        identifier, throw an exception
                    </p></li></ul></div><p>
                The last case can be avoided by using <tt class="literal">Merge(Object o)</tt>. This method
                copies the state of the given object onto the persistent object with the same identifier. If
                there is no persistent instance currently associated with the session, it will be loaded.
                The method returns the persistent instance. If the given instance is unsaved or does not
                exist in the database, NHibernate will save it and return it as a newly persistent instance.
                Otherwise, the given instance  does not become associated with the session. In most
                applications with detached objects, you need both methods, <tt class="literal">SaveOrUpdate()</tt>
                and <tt class="literal">Merge()</tt>.
             </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-update-lock"></a>10.4.3.&nbsp;Reattaching detached objects</h3></div></div><div></div></div><p>
                The <tt class="literal">Lock()</tt> method allows the application to re-associate
                an unmodified object with a new session.
            </p><pre class="programlisting">//just reassociate:
sess.Lock(fritz, LockMode.None);
//do a version check, then reassociate:
sess.Lock(izi, LockMode.Read);
//do a version check, using SELECT ... FOR UPDATE, then reassociate:
sess.Lock(pk, LockMode.Upgrade);</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-deleting"></a>10.5.&nbsp;Deleting persistent objects</h2></div></div><div></div></div><p>
            <tt class="literal">ISession.Delete()</tt> will remove an object's state from the database. 
            Of course, your application might still hold a reference to it. So it's best to think 
            of <tt class="literal">Delete()</tt> as making a persistent instance transient.
        </p><pre class="programlisting">sess.Delete(cat);</pre><p>
            You may also delete many objects at once by passing a NHibernate query string to
            <tt class="literal">Delete()</tt>.
        </p><pre class="programlisting">sess.Delete("from Cat");</pre><p>
            You may now delete objects in any order you like, without risk of foreign key
            constraint violations. Of course, it is still possible to violate a <tt class="literal">NOT
            NULL</tt> constraint on a foreign key column by deleting objects in
            the wrong order.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-flushing"></a>10.6.&nbsp;Flush</h2></div></div><div></div></div><p>
            From time to time the <tt class="literal">ISession</tt> will execute the SQL statements 
            needed to synchronize the ADO.NET connection's state with the state of objects held in 
            memory. This process, <span class="emphasis"><em>flush</em></span>, occurs by default at the following 
            points
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    from some invocations of <tt class="literal">IQuery</tt> methods such as <tt class="literal">List</tt>
                    or <tt class="literal">Enumerable</tt>, and from similar methods of other querying API.
                </p></li><li><p>
                    from <tt class="literal">NHibernate.ITransaction.Commit()</tt>
                </p></li><li><p>
                    from <tt class="literal">ISession.Flush()</tt>
                </p></li></ul></div><p>
            The SQL statements are issued in the following order
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    all entity insertions, in the same order the corresponding objects
                    were saved using <tt class="literal">ISession.Save()</tt>
                </p></li><li><p>
                    all entity updates
                </p></li><li><p>
                    all collection deletions
                </p></li><li><p>
                    all collection element deletions, updates and insertions
                </p></li><li><p>
                    all collection insertions
                </p></li><li><p>
                    all entity deletions, in the same order the corresponding objects
                    were deleted using <tt class="literal">ISession.Delete()</tt>
                </p></li></ol></div><p>
            (An exception is that objects using <tt class="literal">identity</tt> ID generation are
            inserted when they are saved.)
        </p><p>
            Except when you explicitly <tt class="literal">Flush()</tt>, there are absolutely no 
            guarantees about <span class="emphasis"><em>when</em></span> the <tt class="literal">Session</tt> executes 
            the ADO.NET calls, only the <span class="emphasis"><em>order</em></span> in which they are executed.
            However, NHibernate does guarantee that the queries methods will never return stale
            data; nor will they return the wrong data.
        </p><p>
            It is possible to change the default behavior so that flush occurs less frequently.
            The <tt class="literal">FlushMode</tt> class defines three different modes:
            only flush at commit time (and only when the NHibernate <tt class="literal">ITransaction</tt>
            API is used, or inside a transaction scope), flush automatically using the explained
            routine (will only work inside an explicit NHibernate <tt class="literal">ITransaction</tt> or
            inside a transaction scope), or never flush unless
            <tt class="literal">Flush()</tt> is called explicitly. The last mode is useful for long
            running units of work, where an ISession is kept open and disconnected for a long time
            (see <a href="#transactions-optimistic" title="12.4.&nbsp;Optimistic concurrency control">Section&nbsp;12.4, &#8220;Optimistic concurrency control&#8221;</a>).
        </p><pre class="programlisting">sess = sf.OpenSession();
using (ITransaction tx = sess.BeginTransaction())
{
    // allow queries to return stale state
    sess.FlushMode = FlushMode.Commit;
    Cat izi = sess.Load&lt;Cat&gt;(id);
    izi.Name = "iznizi";
    // execute some queries....
    sess.CreateQuery("from Cat as cat left outer join cat.Kittens kitten")
        .List&lt;object[]&gt;();
    // change to izi is not flushed!
    ...
    tx.Commit(); // flush occurs
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-dirtiness"></a>10.7.&nbsp;Checking dirtiness</h2></div></div><div></div></div><p>
            <tt class="literal">ISession.IsDirty()</tt> will return whether the session hold any pending
            change to flush or not. Be cautious when using this method, its default implementation
            may have the following effects:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Dirty checks all the loaded entities. NHibernate does not instrument the entities
                    for being notified of changes done on loaded ones. Instead, it stores their
                    initial state and compare them to it. If session has loaded a lot of entities,
                    the dirty checking will have a significant impact.
                </p></li><li><p>
                    Triggers pending cascade operations. This includes any pending <tt class="literal">Save</tt>
                    of, by example, children added to a collection having the <tt class="literal">Save</tt>
                    cascade enabled. Depending on the entities ID generators (see
                    <a href="#mapping-declaration-id-generator" title="5.1.5.1.&nbsp;generator">Section&nbsp;5.1.5.1, &#8220;generator&#8221;</a>), this may trigger calls to the
                    database, or even entity insertions if they are using the <tt class="literal">identity</tt>
                    generator.
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-endingsession"></a>10.8.&nbsp;Ending a Session</h2></div></div><div></div></div><p>
            Ending a session involves four distinct phases:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    flush the session
                </p></li><li><p>
                    commit the transaction
                </p></li><li><p>
                    close the session
                </p></li><li><p>
                    handle exceptions
                </p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-flushing"></a>10.8.1.&nbsp;Flushing the Session</h3></div></div><div></div></div><p>
                If you happen to be using the <tt class="literal">ITransaction</tt> API, you don't
                need to worry about this step. It will be performed implicitly when the 
                transaction is committed. Otherwise you should call 
                <tt class="literal">ISession.Flush()</tt> to ensure that all changes are synchronized
                with the database.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-commit"></a>10.8.2.&nbsp;Committing the database transaction</h3></div></div><div></div></div><p>
                If you are using the NHibernate <tt class="literal">ITransaction</tt> API, this looks like:
            </p><pre class="programlisting">tx.Commit(); // flush the session and commit the transaction</pre><p>
                If you are managing ADO.NET transactions yourself you should manually
                <tt class="literal">Commit()</tt> the ADO.NET transaction.
            </p><pre class="programlisting">sess.Flush();
currentTransaction.Commit();</pre><p>
                If you decide <span class="emphasis"><em>not</em></span> to commit your changes:
            </p><pre class="programlisting">tx.Rollback();  // rollback the transaction</pre><p>
                or:
            </p><pre class="programlisting">currentTransaction.Rollback();</pre><p>
                If you rollback the transaction you should immediately close and discard the current
                session to ensure that NHibernate's internal state is consistent.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-close"></a>10.8.3.&nbsp;Closing the ISession</h3></div></div><div></div></div><p>
                A call to <tt class="literal">ISession.Close()</tt> marks the end of a session. The main implication
                of <tt class="literal">Close()</tt> is that the ADO.NET connection will be relinquished by the session.
            </p><pre class="programlisting">tx.Commit();
sess.Close();</pre><pre class="programlisting">sess.Flush();
currentTransaction.Commit();
sess.Close();</pre><p>
                If you provided your own connection, <tt class="literal">Close()</tt> returns a reference 
                to it, so you can manually close it or return it to the pool. Otherwise
                <tt class="literal">Close()</tt> returns it to the pool.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-exceptions"></a>10.9.&nbsp;Exception handling</h2></div></div><div></div></div><p>
            NHibernate use might lead to exceptions, usually <tt class="literal">HibernateException</tt>.
            This exception can have	a nested inner exception (the root cause), use the
            <tt class="literal">InnerException</tt> property to access it.
        </p><p>
            If the <tt class="literal">ISession</tt> throws an exception you should immediately
            rollback the transaction, call <tt class="literal">ISession.Close()</tt>
            and discard the <tt class="literal">ISession</tt> instance. Certain
            methods of <tt class="literal">ISession</tt> will <span class="emphasis"><em>not</em></span>
            leave the session in a consistent state.
        </p><p>
            For exceptions thrown by the data provider while interacting with the database,
            NHibernate will wrap the error in an instance of <tt class="literal">ADOException</tt>.
            The underlying exception is accessible by calling <tt class="literal">ADOException.InnerException</tt>.
            NHibernate converts the <tt class="literal">DbException</tt> into an appropriate <tt class="literal">ADOException</tt>
            subclass using the <tt class="literal">ISQLExceptionConverter</tt> attached to the SessionFactory.
            By default, the <tt class="literal">ISQLExceptionConverter</tt> is defined by the configured dialect;
            however, it is also possible to plug in a custom implementation
            (see the api-docs for the <tt class="literal">ISQLExceptionConverter</tt> class for details).
        </p><p>
            The following exception handling idiom shows the typical case in NHibernate applications:
        </p><pre class="programlisting">using (ISession sess = factory.OpenSession())
using (ITransaction tx = sess.BeginTransaction())
{
    // do some work
    ...
    tx.Commit();
}</pre><p>
            Or, when manually managing ADO.NET transactions:
        </p><pre class="programlisting">ISession sess = factory.openSession();
try
{
    // do some work
    ...
    sess.Flush();
    currentTransaction.Commit();
}
catch (Exception e)
{
    currentTransaction.Rollback();
    throw;
}
finally
{
    sess.Close();
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-graphs"></a>10.10.&nbsp;Lifecycles and object graphs</h2></div></div><div></div></div><p>
            To save or update all objects in a graph of associated objects, you must either
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">Save()</tt>, <tt class="literal">SaveOrUpdate()</tt> or
                    <tt class="literal">Update()</tt> each individual object OR
                </p></li><li><p>
                    map associated objects using <tt class="literal">cascade="all"</tt> or
                    <tt class="literal">cascade="save-update"</tt>.
                </p></li></ul></div><p>
            Likewise, to delete all objects in a graph, either
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">Delete()</tt> each individual object OR
                </p></li><li><p>
                    map associated objects using <tt class="literal">cascade="all"</tt>,
                    <tt class="literal">cascade="all-delete-orphan"</tt> or
                    <tt class="literal">cascade="delete"</tt>.
                </p></li></ul></div><p>
            Recommendation:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    If the child object's lifespan is bounded by the lifespan of the of the parent
                    object make it a <span class="emphasis"><em>lifecycle object</em></span> by specifying
                    <tt class="literal">cascade="all"</tt>.
                </p></li><li><p>
                    Otherwise, <tt class="literal">Save()</tt> and <tt class="literal">Delete()</tt> it
                    explicitly from application code. If you really want to save yourself some
                    extra typing, use <tt class="literal">cascade="save-update"</tt> and explicit
                    <tt class="literal">Delete()</tt>.
                </p></li></ul></div><p>
            Mapping an association (many-to-one, one-to-one or collection) with <tt class="literal">cascade="all"</tt>
            marks the association as a <span class="emphasis"><em>parent/child</em></span> style relationship where
            save/update/deletion of the parent results in save/update/deletion of the child(ren).
            Furthermore, a mere reference to a child from a persistent parent will result in save / update
            of the child. The metaphor is incomplete, however. A child which becomes unreferenced by its
            parent is <span class="emphasis"><em>not</em></span> automatically deleted, except in the cases of 
            <tt class="literal">&lt;one-to-many&gt;</tt> and <tt class="literal">&lt;one-to-one&gt;</tt> associations 
            that have been mapped with <tt class="literal">cascade="all-delete-orphan"</tt> or 
            <tt class="literal">cascade="delete-orphan"</tt>. The precise semantics of cascading operations
            are as follows:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    If a parent is saved, all children are passed to <tt class="literal">SaveOrUpdate()</tt>
                </p></li><li><p>
                    If a parent is passed to <tt class="literal">Update()</tt> or <tt class="literal">SaveOrUpdate()</tt>,
                    all children are passed to <tt class="literal">SaveOrUpdate()</tt>
                </p></li><li><p>
                    If a transient child becomes referenced by a persistent parent, it is passed to
                    <tt class="literal">SaveOrUpdate()</tt>
                </p></li><li><p>
                    If a parent is deleted, all children are passed to <tt class="literal">Delete()</tt>
                </p></li><li><p>
                    If a transient child is dereferenced by a persistent parent, <span class="emphasis"><em>nothing
                    special happens</em></span> (the application should explicitly delete the child if
                    necessary) unless <tt class="literal">cascade="all-delete-orphan"</tt> or 
                    <tt class="literal">cascade="delete-orphan"</tt>, in which case the "orphaned" child is deleted.
                </p></li></ul></div><p>
            NHibernate does not fully implement "persistence by reachability", which would imply
            (inefficient) persistent garbage collection. However, due to popular demand,
            NHibernate does support the notion of entities becoming persistent when referenced
            by another persistent object. Associations marked
            <tt class="literal">cascade="save-update"</tt> behave in this way. If you wish to use this
            approach throughout your application, it's easier to specify the
            <tt class="literal">default-cascade</tt> attribute of the
            <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-interceptors"></a>10.11.&nbsp;Interceptors</h2></div></div><div></div></div><p>
            The <tt class="literal">IInterceptor</tt> interface provides callbacks from the session to the 
            application allowing the application to inspect and / or manipulate properties of a 
            persistent object before it is saved, updated, deleted or loaded. One 
            possible use for this is to track auditing information. See
            <a href="#objectstate-interceptors" title="13.1.&nbsp;Interceptors">Section&nbsp;13.1, &#8220;Interceptors&#8221;</a> for more information.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-metadata"></a>10.12.&nbsp;Metadata API</h2></div></div><div></div></div><p>
            NHibernate requires a very rich meta-level model of all entity and value types. From time
            to time, this model is very useful to the application itself. For example, the application
            might use NHibernate's metadata to implement a "smart" deep-copy algorithm that understands
            which objects should be copied (eg. mutable value types) and which should not (eg. 
            immutable value types and, possibly, associated entities).
        </p><p>
            NHibernate exposes metadata via the <tt class="literal">IClassMetadata</tt> and
            <tt class="literal">ICollectionMetadata</tt> interfaces and the <tt class="literal">IType</tt>
            hierarchy. Instances of the metadata interfaces may be obtained from the 
            <tt class="literal">ISessionFactory</tt>.
        </p><pre class="programlisting">Cat fritz = ......;
IClassMetadata catMeta = sessionfactory.GetClassMetadata(typeof(Cat));
long id = (long) catMeta.GetIdentifier(fritz);
object[] propertyValues = catMeta.GetPropertyValues(fritz);
string[] propertyNames = catMeta.PropertyNames;
IType[] propertyTypes = catMeta.PropertyTypes;

// get an dictionary of all properties which are not collections or associations
// TODO: what about components?

var namedValues = new Dictionary&lt;string, object&gt;();
for (int i = 0; i &lt; propertyNames.Length; i++)
{
    if (!propertyTypes[i].IsEntityType &amp;&amp; !propertyTypes[i].IsCollectionType)
    {
        namedValues[propertyNames[i]] = propertyValues[i];
    }
}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="readonly"></a>Chapter&nbsp;11.&nbsp;Read-only entities</h2></div></div><div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
            NHibernate's treatment of <span class="emphasis"><em>read-only</em></span> entities may 
            differ from what you may have encountered elsewhere. Incorrect usage 
            may cause unexpected results.
        </p></div><p>
        When an entity is read-only:

        </p><div class="itemizedlist"><ul type="disc"><li><p> 
                    NHibernate does not dirty-check the entity's simple 
                    properties or single-ended associations;
                </p></li><li><p> 
                    NHibernate will not update simple properties or updatable
                    single-ended associations; 
                </p></li><li><p> 
                    NHibernate will not update the version of the read-only 
                    entity if only simple properties or single-ended 
                    updatable associations are changed;
                </p></li></ul></div><p>
    </p><p>
        In some ways, NHibernate treats read-only entities the same as entities that are 
        not read-only:
 
        </p><div class="itemizedlist"><ul type="disc"><li><p> 
                    NHibernate cascades operations to associations as
                    defined in the entity mapping.
                </p></li><li><p> 
                    NHibernate updates the version if the entity has a 
                    collection with changes that dirties the entity;
                </p></li><li><p> 
                    A read-only entity can be deleted.
                </p></li></ul></div><p>
    </p><p>
        Even if an entity is not read-only, its collection association can 
        be affected if it contains a read-only entity.
    </p><p>
        For details about the affect of read-only entities on different
        property and association types, see 
        <a href="#readonly-proptypes" title="11.2.&nbsp;Read-only affect on property type">Section&nbsp;11.2, &#8220;Read-only affect on property type&#8221;</a>.
    </p><p>     
        For details about how to make entities read-only, see 
        <a href="#readonly-api" title="11.1.&nbsp;Making persistent entities read-only">Section&nbsp;11.1, &#8220;Making persistent entities read-only&#8221;</a>
    </p><p>
        NHibernate does some optimizing for read-only entities:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
                    It saves execution time by not dirty-checking simple properties or 
                    single-ended associations.
                 </p></li><li><p>
                    It saves memory by deleting database snapshots.
                </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="readonly-api"></a>11.1.&nbsp;Making persistent entities read-only</h2></div></div><div></div></div><p>
            Only persistent entities can be made read-only. Transient and
            detached entities must be put in persistent state before they
            can be made read-only.
        </p><p>
            NHibernate provides the following ways to make persistent entities read-only:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    you can map an entity class as <span class="emphasis"><em>immutable</em></span>;
                    when an entity of an immutable class is made persistent,
                    NHibernate automatically makes it read-only.
                    see <a href="#readonly-api-immutable" title="11.1.1.&nbsp;Entities of immutable classes">Section&nbsp;11.1.1, &#8220;Entities of immutable classes&#8221;</a> for details 
                </p></li><li><p>
                    you can change a default so that entities loaded
                    into the session by NHibernate are automatically 
                    made read-only; see <a href="#readonly-api-loaddefault" title="11.1.2.&nbsp;Loading persistent entities as read-only">Section&nbsp;11.1.2, &#8220;Loading persistent entities as read-only&#8221;</a> for details
                </p></li><li><p>
                    you can make an HQL query or criteria read-only so
                    that entities loaded when the query or criteria executes,
                    or iterates, are automatically 
                    made read-only; see <a href="#readonly-api-querycriteria" title="11.1.3.&nbsp;Loading read-only entities from an HQL query/criteria">Section&nbsp;11.1.3, &#8220;Loading read-only entities from an HQL query/criteria&#8221;</a> for details
                </p></li><li><p>
                    you can make a persistent entity that is already in the
                    in the session read-only; see 
                    <a href="#readonly-api-entity" title="11.1.4.&nbsp;Making a persistent entity read-only">Section&nbsp;11.1.4, &#8220;Making a persistent entity read-only&#8221;</a> for details
                </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="readonly-api-immutable"></a>11.1.1.&nbsp;Entities of immutable classes</h3></div></div><div></div></div><p>
                When an entity instance of an immutable class is made 
                persistent, NHibernate automatically makes it read-only. 
            </p><p>
                An entity of an immutable class can created
                and deleted the same as an entity of a mutable class.
            </p><p>
                NHibernate treats a persistent entity of an immutable 
                class the same way as a read-only persistent entity
                of a mutable class. The only exception is that 
                NHibernate will not allow an entity of an immutable
                class to be changed so it is not read-only.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="readonly-api-loaddefault"></a>11.1.2.&nbsp;Loading persistent entities as read-only</h3></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Entities of immutable classes are automatically loaded
                    as read-only.
                </p></div><p>
                To change the default behavior so NHibernate loads entity 
                instances of mutable classes into the session and automatically 
                makes them read-only, call:
            </p><pre class="programlisting">Session.DefaultReadOnly = true;</pre><p>
                To change the default back so entities loaded by NHibernate are not
                made read-only, call:
            </p><pre class="programlisting">Session.DefaultReadOnly = false;</pre><p>
                You can determine the current setting by using the property:
            </p><pre class="programlisting">Session.DefaultReadOnly;</pre><p> 
                If <tt class="literal">Session.DefaultReadOnly</tt> property returns true, entities loaded by
                the following are automatically made read-only:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        Session.Load() and Session.Load&lt;T&gt;
                    </p></li><li><p>
                        Session.Get() and Session.Get&lt;T&gt;
                    </p></li><li><p>
                        Session.Merge()
                    </p></li><li><p>
                        executing, or iterating HQL queries and 
                        criteria; to override this setting for a particular
                        HQL query or criteria see 
                        <a href="#readonly-api-querycriteria" title="11.1.3.&nbsp;Loading read-only entities from an HQL query/criteria">Section&nbsp;11.1.3, &#8220;Loading read-only entities from an HQL query/criteria&#8221;</a> 
                    </p></li></ul></div><p>
                Changing this default has no effect on:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        persistent entities already in the session when the 
                        default was changed
                    </p></li><li><p>
                        persistent entities that are refreshed via
                        <tt class="literal">Session.Refresh()</tt>; a refreshed persistent
                        entity will only be read-only if it was 
                        read-only before refreshing
                    </p></li><li><p>
                        persistent entities added by the application via
                        <tt class="literal">Session.Persist()</tt>, <tt class="literal">Session.Save()</tt>,
                        <tt class="literal">Session.Update()</tt> and <tt class="literal">Session.SaveOrUpdate()</tt>
                    </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="readonly-api-querycriteria"></a>11.1.3.&nbsp;Loading read-only entities from an HQL query/criteria</h3></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Entities of immutable classes are automatically loaded
                    as read-only.
                </p></div><p>
                If <tt class="literal">Session.DefaultReadOnly</tt> returns false (the default)
                when an HQL query or criteria executes, then entities 
                and proxies of mutable classes loaded by the query will 
                not be read-only.
            </p><p>
                You can override this behavior so that entities and proxies loaded 
                by an HQL query or criteria are automatically made read-only. 
            </p><p>
                For an HQL query, call:
            </p><pre class="programlisting">Query.SetReadOnly(true);</pre><p>
                <tt class="literal">Query.SetReadOnly(true)</tt> must be called before
                <tt class="literal">Query.List()</tt>, <tt class="literal">Query.UniqueResult()</tt>, or <tt class="literal">Query.Enumerable()</tt>
            </p><p>
                For an HQL criteria, call:
            </p><pre class="programlisting">Criteria.SetReadOnly(true);</pre><p>
                <tt class="literal">Criteria.SetReadOnly(true)</tt> must be called before
                <tt class="literal">Criteria.List()</tt>, or <tt class="literal">Criteria.UniqueResult()</tt>
            </p><p>
                Entities and proxies that exist in the session before being returned
                by an HQL query or criteria are not affected.
            </p><p>
                Uninitialized persistent collections returned by the query are 
                not affected. Later, when the collection is initialized,
                entities loaded into the session will be read-only if 
                <tt class="literal">Session.DefaultReadOnly</tt> returns true.
            </p><p>
                Using <tt class="literal">Query.SetReadOnly(true)</tt> or
                <tt class="literal">Criteria.SetReadOnly(true)</tt> works well
                when a single HQL query or criteria loads all the entities and 
                initializes all the proxies and collections that the application
                needs to be read-only.
            </p><p>
                When it is not possible to load and initialize all 
                necessary entities in a single query or criteria,
                you can temporarily change the session default to load
                entities as read-only before the query is executed.
                Then you can explicitly initialize proxies and collections 
                before restoring the session default.
            </p><pre class="programlisting">using (ISession session = factory.OpenSession())
using (ITransaction tx = session.BeginTransaction())
{
    session.DefaultReadOnly = true;
    Contract contract = session
        .CreateQuery("from Contract where CustomerName = 'Sherman'")
        .UniqueResult&lt;Contract&gt;();
    NHibernate.Initialize(contract.Plan);
    NHibernate.Initialize(contract.Variations);
    NHibernate.Initialize(contract.Notes);
    session.DefaultReadOnly = false;
    ...
    tx.Commit();
}</pre><p>
                If <tt class="literal">Session.DefaultReadOnly</tt> returns true, then you can
                use Query.SetReadOnly(false) and Criteria.SetReadOnly(false)
                to override this session setting and load entities that are 
                not read-only.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="readonly-api-entity"></a>11.1.4.&nbsp;Making a persistent entity read-only</h3></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Persistent entities of immutable classes are automatically
                    made read-only.
                </p></div><p>
                To make a persistent entity or proxy read-only, call:
            </p><pre class="programlisting">Session.SetReadOnly(entityOrProxy, true)</pre><p>
                To change a read-only entity or proxy of a mutable class so 
                it is no longer read-only, call:
            </p><pre class="programlisting">Session.SetReadOnly(entityOrProxy, false)</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                    When a read-only entity or proxy is changed so it is no longer 
                    read-only, NHibernate assumes that the current state of the 
                    read-only entity is consistent with its database representation. 
                    If this is not true, then any non-flushed changes made before
                    or while the entity was read-only, will be ignored.
                </p></div><p>        
                To throw away non-flushed changes and make the persistent entity 
                consistent with its database representation, call:
            </p><pre class="programlisting">Session.Refresh(entity);</pre><p>
                To flush changes made before or while the entity
                was read-only and make the database representation 
                consistent with the current state of the persistent
                entity:
            </p><pre class="programlisting">// evict the read-only entity so it is detached
session.Evict(entity);

// make the detached entity (with the non-flushed changes) persistent
session.Update(entity);

// now entity is no longer read-only and its changes can be flushed
s.Flush();</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="readonly-proptypes"></a>11.2.&nbsp;Read-only affect on property type</h2></div></div><div></div></div><p>
            The following table summarizes how different property types are 
            affected by making an entity read-only.
        </p><div class="table"><a name="readonly-proptype-summary"></a><p class="title"><b>Table&nbsp;11.1.&nbsp;Affect of read-only entity on property types</b></p><table summary="Affect of read-only entity on property types" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property/Association Type</th><th>Changes flushed to DB?</th></tr></thead><tbody><tr><td>
                            Simple
                            <p>
                                (<a href="#readonly-proptypes-simple" title="11.2.1.&nbsp;Simple properties">Section&nbsp;11.2.1, &#8220;Simple properties&#8221;</a>)
                            </p></td><td>no*</td></tr><tr><td><p>Unidirectional one-to-one</p><p>Unidirectional many-to-one</p><p>
                                (<a href="#readonly-proptypes-singleended-unidir" title="11.2.2.1.&nbsp;Unidirectional one-to-one and many-to-one">Section&nbsp;11.2.2.1, &#8220;Unidirectional one-to-one and many-to-one&#8221;</a>)
                            </p></td><td><p>no*</p><p>no*</p></td></tr><tr><td><p>Unidirectional one-to-many</p><p>Unidirectional many-to-many</p><p>
                                (<a href="#readonly-proptypes-manyended-unidir" title="11.2.2.2.&nbsp;Unidirectional one-to-many and many-to-many">Section&nbsp;11.2.2.2, &#8220;Unidirectional one-to-many and many-to-many&#8221;</a>)
                            </p></td><td><p>yes</p><p>yes</p></td></tr><tr><td><p>Bidirectional one-to-one</p><p>
                                (<a href="#readonly-proptypes-onetoone-bidir" title="11.2.3.1.&nbsp;Bidirectional one-to-one">Section&nbsp;11.2.3.1, &#8220;Bidirectional one-to-one&#8221;</a>)
                            </p></td><td>only if the owning entity is not read-only*</td></tr><tr><td><p>Bidirectional one-to-many/many-to-one</p><p>inverse collection</p><p>non-inverse collection</p><p>
                                (<a href="#readonly-proptypes-onetomany-manytoone" title="11.2.3.2.&nbsp;Bidirectional one-to-many/many-to-one">Section&nbsp;11.2.3.2, &#8220;Bidirectional one-to-many/many-to-one&#8221;</a>)
                            </p></td><td><p> </p><p>only added/removed entities that are not read-only*</p><p>yes</p></td></tr><tr><td><p>Bidirectional many-to-many</p><p>
                                (<a href="#readonly-proptypes-manytomany-bidir" title="11.2.3.3.&nbsp;Bidirectional many-to-many">Section&nbsp;11.2.3.3, &#8220;Bidirectional many-to-many&#8221;</a>)
                            </p></td><td>yes</td></tr></tbody></table></div><p>
            * Behavior is different when the entity having the property/association
              is read-only, compared to when it is not read-only.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="readonly-proptypes-simple"></a>11.2.1.&nbsp;Simple properties</h3></div></div><div></div></div><p>
                When a persistent object is read-only, NHibernate does not 
                dirty-check simple properties.
            </p><p>
                NHibernate will not synchronize simple property state changes 
                to the database. If you have automatic versioning, NHibernate 
                will not increment the version if any simple properties change.
            </p><pre class="programlisting">using (ISession session = factory.OpenSession())
using (ITransaction tx = session.BeginTransaction())
{
    // get a contract and make it read-only
    Contract contract = session.Get&lt;Contract&gt;(contractId);
    session.SetReadOnly(contract, true);

    // contract.CustomerName is "Sherman"
    contract.CustomerName = "Yogi";
    tx.Commit();

    tx = session.BeginTransaction();

    contract = session.Get&lt;Contract&gt;(contractId);
    // contract.CustomerName is still "Sherman"
    ...
    tx.Commit();
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="readonly-prop-types-unidir"></a>11.2.2.&nbsp;Unidirectional associations</h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="readonly-proptypes-singleended-unidir"></a>11.2.2.1.&nbsp;Unidirectional one-to-one and many-to-one</h4></div></div><div></div></div><p>
                    NHibernate treats unidirectional one-to-one and many-to-one
                    associations in the same way when the owning entity is 
                    read-only. 
                </p><p>
                    We use the term <span class="emphasis"><em>unidirectional single-ended 
                    association</em></span> when referring to functionality
                    that is common to unidirectional one-to-one and many-to-one
                    associations.
                </p><p>
                    NHibernate does not dirty-check unidirectional single-ended
                    associations when the owning entity is read-only. 
                </p><p>
                    If you change a read-only entity's reference to a 
                    unidirectional single-ended association to null,
                    or to refer to a different entity, that change
                    will not be flushed to the database. 
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        If an entity is of an immutable class,
                        then its references to unidirectional single-ended
                        associations must be assigned when that 
                        entity is first created. Because the entity is
                        automatically made read-only, these references can
                        not be updated.
                    </p></div><p>
                    If automatic versioning is used, NHibernate will not 
                    increment the version due to local changes to 
                    unidirectional single-ended associations.
                </p><p>
                    In the following examples, Contract has a unidirectional 
                    many-to-one association with Plan. Contract cascades save and
                    update operations to the association.
                </p><p>
                    The following shows that changing a read-only entity's 
                    many-to-one association reference to null has no effect
                    on the entity's database representation.
                </p><pre class="programlisting">// get a contract with an existing plan;
// make the contract read-only and set its plan to null
using (var tx = session.BeginTransaction())
{
    Contract contract = session.Get&lt;Contract&gt;(contractId);
    session.SetReadOnly(contract, true);
    contract.Plan = null;
    tx.Commit();
}

// get the same contract
using (var tx = session.BeginTransaction())
{
    Contract contract = session.Get&lt;Contract&gt;(contractId);

    // contract.Plan still refers to the original plan;

    tx.Commit();
}
session.Close();</pre><p>
                    The following shows that, even though
                    an update to a read-only entity's many-to-one 
                    association has no affect on the entity's 
                    database representation, flush still cascades 
                    the save-update operation to the locally
                    changed association.
                </p><pre class="programlisting">// get a contract with an existing plan;
// make the contract read-only and change to a new plan
Contract contract;
Plan newPlan;
using (var tx = session.BeginTransaction())
{
    contract = session.Get&lt;Contract&gt;(contractId);
    session.SetReadOnly(contract, true);
    newPlan = new Plan("new plan");
    contract.Plan = newPlan;
    tx.Commit();
}

// get the same contract
using (var tx = session.BeginTransaction())
{
    contract = session.Get&lt;Contract&gt;(contractId);
    newPlan = session.Get&lt;Plan&gt;(newPlan.Id);

    // contract.Plan still refers to the original plan;
    // newPlan is non-null because it was persisted when
    // the previous transaction was committed;

    tx.Commit();
}
session.Close();</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="readonly-proptypes-manyended-unidir"></a>11.2.2.2.&nbsp;Unidirectional one-to-many and many-to-many</h4></div></div><div></div></div><p>
                    NHibernate treats unidirectional one-to-many 
                    and many-to-many associations owned by a read-only
                    entity the same as when owned by an entity that is not 
                    read-only.
                </p><p>
                    NHibernate dirty-checks unidirectional one-to-many and 
                    many-to-many associations;
                </p><p>
                    The collection can contain entities that 
                    are read-only, as well as entities
                    that are not read-only.
                </p><p> 
                    Entities can be added and removed from the
                    collection; changes are flushed to the database.
                </p><p> 
                    If automatic versioning is used, NHibernate will 
                    update the version due to changes in the collection
                    if they dirty the owning entity.
                </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="readonly-proptypes-bidir"></a>11.2.3.&nbsp;Bidirectional associations</h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="readonly-proptypes-onetoone-bidir"></a>11.2.3.1.&nbsp;Bidirectional one-to-one</h4></div></div><div></div></div><p>
                    If a read-only entity owns a bidirectional 
                    one-to-one association:
                </p><div class="itemizedlist"><ul type="disc"><li><p>
                            NHibernate does not dirty-check the association. 
                        </p></li><li><p>
                            updates that change the association reference 
                            to null or to refer to a different entity
                            will not be flushed to the database. 
                        </p></li><li><p>
                            If automatic versioning is used, NHibernate will not 
                            increment the version due to local changes to 
                            the association.
                       </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        If an entity is of an immutable class,
                        and it owns a bidirectional one-to-one
                        association, then its reference must be
                        assigned when that entity is first created. 
                        Because the entity is automatically made 
                        read-only, these references cannot be updated.
                    </p></div><p>
                    When the owner is not read-only, NHibernate treats 
                    an association with a read-only entity the same
                    as when the association is with an entity that is
                    not read-only.
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="readonly-proptypes-onetomany-manytoone"></a>11.2.3.2.&nbsp;Bidirectional one-to-many/many-to-one</h4></div></div><div></div></div><p>
                    A read-only entity has no impact on a bidirectional
                    one-to-many/many-to-one association if:
                </p><div class="itemizedlist"><ul type="disc"><li><p>
                            the read-only entity is on the one-to-many side
                            using an inverse collection;
                        </p></li><li><p>
                            the read-only entity is on the one-to-many side
                            using a non-inverse collection;                            
                        </p></li><li><p>
                            the one-to-many side uses a non-inverse collection 
                            that contains the read-only entity
                       </p></li></ul></div><p>
                    When the one-to-many side uses an inverse collection:
                </p><div class="itemizedlist"><ul type="disc"><li><p>
                            a read-only entity can only be added to the collection
                            when it is created;
                        </p></li><li><p>
                            a read-only entity can only be removed from the
                            collection by an orphan delete or by explicitly
                            deleting the entity.                            
                        </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="readonly-proptypes-manytomany-bidir"></a>11.2.3.3.&nbsp;Bidirectional many-to-many</h4></div></div><div></div></div><p>
                    NHibernate treats bidirectional many-to-many 
                    associations owned by a read-only entity the
                    same as when owned by an entity that is not
                    read-only.
                </p><p>
                    NHibernate dirty-checks bidirectional many-to-many 
                    associations.
                </p><p> 
                    The collection on either side of the association
                    can contain entities that are read-only, as well
                    as entities that are not read-only.
                </p><p> 
                    Entities are added and removed from both sides 
                    of the collection; changes are flushed to the 
                    database.
                </p><p> 
                    If automatic versioning is used, NHibernate will 
                    update the version due to changes in both sides of
                    the collection if they dirty the entity owning the
                    respective collections.
                </p></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="transactions"></a>Chapter&nbsp;12.&nbsp;Transactions And Concurrency</h2></div></div><div></div></div><p>
        NHibernate is not itself a database. It is a lightweight object-relational
        mapping tool. Transaction management is delegated to the underlying database
        connection. If the connection is enlisted with a distributed transaction,
        operations performed by the <tt class="literal">ISession</tt> are atomically part
        of the wider distributed transaction. NHibernate can be seen as a thin adapter
        to ADO.NET, adding object-oriented semantics.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-basics"></a>12.1.&nbsp;Configurations, Sessions and Factories</h2></div></div><div></div></div><p>
            An <tt class="literal">ISessionFactory</tt> is an expensive-to-create, threadsafe object 
            intended to be shared by all application threads. An <tt class="literal">ISession</tt> 
            is an inexpensive, non-threadsafe object that should be used once, for a single
            business process, and then discarded. For example, when using NHibernate in an
            ASP.NET application, pages could obtain an <tt class="literal">ISessionFactory</tt> 
            using:
        </p><pre class="programlisting">ISessionFactory sf = Global.SessionFactory;</pre><p>
            Each call to a service method could create a new <tt class="literal">ISession</tt>,
            <tt class="literal">Flush()</tt> it, <tt class="literal">Commit()</tt> its transaction,
            <tt class="literal">Close()</tt> it and finally discard it. (The <tt class="literal">ISessionFactory</tt>
            may also be kept in a static <span class="emphasis"><em>Singleton</em></span> helper variable.)
        </p><p>
            We use the NHibernate <tt class="literal">ITransaction</tt> API as discussed previously,
            a single <tt class="literal">Commit()</tt> of a NHibernate <tt class="literal">ITransaction</tt>
            flushes the state and commits any underlying database connection. Transaction scopes
            can be used instead, which allows the transaction to be distributed. See
            <a href="#transactions-scopes" title="12.8.&nbsp;Transaction scopes (System.Transactions)">Section&nbsp;12.8, &#8220;Transaction scopes (System.Transactions)&#8221;</a>.
        </p><p>
            NHibernate may be used without managing transactions neither with the
            <tt class="literal">ITransaction</tt> API nor with transaction scopes. We advise against
            such a pattern, because this causes each single interaction of the session with the
            database to be a transaction on its own. This causes overhead, breaks the unit of
            work in case of errors during flushing, and causes some features to be disabled like
            auto-flush and second level cache. If the application encounters locks contention or
            deadlocks, investigate lowering the isolation level (like enabling read committed
            snapshot with SQL Server) or shortening your transactions rather than removing them.
        </p><p>
            Ensure you understand the semantics of <tt class="literal">Flush()</tt>.
            Flushing synchronizes the persistent store with in-memory changes but
            <span class="emphasis"><em>not</em></span> vice-versa. Note that for all NHibernate ADO.NET
            connections/transactions, the transaction isolation level for that connection
            applies to all operations executed by NHibernate!
        </p><p>
            The next few sections will discuss alternative approaches that utilize versioning
            to ensure transaction atomicity. These are considered "advanced" approaches to
            be used with care.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-threads"></a>12.2.&nbsp;Threads and connections</h2></div></div><div></div></div><p>
            You should observe the following practices when creating NHibernate Sessions:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Never create more than one concurrent <tt class="literal">ISession</tt> or
                    <tt class="literal">ITransaction</tt> instance per database connection.
                </p></li><li><p>
                    Be extremely careful when creating more than one <tt class="literal">ISession</tt>
                    per database per transaction. The <tt class="literal">ISession</tt> itself keeps
                    track of updates made to loaded objects, so a different <tt class="literal">ISession</tt>
                    might see stale data.
                </p></li><li><p>
                    The <tt class="literal">ISession</tt> is <span class="emphasis"><em>not</em></span> threadsafe!
                    Never access the same <tt class="literal">ISession</tt> in two concurrent threads.
                    An <tt class="literal">ISession</tt> is usually only a single unit-of-work!
                </p><p>
                    Since NHibernate 5.0, the session and its queries IO bound methods have async counterparts.
                    Each call to an async method must be awaited before further interacting with the session or
                    its queries.
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-identity"></a>12.3.&nbsp;Considering object identity</h2></div></div><div></div></div><p>
            The application may concurrently access the same persistent state in two
            different units-of-work. However, an instance of a persistent class is never shared
            between two <tt class="literal">ISession</tt> instances. Hence there are
            two different notions of identity:
        </p><div class="variablelist"><dl><dt><span class="term">Database Identity</span></dt><dd><p>
                        <tt class="literal">foo.Id.Equals( bar.Id )</tt>
                    </p></dd><dt><span class="term">CLR Identity</span></dt><dd><p>
                        <tt class="literal">foo == bar</tt>
                    </p></dd></dl></div><p>
            Then for objects attached to a <span class="emphasis"><em>particular</em></span> <tt class="literal">Session</tt>,
            the two notions are equivalent. However, while the application might concurrently access
            the "same" (persistent identity) business object in two different sessions, the two
            instances will actually be "different" (CLR identity).
        </p><p>
            This approach leaves NHibernate and the database to worry about concurrency. The
            application never needs to synchronize on any business object, as long as it sticks to a
            single thread per <tt class="literal">ISession</tt> or object identity (within an
            <tt class="literal">ISession</tt> the application may safely use <tt class="literal">==</tt> to
            compare objects).
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-optimistic"></a>12.4.&nbsp;Optimistic concurrency control</h2></div></div><div></div></div><p>
            Many business processes require a whole series of interactions with the user
            interleaved with database accesses. In web and enterprise applications it is
            not acceptable for a database transaction to span a user interaction.
        </p><p>
            Maintaining isolation of business processes becomes the partial responsibility
            of the application tier, hence we call this process a long running
            <span class="emphasis"><em>application transaction</em></span>. A single application transaction
            usually spans several database transactions. It will be atomic if only one of
            these database transactions (the last one) stores the updated data, all others
            simply read data.
        </p><p>
            The only approach that is consistent with high concurrency and high
            scalability is optimistic concurrency control with versioning. NHibernate
            provides for three possible approaches to writing application code that
            uses optimistic concurrency.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-longsession"></a>12.4.1.&nbsp;Long session with automatic versioning</h3></div></div><div></div></div><p>
                A single <tt class="literal">ISession</tt> instance and its persistent instances are
                used for the whole application transaction.
            </p><p>
                The <tt class="literal">ISession</tt> uses optimistic locking with versioning to
                ensure that many database transactions appear to the application as a single
                logical application transaction. The <tt class="literal">ISession</tt> is disconnected
                from any underlying ADO.NET connection when waiting for user interaction. This
                approach is the most efficient in terms of database access. The application
                need not concern itself with version checking or with reattaching detached
                instances.
            </p><pre class="programlisting">// foo is an instance loaded earlier by the Session
session.Reconnect();
using (var transaction = session.BeginTransaction())
{
    foo.Property = "bar";
    session.Flush();
    transaction.Commit();
}
session.Disconnect();</pre><p>
                The <tt class="literal">foo</tt> object still knows which <tt class="literal">ISession</tt>
                it was loaded it. As soon as the <tt class="literal">ISession</tt> has an ADO.NET connection,
                we commit the changes to the object.
            </p><p>
                This pattern is problematic if our <tt class="literal">ISession</tt> is too big to
                be stored during user think time, e.g. an <tt class="literal">HttpSession</tt> should
                be kept as small as possible. As the <tt class="literal">ISession</tt> is also the
                (mandatory) first-level cache and contains all loaded objects, we can probably
                use this strategy only for a few request/response cycles. This is indeed
                recommended, as the <tt class="literal">ISession</tt> will soon also have stale data.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-detached"></a>12.4.2.&nbsp;Many sessions with automatic versioning</h3></div></div><div></div></div><p>
                Each interaction with the persistent store occurs in a new <tt class="literal">ISession</tt>. 
                However, the same persistent instances are reused for each interaction with the database.
                The application manipulates the state of detached instances originally loaded in another
                <tt class="literal">ISession</tt> and then "re-associates" them using 
                <tt class="literal">ISession.Update()</tt> or <tt class="literal">ISession.SaveOrUpdate()</tt>.
            </p><pre class="programlisting">// foo is an instance loaded by a previous Session
foo.Property = "bar";
using (var session = factory.OpenSession())
using (var transaction = session.BeginTransaction())
{
    session.SaveOrUpdate(foo);
    session.Flush();
    transaction.Commit();
}</pre><p>
                You may also call <tt class="literal">Lock()</tt> instead of <tt class="literal">Update()</tt>
                and use <tt class="literal">LockMode.Read</tt> (performing a version check, bypassing all
                caches) if you are sure that the object has not been modified.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-customizing"></a>12.4.3.&nbsp;Customizing automatic versioning</h3></div></div><div></div></div><p>
                You may disable NHibernate's automatic version increment for particular properties and 
                collections by setting the <tt class="literal">optimistic-lock</tt> mapping attribute to 
                <tt class="literal">false</tt>. NHibernate will then no longer increment versions if the 
                property is dirty.
            </p><p>
                Legacy database schemas are often static and can't be modified. Or, other applications
                might also access the same database and don't know how to handle version numbers or
                even timestamps. In both cases, versioning can't rely on a particular column in a table.
                To force a version check without a version or timestamp property mapping, with a
                comparison of the state of all fields in a row, turn on <tt class="literal">optimistic-lock="all"</tt>
                in the <tt class="literal">&lt;class&gt;</tt> mapping. Note that this conceptually only works
                if NHibernate can compare the old and new state, i.e. if you use a single long
                <tt class="literal">ISession</tt> and not session-per-request-with-detached-objects.
            </p><p>
                Sometimes concurrent modification can be permitted as long as the changes that have been
                made don't overlap. If you set <tt class="literal">optimistic-lock="dirty"</tt> when mapping the
                <tt class="literal">&lt;class&gt;</tt>, NHibernate will only compare dirty fields during flush.
            </p><p>
                In both cases, with dedicated version/timestamp columns or with full/dirty field
                comparison, NHibernate uses a single <tt class="literal">UPDATE</tt> statement (with an
                appropriate <tt class="literal">WHERE</tt> clause) per entity to execute the version check
                and update the information. If you use transitive persistence to cascade reattachment
                to associated entities, NHibernate might execute unnecessary updates. This is usually
                not a problem, but <span class="emphasis"><em>on update</em></span> triggers in the database might be
                executed even when no changes have been made to detached instances. You can customize
                this behavior by setting  <tt class="literal">select-before-update="true"</tt> in the
                <tt class="literal">&lt;class&gt;</tt> mapping, forcing NHibernate to <tt class="literal">SELECT</tt>
                the instance to ensure that changes did actually occur, before updating the row.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-manual"></a>12.4.4.&nbsp;Application version checking</h3></div></div><div></div></div><p>
                Each interaction with the database occurs in a new <tt class="literal">ISession</tt>
                that reloads all persistent instances from the database before manipulating them.
                This approach forces the application to carry out its own version checking to ensure 
                application transaction isolation. (Of course, NHibernate will still <span class="emphasis"><em>update</em></span>
                version numbers for you.) This approach is the least efficient in terms of database access.
            </p><pre class="programlisting">// foo is an instance loaded by a previous Session
using (var session = factory.OpenSession())
using (var transaction = session.BeginTransaction())
{
    int oldVersion = foo.Version;
    session.Load( foo, foo.Key );
    if ( oldVersion != foo.Version ) throw new StaleObjectStateException();
    foo.Property = "bar";
    session.Flush();
    transaction.Commit();
}</pre><p>
                Of course, if you are operating in a low-data-concurrency environment and don't
                require version checking, you may use this approach and just skip the version
                check.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-disconnection"></a>12.5.&nbsp;Session disconnection</h2></div></div><div></div></div><p>
            The first approach described above is to maintain a single <tt class="literal">ISession</tt> 
            for a whole business process that spans user think time. (For example, a servlet might 
            keep an <tt class="literal">ISession</tt> in the user's <tt class="literal">HttpSession</tt>.) For 
            performance reasons you should
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    commit the <tt class="literal">ITransaction</tt> and then
                </p></li><li><p>
                    disconnect the <tt class="literal">ISession</tt> from the ADO.NET connection
                </p></li></ol></div><p>
            before waiting for user activity. The method <tt class="literal">ISession.Disconnect()</tt> 
            will disconnect the session from the ADO.NET connection and return the connection to 
            the pool (unless you provided the connection).
        </p><p>
            <tt class="literal">ISession.Reconnect()</tt> obtains a new connection (or you may supply one) 
            and restarts the session. After reconnection, to force a version check on data you aren't 
            updating, you may call <tt class="literal">ISession.Lock()</tt> on any objects that might have
            been updated by another transaction. You don't need to lock any data that you
            <span class="emphasis"><em>are</em></span> updating.
        </p><p>
            Here is an example:
        </p><pre class="programlisting">ISessionFactory sessions;
IList&lt;Foo&gt; fooList;
Bar bar;
....
ISession s = sessions.OpenSession();
ITransaction tx = null;

try
{
    tx = s.BeginTransaction())

    fooList = s
        .CreateQuery(
            "select foo from Eg.Foo foo where foo.Date = current date"
            // uses db2 date function
        ).List&lt;Foo&gt;();

    bar = new Bar();
    s.Save(bar);

    tx.Commit();
}
catch (Exception)
{
    if (tx != null) tx.Rollback();
    s.Close();
    throw;
}
s.Disconnect();</pre><p>
            Later on:
        </p><pre class="programlisting">s.Reconnect();

try
{
    tx = s.BeginTransaction();

    bar.FooTable = new HashMap();
    foreach (Foo foo in fooList)
    {
        s.Lock(foo, LockMode.Read);    //check that foo isn't stale
        bar.FooTable.Put( foo.Name, foo );
    }

    tx.Commit();
}
catch (Exception)
{
    if (tx != null) tx.Rollback();
    throw;
}
finally
{
    s.Close();
}</pre><p>
            You can see from this how the relationship between <tt class="literal">ITransaction</tt>s and
            <tt class="literal">ISession</tt>s is many-to-one, An <tt class="literal">ISession</tt> represents a 
            conversation between the application and the database. The
            <tt class="literal">ITransaction</tt> breaks that conversation up into atomic units of work
            at the database level.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-locking"></a>12.6.&nbsp;Pessimistic Locking</h2></div></div><div></div></div><p>
            It is not intended that users spend much time worrying about locking strategies. It's usually
            enough to specify an isolation level for the ADO.NET connections and then simply let the
            database do all the work. However, advanced users may sometimes wish to obtain
            exclusive pessimistic locks, or re-obtain locks at the start of a new transaction.
        </p><p>
            NHibernate will always use the locking mechanism of the database, never lock objects
            in memory!
        </p><p>
            The <tt class="literal">LockMode</tt> class defines the different lock levels that may be acquired
            by NHibernate. A lock is obtained by the following mechanisms:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">LockMode.Write</tt> is acquired automatically when NHibernate updates or inserts 
                    a row. 
                </p></li><li><p>
                    <tt class="literal">LockMode.Upgrade</tt> may be acquired upon explicit user request using 
                    <tt class="literal">SELECT ... FOR UPDATE</tt> on databases which support that syntax.
                </p></li><li><p>
                    <tt class="literal">LockMode.UpgradeNoWait</tt> may be acquired upon explicit user request using a 
                    <tt class="literal">SELECT ... FOR UPDATE NOWAIT</tt> under Oracle.
                </p></li><li><p>
                    <tt class="literal">LockMode.Read</tt> is acquired automatically when NHibernate reads data
                    under Repeatable Read or Serializable isolation level. May be re-acquired by explicit user 
                    request.
                </p></li><li><p>
            <tt class="literal">LockMode.None</tt> represents the absence of a lock. All objects switch to this
            lock mode at the end of an <tt class="literal">ITransaction</tt>. Objects associated with the session 
            via a call to <tt class="literal">Update()</tt> or <tt class="literal">SaveOrUpdate()</tt> also start out 
            in this lock mode.
        </p></li></ul></div><p>
            The "explicit user request" is expressed in one of the following ways:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    A call to <tt class="literal">ISession.Load()</tt>, specifying a <tt class="literal">LockMode</tt>.
                </p></li><li><p>
                    A call to <tt class="literal">ISession.Lock()</tt>.
                </p></li><li><p>
                    A call to <tt class="literal">IQuery.SetLockMode()</tt>.
                </p></li></ul></div><p>
            If <tt class="literal">ISession.Load()</tt> is called with <tt class="literal">Upgrade</tt> or
            <tt class="literal">UpgradeNoWait</tt>, and the requested object was not yet loaded by
            the session, the object is loaded using <tt class="literal">SELECT ... FOR UPDATE</tt>.
            If <tt class="literal">Load()</tt> is called for an object that is already loaded with
            a less restrictive lock than the one requested, NHibernate calls 
            <tt class="literal">Lock()</tt> for that object.
        </p><p>
            <tt class="literal">ISession.Lock()</tt> performs a version number check if the specified lock
            mode is <tt class="literal">Read</tt>, <tt class="literal">Upgrade</tt> or 
            <tt class="literal">UpgradeNoWait</tt>. (In the case of <tt class="literal">Upgrade</tt> or
            <tt class="literal">UpgradeNoWait</tt>, <tt class="literal">SELECT ... FOR UPDATE</tt> is used.)
        </p><p>
            If the database does not support the requested lock mode, NHibernate will use an appropriate
            alternate mode (instead of throwing an exception). This ensures that applications will
            be portable.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-connection-release"></a>12.7.&nbsp;Connection Release Modes</h2></div></div><div></div></div><p>
            The legacy (1.0.x) behavior of NHibernate in regards to ADO.NET connection management
            was that a <tt class="literal">ISession</tt> would obtain a connection when it was first
            needed and then hold unto that connection until the session was closed.
            NHibernate introduced the notion of connection release modes to tell a session
            how to handle its ADO.NET connections.  Note that the following discussion is pertinent
            only to connections provided through a configured <tt class="literal">IConnectionProvider</tt>;
            user-supplied connections are outside the breadth of this discussion.  The different
            release modes are identified by the enumerated values of
            <tt class="literal">NHibernate.ConnectionReleaseMode</tt>:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">OnClose</tt> - is essentially the legacy behavior described above. The
                    NHibernate session obtains a connection when it first needs to perform some database
                    access and holds unto that connection until the session is closed.
                </p></li><li><p>
                    <tt class="literal">AfterTransaction</tt> - says to release connections after a
                    <tt class="literal">NHibernate.ITransaction</tt> has completed.
                </p></li></ul></div><p>
            The configuration parameter <tt class="literal">connection.release_mode</tt> is used
            to specify which release mode to use.  The possible values:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">auto</tt> (the default) - equivalent to <tt class="literal">after_transaction</tt>
                    in the current release. It is rarely a good idea to change this default behavior as failures
                    due to the value of this setting tend to indicate bugs and/or invalid assumptions in user code.
                </p></li><li><p>
                    <tt class="literal">on_close</tt> - says to use <tt class="literal">ConnectionReleaseMode.OnClose</tt>.
                    This setting is left for backwards compatibility, but its use is highly discouraged.
                </p></li><li><p>
                    <tt class="literal">after_transaction</tt> - says to use <tt class="literal">ConnectionReleaseMode.AfterTransaction</tt>.
                    Note that with <tt class="literal">ConnectionReleaseMode.AfterTransaction</tt>, if a session is considered to be in
                    auto-commit mode (i.e. no transaction was started) connections will be released after every operation.
                </p></li></ul></div><p>
            If your application manages transactions through .NET APIs such as <tt class="literal">System.Transactions</tt> library
            while not using a compatible transaction factory (see <tt class="literal">transaction.factory_class</tt>
            in <a href="#configuration-optional" title="3.6.&nbsp;Optional configuration properties">Section&nbsp;3.6, &#8220;Optional configuration properties&#8221;</a>), <tt class="literal">ConnectionReleaseMode.AfterTransaction</tt> may cause
            NHibernate to open and close several connections during one transaction, leading to unnecessary overhead and
            transaction promotion from local to distributed. Specifying <tt class="literal">ConnectionReleaseMode.OnClose</tt>
            will revert to the legacy behavior and prevent this problem from occurring.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-scopes"></a>12.8.&nbsp;Transaction scopes (System.Transactions)</h2></div></div><div></div></div><p>
            Instead of using NHibernate <tt class="literal">ITransaction</tt>, <tt class="literal">TransactionScope</tt>
            can be used. Please do not use both simultaneously. Using <tt class="literal">TransactionScope</tt>
            requires using a compatible transaction factory (see <tt class="literal">transaction.factory_class</tt>
            in <a href="#configuration-optional" title="3.6.&nbsp;Optional configuration properties">Section&nbsp;3.6, &#8220;Optional configuration properties&#8221;</a>). The default transaction factory supports scopes.
        </p><p>
            When using <tt class="literal">TransactionScope</tt> with NHibernate, you need to be aware of following
            points:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    The session will enlist with the first scope in which the session is used (or opened).
                    As of NHibernate v5.0, it will enlist its connection in the transaction regardless of
                    connection string <tt class="literal">Enlist</tt> setting. Prior to v5.0, it was relying on
                    that setting being considered <tt class="literal">true</tt>, and on acquiring the connection
                    within the scope.
                </p><p>
                    Sub-scopes are not supported. The session will be enlisted in the first scope within
                    which it was used, until this scope is committed or rollback. If auto-enlistment is
                    enabled on the connection and the session used on others scopes than the one in which
                    it is currently enlisted, the connection may enlist in another scope, and the session
                    will then fail to use it.
                </p><p>
                    Session auto-enlistment can be controlled from the session builder
                    obtained with <tt class="literal">ISessionFactory.WithOptions()</tt>, using the
                    <tt class="literal">AutoJoinTransaction</tt> option. It can also be controlled at the configuration level,
                    see <tt class="literal">transaction.auto_join</tt> in <a href="#configuration-optional" title="3.6.&nbsp;Optional configuration properties">Section&nbsp;3.6, &#8220;Optional configuration properties&#8221;</a>.
                    When auto-join is disabled, the connection may still enlist itself
                    if connection string <tt class="literal">Enlist</tt> setting is not <tt class="literal">false</tt>.
                    A session can explicitly join the current system transaction by calling
                    <tt class="literal">ISession.JoinTransaction()</tt>.
                </p></li><li><p>
                    As of NHibernate v5.0, <tt class="literal">FlushMode.Commit</tt> requires the configuration setting
                    <tt class="literal">transaction.use_connection_on_system_prepare</tt> to be true for flushing
                    from transaction scope commit. Otherwise, it will be your responsibility to flush the session
                    before completing the scope.
                </p><p>
                    Using <tt class="literal">transaction.use_connection_on_system_prepare</tt> can cause undesired
                    transaction promotions to distributed: it requires using a dedicated connection for flushing,
                    and it delays session disposal (if done inside the scope) to the scope disposal. If you want
                    to avoid this, set this setting to <tt class="literal">false</tt> and manually flush your sessions.
                </p><p>
                    For new applications, it is recommended to set
                    <tt class="literal">transaction.use_connection_on_system_prepare</tt> to <tt class="literal">false</tt>,
                    and to flush explicitly your sessions before scope completion. For old applications, consider
                    checking how sessions are flushed, and if possible switch it to <tt class="literal">false</tt> too.
                </p></li><li><p>
                    As of NHibernate v5.0, <tt class="literal">ConnectionReleaseMode.AfterTransaction</tt> has no more
                    by default an "immediate" effect with transaction scopes. Previously, it was releasing the
                    connection from transaction completion events. But this is not officially supported by
                    Microsoft and this can cause issues especially with distributed transactions.
                </p><p>
                    Since v5.0, by default, the connection will be actually released after the scope disposal at the
                    first session usage involving a connection, or at the session closing, whichever come first.
                    Alternatively, you may <tt class="literal">Disconnect()</tt> the session. (Requires
                    <tt class="literal">Reconnect()</tt> before re-using the session.)
                </p><p>
                    When using <tt class="literal">transaction.use_connection_on_system_prepare</tt>, if the session is
                    disposed within the scope, the connection releasing will still occurs from transaction
                    completion event.
                </p></li><li><p>
                    As of NHibernate v5.0, using transaction scope and trying to use the session connection within
                    <tt class="literal">AfterTransactionCompletion</tt> is forbidden and will raise an exception.
                    If the setting <tt class="literal">transaction.use_connection_on_system_prepare</tt>
                    is <tt class="literal">false</tt>, it will forbid any connection usage from
                    <tt class="literal">BeforeTransactionCompletion</tt> event too, when this event is triggered by
                    a transaction scope commit or rollback.
                </p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="events"></a>Chapter&nbsp;13.&nbsp;Interceptors and events</h2></div></div><div></div></div><p>
        It is often useful for the application to react to certain events that occur
        inside NHibernate. This allows implementation of certain kinds of generic 
        functionality, and extension of NHibernate functionality.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-interceptors"></a>13.1.&nbsp;Interceptors</h2></div></div><div></div></div><p>
            The <tt class="literal">IInterceptor</tt> interface provides callbacks from the session to the 
            application allowing the application to inspect and/or manipulate properties of a
            persistent object before it is saved, updated, deleted or loaded. One 
            possible use for this is to track auditing information. For example, the following 
            <tt class="literal">IInterceptor</tt> automatically sets the  <tt class="literal">createTimestamp</tt> 
            when an <tt class="literal">IAuditable</tt> is created and updates the 
            <tt class="literal">lastUpdateTimestamp</tt> property when an <tt class="literal">IAuditable</tt> is 
            updated.
        </p><p>
            You may either implement <tt class="literal">IInterceptor</tt> directly or (better) extend
            <tt class="literal">EmptyInterceptor</tt>.
        </p><pre class="programlisting">using System;
	
using NHibernate;
using NHibernate.Type;

public class AuditInterceptor : EmptyInterceptor {

    private int updates;
    private int creates;
    private int loads;

    public override void OnDelete(object entity,
                                  object id,
                                  object[] state,
                                  string[] propertyNames,
                                  IType[] types)
    {
        // do nothing
    }

    public override bool OnFlushDirty(object entity, 
                                      object id, 
                                      object[] currentState,
                                      object[] previousState,
                                      string[] propertyNames,
                                      IType[] types)
    {
        if ( entity is IAuditable ) {
            updates++;
            for ( int i=0; i &lt; propertyNames.Length; i++ ) {
                if ( "lastUpdateTimestamp".Equals( propertyNames[i] ) ) {
                    currentState[i] = new DateTime();
                    return true;
                }
            }
        }
        return false;
    }

    public override bool OnLoad(object entity, 
                                object id, 
                                object[] state,
                                string[] propertyNames,
                                IType[] types)
    {
        if ( entity is IAuditable ) {
            loads++;
        }
        return false;
    }

    public override bool OnSave(object entity, 
                                object id, 
                                object[] state,
                                string[] propertyNames,
                                IType[] types)
    {
        if ( entity is IAuditable ) {
            creates++;
            for ( int i=0; i&lt;propertyNames.Length; i++ ) {
                if ( "createTimestamp".Equals( propertyNames[i] ) ) {
                    state[i] = new DateTime();
                    return true;
                }
            }
        }
        return false;
    }

    public override void AfterTransactionCompletion(ITransaction tx)
    {
        if ( tx.WasCommitted ) {
            System.Console.WriteLine(
                "Creations: " + creates +
                ", Updates: " + updates +
                ", Loads: " + loads);
        }
        updates=0;
        creates=0;
        loads=0;
    }

}</pre><p>
            Interceptors come in two flavors: <tt class="literal">ISession</tt>-scoped and
            <tt class="literal">ISessionFactory</tt>-scoped.
        </p><p>
            An <tt class="literal">ISession</tt>-scoped interceptor is specified
            when a session is opened using one of the overloaded ISessionFactory.OpenSession()
            methods accepting an <tt class="literal">IInterceptor</tt>.
        </p><pre class="programlisting">ISession session = sf.OpenSession( new AuditInterceptor() );</pre><p>
            An <tt class="literal">ISessionFactory</tt>-scoped interceptor is registered with the <tt class="literal">Configuration</tt>
            object prior to building the <tt class="literal">ISessionFactory</tt>.  In this case, the supplied interceptor
            will be applied to all sessions opened from that <tt class="literal">ISessionFactory</tt>; this is true unless
            a session is opened explicitly specifying the interceptor to use.  <tt class="literal">ISessionFactory</tt>-scoped
            interceptors must be thread safe, taking care to not store session-specific state since multiple
            sessions will use this interceptor (potentially) concurrently.
        </p><pre class="programlisting">new Configuration().SetInterceptor( new AuditInterceptor() );</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-events"></a>13.2.&nbsp;Event system</h2></div></div><div></div></div><p>
            If you have to react to particular events in your persistence layer, you may
            also use the NHibernate2 <span class="emphasis"><em>event</em></span> architecture. The event
            system can be used in addition or as a replacement for interceptors.
        </p><p>
            Essentially all of the methods of the <tt class="literal">ISession</tt> interface correlate
            to an event. You have a <tt class="literal">LoadEvent</tt>, a <tt class="literal">FlushEvent</tt>, etc
            (consult the XML configuration-file XSD or the <tt class="literal">NHibernate.Event</tt>
            namespace for the full list of defined event types). When a request is made of one of
            these methods, the <tt class="literal">ISession</tt> generates an appropriate
            event and passes it to the configured event listeners for that type. Out-of-the-box,
            these listeners implement the same processing in which those methods always resulted.
            However, you are free to implement a customization of one of the listener interfaces
            (i.e., the <tt class="literal">LoadEvent</tt> is processed by the registered implementation
            of the <tt class="literal">ILoadEventListener</tt> interface), in which case their
            implementation would be responsible for processing any <tt class="literal">Load()</tt> requests
            made of the <tt class="literal">ISession</tt>.
        </p><p>
            The listeners should be considered effectively singletons; meaning, they are shared between
            requests, and thus should not save any state as instance variables.
        </p><p>
            A custom listener should implement the appropriate interface for the event it wants to
            process and/or extend one of the convenience base classes (or even the default event
            listeners used by NHibernate out-of-the-box as their methods are declared virtual for this
            purpose). Custom listeners can either be registered programmatically through the
            <tt class="literal">Configuration</tt> object, or specified in the NHibernate configuration
            XML. Here's an example of a custom load event listener:
        </p><pre class="programlisting">public class MyLoadListener : ILoadEventListener 
{
    // this is the single method defined by the LoadEventListener interface
    public void OnLoad(LoadEvent theEvent, LoadType loadType)
    {
        if ( !MySecurity.IsAuthorized( theEvent.EntityClassName, theEvent.EntityId ) ) {
            throw new MySecurityException("Unauthorized access");
        }
    }
}</pre><p>
            You also need a configuration entry telling NHibernate to use the listener in addition
            to the default listener:
        </p><pre class="programlisting">&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        ...
        &lt;event type="load"&gt;
            &lt;listener class="MyLoadListener"/&gt;
            &lt;listener class="NHibernate.Event.Default.DefaultLoadEventListener"/&gt;
        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</pre><p>
            Instead, you may register it programmatically:
        </p><pre class="programlisting">Configuration cfg = new Configuration();
ILoadEventListener[] stack =
    new ILoadEventListener[] { new MyLoadListener(), new DefaultLoadEventListener() };
cfg.EventListeners.LoadEventListeners = stack;</pre><p>
            Listeners registered declaratively cannot share instances. If the same class name is
            used in multiple <tt class="literal">&lt;listener/&gt;</tt> elements, each reference will
            result in a separate instance of that class. If you need the capability to share
            listener instances between listener types you must use the programmatic registration
            approach.
        </p><p>
            Why implement an interface and define the specific type during configuration? Well, a
            listener implementation could implement multiple event listener interfaces. Having the
            type additionally defined during registration makes it easier to turn custom listeners on
            or off during configuration.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="batch"></a>Chapter&nbsp;14.&nbsp;Batch processing</h2></div></div><div></div></div><p>
        A naive approach to inserting 100 000 rows in the database using NHibernate might 
        look like this:
    </p><pre class="programlisting">using (ISession session = sessionFactory.OpenSession())
using (ITransaction tx = session.BeginTransaction())
{
    for (int i = 0; i &lt; 100000; i++)
    {
        Customer customer = new Customer(.....);
        session.Save(customer);
    }
    tx.Commit();
}</pre><p>
        This would fall over with an <tt class="literal">OutOfMemoryException</tt> somewhere 
        around the 50 000th row. That's because NHibernate caches all the newly inserted 
        <tt class="literal">Customer</tt> instances in the session-level cache. 
    </p><p>
        In this chapter we'll show you how to avoid this problem. First, however, if you
        are doing batch processing, it is absolutely critical that you enable the use of
        ADO batching, if you intend to achieve reasonable performance. Set the ADO batch 
        size to a reasonable number (say, 10-50):
    </p><pre class="programlisting">adonet.batch_size 20</pre><p><a name="disablebatching"></a>
        Note that NHibernate disables insert batching at the ADO level transparently if you
        use an <tt class="literal">identity</tt> identifier generator.
    </p><p>
        You also might like to do this kind of work in a process where interaction with 
        the second-level cache is completely disabled:
    </p><pre class="programlisting">cache.use_second_level_cache false</pre><p>
        However, this is not absolutely necessary, since we can explicitly set the
        <tt class="literal">CacheMode</tt> to disable interaction with the second-level cache.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-inserts"></a>14.1.&nbsp;Batch inserts</h2></div></div><div></div></div><p>
            When making new objects persistent, you must <tt class="literal">Flush()</tt> and 
            then <tt class="literal">Clear()</tt> the session regularly, to control the size of
            the first-level cache.
        </p><pre class="programlisting">using (ISession session = sessionFactory.openSession())
using (ITransaction tx = session.BeginTransaction())
{
    for (int i = 0; i &lt; 100000; i++)
    {
        Customer customer = new Customer(.....);
        session.Save(customer);
        // 20, same as the ADO batch size
        if (i % 20 == 0)
        {
            // flush a batch of inserts and release memory:
            session.Flush();
            session.Clear();
        }
    }

    tx.Commit();
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-statelesssession"></a>14.2.&nbsp;The StatelessSession interface</h2></div></div><div></div></div><p>
            Alternatively, NHibernate provides a command-oriented API that may be used for 
            streaming data to and from the database in the form of detached objects. A 
            <tt class="literal">IStatelessSession</tt> has no persistence context associated
            with it and does not provide many of the higher-level life cycle semantics.
            In particular, a stateless session does not implement a first-level cache nor
            interact with any second-level or query cache. It does not implement 
            transactional write-behind or automatic dirty checking. Operations performed
            using a stateless session do not ever cascade to associated instances. Collections 
            are ignored by a stateless session. Operations performed via a stateless session 
            bypass NHibernate's event model and interceptors. Stateless sessions are vulnerable 
            to data aliasing effects, due to the lack of a first-level cache. A stateless
            session is a lower-level abstraction, much closer to the underlying ADO.
        </p><pre class="programlisting">using (IStatelessSession session = sessionFactory.OpenStatelessSession())
using (ITransaction tx = session.BeginTransaction())
{
    var customers = session.GetNamedQuery("GetCustomers")
        .Enumerable&lt;Customer&gt;();
    while (customers.MoveNext())
    {
        Customer customer = customers.Current;
        customer.updateStuff(...);
        session.Update(customer);
    }

    tx.Commit();
}</pre><p>
            Note that in this code example, the <tt class="literal">Customer</tt> instances returned
            by the query are immediately detached. They are never associated with any persistence
            context.
        </p><p>
            The <tt class="literal">insert(), update()</tt> and <tt class="literal">delete()</tt> operations
            defined by the <tt class="literal">StatelessSession</tt> interface are considered to be
            direct database row-level operations, which result in immediate execution of a SQL
            <tt class="literal">INSERT, UPDATE</tt> or <tt class="literal">DELETE</tt> respectively. Thus,
            they have very different semantics to the <tt class="literal">Save(), SaveOrUpdate()</tt> 
            and <tt class="literal">Delete()</tt> operations defined by the <tt class="literal">ISession</tt> 
            interface.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-direct"></a>14.3.&nbsp;DML-style operations</h2></div></div><div></div></div><p>
            As already discussed, automatic and transparent object/relational mapping is concerned
            with the management of object state. This implies that the object state is available
            in memory, hence manipulating (using the SQL <tt class="literal">Data Manipulation Language</tt>
            (DML) statements: <tt class="literal">INSERT</tt>, <tt class="literal">UPDATE</tt>, <tt class="literal">DELETE</tt>)
            data directly in the database will not affect in-memory state. However, NHibernate provides methods
            for bulk SQL-style DML statement execution which are performed through the
            Hibernate Query Language (<a href="#queryhql" title="Chapter&nbsp;15.&nbsp;HQL: The Hibernate Query Language">HQL</a>). A
            <a href="#querylinq-modifying" title="18.6.&nbsp;Modifying entities inside the database">Linq implementation</a> is available too.
        </p><p>
            The pseudo-syntax for <tt class="literal">UPDATE</tt> and <tt class="literal">DELETE</tt> statements
            is: <tt class="literal">( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</tt>.  Some
            points to note:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    In the from-clause, the FROM keyword is optional
                </p></li><li><p>
                    There can only be a single entity named in the from-clause; it can optionally be
                    aliased.  If the entity name is aliased, then any property references must
                    be qualified using that alias; if the entity name is not aliased, then it is
                    illegal for any property references to be qualified.
                </p></li><li><p>
                    No <a href="#queryhql-joins" title="15.3.&nbsp;Associations and joins">joins</a> (either implicit or explicit)
	                can be specified in a bulk HQL query.  Sub-queries may be used in the where-clause;
	                the sub-queries, themselves, may contain joins.
                </p></li><li><p>
                    The where-clause is also optional.
                </p></li></ul></div><p>
            As an example, to execute an HQL <tt class="literal">UPDATE</tt>, use the
            <tt class="literal">IQuery.ExecuteUpdate()</tt> method:
        </p><pre class="programlisting">using (ISession session = sessionFactory.OpenSession())
using (ITransaction tx = session.BeginTransaction())
{
    string hqlUpdate = "update Customer c set c.name = :newName where c.name = :oldName";
    // or string hqlUpdate = "update Customer set name = :newName where name = :oldName";
    int updatedEntities = s.CreateQuery(hqlUpdate)
        .SetString("newName", newName)
        .SetString("oldName", oldName)
        .ExecuteUpdate();
    tx.Commit();
}</pre><p>
            HQL <tt class="literal">UPDATE</tt> statements, by default do not effect the
            <a href="#mapping-declaration-version" title="5.1.8.&nbsp;version (optional)">version</a>
            or the <a href="#mapping-declaration-timestamp" title="5.1.9.&nbsp;timestamp (optional)">timestamp</a> property values
            for the affected entities.  However,
            you can force NHibernate to properly reset the <tt class="literal">version</tt> or
            <tt class="literal">timestamp</tt> property values through the use of a <tt class="literal">versioned update</tt>.
            This is achieved by adding the <tt class="literal">VERSIONED</tt> keyword after the <tt class="literal">UPDATE</tt>
            keyword.
        </p><pre class="programlisting">using (ISession session = sessionFactory.OpenSession())
using (ITransaction tx = session.BeginTransaction())
{
    string hqlVersionedUpdate =
        "update versioned Customer set name = :newName where name = :oldName";
    int updatedEntities = s.CreateQuery(hqlUpdate)
        .SetString("newName", newName)
        .SetString("oldName", oldName)
        .ExecuteUpdate();
    tx.Commit();
}</pre><p>
            Note that custom version types (<tt class="literal">NHibernate.Usertype.IUserVersionType</tt>)
            are not allowed in conjunction with a <tt class="literal">update versioned</tt> statement.
        </p><p>
            To execute an HQL <tt class="literal">DELETE</tt>, use the same <tt class="literal">IQuery.ExecuteUpdate()</tt>
            method:
        </p><pre class="programlisting">using (ISession session = sessionFactory.OpenSession())
using (ITransaction tx = session.BeginTransaction())
{
    string hqlDelete = "delete Customer c where c.name = :oldName";
    // or String hqlDelete = "delete Customer where name = :oldName";
    int deletedEntities = s.CreateQuery(hqlDelete)
        .SetString("oldName", oldName)
        .ExecuteUpdate();
    tx.Commit();
}</pre><p>
            The <tt class="literal">int</tt> value returned by the <tt class="literal">IQuery.ExecuteUpdate()</tt>
            method indicate the number of entities effected by the operation.  Consider this may or may not
            correlate to the number of rows effected in the database.  An HQL bulk operation might result in
            multiple actual SQL statements being executed, for joined-subclass, for example.  The returned
            number indicates the number of actual entities affected by the statement.  Going back to the
            example of joined-subclass, a delete against one of the subclasses may actually result
            in deletes against not just the table to which that subclass is mapped, but also the "root"
            table and potentially joined-subclass tables further down the inheritance hierarchy.
        </p><p>
            The pseudo-syntax for <tt class="literal">INSERT</tt> statements is:
            <tt class="literal">INSERT INTO EntityName properties_list select_statement</tt>.  Some
            points to note:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Only the INSERT INTO ... SELECT ... form is supported; not the INSERT INTO ... VALUES ... form.
                </p><p>
                    The properties_list is analogous to the <tt class="literal">column specification</tt>
                    in the SQL <tt class="literal">INSERT</tt> statement.  For entities involved in mapped
                    inheritance, only properties directly defined on that given class-level can be
                    used in the properties_list.  Superclass properties are not allowed; and subclass
                    properties do not make sense.  In other words, <tt class="literal">INSERT</tt>
                    statements are inherently non-polymorphic.
                </p></li><li><p>
                    select_statement can be any valid HQL select query, with the caveat that the return types
                    must match the types expected by the insert.  Currently, this is checked during query
                    compilation rather than allowing the check to relegate to the database.  Note however
                    that this might cause problems between NHibernate <tt class="literal">Type</tt>s which are
                    <span class="emphasis"><em>equivalent</em></span> as opposed to <span class="emphasis"><em>equal</em></span>.  This might cause
                    issues with mismatches between a property defined as a <tt class="literal">NHibernate.Type.DateType</tt>
                    and a property defined as a <tt class="literal">NHibernate.Type.TimestampType</tt>, even though the
                    database might not make a distinction or might be able to handle the conversion.
                </p></li><li><p>
                    For the id property, the insert statement gives you two options.  You can either
                    explicitly specify the id property in the properties_list (in which case its value
                    is taken from the corresponding select expression) or omit it from the properties_list
                    (in which case a generated value is used).  This later option is only available when
                    using id generators that operate in the database; attempting to use this option with
                    any "in memory" type generators will cause an exception during parsing.  Note that
                    for the purposes of this discussion, in-database generators are considered to be
                    <tt class="literal">NHibernate.Id.SequenceGenerator</tt> (and its subclasses) and
                    any implementors of <tt class="literal">NHibernate.Id.IPostInsertIdentifierGenerator</tt>.
                    The most notable exception here is <tt class="literal">NHibernate.Id.TableHiLoGenerator</tt>,
                    which cannot be used because it does not expose a selectable way to get its values.
                </p></li><li><p>
                    For properties mapped as either <tt class="literal">version</tt> or <tt class="literal">timestamp</tt>,
                    the insert statement gives you two options.  You can either specify the property in the
                    properties_list (in which case its value is taken from the corresponding select expressions)
                    or omit it from the properties_list (in which case the <tt class="literal">seed value</tt> defined
                    by the <tt class="literal">NHibernate.Type.IVersionType</tt> is used).
                </p></li></ul></div><p>
            An example HQL <tt class="literal">INSERT</tt> statement execution:
        </p><pre class="programlisting">using (ISession session = sessionFactory.OpenSession())
using (ITransaction tx = session.BeginTransaction())
{
    var hqlInsert =
        "insert into DelinquentAccount (id, name) " +
        "select c.id, c.name from Customer c where ...";
    int createdEntities = s.CreateQuery(hqlInsert)
        .ExecuteUpdate();
    tx.Commit();
}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="queryhql"></a>Chapter&nbsp;15.&nbsp;HQL: The Hibernate Query Language</h2></div></div><div></div></div><p>
        NHibernate is equipped with an extremely powerful query language that (quite intentionally)
        looks very much like SQL. But don't be fooled by the syntax; HQL is fully object-oriented,
        understanding notions like inheritance, polymorphism and association.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-casesensitivity"></a>15.1.&nbsp;Case Sensitivity</h2></div></div><div></div></div><p>
            Queries are case-insensitive, except for names of .NET classes and properties.
            So <tt class="literal">SeLeCT</tt> is the same as
            <tt class="literal">sELEct</tt> is the same as
            <tt class="literal">SELECT</tt> but
            <tt class="literal">Eg.FOO</tt> is not
            <tt class="literal">Eg.Foo</tt> and
            <tt class="literal">foo.barSet</tt> is not
            <tt class="literal">foo.BARSET</tt>.
        </p><p>
            This manual uses lowercase HQL keywords. Some users find queries with uppercase keywords 
            more readable, but we find this convention ugly when embedded in C# code.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-from"></a>15.2.&nbsp;The from clause</h2></div></div><div></div></div><p>
            The simplest possible NHibernate query is of the form:
        </p><pre class="programlisting">from Eg.Cat</pre><p>
            which simply returns all instances of the class <tt class="literal">Eg.Cat</tt>. 
        </p><p>
            Most of the time, you will need to assign an <span class="emphasis"><em>alias</em></span>, since
            you will want to refer to the <tt class="literal">Cat</tt> in other parts of the
            query.
        </p><pre class="programlisting">from Eg.Cat as cat</pre><p>
            This query assigns the alias <tt class="literal">cat</tt> to <tt class="literal">Cat</tt>
            instances, so we could use that alias later in the query. The <tt class="literal">as</tt>
            keyword is optional; we could also write:
        </p><pre class="programlisting">from Eg.Cat cat</pre><p>
            Multiple classes may appear, resulting in a cartesian product or "cross" join.
        </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>
            It is considered good practice to name query aliases using an initial lowercase,
            consistent with naming standards for local variables
            (eg. <tt class="literal">domesticCat</tt>).
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-joins"></a>15.3.&nbsp;Associations and joins</h2></div></div><div></div></div><p>
            We may also assign aliases to associated entities, or even to elements of a collection of
            values, using a <tt class="literal">join</tt>.
        </p><pre class="programlisting">from Eg.Cat as cat 
    inner join cat.Mate as mate
    left outer join cat.Kittens as kitten

from Eg.Cat as cat left join cat.Mate.Kittens as kittens

from Formula form full join form.Parameter param</pre><p>
            The supported join types are borrowed from ANSI SQL
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">inner join</tt>
                </p></li><li><p>
                    <tt class="literal">left outer join</tt>
                </p></li><li><p>
                    <tt class="literal">right outer join</tt>
                </p></li><li><p>
                    <tt class="literal">full join</tt> (not usually useful)
                </p></li></ul></div><p>
            The <tt class="literal">inner join</tt>, <tt class="literal">left outer join</tt> and 
            <tt class="literal">right outer join</tt> constructs may be abbreviated.
        </p><pre class="programlisting">from Eg.Cat as cat 
    join cat.Mate as mate
    left join cat.Kittens as kitten</pre><p>
            In addition, a "fetch" join allows associations or collections of values to be 
            initialized along with their parent objects, using a single select. This is particularly 
            useful in the case of a collection. It effectively overrides the outer join and
            lazy declarations of the mapping file for associations and collections. See
            <a href="#performance-fetching" title="21.1.&nbsp;Fetching strategies">Section&nbsp;21.1, &#8220;Fetching strategies&#8221;</a> for more information.
        </p><pre class="programlisting">from Eg.Cat as cat 
    inner join fetch cat.Mate
    left join fetch cat.Kittens</pre><p>
            The associated objects are not returned directly in the query results. Instead, they may 
            be accessed via the parent object.
        </p><p>
            It is possible to create a cartesian product by join fetching more than one collection in
            a query, so take care in this case. Join fetching multiple collection roles is also
            disabled for bag mappings. Note also that the <tt class="literal">fetch</tt> construct may not
            be used in queries called using <tt class="literal">Enumerable()</tt>. Finally, note that
            <tt class="literal">full join fetch</tt> and <tt class="literal">right join fetch</tt> are not meaningful.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-select"></a>15.4.&nbsp;The select clause</h2></div></div><div></div></div><p>
            The <tt class="literal">select</tt> clause picks which objects and properties to return in 
            the query result set. Consider:
        </p><pre class="programlisting">select mate 
from Eg.Cat as cat 
    inner join cat.Mate as mate</pre><p>
            The query will select <tt class="literal">Mate</tt>s of other <tt class="literal">Cat</tt>s.
            Actually, you may express this query more compactly as:
        </p><pre class="programlisting">select cat.Mate from Eg.Cat cat</pre><p>
            You may even select collection elements, using the special <tt class="literal">elements</tt>
            function. The following query returns all kittens of any cat.
        </p><pre class="programlisting">select elements(cat.Kittens) from Eg.Cat cat</pre><p>
            Queries may return properties of any value type including properties of component type:
        </p><pre class="programlisting">select cat.Name from Eg.DomesticCat cat
where cat.Name like 'fri%'

select cust.Name.FirstName from Customer as cust</pre><p>
            Queries may return multiple objects and/or properties as an array of type 
            <tt class="literal">object[]</tt>
        </p><pre class="programlisting">select mother, offspr, mate.Name 
from Eg.DomesticCat as mother
    inner join mother.Mate as mate
    left outer join mother.Kittens as offspr</pre><p>
            or as an actual type-safe object
        </p><pre class="programlisting">select new Family(mother, mate, offspr)
from Eg.DomesticCat as mother
    join mother.Mate as mate
    left join mother.Kittens as offspr</pre><p>
            assuming that the class <tt class="literal">Family</tt> has an appropriate constructor.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-aggregation"></a>15.5.&nbsp;Aggregate functions</h2></div></div><div></div></div><p>
            HQL queries may even return the results of aggregate functions on properties:
        </p><pre class="programlisting">select avg(cat.Weight), sum(cat.Weight), max(cat.Weight), count(cat)
from Eg.Cat cat</pre><p>
            Collections may also appear inside aggregate functions in the <tt class="literal">select</tt> 
            clause.
        </p><pre class="programlisting">select cat, count( elements(cat.Kittens) ) 
from Eg.Cat cat group by cat.Id, cat.Weight, ...</pre><p>
            The supported aggregate functions are
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">avg(...), sum(...), min(...), max(...)</tt>
                </p></li><li><p>
                    <tt class="literal">count(*)</tt>
                </p></li><li><p>
                    <tt class="literal">count(...), count(distinct ...), count(all...)</tt>
                </p></li></ul></div><p>
            The <tt class="literal">distinct</tt> and <tt class="literal">all</tt> keywords may be used and have
            the same semantics as in SQL.
        </p><pre class="programlisting">select distinct cat.Name from Eg.Cat cat

select count(distinct cat.Name), count(cat) from Eg.Cat cat</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-polymorphism"></a>15.6.&nbsp;Polymorphic queries</h2></div></div><div></div></div><p>
            A query like:
        </p><pre class="programlisting">from Eg.Cat as cat</pre><p>
            returns instances not only of <tt class="literal">Cat</tt>, but also of subclasses like
            <tt class="literal">DomesticCat</tt>. NHibernate queries may name <span class="emphasis"><em>any</em></span> .NET 
            class or interface in the <tt class="literal">from</tt> clause. The query will return instances 
            of all persistent classes that extend that class or implement the interface. The following 
            query would return all persistent objects:
        </p><pre class="programlisting">from System.Object o</pre><p>
            The interface <tt class="literal">INamed</tt> might be implemented by various persistent
            classes:
        </p><pre class="programlisting">from Eg.Named n, Eg.Named m where n.Name = m.Name</pre><p>
            Note that these last two queries will require more than one SQL <tt class="literal">SELECT</tt>. This
            means that the <tt class="literal">order by</tt> clause does not correctly order the whole result set.
        </p><p>
			In order to use non-mapped base classes or interfaces in HQL queries, they have to be imported. See <a href="#mapping-declaration-import" title="5.1.23.&nbsp;import">Section&nbsp;5.1.23, &#8220;import&#8221;</a> for more information.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-where"></a>15.7.&nbsp;The where clause</h2></div></div><div></div></div><p>
            The <tt class="literal">where</tt> clause allows you to narrow the list of instances returned.
        </p><pre class="programlisting">from Eg.Cat as cat where cat.Name='Fritz'</pre><p>
            returns instances of <tt class="literal">Cat</tt> named 'Fritz'.
        </p><pre class="programlisting">select foo 
from Eg.Foo foo, Eg.Bar bar
where foo.StartDate = bar.Date</pre><p>
            will return all instances of <tt class="literal">Foo</tt> for which
            there exists an instance of <tt class="literal">Bar</tt> with a
            <tt class="literal">Date</tt> property equal to the
            <tt class="literal">StartDate</tt> property of the
            <tt class="literal">Foo</tt>. Compound path expressions make the
            <tt class="literal">where</tt> clause extremely powerful. Consider:
        </p><pre class="programlisting">from Eg.Cat cat where cat.Mate.Name is not null</pre><p>
            This query translates to an SQL query with a table (inner) join. If you were to write
            something like
        </p><pre class="programlisting">from Eg.Foo foo  
where foo.Bar.Baz.Customer.Address.City is not null</pre><p>
            you would end up with a query that would require four table joins in SQL.
        </p><p>
            The <tt class="literal">=</tt> operator may be used to compare not only properties, but also 
            instances:
        </p><pre class="programlisting">from Eg.Cat cat, Eg.Cat rival where cat.Mate = rival.Mate

select cat, mate 
from Eg.Cat cat, Eg.Cat mate
where cat.Mate = mate</pre><p>
            The special property (lowercase) <tt class="literal">id</tt> may be used to reference the 
            unique identifier of an object. (You may also use its property name.)
        </p><pre class="programlisting">from Eg.Cat as cat where cat.id = 123

from Eg.Cat as cat where cat.Mate.id = 69</pre><p>
            The second query is efficient. No table join is required!
        </p><p>
            Properties of composite identifiers may also be used. Suppose <tt class="literal">Person</tt> 
            has a composite identifier consisting of <tt class="literal">Country</tt> and 
            <tt class="literal">MedicareNumber</tt>.
        </p><pre class="programlisting">from Bank.Person person
where person.id.Country = 'AU' 
    and person.id.MedicareNumber = 123456

from Bank.Account account
where account.Owner.id.Country = 'AU' 
    and account.Owner.id.MedicareNumber = 123456</pre><p>
            Once again, the second query requires no table join.
        </p><p>
            Likewise, the special property <tt class="literal">class</tt> accesses the discriminator value
            of an instance in the case of polymorphic persistence. A .Net class name embedded in the 
            where clause will be translated to its discriminator value.
        </p><pre class="programlisting">from Eg.Cat cat where cat.class = Eg.DomesticCat</pre><p>
            You may also specify properties of components or composite user types (and of components 
            of components, etc). Never try to use a path-expression that ends in a property of component 
            type (as opposed to a property of a component). For example, if <tt class="literal">store.Owner</tt>
            is an entity with a component <tt class="literal">Address</tt>
        </p><pre class="programlisting">store.Owner.Address.City    // okay
store.Owner.Address         // error!</pre><p>
            An "any" type has the special properties <tt class="literal">id</tt> and <tt class="literal">class</tt>,
            allowing us to express a join in the following way (where <tt class="literal">AuditLog.Item</tt>
            is a property mapped with <tt class="literal">&lt;any&gt;</tt>).
        </p><pre class="programlisting">from Eg.AuditLog log, Eg.Payment payment 
where log.Item.class = 'Eg.Payment, Eg, Version=...' and log.Item.id = payment.id</pre><p>
            Notice that <tt class="literal">log.Item.class</tt> and <tt class="literal">payment.class</tt>
            would refer to the values of completely different database columns in the above query.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-expressions"></a>15.8.&nbsp;Expressions</h2></div></div><div></div></div><p>
            Expressions allowed in the <tt class="literal">where</tt> clause include
            most of the kind of things you could write in SQL:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    mathematical operators <tt class="literal">+, -, *, /</tt>
                </p></li><li><p>
                    binary comparison operators <tt class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</tt>
                </p></li><li><p>
                    logical operations <tt class="literal">and, or, not</tt>
                </p></li><li><p>
                    string concatenation ||
                </p></li><li><p>
                    SQL scalar functions like <tt class="literal">upper()</tt> and
                    <tt class="literal">lower()</tt>
                </p></li><li><p>
                    Parentheses <tt class="literal">( )</tt> indicate grouping
                </p></li><li><p>
                    <tt class="literal">in</tt>,
                    <tt class="literal">between</tt>,
                    <tt class="literal">is null</tt>
                </p></li><li><p>
                    positional parameters <tt class="literal">?</tt>
                </p></li><li><p>
                    named parameters <tt class="literal">:name</tt>, <tt class="literal">:start_date</tt>, <tt class="literal">:x1</tt>
                </p></li><li><p>
                    SQL literals <tt class="literal">'foo'</tt>, <tt class="literal">69</tt>, <tt class="literal">'1970-01-01 10:00:01.0'</tt>
                </p></li><li><p>
                    Enumeration values and constants <tt class="literal">Eg.Color.Tabby</tt>
                </p></li></ul></div><p>
            <tt class="literal">in</tt> and <tt class="literal">between</tt> may be used as follows:
        </p><pre class="programlisting">from Eg.DomesticCat cat where cat.Name between 'A' and 'B'

from Eg.DomesticCat cat where cat.Name in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            and the negated forms may be written
        </p><pre class="programlisting">from Eg.DomesticCat cat where cat.Name not between 'A' and 'B'

from Eg.DomesticCat cat where cat.Name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            Likewise, <tt class="literal">is null</tt> and <tt class="literal">is not null</tt> may be used to test 
            for null values.
        </p><p>
            Booleans may be easily used in expressions by declaring HQL query substitutions in NHibernate
            configuration:
        </p><pre class="programlisting">&lt;property name="query.substitutions"&gt;true 1, false 0&lt;/property&gt;</pre><p>
            This will replace the keywords <tt class="literal">true</tt> and <tt class="literal">false</tt> with the
            literals <tt class="literal">1</tt> and <tt class="literal">0</tt> in the translated SQL from this HQL:
        </p><pre class="programlisting">from Eg.Cat cat where cat.Alive = true</pre><p>
            You may test the size of a collection with the special property <tt class="literal">size</tt>, or
            the special <tt class="literal">size()</tt> function.
        </p><pre class="programlisting">from Eg.Cat cat where cat.Kittens.size &gt; 0

from Eg.Cat cat where size(cat.Kittens) &gt; 0</pre><p>
            For indexed collections, you may refer to the minimum and maximum indices using
            <tt class="literal">minIndex</tt> and <tt class="literal">maxIndex</tt>. Similarly, you may refer to the
            minimum and maximum elements of a collection of basic type using <tt class="literal">minElement</tt> 
            and <tt class="literal">maxElement</tt>.
        </p><pre class="programlisting">from Calendar cal where cal.Holidays.maxElement &gt; current date</pre><p>
            There are also functional forms (which, unlike the constructs above, are not case sensitive):
        </p><pre class="programlisting">from Order order where maxindex(order.Items) &gt; 100

from Order order where minelement(order.Items) &gt; 10000</pre><p>
            The SQL functions <tt class="literal">any, some, all, exists, in</tt> are supported when passed the element 
            or index set of a collection (<tt class="literal">elements</tt> and <tt class="literal">indices</tt> functions)
            or the result of a sub-query (see below).
        </p><pre class="programlisting">select mother from Eg.Cat as mother, Eg.Cat as kit
where kit in elements(mother.Kittens)

select p from Eg.NameList list, Eg.Person p
where p.Name = some elements(list.Names)

from Eg.Cat cat where exists elements(cat.Kittens)

from Eg.Player p where 3 &gt; all elements(p.Scores)

from Eg.Show show where 'fizard' in indices(show.Acts)</pre><p>
            Note that these constructs - <tt class="literal">size</tt>, <tt class="literal">elements</tt>,
            <tt class="literal">indices</tt>, <tt class="literal">minIndex</tt>, <tt class="literal">maxIndex</tt>,
            <tt class="literal">minElement</tt>, <tt class="literal">maxElement</tt> - have certain usage 
            restrictions:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    in a <tt class="literal">where</tt> clause: only for databases with sub-selects
                </p></li><li><p>
                    in a <tt class="literal">select</tt> clause: only <tt class="literal">elements</tt> and 
                    <tt class="literal">indices</tt> make sense
                </p></li></ul></div><p>
            Elements of indexed collections (arrays, lists, maps) may be referred to by
            index (in a where clause only):
        </p><pre class="programlisting">from Order order where order.Items[0].id = 1234

select person from Person person, Calendar calendar
where calendar.Holidays['national day'] = person.BirthDay
    and person.Nationality.Calendar = calendar

select item from Item item, Order order
where order.Items[ order.DeliveredItemIndices[0] ] = item and order.id = 11

select item from Item item, Order order
where order.Items[ maxindex(order.items) ] = item and order.id = 11</pre><p>
            The expression inside <tt class="literal">[]</tt> may even be an arithmetic expression.
        </p><pre class="programlisting">select item from Item item, Order order
where order.Items[ size(order.Items) - 1 ] = item</pre><p>
            HQL also provides the built-in <tt class="literal">index()</tt> function, for elements of
            a one-to-many association or collection of values.
        </p><pre class="programlisting">select item, index(item) from Order order 
    join order.Items item
where index(item) &lt; 5</pre><p>
            Scalar SQL functions supported by the underlying database may be used
        </p><pre class="programlisting">from Eg.DomesticCat cat where upper(cat.Name) like 'FRI%'</pre><p>
            If you are not yet convinced by all this, think how much longer and less readable the 
            following query would be in SQL:
        </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.Customers cust
where prod.Name = 'widget'
    and store.Location.Name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.CurrentOrder.LineItems)</pre><p>
            <span class="emphasis"><em>Hint:</em></span> something like
        </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-ordering"></a>15.9.&nbsp;The order by clause</h2></div></div><div></div></div><p>
            The list returned by a query may be ordered by any property of a returned class or components:
        </p><pre class="programlisting">from Eg.DomesticCat cat
order by cat.Name asc, cat.Weight desc, cat.Birthdate</pre><p>
            The optional <tt class="literal">asc</tt> or <tt class="literal">desc</tt> indicate ascending or descending order 
            respectively.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-grouping"></a>15.10.&nbsp;The group by clause</h2></div></div><div></div></div><p>
            A query that returns aggregate values may be grouped by any property of a returned class or components:
        </p><pre class="programlisting">select cat.Color, sum(cat.Weight), count(cat) 
from Eg.Cat cat
group by cat.Color

select foo.id, avg( elements(foo.Names) ), max( indices(foo.Names) ) 
from Eg.Foo foo
group by foo.id</pre><p>
            Note: You may use the <tt class="literal">elements</tt> and <tt class="literal">indices</tt> constructs
            inside a select clause, even on databases with no sub-selects.
        </p><p>
            A <tt class="literal">having</tt> clause is also allowed.
        </p><pre class="programlisting">select cat.color, sum(cat.Weight), count(cat) 
from Eg.Cat cat
group by cat.Color 
having cat.Color in (Eg.Color.Tabby, Eg.Color.Black)</pre><p>
            SQL functions and aggregate functions are allowed in the <tt class="literal">having</tt>
            and <tt class="literal">order by</tt> clauses, if supported by the underlying database (ie.
            not in MySQL).
        </p><pre class="programlisting">select cat
from Eg.Cat cat
    join cat.Kittens kitten
group by cat.Id, cat.Name, cat.Other, cat.Properties
having avg(kitten.Weight) &gt; 100
order by count(kitten) asc, sum(kitten.Weight) desc</pre><p>
            Note that neither the <tt class="literal">group by</tt> clause nor the
            <tt class="literal">order by</tt> clause may contain arithmetic expressions.
            Also note that NHibernate currently does not expand a grouped entity,
            so you can't write <tt class="literal">group by cat</tt> if all properties
            of <tt class="literal">cat</tt> are non-aggregated. You have to list all
            non-aggregated properties explicitly.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-subqueries"></a>15.11.&nbsp;Sub-queries</h2></div></div><div></div></div><p>
            For databases that support sub-selects, NHibernate supports sub-queries within queries. A sub-query must
            be surrounded by parentheses (often by an SQL aggregate function call). Even correlated sub-queries
            (sub-queries that refer to an alias in the outer query) are allowed.
        </p><pre class="programlisting">from Eg.Cat as fatcat 
where fatcat.Weight &gt; ( 
    select avg(cat.Weight) from Eg.DomesticCat cat 
)

from Eg.DomesticCat as cat 
where cat.Name = some ( 
    select name.NickName from Eg.Name as name 
)
    
from Eg.Cat as cat 
where not exists ( 
    from eg.Cat as mate where mate.Mate = cat 
)

from Eg.DomesticCat as cat 
where cat.Name not in ( 
    select name.NickName from Eg.Name as name 
)</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-examples"></a>15.12.&nbsp;HQL examples</h2></div></div><div></div></div><p>
            NHibernate queries can be quite powerful and complex. In fact, the power of the query language
            is one of NHibernate's main selling points. Here are some example queries very similar to queries
            that I used on a recent project. Note that most queries you will write are much simpler than these!
        </p><p>
            The following query returns the order id, number of items and total value of the order for all 
            unpaid orders for a particular customer and given minimum total value, ordering the results by 
            total value. In determining the prices, it uses the current catalog. The resulting SQL query, 
            against the <tt class="literal">ORDER</tt>, <tt class="literal">ORDER_LINE</tt>, <tt class="literal">PRODUCT</tt>,
            <tt class="literal">CATALOG</tt> and <tt class="literal">PRICE</tt> tables has four inner joins and an
            (uncorrelated) subselect.
        </p><pre class="programlisting">select order.id, sum(price.Amount), count(item)
from Order as order
    join order.LineItems as item
    join item.Product as product,
    Catalog as catalog
    join catalog.Prices as price
where order.Paid = false
    and order.Customer = :customer
    and price.Product = product
    and catalog.EffectiveDate &lt; sysdate
    and catalog.EffectiveDate &gt;= all (
        select cat.EffectiveDate 
        from Catalog as cat
        where cat.EffectiveDate &lt; sysdate
    )
group by order
having sum(price.Amount) &gt; :minAmount
order by sum(price.Amount) desc</pre><p>
            What a monster! Actually, in real life, I'm not very keen on sub-queries, so my query was 
            really more like this:
        </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.LineItems as item
    join item.Product as product,
    Catalog as catalog
    join catalog.Prices as price
where order.Paid = false
    and order.Customer = :customer
    and price.Product = product
    and catalog = :currentCatalog
group by order
having sum(price.Amount) &gt; :minAmount
order by sum(price.Amount) desc</pre><p>
            The next query counts the number of payments in each status, excluding all payments in the
            <tt class="literal">AwaitingApproval</tt> status where the most recent status change was made by the 
            current user. It translates to an SQL query with two inner joins and a correlated subselect 
            against the <tt class="literal">PAYMENT</tt>, <tt class="literal">PAYMENT_STATUS</tt> and 
            <tt class="literal">PAYMENT_STATUS_CHANGE</tt> tables.
        </p><pre class="programlisting">select count(payment), status.Name 
from Payment as payment 
    join payment.CurrentStatus as status
    join payment.StatusChanges as statusChange
where payment.Status.Name &lt;&gt; PaymentStatus.AwaitingApproval
    or (
        statusChange.TimeStamp = ( 
            select max(change.TimeStamp) 
            from PaymentStatusChange change 
            where change.Payment = payment
        )
        and statusChange.User &lt;&gt; :currentUser
    )
group by status.Name, status.SortOrder
order by status.SortOrder</pre><p>
            If I would have mapped the <tt class="literal">StatusChanges</tt> collection as a list, instead of a set, 
            the query would have been much simpler to write.
        </p><pre class="programlisting">select count(payment), status.Name 
from Payment as payment
    join payment.CurrentStatus as status
where payment.Status.Name &lt;&gt; PaymentStatus.AwaitingApproval
    or payment.StatusChanges[ maxIndex(payment.StatusChanges) ].User &lt;&gt; :currentUser
group by status.Name, status.SortOrder
order by status.SortOrder</pre><p>
            The next query uses the MS SQL Server <tt class="literal">isNull()</tt> function to return all
            the accounts and unpaid payments for the organization to which the current user belongs.
            It translates to an SQL query with three inner joins, an outer join and a subselect against 
            the <tt class="literal">ACCOUNT</tt>, <tt class="literal">PAYMENT</tt>, <tt class="literal">PAYMENT_STATUS</tt>,
            <tt class="literal">ACCOUNT_TYPE</tt>, <tt class="literal">ORGANIZATION</tt> and 
            <tt class="literal">ORG_USER</tt> tables.
        </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.Payments as payment
where :currentUser in elements(account.Holder.Users)
    and PaymentStatus.Unpaid = isNull(payment.CurrentStatus.Name, PaymentStatus.Unpaid)
order by account.Type.SortOrder, account.AccountNumber, payment.DueDate</pre><p>
            For some databases, we would need to do away with the (correlated) subselect.
        </p><pre class="programlisting">select account, payment
from Account as account
    join account.Holder.Users as user
    left outer join account.Payments as payment
where :currentUser = user
    and PaymentStatus.Unpaid = isNull(payment.CurrentStatus.Name, PaymentStatus.Unpaid)
order by account.Type.SortOrder, account.AccountNumber, payment.DueDate</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-tipstricks"></a>15.13.&nbsp;Tips &amp; Tricks</h2></div></div><div></div></div><p>
            You can count the number of query results without actually returning them:
        </p><pre class="programlisting">var count = session.CreateQuery("select count(*) from ....").UniqueResult&lt;long&gt;();</pre><p>
            To order a result by the size of a collection, use the following query:
        </p><pre class="programlisting">select usr.id, usr.Name
from User as usr 
    left join usr.Messages as msg
group by usr.id, usr.Name
order by count(msg)</pre><p>
            If your database supports sub-selects, you can place a condition upon selection
            size in the where clause of your query:
        </p><pre class="programlisting">from User usr where size(usr.Messages) &gt;= 1</pre><p>
            If your database doesn't support sub-selects, use the following query:
        </p><pre class="programlisting">select usr.id, usr.Name
from User usr
    join usr.Messages msg
group by usr.id, usr.Name
having count(msg) &gt;= 1</pre><p>
            As this solution can't return a <tt class="literal">User</tt> with zero messages
            because of the inner join, the following form is also useful:
        </p><pre class="programlisting">select usr.id, usr.Name
from User as usr
    left join usr.Messages as msg
group by usr.id, usr.Name
having count(msg) = 0</pre><p>
            Properties of an object can be bound to named query parameters:
        </p><pre class="programlisting">IQuery q =
    s.CreateQuery("from foo in class Foo where foo.Name=:Name and foo.Size=:Size");
q.SetProperties(fooBean); // fooBean has properties Name and Size
var foos = q.List&lt;Foo&gt;();</pre><p>
            Collections are pageable by using the <tt class="literal">IQuery</tt> interface with a filter:
        </p><pre class="programlisting">IQuery q = s.CreateFilter( collection, "" ); // the trivial filter
q.setMaxResults(PageSize);
q.setFirstResult(PageSize * pageNumber);
var page = q.List&lt;Cat&gt;();</pre><p>
            Collection elements may be ordered or grouped using a query filter:
        </p><pre class="programlisting">var orderedCollection = s
    .CreateFilter(collection, "order by this.Amount")
    .List&lt;Cat&gt;();
var counts = s
    .CreateFilter(collection,
        "select this.Type, count(this) group by this.Type")
    .List&lt;object[]&gt;();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="querycriteria"></a>Chapter&nbsp;16.&nbsp;Criteria Queries</h2></div></div><div></div></div><p>
        NHibernate features an intuitive, extensible criteria query API.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-creating"></a>16.1.&nbsp;Creating an <tt class="literal">ICriteria</tt> instance</h2></div></div><div></div></div><p>
            The interface <tt class="literal">NHibernate.ICriteria</tt> represents a query against
            a particular persistent class. The <tt class="literal">ISession</tt> is a factory for
            <tt class="literal">ICriteria</tt> instances.
        </p><pre class="programlisting">ICriteria crit = sess.CreateCriteria&lt;Cat&gt;();
crit.SetMaxResults(50);
var cats = crit.List&lt;Cat&gt;();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-narrowing"></a>16.2.&nbsp;Narrowing the result set</h2></div></div><div></div></div><p>
            An individual query criterion is an instance of the interface
            <tt class="literal">NHibernate.Expression.ICriterion</tt>. The class
            <tt class="literal">NHibernate.Expression.Expression</tt> defines
            factory methods for obtaining certain built-in
            <tt class="literal">ICriterion</tt> types.
        </p><pre class="programlisting">var cats = sess.CreateCriteria&lt;Cat&gt;()
    .Add( Expression.Like("Name", "Fritz%") )
    .Add( Expression.Between("Weight", minWeight, maxWeight) )
    .List&lt;Cat&gt;();</pre><p>
            Expressions may be grouped logically.
        </p><pre class="programlisting">var cats = sess.CreateCriteria&lt;Cat&gt;()
    .Add( Expression.Like("Name", "Fritz%") )
    .Add( Expression.Or(
        Expression.Eq( "Age", 0 ),
        Expression.IsNull("Age")
    ) )
    .List&lt;Cat&gt;();</pre><pre class="programlisting">var cats = sess.CreateCriteria&lt;Cat&gt;()
    .Add( Expression.In( "Name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .Add( Expression.Disjunction()
        .Add( Expression.IsNull("Age") )
    	.Add( Expression.Eq("Age", 0 ) )
    	.Add( Expression.Eq("Age", 1 ) )
    	.Add( Expression.Eq("Age", 2 ) )
    ) )
    .List&lt;Cat&gt;();</pre><p>
            There are quite a range of built-in criterion types (<tt class="literal">Expression</tt>
            subclasses), but one that is especially useful lets you specify SQL directly.
        </p><pre class="programlisting">// Create a string parameter for the SqlString below
var cats = sess.CreateCriteria&lt;Cat&gt;()
    .Add(Expression.Sql("lower({alias}.Name) like lower(?)",
        "Fritz%", NHibernateUtil.String))
    .List&lt;Cat&gt;();</pre><p>
            The <tt class="literal">{alias}</tt> placeholder with be replaced by the row alias
            of the queried entity.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-ordering"></a>16.3.&nbsp;Ordering the results</h2></div></div><div></div></div><p>
            You may order the results using <tt class="literal">NHibernate.Expression.Order</tt>.
        </p><pre class="programlisting">var cats = sess.CreateCriteria&lt;Cat&gt;()
    .Add( Expression.Like("Name", "F%")
    .AddOrder( Order.Asc("Name") )
    .AddOrder( Order.Desc("Age") )
    .SetMaxResults(50)
    .List&lt;Cat&gt;();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-associations"></a>16.4.&nbsp;Associations</h2></div></div><div></div></div><p>
            You may easily specify constraints upon related entities by navigating
            associations using <tt class="literal">CreateCriteria()</tt>.
        </p><pre class="programlisting">var cats = sess.CreateCriteria&lt;Cat&gt;()
    .Add( Expression.Like("Name", "F%")
    .CreateCriteria("Kittens")
        .Add( Expression.Like("Name", "F%") )
    .List&lt;Cat&gt;();</pre><p>
            Note that the second <tt class="literal">CreateCriteria()</tt> returns a new
            instance of <tt class="literal">ICriteria</tt>, which refers to the elements of
            the <tt class="literal">Kittens</tt> collection.
        </p><p>
            The following, alternate form is useful in certain circumstances.
        </p><pre class="programlisting">var cats = sess.CreateCriteria&lt;Cat&gt;()
    .CreateAlias("Kittens", "kt")
    .CreateAlias("Mate", "mt")
    .Add( Expression.EqProperty("kt.Name", "mt.Name") )
    .List&lt;Cat&gt;();</pre><p>
            (<tt class="literal">CreateAlias()</tt> does not create a new instance of
            <tt class="literal">ICriteria</tt>.)
        </p><p>
            Note that the kittens collections held by the <tt class="literal">Cat</tt> instances
            returned by the previous two queries are <span class="emphasis"><em>not</em></span> pre-filtered
            by the criteria! If you wish to retrieve just the kittens that match the
            criteria, you must use <tt class="literal">SetResultTransformer(Transformers.AliasToEntityMap)</tt>.
        </p><pre class="programlisting">var cats = sess.CreateCriteria&lt;Cat&gt;()
    .CreateCriteria("Kittens", "kt")
        .Add( Expression.Eq("Name", "F%") )
    .SetResultTransformer(Transformers.AliasToEntityMap)
    .List&lt;IDictionary&gt;();
foreach ( IDictionary map in cats )
{
    Cat cat = (Cat) map[CriteriaSpecification.RootAlias];
    Cat kitten = (Cat) map["kt"];
}</pre><p>
        Note that for retrieving just kittens you can also use an entity projection.
        See <a href="#querycriteria-projection" title="16.8.&nbsp;Projections, aggregation and grouping">Section&nbsp;16.8, &#8220;Projections, aggregation and grouping&#8221;</a> for more information.
      </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria_entityjoin"></a>16.5.&nbsp;Join entities without association (Entity joins or ad hoc joins)</h2></div></div><div></div></div><p>
        In criteria you have the ability to define a join to any entity, not just through a mapped association.
        To achieve it, use <tt class="literal">CreateEntityAlias</tt> and <tt class="literal">CreateEntityCriteria</tt>. By example:
      </p><pre class="programlisting">IList&lt;Cat&gt; uniquelyNamedCats = sess.CreateCriteria&lt;Cat&gt;("c")
    .CreateEntityAlias(
        "joinedCat",
        Restrictions.And(
            Restrictions.EqProperty("c.Name", "joinedCat.Name"),
            Restrictions.NotEqProperty("c.Id", "joinedCat.Id")),
        JoinType.LeftOuterJoin,
        typeof(Cat).FullName)
    .Add(Restrictions.IsNull("joinedCat.Id"))
    .List();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-dynamicfetching"></a>16.6.&nbsp;Dynamic association fetching</h2></div></div><div></div></div><p>
            You may specify association fetching semantics at runtime using
            <tt class="literal">Fetch()</tt>.
        </p><pre class="programlisting">var cats = sess.CreateCriteria&lt;Cat&gt;()
    .Add( Expression.Like("Name", "Fritz%") )
    .Fetch(SelectMode.Fetch, "Mate")
    .Fetch(SelectMode.Fetch, "Kittens")
    .List&lt;Cat&gt;();</pre><p>
            This query will fetch both <tt class="literal">Mate</tt> and <tt class="literal">Kittens</tt>
            by outer join. See <a href="#performance-fetching" title="21.1.&nbsp;Fetching strategies">Section&nbsp;21.1, &#8220;Fetching strategies&#8221;</a> for more information.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-examples"></a>16.7.&nbsp;Example queries</h2></div></div><div></div></div><p>
            The class <tt class="literal">NHibernate.Expression.Example</tt> allows
            you to construct a query criterion from a given instance.
        </p><pre class="programlisting">Cat cat = new Cat();
cat.Sex = 'F';
cat.Color = Color.Black;
var results = session.CreateCriteria&lt;Cat&gt;()
    .Add( Example.Create(cat) )
    .List&lt;Cat&gt;();</pre><p>
           Version properties, identifiers and associations are ignored. By default,
           null-valued properties and properties which return an empty string from
           the call to <tt class="code">ToString()</tt> are excluded.
        </p><p>
           You can adjust how the <tt class="literal">Example</tt> is applied.
        </p><pre class="programlisting">Example example = Example.Create(cat)
    .ExcludeZeroes()           //exclude null- or zero-valued properties
    .ExcludeProperty("Color")  //exclude the property named "color"
    .IgnoreCase()              //perform case insensitive string comparisons
    .EnableLike();             //use like for string comparisons
var results = session.CreateCriteria&lt;Cat&gt;()
    .Add(example)
    .List&lt;Cat&gt;();</pre><p>
            You can even use examples to place criteria upon associated objects.
        </p><pre class="programlisting">var results = session.CreateCriteria&lt;Cat&gt;()
    .Add( Example.Create(cat) )
    .CreateCriteria("Mate")
        .Add( Example.Create( cat.Mate ) )
    .List&lt;Cat&gt;();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-projection"></a>16.8.&nbsp;Projections, aggregation and grouping</h2></div></div><div></div></div><p>
            The class <tt class="literal">NHibernate.Expression.Projections</tt> is a
            factory for <tt class="literal">IProjection</tt> instances. We apply a
            projection to a query by calling <tt class="literal">SetProjection()</tt>.
        </p><pre class="programlisting">var results = session.CreateCriteria&lt;Cat&gt;()
    .SetProjection( Projections.RowCount() )
    .Add( Expression.Eq("Color", Color.BLACK) )
    .List&lt;int&gt;();</pre><pre class="programlisting">var results = session.CreateCriteria&lt;Cat&gt;()
    .SetProjection( Projections.ProjectionList()
        .Add( Projections.RowCount() )
        .Add( Projections.Avg("Weight") )
        .Add( Projections.Max("Weight") )
        .Add( Projections.GroupProperty("Color") )
    )
    .List&lt;object[]&gt;();</pre><p>
            There is no explicit "group by" necessary in a criteria query. Certain
            projection types are defined to be <span class="emphasis"><em>grouping projections</em></span>,
            which also appear in the SQL <tt class="literal">group by</tt> clause.
        </p><p>
            An alias may optionally be assigned to a projection, so that the projected value
            may be referred to in restrictions or orderings. Here are two different ways to
            do this:
        </p><pre class="programlisting">var results = session.CreateCriteria&lt;Cat&gt;()
    .SetProjection( Projections.Alias( Projections.GroupProperty("Color"), "colr" ) )
    .AddOrder( Order.Asc("colr") )
    .List&lt;string&gt;();</pre><pre class="programlisting">var results = session.CreateCriteria&lt;Cat&gt;()
    .SetProjection( Projections.GroupProperty("Color").As("colr") )
    .AddOrder( Order.Asc("colr") )
    .List&lt;string&gt;();</pre><p>
            The <tt class="literal">Alias()</tt> and <tt class="literal">As()</tt> methods simply wrap a
            projection instance in another, aliased, instance of <tt class="literal">IProjection</tt>.
            As a shortcut, you can assign an alias when you add the projection to a 
            projection list:
        </p><pre class="programlisting">var results = session.CreateCriteria&lt;Cat&gt;()
    .SetProjection( Projections.ProjectionList()
        .Add( Projections.RowCount(), "catCountByColor" )
        .Add( Projections.Avg("Weight"), "avgWeight" )
        .Add( Projections.Max("Weight"), "maxWeight" )
        .Add( Projections.GroupProperty("Color"), "color" )
    )
    .AddOrder( Order.Desc("catCountByColor") )
    .AddOrder( Order.Desc("avgWeight") )
    .List&lt;object[]&gt;();</pre><pre class="programlisting">var results = session.CreateCriteria(typeof(DomesticCat), "cat")
    .CreateAlias("kittens", "kit")
    .SetProjection( Projections.ProjectionList()
        .Add( Projections.Property("cat.Name"), "catName" )
        .Add( Projections.Property("kit.Name"), "kitName" )
    )
    .AddOrder( Order.Asc("catName") )
    .AddOrder( Order.Asc("kitName") )
    .List&lt;object[]&gt;();</pre><p>
        You can also add an entity projection to a criteria query:
      </p><pre class="programlisting">var kittens = sess.CreateCriteria&lt;Cat&gt;()
    .CreateCriteria("Kittens", "kt")
    .Add(Expression.Eq("Name", "F%"))
    .SetProjection(Projections.Entity(typeof(Cat), "kt"))
    .List();</pre><pre class="programlisting">var cats = sess.CreateCriteria&lt;Cat&gt;()
    .CreateCriteria("Kittens", "kt")
    .Add(Expression.Eq("Name", "F%"))
    .SetProjection(
        Projections.RootEntity(),
        Projections.Entity(typeof(Cat), "kt"))
    .List&lt;object[]&gt;();

foreach (var objs in cats)
{
    Cat cat = (Cat) objs[0];
    Cat kitten = (Cat) objs[1];
}</pre><p>
        See <a href="#queryqueryover-projectionentities" title="17.9.&nbsp;Entities Projection">Section&nbsp;17.9, &#8220;Entities Projection&#8221;</a> for more information.
      </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-detachedqueries"></a>16.9.&nbsp;Detached queries and sub-queries</h2></div></div><div></div></div><p>
            The <tt class="literal">DetachedCriteria</tt> class lets you create a query outside the scope 
            of a session, and then later execute it using some arbitrary <tt class="literal">ISession</tt>.
        </p><pre class="programlisting">DetachedCriteria query = DetachedCriteria.For&lt;Cat&gt;()
    .Add( Expression.Eq("sex", 'F') );

using (ISession session = ....)
using (ITransaction txn = session.BeginTransaction())
{
    var results = query.GetExecutableCriteria(session).SetMaxResults(100).List&lt;Cat&gt;();
    txn.Commit();
}</pre><p>
            A <tt class="literal">DetachedCriteria</tt> may also be used to express a sub-query. ICriterion
            instances involving sub-queries may be obtained via <tt class="literal">Subqueries</tt>.
            
        </p><pre class="programlisting">DetachedCriteria avgWeight = DetachedCriteria.For&lt;Cat&gt;()
    .SetProjection( Projections.Avg("Weight") );
session.CreateCriteria&lt;Cat&gt;()
    .Add( Subqueries.Gt("Weight", avgWeight) )
    .List&lt;Cat&gt;();</pre><pre class="programlisting">DetachedCriteria weights = DetachedCriteria.For&lt;Cat&gt;()
    .SetProjection( Projections.Property("Weight") );
session.CreateCriteria&lt;Cat&gt;()
    .Add( Subqueries.GeAll("Weight", weights) )
    .List&lt;Cat&gt;();</pre><p>
            Even correlated sub-queries are possible:
        </p><pre class="programlisting">DetachedCriteria avgWeightForSex = DetachedCriteria.For&lt;Cat&gt;("cat2")
    .SetProjection( Projections.Avg("Weight") )
    .Add( Expression.EqProperty("cat2.Sex", "cat.Sex") );
session.CreateCriteria(typeof(Cat), "cat")
    .Add( Subqueries.Gt("weight", avgWeightForSex) )
    .List&lt;Cat&gt;();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="queryqueryover"></a>Chapter&nbsp;17.&nbsp;QueryOver Queries</h2></div></div><div></div></div><p>
        The ICriteria API
        is NHibernate's implementation of Query Object.
        NHibernate 3.0 introduces the QueryOver API, which combines the use of
        Extension Methods
        and
        Lambda Expressions
        (both new in .Net 3.5) to provide a statically type-safe wrapper round the ICriteria API.
    </p><p>
        QueryOver uses Lambda Expressions to provide some extra
        syntax to remove the 'magic strings' from your ICriteria queries.
    </p><p>
        So, for example:
    </p><pre class="programlisting">.Add(Expression.Eq("Name", "Smith"))</pre><p>becomes:</p><pre class="programlisting">.Where&lt;Person&gt;(p =&gt; p.Name == "Smith")</pre><p>
        With this kind of syntax there are no 'magic strings', and refactoring tools like
        'Find All References', and 'Refactor-&gt;Rename' work perfectly.
    </p><p>
        Note: QueryOver is intended to remove the references to 'magic strings'
        from the ICriteria API while maintaining it's opaqueness.  It is <span class="underline">not</span> a LINQ provider;
        NHibernate has a built-in <a href="#querylinq" title="Chapter&nbsp;18.&nbsp;Linq Queries">Linq provider</a> for this.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-querystructure"></a>17.1.&nbsp;Structure of a Query</h2></div></div><div></div></div><p>
            Queries are created from an ISession using the syntax:
        </p><pre class="programlisting">IList&lt;Cat&gt; cats =
    session.QueryOver&lt;Cat&gt;()
        .Where(c =&gt; c.Name == "Max")
        .List();</pre><p>&nbsp;</p><p>
            Detached QueryOver (analogous to DetachedCriteria) can be created, and then used with an ISession using:
        </p><pre class="programlisting">QueryOver&lt;Cat&gt; query =
    QueryOver.Of&lt;Cat&gt;()
        .Where(c =&gt; c.Name == "Paddy");
        
IList&lt;Cat&gt; cats =
    query.GetExecutableQueryOver(session)
        .List();</pre><p>
            Queries can be built up to use restrictions, projections, and ordering using
            a fluent inline syntax:    
        </p><pre class="programlisting">var catNames =
    session.QueryOver&lt;Cat&gt;()
        .WhereRestrictionOn(c =&gt; c.Age).IsBetween(2).And(8)
        .Select(c =&gt; c.Name)
        .OrderBy(c =&gt; c.Name).Asc
        .List&lt;string&gt;();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-simpleexpressions"></a>17.2.&nbsp;Simple Expressions</h2></div></div><div></div></div><p>
            The Restrictions class (used by ICriteria) has been extended to include overloads
            that allow Lambda Expression syntax.  The Where() method works for simple expressions (&lt;, &lt;=, ==, !=, &gt;, &gt;=)
            so instead of:
        </p><pre class="programlisting">ICriterion equalCriterion = Restrictions.Eq("Name", "Max")</pre><p>
            You can write:
        </p><pre class="programlisting">ICriterion equalCriterion = Restrictions.Where&lt;Cat&gt;(c =&gt; c.Name == "Max")</pre><p>&nbsp;</p><p>
            Since the QueryOver class (and IQueryOver interface) is generic and knows the type of the query,
            there is an inline syntax for restrictions that does not require the additional qualification
            of class name.  So you can also write:
        </p><pre class="programlisting">var cats =
    session.QueryOver&lt;Cat&gt;()
        .Where(c =&gt; c.Name == "Max")
        .And(c =&gt; c.Age &gt; 4)
        .List();</pre><p>
            Note, the methods Where() and And() are semantically identical; the And() method is purely to allow
            QueryOver to look similar to HQL/SQL.
        </p><p>&nbsp;</p><p>
            Boolean comparisons can be made directly instead of comparing to true/false:
        </p><pre class="programlisting">        .Where(p =&gt; p.IsParent)
        .And(p =&gt; !p.IsRetired)</pre><p>&nbsp;</p><p>
            Simple expressions can also be combined using the || and &amp;&amp; operators.  So ICriteria like:
        </p><pre class="programlisting">        .Add(Restrictions.And(
                Restrictions.Eq("Name", "test name"),
                Restrictions.Or(
                    Restrictions.Gt("Age", 21),
                    Restrictions.Eq("HasCar", true))))</pre><p>
            Can be written in QueryOver as:
        </p><pre class="programlisting">        .Where(p =&gt; p.Name == "test name" &amp;&amp; (p.Age &gt; 21 || p.HasCar))</pre><p>&nbsp;</p><p>
            Each of the corresponding overloads in the QueryOver API allows the use of regular ICriterion
            to allow access to private properties.
        </p><pre class="programlisting">        .Where(Restrictions.Eq("Name", "Max"))</pre><p>&nbsp;</p><p>
            It is worth noting that the QueryOver API is built on top of the ICriteria API.  Internally the structures are the same, so at runtime
            the statement below, and the statement above, are stored as exactly the same ICriterion.  The actual Lambda Expression is not stored
            in the query.
        </p><pre class="programlisting">        .Where(c =&gt; c.Name == "Max")</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-additionalrestrictions"></a>17.3.&nbsp;Additional Restrictions</h2></div></div><div></div></div><p>
            Some SQL operators/functions do not have a direct equivalent in C#.
            (e.g., the SQL <tt class="literal">where name like '%anna%'</tt>).
            These operators have overloads for QueryOver in the Restrictions class, so you can write:
        </p><pre class="programlisting">        .Where(Restrictions.On&lt;Cat&gt;(c =&gt; c.Name).IsLike("%anna%"))</pre><p>
            There is also an inline syntax to avoid the qualification of the type:
        </p><pre class="programlisting">        .WhereRestrictionOn(c =&gt; c.Name).IsLike("%anna%")</pre><p>&nbsp;</p><p>
            While simple expressions (see above) can be combined using the || and &amp;&amp; operators, this is not possible with the other
            restrictions.  So this ICriteria:
        </p><pre class="programlisting">        .Add(Restrictions.Or(
            Restrictions.Gt("Age", 5)
            Restrictions.In("Name", new string[] { "Max", "Paddy" })))</pre><p>
            Would have to be written as:
        </p><pre class="programlisting">        .Add(Restrictions.Or(
            Restrictions.Where&lt;Cat&gt;(c =&gt; c.Age &gt; 5)
            Restrictions.On&lt;Cat&gt;(c =&gt; c.Name).IsIn(new string[] { "Max", "Paddy" })))</pre><p>
            However, in addition to the additional restrictions factory methods, there are extension methods to allow
            a more concise inline syntax for some of the operators.  So this:
        </p><pre class="programlisting">        .WhereRestrictionOn(c =&gt; c.Name).IsLike("%anna%")</pre><p>
            May also be written as:
        </p><pre class="programlisting">        .Where(c =&gt; c..Name.IsLike("%anna%"))</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-associations"></a>17.4.&nbsp;Associations</h2></div></div><div></div></div><p>
            QueryOver can navigate association paths using JoinQueryOver() (analogous to ICriteria.CreateCriteria() to create sub-criteria).
        </p><p>
            The factory method QuerOver&lt;T&gt;() on ISession returns an IQueryOver&lt;T&gt;.
            More accurately, it returns an IQueryOver&lt;T,T&gt; (which inherits from IQueryOver&lt;T&gt;).
        </p><p>
            An IQueryOver has two types of interest; the root type (the type of entity that the query returns),
            and the type of the 'current' entity being queried.  For example, the following query uses
            a join to create a sub-QueryOver (analogous to creating sub-criteria in the ICriteria API):
        </p><pre class="programlisting">IQueryOver&lt;Cat,Kitten&gt; catQuery =
    session.QueryOver&lt;Cat&gt;()
        .JoinQueryOver(c =&gt; c.Kittens)
            .Where(k =&gt; k.Name == "Tiddles");</pre><p>
            The JoinQueryOver returns a new instance of the IQueryOver than has its root at the Kittens collection.
            The default type for restrictions is now Kitten (restricting on the name 'Tiddles' in the above example),
            while calling .List() will return an IList&lt;Cat&gt;.  The type IQueryOver&lt;Cat,Kitten&gt; inherits from IQueryOver&lt;Cat&gt;.
        </p><p>
            Note, the overload for JoinQueryOver takes an IEnumerable&lt;T&gt;, and the C# compiler infers the type from that.
            If your collection type is not IEnumerable&lt;T&gt;, then you need to qualify the type of the sub-criteria:
        </p><pre class="programlisting">IQueryOver&lt;Cat,Kitten&gt; catQuery =
    session.QueryOver&lt;Cat&gt;()
        .JoinQueryOver&lt;<span class="emphasis"><em>Kitten</em></span>&gt;(c =&gt; c.Kittens)
            .Where(k =&gt; k.Name == "Tiddles");</pre><p>&nbsp;</p><p>
            The default join is an inner-join.  Each of the additional join types can be specified using
            the methods <tt class="code">.Inner, .Left, .Right,</tt> or <tt class="code">.Full</tt>.
            For example, to left outer-join on Kittens use:
        </p><pre class="programlisting">IQueryOver&lt;Cat,Kitten&gt; catQuery =
    session.QueryOver&lt;Cat&gt;()
        .Left.JoinQueryOver(c =&gt; c.Kittens)
            .Where(k =&gt; k.Name == "Tiddles");</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover_entityjoin"></a>17.5.&nbsp;Join entities without association (Entity joins or ad hoc joins)</h2></div></div><div></div></div><p>
        In QueryOver you have the ability to define a join to any entity, not just through a mapped association.
        To achieve it, use <tt class="literal">JoinEntityAlias</tt> and <tt class="literal">JoinEntityQueryOver</tt>. By example:
      </p><pre class="programlisting">Cat cat = null;
Cat joinedCat = null;

var uniquelyNamedCats = sess.QueryOver&lt;Cat&gt;(() =&gt; cat)
    .JoinEntityAlias(
        () =&gt; joinedCat,
        () =&gt; cat.Name == joinedCat.Name &amp;&amp; cat.Id != joinedCat.Id,
        JoinType.LeftOuterJoin)
    .Where(() =&gt; joinedCat.Id == null)
    .List();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-aliases"></a>17.6.&nbsp;Aliases</h2></div></div><div></div></div><p>
            In the traditional ICriteria interface aliases are assigned using 'magic strings', however their value
            does not correspond to a name in the object domain.  For example, when an alias is assigned using
            <tt class="code">.CreateAlias("Kitten", "kittenAlias")</tt>, the string "kittenAlias" does not correspond
            to a property or class in the domain.
        </p><p>
            In QueryOver, aliases are assigned using an empty variable.
            The variable can be declared anywhere (but should
            be <tt class="code">null</tt> at runtime).  The compiler can then check the syntax against the variable is
            used correctly, but at runtime the variable is not evaluated (it's just used as a placeholder for
            the alias).
        </p><p>
            Each Lambda Expression function in QueryOver has a corresponding overload to allow use of aliases,
            and a .JoinAlias function to traverse associations using aliases without creating a sub-QueryOver.
        </p><pre class="programlisting">Cat catAlias = null;
Kitten kittenAlias = null;

IQueryOver&lt;Cat,Cat&gt; catQuery =
    session.QueryOver&lt;Cat&gt;(() =&gt; catAlias)
        .JoinAlias(() =&gt; catAlias.Kittens, () =&gt; kittenAlias)
        .Where(() =&gt; catAlias.Age &gt; 5)
        .And(() =&gt; kittenAlias.Name == "Tiddles");</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-projections"></a>17.7.&nbsp;Projections</h2></div></div><div></div></div><p>
            Simple projections of the properties of the root type can be added using the <tt class="code">.Select</tt> method
            which can take multiple Lambda Expression arguments:
        </p><pre class="programlisting">var selection =
    session.QueryOver&lt;Cat&gt;()
        .Select(
            c =&gt; c.Name,
            c =&gt; c.Age)
        .List&lt;object[]&gt;();</pre><p>
            Because this query no longer returns a Cat, the return type must be explicitly specified.
            If a single property is projected, the return type can be specified using:
        </p><pre class="programlisting">IList&lt;int&gt; ages =
    session.QueryOver&lt;Cat&gt;()
        .Select(c =&gt; c.Age)
        .List&lt;int&gt;();</pre><p>
            However, if multiple properties are projected, then the returned list will contain
            object arrays, as per a projection
            in ICriteria.  This could be fed into an anonymous type using:
        </p><pre class="programlisting">var catDetails =
    session.QueryOver&lt;Cat&gt;()
        .Select(
            c =&gt; c.Name,
            c =&gt; c.Age)
        .List&lt;object[]&gt;()
        .Select(properties =&gt; new {
            CatName = (string)properties[0],
            CatAge = (int)properties[1],
            });
            
Console.WriteLine(catDetails[0].CatName);
Console.WriteLine(catDetails[0].CatAge);</pre><p>
            Note that the second <tt class="code">.Select</tt> call in this example is an extension method on IEnumerable&lt;T&gt; supplied in System.Linq;
            it is not part of NHibernate.
        </p><p>&nbsp;</p><p>
            QueryOver allows arbitrary IProjection to be added (allowing private properties to be projected).  The Projections factory
            class also has overloads to allow Lambda Expressions to be used:
        </p><pre class="programlisting">var selection =
    session.QueryOver&lt;Cat&gt;()
        .Select(Projections.ProjectionList()
            .Add(Projections.Property&lt;Cat&gt;(c =&gt; c.Name))
            .Add(Projections.Avg&lt;Cat&gt;(c =&gt; c.Age)))
        .List&lt;object[]&gt;();</pre><p>&nbsp;</p><p>
            In addition there is an inline syntax for creating projection lists that does not require the explicit class qualification:
        </p><pre class="programlisting">var selection =
    session.QueryOver&lt;Cat&gt;()
        .SelectList(list =&gt; list
            .Select(c =&gt; c.Name)
            .SelectAvg(c =&gt; c.Age))
        .List&lt;object[]&gt;();</pre><p>&nbsp;</p><p>
            Projections can also have arbitrary aliases assigned to them to allow result transformation.
            If there is a CatSummary DTO class defined as:
        </p><pre class="programlisting">public class CatSummary
{
    public string Name { get; set; }
    public int AverageAge { get; set; }
}</pre><p>
            ... then aliased projections can be used with the AliasToBean&lt;T&gt; transformer:
        </p><pre class="programlisting">CatSummary summaryDto = null;
IList&lt;CatSummary&gt; catReport =
    session.QueryOver&lt;Cat&gt;()
        .SelectList(list =&gt; list
            .SelectGroup(c =&gt; c.Name).WithAlias(() =&gt; summaryDto.Name)
            .SelectAvg(c =&gt; c.Age).WithAlias(() =&gt; summaryDto.AverageAge))
        .TransformUsing(Transformers.AliasToBean&lt;CatSummary&gt;())
        .List&lt;CatSummary&gt;();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-projectionfunctions"></a>17.8.&nbsp;Projection Functions</h2></div></div><div></div></div><p>
            In addition to projecting properties, there are extension methods to allow certain common dialect-registered
            functions to be applied.  For example you can write the following to get 3 letters named people.
        </p><pre class="programlisting">        .Where(p =&gt; p.FirstName.StrLength() == 3)</pre><p>
            The functions can also be used inside projections:
        </p><pre class="programlisting">        .Select(
            p =&gt; Projections.Concat(p.LastName, ", ", p.FirstName),
            p =&gt; p.Height.Abs())</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-projectionentities"></a>17.9.&nbsp;Entities Projection</h2></div></div><div></div></div><p>
        You can add entity projections via the <tt class="literal">AsEntity()</tt> extension.
      </p><pre class="programlisting">Cat mate = null;

var catAndMateNameList = sess.QueryOver&lt;Cat&gt;()
    .JoinAlias(c =&gt; c.Mate, () =&gt; mate)
    .Select(c =&gt; c.AsEntity(), c =&gt; mate.Name)
    .List&lt;object[]&gt;();</pre><p>
        Or it can be done via the <tt class="literal">Projections.RootEntity</tt> and <tt class="literal">Projections.Entity</tt> methods
        if more control over loaded entities is required. For instance, entity projections can be lazy loaded
        or fetched with lazy properties:
      </p><pre class="programlisting">.Select(
    Projections.Entity(() =&gt; alias1).SetLazy(true),
    Projections.Entity(() =&gt; alias2).SetFetchLazyProperties(true),
    Projections.RootEntity()
        )</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-subqueries"></a>17.10.&nbsp;Sub-queries</h2></div></div><div></div></div><p>
            The Sub-queries factory class has overloads to allow Lambda Expressions to express sub-query
            restrictions.  For example:
        </p><pre class="programlisting">QueryOver&lt;Cat&gt; maximumAge =
    QueryOver.Of&lt;Cat&gt;()
        .SelectList(p =&gt; p.SelectMax(c =&gt; c.Age));

IList&lt;Cat&gt; oldestCats =
    session.QueryOver&lt;Cat&gt;()
        .Where(Subqueries.WhereProperty&lt;Cat&gt;(c =&gt; c.Age).Eq(maximumAge))
        .List();</pre><p>&nbsp;</p><p>
            The inline syntax allows you to use sub-queries without re-qualifying the type:
        </p><pre class="programlisting">IList&lt;Cat&gt; oldestCats =
    session.QueryOver&lt;Cat&gt;()
        .WithSubquery.WhereProperty(c =&gt; c.Age).Eq(maximumAge)
        .List();</pre><p>&nbsp;</p><p>
            There is an extension method <tt class="code">As()</tt> on (a detached) QueryOver that allows you to cast it to any type.
            This is used in conjunction with the overloads <tt class="code">Where(), WhereAll(),</tt> and <tt class="code">WhereSome()</tt>
            to allow use of the built-in C# operators for comparison, so the above query can be written as:
        </p><pre class="programlisting">IList&lt;Cat&gt; oldestCats =
    session.QueryOver&lt;Cat&gt;()
        .WithSubquery.Where(c =&gt; c.Age == maximumAge.As&lt;int&gt;())
        .List();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="querylinq"></a>Chapter&nbsp;18.&nbsp;Linq Queries</h2></div></div><div></div></div><p>
    NHibernate 3.0 introduces the Linq to NHibernate provider, which allows the use of the Linq API
    for querying with NHibernate.
  </p><p>
    <tt class="literal">IQueryable</tt> queries are obtained with the <tt class="literal">Query</tt> methods used on the
    <tt class="literal">ISession</tt> or <tt class="literal">IStatelessSession</tt>. (Prior to NHibernate 5.0, these
    methods were extensions defined in the <tt class="literal">NHibernate.Linq</tt> namespace.) A number of
    NHibernate Linq extensions giving access to NHibernate specific features are defined in the
    <tt class="literal">NHibernate.Linq</tt> namespace. Of course, the Linq namespace is still needed too.
  </p><pre class="programlisting">using System.Linq;
using NHibernate.Linq;</pre><p>
    Note: NHibernate has another querying API which uses lambda, <a href="#queryqueryover" title="Chapter&nbsp;17.&nbsp;QueryOver Queries">QueryOver</a>.
    It should not be confused with a Linq provider.
  </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querylinq-querystructure"></a>18.1.&nbsp;Structure of a Query</h2></div></div><div></div></div><p>
      Queries are created from an ISession using the syntax:
    </p><pre class="programlisting">IList&lt;Cat&gt; cats =
    session.Query&lt;Cat&gt;()
        .Where(c =&gt; c.Color == "white")
        .ToList();</pre><p>
      The <tt class="literal">Query&lt;TEntity&gt;</tt> function yields an <tt class="literal">IQueryable&lt;TEntity&gt;</tt>,
      with which Linq extension methods or Linq syntax can be used. When executed, the <tt class="literal">IQueryable&lt;TEntity&gt;</tt>
      will be translated to a SQL query on the database.
    </p><p>&nbsp;</p><p>
      It is possible to query a specific sub-class while still using a queryable of the base class.
    </p><pre class="programlisting">IList&lt;Cat&gt; cats =
    session.Query&lt;Cat&gt;("Eg.DomesticCat, Eg")
        .Where(c =&gt; c.Name == "Max")
        .ToList();</pre><p>
      Starting with NHibernate 5.0, queries can also be created from an entity collection, with the standard
      Linq extension <tt class="literal">AsQueryable</tt> available from <tt class="literal">System.Linq</tt> namespace.
    </p><pre class="programlisting">IList&lt;Cat&gt; whiteKittens =
    cat.Kittens.AsQueryable()
        .Where(k =&gt; k.Color == "white")
        .ToList();</pre><p>
      This will be executed as a query on that <tt class="literal">cat</tt>'s kittens without loading the
      entire collection.
    </p><p>
      If the collection is a map, call <tt class="literal">AsQueryable</tt> on its <tt class="literal">Values</tt>
      property.
    </p><pre class="programlisting">IList&lt;Cat&gt; whiteKittens =
    cat.Kittens.Values.AsQueryable()
        .Where(k =&gt; k.Color == "white")
        .ToList();</pre><p>&nbsp;</p><p>
      A client timeout for the query can be defined. As most others NHibernate specific features for
      Linq, this is available through an extension defined in <tt class="literal">NHibernate.Linq</tt>
      namespace.
    </p><pre class="programlisting">IList&lt;Cat&gt; cats =
    session.Query&lt;Cat&gt;()
        .Where(c =&gt; c.Color == "black")
        // Allows 10 seconds only.
        .SetOptions(o =&gt; o.SetTimeout(10))
        .ToList();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querylinq-parametertypes"></a>18.2.&nbsp;Parameter types</h2></div></div><div></div></div><p>
      Query parameters get extracted from the Linq expression. Their types are selected according to 
      <a href="#mapping-types" title="5.2.&nbsp;NHibernate Types">NHibernate types</a> default for .Net types.
    </p><p>
      The <tt class="literal">MappedAs</tt> extension method allows to override the default type.
    </p><pre class="programlisting">IList&lt;Cat&gt; cats =
    session.Query&lt;Cat&gt;()
        .Where(c =&gt; c.BirthDate == DateTime.Today.MappedAs(NHibernateUtil.Date))
        .ToList();</pre><pre class="programlisting">IList&lt;Cat&gt; cats =
    session.Query&lt;Cat&gt;()
        .Where(c =&gt; c.Name == "Max".MappedAs(TypeFactory.Basic("AnsiString(200)")))
        .ToList();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querylinq-supportedmethods"></a>18.3.&nbsp;Supported methods and members</h2></div></div><div></div></div><p>
      Many methods and members of common .Net types are supported by the Linq to NHibernate provider.
      They will be translated to the appropriate SQL, provided they are called on an entity property
      (or expression deriving from) or at least one of their arguments references an entity property.
      (Otherwise, their return values will be evaluated with .Net runtime before query execution.)
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querylinq-supportedmethods-common"></a>18.3.1.&nbsp;Common methods</h3></div></div><div></div></div><p>
        The .Net 4 <tt class="literal">CompareTo</tt> method of strings and numerical types is translated to
        a <tt class="literal">case</tt> statement yielding <tt class="literal">-1|0|1</tt> according to the result
        of the comparison.
      </p><p>&nbsp;</p><p>
        Many type conversions are available. For all of them, .Net overloads with more than one argument
        are not supported.
      </p><p>
        Numerical types can be converted to other numerical types or parsed from strings, using
        following methods:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <tt class="literal">Convert.ToDecimal</tt>
          </p></li><li><p>
            <tt class="literal">Convert.ToDouble</tt>
          </p></li><li><p>
            <tt class="literal">Convert.ToInt32</tt>
          </p></li><li><p>
            <tt class="literal">Decimal.Parse</tt>
          </p></li><li><p>
            <tt class="literal">Double.Parse</tt>
          </p></li><li><p>
            <tt class="literal">Int32.Parse</tt>
          </p></li></ul></div><p>
        Strings can be converted to <tt class="literal">Boolean</tt> and <tt class="literal">DateTime</tt> with
        <tt class="literal">Convert.ToBoolean</tt> or <tt class="literal">Boolean.Parse</tt> and
        <tt class="literal">Convert.ToDateTime</tt> or <tt class="literal">DateTime.Parse</tt> respectively.
      </p><p>
        On all types supporting string conversion, <tt class="literal">ToString</tt> method can be called.
      </p><pre class="programlisting">IList&lt;string&gt; catBirthDates =
    session.Query&lt;Cat&gt;()
        .Select(c =&gt; c.BirthDate.ToString())
        .ToList();</pre><p>&nbsp;</p><p>
        <tt class="literal">Equals</tt> methods taking a single argument with the same type can be used. Of
        course, <tt class="literal">==</tt> is supported too.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querylinq-supportedmethods-datetime"></a>18.3.2.&nbsp;<tt class="literal">DateTime</tt> and <tt class="literal">DateTimeOffset</tt></h3></div></div><div></div></div><p>
        Date and time parts properties can be called on <tt class="literal">DateTime</tt> and <tt class="literal">DateTimeOffset</tt>.
        Those properties are:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <tt class="literal">Date</tt>
          </p></li><li><p>
            <tt class="literal">Day</tt>
          </p></li><li><p>
            <tt class="literal">Hour</tt>
          </p></li><li><p>
            <tt class="literal">Minute</tt>
          </p></li><li><p>
            <tt class="literal">Month</tt>
          </p></li><li><p>
            <tt class="literal">Second</tt>
          </p></li><li><p>
            <tt class="literal">Year</tt>
          </p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querylinq-supportedmethods-icollection"></a>18.3.3.&nbsp;<tt class="literal">ICollection</tt>, non generic and generic</h3></div></div><div></div></div><p>
        Collections <tt class="literal">Contains</tt> methods are supported.
      </p><pre class="programlisting">IList&lt;Cat&gt; catsWithWrongKitten =
    session.Query&lt;Cat&gt;()
        .Where(c =&gt; c.Kittens.Contains(c))
        .ToList();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querylinq-supportedmethods-idictionary"></a>18.3.4.&nbsp;<tt class="literal">IDictionary</tt>, non generic and generic</h3></div></div><div></div></div><p>
        Dictionaries <tt class="literal">Item</tt> getter are supported. This enables referencing a dictionary
        item value in a <tt class="literal">where</tt> condition, as it can be done with
        <a href="#queryhql-expressions" title="15.8.&nbsp;Expressions">HQL expressions</a>.
      </p><p>
        Non generic dictionary method <tt class="literal">Contains</tt> and generic dictionary method
        <tt class="literal">ContainsKey</tt> are translated to corresponding <tt class="literal">indices</tt>
        <a href="#queryhql-expressions" title="15.8.&nbsp;Expressions">HQL expressions</a>. Supposing <tt class="literal">Acts</tt>
        in following HQL example is generic,
      </p><pre class="programlisting">from Eg.Show show where 'fizard' in indices(show.Acts)</pre><p>
        it could be written with Linq:
      </p><pre class="programlisting">IList&lt;Show&gt; shows =
    session.Query&lt;Show&gt;()
        .Where(s =&gt; s.Acts.ContainsKey("fizard"))
        .ToList();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querylinq-supportedmethods-math"></a>18.3.5.&nbsp;Mathematical functions</h3></div></div><div></div></div><p>
        The following list of mathematical functions from <tt class="literal">System.Math</tt> is handled:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Trigonometric functions: <tt class="literal">Acos</tt>, <tt class="literal">Asin</tt>, <tt class="literal">Atan</tt>,
            <tt class="literal">Atan2</tt>, <tt class="literal">Cos</tt>, <tt class="literal">Cosh</tt>, <tt class="literal">Sin</tt>,
            <tt class="literal">Sinh</tt>, <tt class="literal">Tan</tt>, <tt class="literal">Tanh</tt>
          </p></li><li><p>
            <tt class="literal">Abs</tt> (all overloads)
          </p></li><li><p>
            <tt class="literal">Ceiling</tt> (both overloads)
          </p></li><li><p>
            <tt class="literal">Floor</tt> (both overloads)
          </p></li><li><p>
            <tt class="literal">Pow</tt>
          </p></li><li><p>
            <tt class="literal">Round</tt> (only overloads without a mode argument)
          </p></li><li><p>
            <tt class="literal">Sign</tt> (all overloads)
          </p></li><li><p>
            <tt class="literal">Sqrt</tt>
          </p></li><li><p>
            <tt class="literal">Truncate</tt> (both overloads)
          </p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querylinq-supportedmethods-nullables"></a>18.3.6.&nbsp;Nullables</h3></div></div><div></div></div><p>
        On <tt class="literal">Nullable&lt;&gt;</tt> types, <tt class="literal">GetValueOrDefault</tt> methods, with or
        without a provided default value, are supported.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querylinq-supportedmethods-string"></a>18.3.7.&nbsp;Strings</h3></div></div><div></div></div><p>
        The following properties and methods are supported on strings:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <tt class="literal">Contains</tt>
          </p></li><li><p>
            <tt class="literal">EndsWith</tt> (without additional parameters)
          </p></li><li><p>
            <tt class="literal">IndexOf</tt> (only overloads taking a character or a string, and optionally a start index)
          </p></li><li><p>
            <tt class="literal">Length</tt>
          </p></li><li><p>
            <tt class="literal">Replace</tt> (both overloads)
          </p></li><li><p>
            <tt class="literal">StartsWith</tt> (without additional parameters)
          </p></li><li><p>
            <tt class="literal">Substring</tt> (both overloads)
          </p></li><li><p>
            <tt class="literal">ToLower</tt> (without additional parameters) and <tt class="literal">ToLowerInvariant</tt>,
            both translated to the same database lower function.
          </p></li><li><p>
            <tt class="literal">ToUpper</tt> (without additional parameters) and <tt class="literal">ToUpperInvariant</tt>,
            both translated to the same database upper function.
          </p></li><li><p>
            <tt class="literal">Trim</tt> (both overloads)
          </p></li><li><p>
            <tt class="literal">TrimEnd</tt>
          </p></li><li><p>
            <tt class="literal">TrimStart</tt>
          </p></li></ul></div><p>&nbsp;</p><p>
        Furthermore, a string <tt class="literal">Like</tt> extension methods allows expressing SQL
        <tt class="literal">like</tt> conditions.
      </p><pre class="programlisting">IList&lt;DomesticCat&gt; cats =
    session.Query&lt;DomesticCat&gt;()
        .Where(c =&gt; c.Name.Like("L%l%l"))
        .ToList();</pre><p>
        This <tt class="literal">Like</tt> extension method is a Linq to NHibernate method only. Trying to call it
        in another context is not supported.
      </p><p>
        If you want to avoid depending on the <tt class="literal">NHibernate.Linq</tt> namespace,
        you can define your own replica of the <tt class="literal">Like</tt> methods. Any 2 or 3 arguments method
        named <tt class="literal">Like</tt> in a class named <tt class="literal">SqlMethods</tt> will be translated.
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querylinq-futureresults"></a>18.4.&nbsp;Future results</h2></div></div><div></div></div><p>
      Future results are supported by the Linq provider. They are not evaluated till one gets executed.
      At that point, all defined future results are evaluated in one single round-trip to the database.
    </p><pre class="programlisting">// Define queries
IFutureEnumerable&lt;Cat&gt; cats =
    session.Query&lt;Cat&gt;()
        .Where(c =&gt; c.Color == "black")
        .ToFuture();
IFutureValue&lt;int&gt; catCount =
    session.Query&lt;Cat&gt;()
        .ToFutureValue(q =&gt; q.Count());
// Execute them
foreach(Cat cat in cats.GetEnumerable())
{
    // Do something
}
if (catCount.Value &gt; 10)
{
    // Do something
}
</pre><p>
      See <a href="#performance-future" title="21.8.&nbsp;Future results">Section&nbsp;21.8, &#8220;Future results&#8221;</a> for more information.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querylinq-fetching"></a>18.5.&nbsp;Fetching associations</h2></div></div><div></div></div><p>
      A Linq query may load associated entities or collection of entities. Once the query is defined, using
      <tt class="literal">Fetch</tt> allows fetching a related entity, and <tt class="literal">FetchMany</tt> allows
      fetching a collection. These methods are defined as extensions in <tt class="literal">NHibernate.Linq</tt>
      namespace.
    </p><pre class="programlisting">IList&lt;Cat&gt; oldCats =
    session.Query&lt;Cat&gt;()
        .Where(c =&gt; c.BirthDate.Year &lt; 2010)
        .Fetch(c =&gt; c.Mate)
        .FetchMany(c =&gt; c.Kittens)
        .ToList();</pre><p>
      Issuing many <tt class="literal">FetchMany</tt> on the same query may cause a cartesian product over
      the fetched collections. This can be avoided by splitting the fetches among 
      <a href="#querylinq-futureresults" title="18.4.&nbsp;Future results">future queries</a>.
    </p><pre class="programlisting">IQueryable&lt;Cat&gt; oldCatsQuery =
    session.Query&lt;Cat&gt;()
        .Where(c =&gt; c.BirthDate.Year &lt; 2010);
oldCatsQuery
    .Fetch(c =&gt; c.Mate)
    .FetchMany(c =&gt; c.Kittens)
    .ToFuture();
IList&lt;Cat&gt; oldCats =
    oldCatsQuery
        .FetchMany(c =&gt; c.AnotherCollection)
        .ToFuture()
        .GetEnumerable()
        .ToList();</pre><p>&nbsp;</p><p>
      Use <tt class="literal">ThenFetch</tt> and <tt class="literal">ThenFetchMany</tt> for fetching associations
      of the previously fetched association.
    </p><pre class="programlisting">IList&lt;Cat&gt; oldCats =
    session.Query&lt;Cat&gt;()
        .Where(c =&gt; c.BirthDate.Year &lt; 2010)
        .Fetch(c =&gt; c.Mate)
        .FetchMany(c =&gt; c.Kittens)
        .ThenFetch(k =&gt; k.Mate)
        .ToList();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querylinq-modifying"></a>18.6.&nbsp;Modifying entities inside the database</h2></div></div><div></div></div><p>
      Beginning with NHibernate 5.0, Linq queries can be used for inserting, updating or deleting entities.
      The query defines the data to delete, update or insert, and then <tt class="literal">Delete</tt>,
      <tt class="literal">Update</tt>, <tt class="literal">UpdateBuilder</tt>, <tt class="literal">InsertInto</tt> and
      <tt class="literal">InsertBuilder</tt> queryable extension methods allow to delete it,
      or instruct in which way it should be updated or inserted. Those queries happen entirely inside the
      database, without extracting corresponding entities out of the database.
    </p><p>
      These operations are a Linq implementation of <a href="#batch-direct" title="14.3.&nbsp;DML-style operations">Section&nbsp;14.3, &#8220;DML-style operations&#8221;</a>, with the same abilities
      and limitations.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querylinq-modifying-insert"></a>18.6.1.&nbsp;Inserting new entities</h3></div></div><div></div></div><p>
        <tt class="literal">InsertInto</tt> and <tt class="literal">InsertBuilder</tt> method extensions expect a NHibernate
        queryable defining the data source of the insert. This data can be entities or a projection. Then they
        allow specifying the target entity type to insert, and how to convert source data to those target
        entities. Three forms of target specification exist.
      </p><p>
        Using projection to target entity:
      </p><pre class="programlisting">session.Query&lt;Cat&gt;()
    .Where(c =&gt; c.BodyWeight &gt; 20)
    .InsertInto(c =&gt; new Dog { Name = c.Name + "dog", BodyWeight = c.BodyWeight });</pre><p>
        Projections can be done with an anonymous object too, but it requires supplying explicitly the target
        type, which in turn requires re-specifying the source type:
      </p><pre class="programlisting">session.Query&lt;Cat&gt;()
    .Where(c =&gt; c.BodyWeight &gt; 20)
    .InsertInto&lt;Cat, Dog&gt;(c =&gt; new { Name = c.Name + "dog", BodyWeight = c.BodyWeight });</pre><p>
        Or using assignments:
      </p><pre class="programlisting">session.Query&lt;Cat&gt;()
    .Where(c =&gt; c.BodyWeight &gt; 20)
    .InsertBuilder()
    .Into&lt;Dog&gt;()
    .Value(d =&gt; d.Name, c =&gt; c.Name + "dog")
    .Value(d =&gt; d.BodyWeight, c =&gt; c.BodyWeight)
    .Insert();</pre><p>
        In all cases, unspecified properties are not included in the resulting SQL insert.
        <a href="#mapping-declaration-version" title="5.1.8.&nbsp;version (optional)"><tt class="literal">version</tt></a> and
        <a href="#mapping-declaration-timestamp" title="5.1.9.&nbsp;timestamp (optional)"><tt class="literal">timestamp</tt></a> properties are
        exceptions. If not specified, they are inserted with their <tt class="literal">seed</tt> value.
      </p><p>
        For more information on <tt class="literal">Insert</tt> limitations, please refer to
        <a href="#batch-direct" title="14.3.&nbsp;DML-style operations">Section&nbsp;14.3, &#8220;DML-style operations&#8221;</a>.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querylinq-modifying-update"></a>18.6.2.&nbsp;Updating entities</h3></div></div><div></div></div><p>
        <tt class="literal">Update</tt> and <tt class="literal">UpdateBuilder</tt> method extensions expect a NHibernate
        queryable defining the entities to update. Then they allow specifying which properties should be
        updated with which values. As for insertion, three forms of target specification exist.
      </p><p>
        Using projection to updated entity:
      </p><pre class="programlisting">session.Query&lt;Cat&gt;()
    .Where(c =&gt; c.BodyWeight &gt; 20)
    .Update(c =&gt; new Cat { BodyWeight = c.BodyWeight / 2 });</pre><p>
        Projections can be done with an anonymous object too:
      </p><pre class="programlisting">session.Query&lt;Cat&gt;()
    .Where(c =&gt; c.BodyWeight &gt; 20)
    .Update(c =&gt; new { BodyWeight = c.BodyWeight / 2 });</pre><p>
        Or using assignments:
      </p><pre class="programlisting">session.Query&lt;Cat&gt;()
    .Where(c =&gt; c.BodyWeight &gt; 20)
    .UpdateBuilder()
    .Set(c =&gt; c.BodyWeight, c =&gt; c.BodyWeight / 2)
    .Update();</pre><p>
        In all cases, unspecified properties are not included in the resulting SQL update. This could
        be changed for <a href="#mapping-declaration-version" title="5.1.8.&nbsp;version (optional)"><tt class="literal">version</tt></a> and
        <a href="#mapping-declaration-timestamp" title="5.1.9.&nbsp;timestamp (optional)"><tt class="literal">timestamp</tt></a> properties:
        using <tt class="literal">UpdateVersioned</tt> instead of <tt class="literal">Update</tt> allows incrementing
        the version. Custom version types (<tt class="literal">NHibernate.Usertype.IUserVersionType</tt>) are
        not supported.
      </p><p>
        When using projection to updated entity, please note that the constructed entity must have the
        exact same type than the underlying queryable source type. Attempting to project to any other class
        (anonymous projections excepted) will fail.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querylinq-modifying-delete"></a>18.6.3.&nbsp;Deleting entities</h3></div></div><div></div></div><p>
        <tt class="literal">Delete</tt> method extension expects a queryable defining the entities to delete.
        It immediately deletes them.
      </p><pre class="programlisting">session.Query&lt;Cat&gt;()
    .Where(c =&gt; c.BodyWeight &gt; 20)
    .Delete();</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querylinq-querycache"></a>18.7.&nbsp;Query cache</h2></div></div><div></div></div><p>
      The Linq provider can use the query cache if it is setup. Refer to
      <a href="#performance-querycache" title="21.4.&nbsp;The Query Cache">Section&nbsp;21.4, &#8220;The Query Cache&#8221;</a> for more details on how to set it up.
    </p><p>&nbsp;</p><p>
      <tt class="literal">SetOptions</tt> extension method allows to enable the cache for the query.
    </p><pre class="programlisting">IList&lt;Cat&gt; oldCats =
    session.Query&lt;Cat&gt;()
        .Where(c =&gt; c.BirthDate.Year &lt; 2010)
        .SetOptions(o =&gt; o.SetCacheable(true))
        .ToList();</pre><p>&nbsp;</p><p>
      The cache mode and cache region can be specified too.
    </p><pre class="programlisting">IList&lt;Cat&gt; cats =
    session.Query&lt;Cat&gt;()
        .Where(c =&gt; c.Name == "Max")
        .SetOptions(o =&gt; o
            .SetCacheable(true)
            .SetCacheRegion("catNames")
            .SetCacheMode(CacheMode.Put))
        .ToList();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querylinq-extending"></a>18.8.&nbsp;Extending the Linq to NHibernate provider</h2></div></div><div></div></div><p>
      The Linq to NHibernate provider can be extended for supporting additional SQL functions or
      translating additional methods or properties to a SQL query.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querylinq-extending-sqlfunctions"></a>18.8.1.&nbsp;Adding SQL functions</h3></div></div><div></div></div><p>
        NHibernate Linq provider feature a <tt class="literal">LinqExtensionMethod</tt> attribute. It allows using an
        arbitrary, built-in or user defined, SQL function. It should be applied on a method having the same
        arguments than the SQL function.
      </p><pre class="programlisting">public static class CustomLinqExtensions
{
    [LinqExtensionMethod()]
    public static string Checksum(this double input)
    {
        // No need to implement it in .Net, unless you wish to call it
        // outside IQueryable context too.
        throw new NotImplementedException("This call should be translated " +
            "to SQL and run db side, but it has been run with .Net runtime");
    }
}</pre><p>
        Then it can be used in a Linq to NHibernate query.
      </p><pre class="programlisting">var rnd = (new Random()).NextDouble();
IList&lt;Cat&gt; cats =
    session.Query&lt;Cat&gt;()
        // Pseudo random order
        .OrderBy(c =&gt; (c.Id * rnd).Checksum())
        .ToList();</pre><p>
        The function name is inferred from the method name. If needed, another name can be provided.
      </p><pre class="programlisting">public static class CustomLinqExtensions
{
    [LinqExtensionMethod("dbo.aCustomFunction")]
    public static string ACustomFunction(this string input, string otherInput)
    {
        throw new NotImplementedException();
    }
}</pre><p>
        Since NHibernate v5.0, the Linq provider will no more evaluate in-memory the method call
        even when it does not depend on the queried data. If you wish to have the method call evaluated
        before querying whenever possible, and then replaced in the query by its resulting value, specify
        <tt class="literal">LinqExtensionPreEvaluation.AllowPreEvaluation</tt> on the attribute.
      </p><pre class="programlisting">public static class CustomLinqExtensions
{
    [LinqExtensionMethod("dbo.aCustomFunction",
        LinqExtensionPreEvaluation.AllowPreEvaluation)]
    public static string ACustomFunction(this string input, string otherInput)
    {
        // In-memory evaluation implementation.
        return input.Replace(otherInput, "blah");
    }
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querylinq-extending-generator"></a>18.8.2.&nbsp;Adding a custom generator</h3></div></div><div></div></div><p>
        Generators are responsible for translating .Net method calls found in lambdas to the proper HQL
        constructs. Adding support for a new method call can be achieved by registering an additional
        generator in the Linq to NHibernate provider.
      </p><p>
        If the purpose of the added method is to simply call some SQL function, using
        <a href="#querylinq-extending-sqlfunctions" title="18.8.1.&nbsp;Adding SQL functions">Section&nbsp;18.8.1, &#8220;Adding SQL functions&#8221;</a> will be easier.
      </p><p>&nbsp;</p><p>
        As an example, here is how to add support for an <tt class="literal">AsNullable</tt> method which
        would allow to call aggregates which may yield <tt class="literal">null</tt> without to explicitly
        cast to the nullable type of the aggregate.
      </p><pre class="programlisting">public static class NullableExtensions
{
    public static T? AsNullable&lt;T&gt;(this T value) where T : struct
    {
        // Allow runtime use.
        // Not useful for linq-to-nhibernate, could be:
        // throw NotSupportedException();
        return value;
    }
}</pre><p>
        Adding support in Linq to NHibernate for a custom method requires a generator. For this
        <tt class="literal">AsNullable</tt> method, we need a method generator, declaring statically its
        supported method.
      </p><pre class="programlisting">public class AsNullableGenerator : BaseHqlGeneratorForMethod
{
    public AsNullableGenerator()
    {
        SupportedMethods = new[]
        {
             ReflectHelper.GetMethodDefinition(() =&gt; NullableExtensions.AsNullable(0))
        };
    }

    public override HqlTreeNode BuildHql(MethodInfo method,
        Expression targetObject,
        ReadOnlyCollection&lt;Expression&gt; arguments,
        HqlTreeBuilder treeBuilder,
        IHqlExpressionVisitor visitor)
    {
        // This has just to transmit the argument "as is", HQL does not need
        // a specific call for null conversion.
        return visitor.Visit(arguments[0]).AsExpression();
    }
}</pre><p>
        There are property generators too, and the supported methods or properties can be
        dynamically declared. Check NHibernate <tt class="literal">NHibernate.Linq.Functions</tt>
        namespace classes's sources for more examples. <tt class="literal">CompareGenerator</tt>
        and <tt class="literal">DateTimePropertiesHqlGenerator</tt> are examples of those other cases.
      </p><p>
        For adding <tt class="literal">AsNullableGenerator</tt> in Linq to NHibernate provider, a new
        generators registry should be used. Derive from the default one and merge it. (Here we
        have a static declaration of method support case.)
      </p><pre class="programlisting">public class ExtendedLinqToHqlGeneratorsRegistry :
DefaultLinqToHqlGeneratorsRegistry
{
    public ExtendedLinqToHqlGeneratorsRegistry()
        : base()
    {
        this.Merge(new AsNullableGenerator());
    }
}</pre><p>
        In the case of dynamic declaration of method support, another call is required instead of
        the merge: <tt class="literal">RegisterGenerator</tt>. <tt class="literal">CompareGenerator</tt>
        illustrates this.
      </p><p>
        The last step is to instruct NHibernate to use this extended registry. It can be achieved
        through <a href="#configuration-xmlconfig" title="3.9.&nbsp;XML Configuration File">xml configuration</a> under
        <tt class="literal">session-factory</tt> node, or by
        <a href="#configuration-programmatic" title="3.1.&nbsp;Programmatic Configuration">code</a> before building the session factory.
        Use one of them.
      </p><pre class="programlisting">&lt;property name="linqtohql.generatorsregistry"&gt;
    YourNameSpace.ExtendedLinqToHqlGeneratorsRegistry, YourAssemblyName
&lt;/property&gt;</pre><pre class="programlisting">using NHibernate.Cfg;
// ...

var cfg = new Configuration();
cfg.LinqToHqlGeneratorsRegistry&lt;ExtendedLinqToHqlGeneratorsRegistry&gt;();
// And build the session factory with this configuration.</pre><p>
        Now the following query could be executed, without failing if no <tt class="literal">Max</tt> cat
        exists.
      </p><pre class="programlisting">var oldestMaxBirthDate =
    session.Query&lt;Cat&gt;()
        .Where(c =&gt; c.Name == "Max")
        .Select(c =&gt; c.BirthDate.AsNullable())
        .Min();</pre><p>
        (Of course, the same result could be obtained with <tt class="literal">(DateTime?)(c.BirthDate)</tt>.)
      </p><p>
        By default, the Linq provider will try to evaluate the method call with .Net runtime
        whenever possible, instead of translating it to SQL. It will not do it if at least one
        of the parameters of the method call has its value originating from an entity, or if
        the method is marked with the <tt class="literal">NoPreEvaluation</tt> attribute (available
        since NHibernate 5.0).
      </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="querysql"></a>Chapter&nbsp;19.&nbsp;Native SQL</h2></div></div><div></div></div><p>You may also express queries in the native SQL dialect of your
  database. This is useful if you want to utilize database specific features
  such as query hints or the <tt class="literal">CONNECT</tt> keyword in Oracle. It
  also provides a clean migration path from a direct SQL/ADO.NET based
  application to NHibernate.</p><p>NHibernate allows you to specify handwritten SQL (including stored
  procedures) for all create, update, delete, and load operations.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-creating"></a>19.1.&nbsp;Using an <tt class="literal">ISQLQuery</tt></h2></div></div><div></div></div><p>Execution of native SQL queries is controlled via the
    <tt class="literal">ISQLQuery</tt> interface, which is obtained by calling
    <tt class="literal">ISession.CreateSQLQuery()</tt>. The following describes how
    to use this API for querying.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querysql-scalar"></a>19.1.1.&nbsp;Scalar queries</h3></div></div><div></div></div><p>The most basic SQL query is to get a list of scalars
      (values).</p><pre class="programlisting">sess.CreateSQLQuery("SELECT * FROM CATS")
 .AddScalar("ID", NHibernateUtil.Int64)
 .AddScalar("NAME", NHibernateUtil.String)
 .AddScalar("BIRTHDATE", NHibernateUtil.Date)
</pre><p>This query specified:</p><div class="itemizedlist"><ul type="disc"><li><p>the SQL query string</p></li><li><p>the columns and types to return</p></li></ul></div><p>This will return an <tt class="literal">IList</tt> of <tt class="literal">Object</tt>
      arrays (<tt class="literal">object[]</tt>) with
      scalar values for each column in the CATS table. Only these three
      columns will be returned, even though the query is using
      <tt class="literal">*</tt> and could return more than the three listed
      columns.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querysql-entity"></a>19.1.2.&nbsp;Entity queries</h3></div></div><div></div></div><p>The above query was about returning scalar values,
      basically returning the "raw" values from the result set. The following
      shows how to get entity objects from a native SQL query via
      <tt class="literal">AddEntity()</tt>.</p><pre class="programlisting">sess.CreateSQLQuery("SELECT * FROM CATS").AddEntity(typeof(Cat));
sess.CreateSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").AddEntity(typeof(Cat));
</pre><p>This query specified:</p><div class="itemizedlist"><ul type="disc"><li><p>the SQL query string</p></li><li><p>the entity returned by the query</p></li></ul></div><p>Assuming that Cat is mapped as a class with the columns ID, NAME
      and BIRTHDATE the above queries will both return an IList where each
      element is a Cat entity.</p><p>If the entity is mapped with a <tt class="literal">many-to-one</tt> to
      another entity it is required to also return its identifier when
      performing the native query, otherwise a database specific "column not
      found" error will occur. The additional columns will automatically be
      returned when using the * notation, but we prefer to be explicit as in
      the following example for a <tt class="literal">many-to-one</tt> to a
      <tt class="literal">Dog</tt>:</p><pre class="programlisting">sess.CreateSQLQuery("SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS")
    .AddEntity(typeof(Cat));</pre><p>This will allow cat.Dog property access to function properly.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querysql-associations-collections"></a>19.1.3.&nbsp;Handling associations and collections</h3></div></div><div></div></div><p>It is possible to eagerly join in the <tt class="literal">Dog</tt> to
      avoid the possible extra round-trip for initializing the proxy. This is
      done via the <tt class="literal">AddJoin()</tt> method, which allows you to
      join in an association or collection.</p><pre class="programlisting">sess
    .CreateSQLQuery(
        "SELECT cat.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME " +
        "FROM CATS cat, DOGS d WHERE cat.DOG_ID = d.D_ID")
    .AddEntity("cat", typeof(Cat))
    .AddJoin("cat.Dog");</pre><p>In this example the returned <tt class="literal">Cat</tt>'s will have
      their <tt class="literal">Dog</tt> property fully initialized without any
      extra round-trip to the database. Notice that we added a alias name
      ("cat") to be able to specify the target property path of the join. It
      is possible to do the same eager joining for collections, e.g. if the
      <tt class="literal">Cat</tt> had a one-to-many to <tt class="literal">Dog</tt>
      instead.</p><pre class="programlisting">sess
    .CreateSQLQuery(
        "SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID " +
        "FROM CATS cat, DOGS d WHERE cat.ID = d.CAT_ID")
    .AddEntity("cat", typeof(Cat))
    .AddJoin("cat.Dogs");</pre><p>At this stage we are reaching the limits of what is possible with
      native queries without starting to enhance the SQL queries to make them
      usable in NHibernate; the problems start to arise when returning
      multiple entities of the same type or when the default alias/column
      names are not enough.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querysql-multiple-entities"></a>19.1.4.&nbsp;Returning multiple entities</h3></div></div><div></div></div><p>Until now the result set column names are assumed to be the same
      as the column names specified in the mapping document. This can be
      problematic for SQL queries which join multiple tables, since the same
      column names may appear in more than one table.</p><p>Column alias injection is needed in the following query (which
      most likely will fail):</p><pre class="programlisting">sess
    .CreateSQLQuery(
        "SELECT cat.*, mother.* " +
        "FROM CATS cat, CATS mother WHERE cat.MOTHER_ID = mother.ID")
    .AddEntity("cat", typeof(Cat))
    .AddEntity("mother", typeof(Cat))</pre><p>The intention for this query is to return two Cat instances per
      row, a cat and its mother. This will fail since there is a conflict of
      names since they are mapped to the same column names and on some
      databases the returned column aliases will most likely be on the form
      "c.ID", "c.NAME", etc. which are not equal to the columns specified in
      the mappings ("ID" and "NAME").</p><p>The following form is not vulnerable to column name
      duplication:</p><pre class="programlisting">sess
    .CreateSQLQuery(
        "SELECT {cat.*}, {mother.*} " +
        "FROM CATS cat, CATS mother WHERE cat.MOTHER_ID = mother.ID")
    .AddEntity("cat", typeof(Cat))
    .AddEntity("mother", typeof(Cat))</pre><p>This query specified:</p><div class="itemizedlist"><ul type="disc"><li><p>the SQL query string, with placeholders for NHibernate to
          inject column aliases</p></li><li><p>the entities returned by the query</p></li></ul></div><p>The {cat.*} and {mother.*} notation used above is a shorthand for
      "all properties". Alternatively, you may list the columns explicitly, but
      even in this case we let NHibernate inject the SQL column aliases for
      each property. The placeholder for a column alias is just the property
      name qualified by the table alias. In the following example, we retrieve
      Cats and their mothers from a different table (cat_log) to the one
      declared in the mapping metadata. Notice that we may even use the
      property aliases in the where clause if we like.</p><pre class="programlisting">String sql = "SELECT c.ID as {c.Id}, c.NAME as {c.Name}, " + 
         "c.BIRTHDATE as {c.BirthDate}, c.MOTHER_ID as {c.Mother}, {mother.*} " +
         "FROM CAT_LOG c, CAT_LOG m WHERE {c.Mother} = m.ID";

var loggedCats = sess.CreateSQLQuery(sql)
    .AddEntity("c", typeof(Cat))
    .AddEntity("m", typeof(Cat)).List&lt;object[]&gt;();
</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="querysql-aliasreferences"></a>19.1.4.1.&nbsp;Alias and property references</h4></div></div><div></div></div><p>For most cases the above alias injection is needed, but for
        queries relating to more complex mappings like composite properties,
        inheritance discriminators, collections etc. there are some specific
        aliases to use to allow NHibernate to inject the proper aliases.</p><p>The following table shows the different possibilities of using
        the alias injection. Note: the alias names in the result are examples,
        each alias will have a unique and probably different name when
        used.</p><div class="table"><a name="aliasinjection-summary"></a><p class="title"><b>Table&nbsp;19.1.&nbsp;Alias injection names</b></p><table summary="Alias injection names" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Description</th><th>Syntax</th><th>Example</th></tr></thead><tbody><tr><td>A simple property</td><td><tt class="literal">{[aliasname].[propertyname]}</tt></td><td><tt class="literal">A_NAME as {item.Name}</tt></td></tr><tr><td>A composite property</td><td><tt class="literal">{[aliasname].[componentname].[propertyname]}</tt></td><td><tt class="literal">CURRENCY as {item.Amount.Currency}, VALUE as
                {item.Amount.Value}</tt></td></tr><tr><td>Discriminator of an entity</td><td><tt class="literal">{[aliasname].class}</tt></td><td><tt class="literal">DISC as {item.class}</tt></td></tr><tr><td>All properties of an entity</td><td><tt class="literal">{[aliasname].*}</tt></td><td><tt class="literal">{item.*}</tt></td></tr><tr><td>A collection key</td><td><tt class="literal">{[aliasname].key}</tt></td><td><tt class="literal">ORGID as {coll.key}</tt></td></tr><tr><td>The id of an collection</td><td><tt class="literal">{[aliasname].id}</tt></td><td><tt class="literal">EMPID as {coll.id}</tt></td></tr><tr><td>The element of an collection</td><td><tt class="literal">{[aliasname].element}</tt></td><td><tt class="literal">XID as {coll.element}</tt></td></tr><tr><td>property of the element in the collection</td><td><tt class="literal">{[aliasname].element.[propertyname]}</tt></td><td><tt class="literal">NAME as {coll.element.Name}</tt></td></tr><tr><td>All properties of the element in the collection</td><td><tt class="literal">{[aliasname].element.*}</tt></td><td><tt class="literal">{coll.element.*}</tt></td></tr><tr><td>All properties of the collection</td><td><tt class="literal">{[aliasname].*}</tt></td><td><tt class="literal">{coll.*}</tt></td></tr></tbody></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querysql-non-managed-entities"></a>19.1.5.&nbsp;Returning non-managed entities</h3></div></div><div></div></div><p>It is possible to apply an <tt class="literal">IResultTransformer</tt> to native sql queries. Allowing it to e.g. return non-managed entities.</p><pre class="programlisting">sess.CreateSQLQuery("SELECT NAME, BIRTHDATE FROM CATS")
        .SetResultTransformer(Transformers.AliasToBean(typeof(CatDTO)))</pre><p>This query specified:</p><div class="itemizedlist"><ul type="disc"><li><p>the SQL query string</p></li><li><p>a result transformer</p></li></ul></div><p>
        The above query will return a list of <tt class="literal">CatDTO</tt> which has been instantiated and injected the values of NAME and BIRTHNAME into its corresponding
        properties or fields.
        </p><p>
			IMPORTANT: The custom <tt class="literal">IResultTransformer</tt> should override <tt class="literal">Equals</tt> and <tt class="literal">GetHashCode</tt>, 
			otherwise the query translation won't be cached. This also will result in memory leak.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querysql-inheritance"></a>19.1.6.&nbsp;Handling inheritance</h3></div></div><div></div></div><p>Native SQL queries which query for entities that are mapped as part
      of an inheritance hierarchy must include all properties for the base class and all
      its subclasses.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="querysql-parameters"></a>19.1.7.&nbsp;Parameters</h3></div></div><div></div></div><p>Native SQL queries support positional as well as named
      parameters:</p><pre class="programlisting">var query = sess
    .CreateSQLQuery("SELECT * FROM CATS WHERE NAME like ?")
    .AddEntity(typeof(Cat));
var pusList = query.SetString(0, "Pus%").List&lt;Cat&gt;();

query = sess
    .createSQLQuery("SELECT * FROM CATS WHERE NAME like :name")
    .AddEntity(typeof(Cat));
var pusList = query.SetString("name", "Pus%").List&lt;Cat&gt;();</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-namedqueries"></a>19.2.&nbsp;Named SQL queries</h2></div></div><div></div></div><p>Named SQL queries may be defined in the mapping document and called
    in exactly the same way as a named HQL query. In this case, we do
    <span class="emphasis"><em>not</em></span> need to call
    <tt class="literal">AddEntity()</tt>.</p><pre class="programlisting">&lt;sql-query name="persons"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    SELECT person.NAME AS {person.Name},
           person.AGE AS {person.Age},
           person.SEX AS {person.Sex}
    FROM PERSON person
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><pre class="programlisting">var people = sess.GetNamedQuery("persons")
    .SetString("namePattern", namePattern)
    .SetMaxResults(50)
    .List&lt;Person&gt;();</pre><p>The <tt class="literal">&lt;return-join&gt;</tt> and
    <tt class="literal">&lt;load-collection&gt;</tt> elements are used to join
    associations and define queries which initialize collections,
    respectively.</p><pre class="programlisting">&lt;sql-query name="personsWith"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.MailingAddress"/&gt;
    SELECT person.NAME AS {person.Name},
           person.AGE AS {person.Age},
           person.SEX AS {person.Sex},
           adddress.STREET AS {address.Street},
           adddress.CITY AS {address.City},
           adddress.STATE AS {address.State},
           adddress.ZIP AS {address.Zip}
    FROM PERSON person
    JOIN ADDRESS adddress
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><p>A named SQL query may return a scalar value. You must declare the
    column alias and NHibernate type using the
    <tt class="literal">&lt;return-scalar&gt;</tt> element:</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return-scalar column="name" type="String"/&gt;
    &lt;return-scalar column="age" type="Int64"/&gt;
    SELECT p.NAME AS name,
           p.AGE AS age,
    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'
&lt;/sql-query&gt;</pre><p>You can externalize the resultset mapping information in a
    <tt class="literal">&lt;resultset&gt;</tt> element to either reuse them across
    several named queries or through the
    <tt class="literal">SetResultSetMapping()</tt> API.</p><pre class="programlisting">&lt;resultset name="personAddress"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.MailingAddress"/&gt;
&lt;/resultset&gt;

&lt;sql-query name="personsWith" resultset-ref="personAddress"&gt;
    SELECT person.NAME AS {person.Name},
           person.AGE AS {person.Age},
           person.SEX AS {person.Sex},
           adddress.STREET AS {address.Street},
           adddress.CITY AS {address.City},
           adddress.STATE AS {address.State},
           adddress.ZIP AS {address.Zip}
    FROM PERSON person
    JOIN ADDRESS adddress
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><p>You can alternatively use the resultset mapping information in your
    .hbm.xml files directly in code.</p><pre class="programlisting">var cats = sess.CreateSQLQuery(
        "select {cat.*}, {kitten.*} " +
        "from cats cat, cats kitten " +
        "where kitten.mother = cat.id")
    .SetResultSetMapping("catAndKitten")
    .List&lt;Cat&gt;();</pre><p>
                Like HQL named queries, SQL named queries accepts a number of attributes matching settings
                available on the <tt class="literal">ISQLQuery</tt> interface.
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">flush-mode</tt> - override the session flush mode just for this query.
                    </p></li><li><p>
                    <tt class="literal">cacheable</tt> - allow the query results to be cached by the second level cache.
                    See <a href="#caches" title="Chapter&nbsp;27.&nbsp;NHibernate.Caches">Chapter&nbsp;27, <i>NHibernate.Caches</i></a>.
                    </p></li><li><p>
                    <tt class="literal">cache-region</tt> - specify the cache region of the query.
                    </p></li><li><p>
                    <tt class="literal">cache-mode</tt> - specify the cache mode of the query.
                    </p></li><li><p>
                    <tt class="literal">fetch-size</tt> - set a fetch size for the underlying ADO query.
                    </p></li><li><p>
                    <tt class="literal">timeout</tt> - set the query timeout in seconds.
                    </p></li><li><p>
                    <tt class="literal">read-only</tt> - <tt class="literal">true</tt> switches yielded entities to read-only.
                    See <a href="#readonly" title="Chapter&nbsp;11.&nbsp;Read-only entities">Chapter&nbsp;11, <i>Read-only entities</i></a>.
                    </p></li><li><p>
                    <tt class="literal">comment</tt> - add a custom comment to the SQL.
                    </p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="propertyresults"></a>19.2.1.&nbsp;Using return-property to explicitly specify column/alias
      names</h3></div></div><div></div></div><p>With <tt class="literal">&lt;return-property&gt;</tt> you can explicitly
      tell NHibernate what column aliases to use, instead of using the
      <tt class="literal">{}</tt>-syntax to let NHibernate inject its own
      aliases.</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return alias="person" class="eg.Person"&gt;
        &lt;return-property name="Name" column="myName"/&gt;
        &lt;return-property name="Age" column="myAge"/&gt;
        &lt;return-property name="Sex" column="mySex"/&gt;
    &lt;/return&gt;
    SELECT person.NAME AS myName,
           person.AGE AS myAge,
           person.SEX AS mySex,
    FROM PERSON person WHERE person.NAME LIKE :name
&lt;/sql-query&gt;
</pre><p><tt class="literal">&lt;return-property&gt;</tt> also works with
      multiple columns. This solves a limitation with the
      <tt class="literal">{}</tt>-syntax which can not allow fine grained control of
      multi-column properties.</p><pre class="programlisting">&lt;sql-query name="organizationCurrentEmployments"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="Salary"&gt;
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;
        &lt;/return-property&gt;
        &lt;return-property name="EndDate" column="myEndDate"/&gt;
    &lt;/return&gt;
        SELECT EMPLOYEE AS {emp.Employee}, EMPLOYER AS {emp.Employer},
        STARTDATE AS {emp.StartDate}, ENDDATE AS {emp.EndDate},
        REGIONCODE as {emp.RegionCode}, EID AS {emp.Id}, VALUE, CURRENCY
        FROM EMPLOYMENT
        WHERE EMPLOYER = :id AND ENDDATE IS NULL
        ORDER BY STARTDATE ASC
&lt;/sql-query&gt;</pre><p>Notice that in this example we used
      <tt class="literal">&lt;return-property&gt;</tt> in combination with the
      <tt class="literal">{}</tt>-syntax for injection, allowing users to choose how
      they want to refer column and properties.</p><p>If your mapping has a discriminator you must use
      <tt class="literal">&lt;return-discriminator&gt;</tt> to specify the
      discriminator column.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sp_query"></a>19.2.2.&nbsp;Using stored procedures for querying</h3></div></div><div></div></div><p>NHibernate introduces support for queries via stored procedures
      and functions. Most of the following documentation is equivalent for
      both. The stored procedure/function must return a resultset to be able to work
      with NHibernate. An example of such a stored function in MS SQL Server 2000 and
      higher is as follows:</p><pre class="programlisting">CREATE PROCEDURE selectAllEmployments AS
    SELECT EMPLOYEE, EMPLOYER, STARTDATE, ENDDATE,
    REGIONCODE, EMPID, VALUE, CURRENCY
    FROM EMPLOYMENT
</pre><p>To use this query in NHibernate you need to map it via a named
      query.</p><pre class="programlisting">&lt;sql-query name="selectAllEmployments_SP"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="employee" column="EMPLOYEE"/&gt;
        &lt;return-property name="employer" column="EMPLOYER"/&gt;
        &lt;return-property name="startDate" column="STARTDATE"/&gt;
        &lt;return-property name="endDate" column="ENDDATE"/&gt;
        &lt;return-property name="regionCode" column="REGIONCODE"/&gt;
        &lt;return-property name="id" column="EID"/&gt;
        &lt;return-property name="salary"&gt;
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;
        &lt;/return-property&gt;
    &lt;/return&gt;
    exec selectAllEmployments
&lt;/sql-query&gt;</pre><p>Notice that stored procedures currently only return scalars and
      entities. <tt class="literal">&lt;return-join&gt;</tt> and
      <tt class="literal">&lt;load-collection&gt;</tt> are not supported.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="querysql-limits-storedprocedures"></a>19.2.2.1.&nbsp;Rules/limitations for using stored procedures</h4></div></div><div></div></div><p>To use stored procedures with NHibernate the procedures/functions
        have to follow some rules. If they do not follow those rules they are
        not usable with NHibernate. If you still want to use these procedures
        you have to execute them via <tt class="literal">session.Connection</tt>.
        The rules are different for each database, since database vendors have
        different stored procedure semantics/syntax.</p><p>Stored procedure queries can't be paged with
        <tt class="literal">SetFirstResult()/SetMaxResults()</tt>.</p><p>Recommended call form is dependent on your database. For MS
        SQL Server use <tt class="literal">exec functionName &lt;parameters&gt;</tt>.
        </p><p>For Oracle the following rules apply:</p><div class="itemizedlist"><ul type="disc" compact><li><p>A function must return a result set. The first parameter of
            a procedure must be an <tt class="literal">OUT</tt> that returns a
            result set. This is done by using a
            <tt class="literal">SYS_REFCURSOR</tt> type in Oracle 9i or later. In Oracle
            you need to define a <tt class="literal">REF CURSOR</tt> type, see
            Oracle literature.</p></li></ul></div><p>For MS SQL server the following rules apply:</p><div class="itemizedlist"><ul type="disc" compact><li><p>The procedure must return a result set. NHibernate will
            use <tt class="literal">DbCommand.ExecuteReader()</tt> to obtain
            the results.
            </p></li><li><p>If you can enable <tt class="literal">SET NOCOUNT ON</tt> in your
            procedure it will probably be more efficient, but this is not a
            requirement.</p></li></ul></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-cud"></a>19.3.&nbsp;Custom SQL for create, update and delete</h2></div></div><div></div></div><p>NHibernate can use custom SQL statements for create, update, and
    delete operations. The class and collection persisters in NHibernate
    already contain a set of configuration time generated strings (insertsql,
    deletesql, updatesql etc.). The mapping tags
    <tt class="literal">&lt;sql-insert&gt;</tt>,
    <tt class="literal">&lt;sql-delete&gt;</tt>, and
    <tt class="literal">&lt;sql-update&gt;</tt> override these strings:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )&lt;/sql-insert&gt;
    &lt;sql-update&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-update&gt;
    &lt;sql-delete&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;
&lt;/class&gt;</pre><p>Note that the custom <tt class="literal">sql-insert</tt> will not be used
    if you use <tt class="literal">identity</tt> to generate identifier values for
    the class.
    </p><p>The SQL is directly executed in your database, so you are free to
    use any dialect you like. This will of course reduce the portability of
    your mapping if you use database specific SQL.</p><p>Stored procedures are supported if the database-native syntax is used:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert&gt;exec createPerson ?, ?&lt;/sql-insert&gt;
    &lt;sql-delete&gt;exec deletePerson ?&lt;/sql-delete&gt;
    &lt;sql-update&gt;exec updatePerson ?, ?&lt;/sql-update&gt;
&lt;/class&gt;</pre><p>The order of the positional parameters is currently vital, as they
    must be in the same sequence as NHibernate expects them.</p><p>You can see the expected order by enabling debug logging for the
    <tt class="literal">NHibernate.Persister.Entity</tt> level. With this level
    enabled NHibernate will print out the static SQL that is used to create,
    update, delete etc. entities. (To see the expected sequence, remember to
    not include your custom SQL in the mapping files as that will override the
    NHibernate generated static sql.)</p><p>The stored procedures are by default required to affect the same number
    of rows as NHibernate-generated SQL would. NHibernate uses
    <tt class="literal">DbCommand.ExecuteNonQuery</tt> to retrieve the number of rows
    affected. This check can be disabled by using <tt class="literal">check="none"</tt>
    attribute in <tt class="literal">sql-insert</tt> element.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-load"></a>19.4.&nbsp;Custom SQL for loading</h2></div></div><div></div></div><p>You may also declare your own SQL (or HQL) queries for entity
    loading:</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person" lock-mode="upgrade"/&gt;
    SELECT NAME AS {pers.Name}, ID AS {pers.Id}
    FROM PERSON
    WHERE ID=?
    FOR UPDATE
&lt;/sql-query&gt;</pre><p>This is just a named query declaration, as discussed earlier. You
    may reference this named query in a class mapping:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="Name" not-null="true"/&gt;
    &lt;loader query-ref="person"/&gt;
&lt;/class&gt;</pre><p>This even works with stored procedures.</p><p>You may even define a query for collection loading:</p><pre class="programlisting">&lt;set name="Employments" inverse="true"&gt;
    &lt;key/&gt;
    &lt;one-to-many class="Employment"/&gt;
    &lt;loader query-ref="employments"/&gt;
&lt;/set&gt;</pre><pre class="programlisting">&lt;sql-query name="employments"&gt;
    &lt;load-collection alias="emp" role="Person.Employments"/&gt;
    SELECT {emp.*}
    FROM EMPLOYMENT emp
    WHERE EMPLOYER = :id
    ORDER BY STARTDATE ASC, EMPLOYEE ASC
&lt;/sql-query&gt;</pre><p>You could even define an entity loader that loads a collection by
    join fetching:</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person"/&gt;
    &lt;return-join alias="emp" property="pers.Employments"/&gt;
    SELECT NAME AS {pers.*}, {emp.*}
    FROM PERSON pers
    LEFT OUTER JOIN EMPLOYMENT emp
        ON pers.ID = emp.PERSON_ID
    WHERE ID=?
&lt;/sql-query&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="filters"></a>Chapter&nbsp;20.&nbsp;Filtering data</h2></div></div><div></div></div><p>
        NHibernate provides an innovative new approach to handling data with "visibility" rules.
        A <span class="emphasis"><em>NHibernate filter</em></span> is a global, named, parameterized filter that may be 
        enabled or disabled for a particular NHibernate session.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-filters"></a>20.1.&nbsp;NHibernate filters</h2></div></div><div></div></div><p>
            NHibernate adds the ability to pre-define filter criteria and attach those filters at both
            a class and a collection level. A filter criteria is the ability to define a restriction clause
            very similar to the existing "where" attribute available on the class and various collection
            elements. Except these filter conditions can be parameterized. The application can then make
            the decision at runtime whether given filters should be enabled and what their parameter
            values should be. Filters can be used like database views, but parameterized inside the
            application.
        </p><p>
            In order to use filters, they must first be defined and then attached to the appropriate
            mapping elements. To define a filter, use the <tt class="literal">&lt;filter-def/&gt;</tt> element
            within a <tt class="literal">&lt;hibernate-mapping/&gt;</tt> element:
        </p><pre class="programlisting">&lt;filter-def name="myFilter"&gt;
    &lt;filter-param name="myFilterParam" type="String"/&gt;
&lt;/filter-def&gt;</pre><p>
            Then, this filter can be attached to a class:
        </p><pre class="programlisting">&lt;class name="MyClass" ...&gt;
    ...
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/class&gt;</pre><p>
            or, to a collection:
        </p><pre class="programlisting">&lt;set ...&gt;
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/set&gt;</pre><p>
            or, even to both (or multiples of each) at the same time.
        </p><p>
            The methods on <tt class="literal">ISession</tt> are: <tt class="literal">EnableFilter(string filterName)</tt>,
            <tt class="literal">GetEnabledFilter(string filterName)</tt>, and <tt class="literal">DisableFilter(string filterName)</tt>.
            By default, filters are <span class="emphasis"><em>not</em></span> enabled for a given session; they must be explicitly
            enabled through use of the <tt class="literal">ISession.EnableFilter()</tt> method, which returns an
            instance of the <tt class="literal">IFilter</tt> interface. Using the simple filter defined above, this
            would look like:
        </p><pre class="programlisting">session.EnableFilter("myFilter").SetParameter("myFilterParam", "some-value");</pre><p>
            Note that methods on the <tt class="literal">NHibernate.IFilter</tt> interface do allow the method-chaining
            common to much of NHibernate.
        </p><p>
            A full example, using temporal data with an effective record date pattern:
        </p><pre class="programlisting">&lt;class name="Employee" ...&gt;
...
    &lt;many-to-one name="Department" column="dept_id" class="Department"/&gt;
    &lt;property name="EffectiveStartDate" type="date" column="eff_start_dt"/&gt;
    &lt;property name="EffectiveEndDate" type="date" column="eff_end_dt"/&gt;
...
    &lt;!--
        Note that this assumes non-terminal records have an eff_end_dt set to
        a max db date for simplicity-sake
    --&gt;
    &lt;filter name="effectiveDate"
            condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
&lt;/class&gt;

&lt;class name="Department" ...&gt;
...
    &lt;set name="Employees" lazy="true"&gt;
        &lt;key column="dept_id"/&gt;
        &lt;one-to-many class="Employee"/&gt;
        &lt;filter name="effectiveDate"
                condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;filter-def name="effectiveDate"&gt;
    &lt;filter-param name="asOfDate" type="date"/&gt;
&lt;/filter-def&gt;</pre><p>
            Then, in order to ensure that you always get back currently effective records, simply
            enable the filter on the session prior to retrieving employee data:
        </p><pre class="programlisting">ISession session = ...;
session.EnableFilter("effectiveDate").SetParameter("asOfDate", DateTime.Today);
var results = session.CreateQuery("from Employee as e where e.Salary &gt; :targetSalary")
         .SetInt64("targetSalary", 1000000L)
         .List&lt;Employee&gt;();
</pre><p>
            In the HQL above, even though we only explicitly mentioned a salary constraint on the results,
            because of the enabled filter the query will return only currently active employees who have
            a salary greater than a million dollars.
        </p><p>
            Note: if you plan on using filters with outer joining (either through HQL or load fetching) be
            careful of the direction of the condition expression.  It's safest to set this up for left
            outer joining; in general, place the parameter first followed by the column name(s) after
            the operator.
        </p><p>
            Default all filter definitions are applied to <tt class="literal">&lt;many-to-one/&gt;</tt> and 
            <tt class="literal">&lt;one-to-one/&gt;</tt> elements. You can turn off this behaviour by
            using <tt class="literal">use-many-to-one</tt> attribute on <tt class="literal">&lt;filter-def/&gt;</tt>
            element.
        </p><pre class="programlisting">&lt;filter-def name="effectiveDate" use-many-to-one="false"/&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="performance"></a>Chapter&nbsp;21.&nbsp;Improving performance</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-fetching"></a>21.1.&nbsp;Fetching strategies</h2></div></div><div></div></div><p>
            A <span class="emphasis"><em>fetching strategy</em></span> is the strategy NHibernate will use for 
            retrieving associated objects if the application needs to navigate the association. 
            Fetch strategies may be declared in the O/R mapping metadata, or overridden by a 
            particular HQL or <tt class="literal">Criteria</tt> query.
        </p><p>
            NHibernate defines the following fetching strategies:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Join fetching</em></span> - NHibernate retrieves the
                    associated instance or collection in the same <tt class="literal">SELECT</tt>,
                    using an <tt class="literal">OUTER JOIN</tt>.
                </p></li><li><p>
                    <span class="emphasis"><em>Select fetching</em></span> - a second <tt class="literal">SELECT</tt>
                    is used to retrieve the associated entity or collection. Unless
                    you explicitly disable lazy fetching by specifying <tt class="literal">lazy="false"</tt>, 
                    this second select will only be executed when you actually access the
                    association.
                </p></li><li><p>
                    <span class="emphasis"><em>Subselect fetching</em></span> - a second <tt class="literal">SELECT</tt>
                    is used to retrieve the associated collections for all entities retrieved in a
                    previous query or fetch. Unless you explicitly disable lazy fetching by specifying 
                    <tt class="literal">lazy="false"</tt>, this second select will only be executed when you 
                    actually access the association.
                </p></li><li><p>
                    <span class="emphasis"><em>"Extra-lazy" collection fetching</em></span> - individual
                    elements of the collection are accessed from the database as needed.
                    NHibernate tries not to fetch the whole collection into memory unless
                    absolutely needed (suitable for very large collections)
                </p></li><li><p>
                    <span class="emphasis"><em>Batch fetching</em></span> - an optimization strategy
                    for select fetching - NHibernate retrieves a batch of entity instances 
                    or collections in a single <tt class="literal">SELECT</tt>, by specifying 
                    a list of primary keys or foreign keys.
                </p></li></ul></div><p>
            NHibernate also distinguishes between:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Immediate fetching</em></span> - an association, collection or
                    attribute is fetched immediately, when the owner is loaded.
                </p></li><li><p>
                    <span class="emphasis"><em>Lazy collection fetching</em></span> - a collection is fetched 
                    when the application invokes an operation upon that collection. (This
                    is the default for collections.)
                </p></li><li><p>
                    <span class="emphasis"><em>Proxy fetching</em></span> - a single-valued association is 
                    fetched when a method other than the identifier getter is invoked
                    upon the associated object.
                </p></li></ul></div><p>
            We have two orthogonal notions here: <span class="emphasis"><em>when</em></span> is the association
            fetched, and <span class="emphasis"><em>how</em></span> is it fetched (what SQL is used). Don't
            confuse them! We use <tt class="literal">fetch</tt> to tune performance. We may use 
            <tt class="literal">lazy</tt> to define a contract for what data is always available 
            in any detached instance of a particular class.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-lazy"></a>21.1.1.&nbsp;Working with lazy associations</h3></div></div><div></div></div><p>
                By default, NHibernate uses lazy select fetching for collections and lazy proxy
                fetching for single-valued associations. These defaults make sense for almost
                all associations in almost all applications. 
            </p><p>
                However, lazy fetching poses one problem that you must be aware of. Access to a 
                lazy association outside of the context of an open NHibernate session will result 
                in an exception. For example:
            </p><pre class="programlisting">IDictionary&lt;string, int&gt; permissions;
using (var s = sessions.OpenSession())
using (Transaction tx = s.BeginTransaction())
{
    User u = s.CreateQuery("from User u where u.Name=:userName")
        .SetString("userName", userName).UniqueResult&lt;User&gt;();
    permissions = u.Permissions;

    tx.Commit();
}

int accessLevel = permissions["accounts"];  // Error!</pre><p>
                Since the <tt class="literal">permissions</tt> collection was not initialized
                when the <tt class="literal">ISession</tt> was closed, the collection will not
                be able to load its state. <span class="emphasis"><em>NHibernate does not support lazy
                initialization for detached objects</em></span>. The fix is to move the
                code that reads from the collection to just before the transaction
                is committed.
            </p><p>
                Alternatively, we could use a non-lazy collection or association, 
                by specifying <tt class="literal">lazy="false"</tt> for the association mapping.
                However, it is intended that lazy initialization be used for almost all 
                collections and associations. If you define too many non-lazy associations 
                in your object model, NHibernate will end up needing to fetch the entire 
                database into memory in every transaction!
            </p><p>
                On the other hand, we often want to choose join fetching (which is non-lazy by 
                nature) instead of select fetching in a particular transaction. We'll now see
                how to customize the fetching strategy. In NHibernate, the mechanisms for
                choosing a fetch strategy are identical for single-valued associations and
                collections.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-custom"></a>21.1.2.&nbsp;Tuning fetch strategies</h3></div></div><div></div></div><p>
                Select fetching (the default) is extremely vulnerable to N+1 selects problems, 
                so we might want to enable join fetching in the mapping document:
            </p><pre class="programlisting">&lt;set name="Permissions" 
            fetch="join"&gt;
    &lt;key column="userId"/&gt;
    &lt;one-to-many class="Permission"/&gt;
&lt;/set</pre><pre class="programlisting">&lt;many-to-one name="Mother" class="Cat" fetch="join"/&gt;</pre><p>
                The <tt class="literal">fetch</tt> strategy defined in the mapping document affects:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        retrieval via <tt class="literal">Get()</tt> or <tt class="literal">Load()</tt>
                    </p></li><li><p>
                        retrieval that happens implicitly when an association is navigated
                    </p></li><li><p>
                        <tt class="literal">ICriteria</tt> queries
                    </p></li><li><p>
                        HQL queries if <tt class="literal">subselect</tt> fetching is used
                    </p></li></ul></div><p>
                No matter what fetching strategy you use, the defined non-lazy graph is guaranteed
                to be loaded into memory. Note that this might result in several immediate selects
                being used to execute a particular HQL query.
            </p><p>
                Usually, we don't use the mapping document to customize fetching. Instead, we
                keep the default behavior, and override it for a particular transaction, using 
                <tt class="literal">left join fetch</tt> in HQL. This tells NHibernate to fetch 
                the association eagerly in the first select, using an outer join. In the
                <tt class="literal">ICriteria</tt> query API, you would use
                <tt class="literal">Fetch()</tt>.
            </p><p>
                If you ever feel like you wish you could change the fetching strategy used by
                <tt class="literal">Get()</tt> or <tt class="literal">Load()</tt>, simply use a 
                <tt class="literal">ICriteria</tt> query, for example:
            </p><pre class="programlisting">User user = session.CreateCriteria(typeof(User))
    .Fetch(SelectMode.Fetch, "Permissions")
    .Add( Expression.Eq("Id", userId) )
    .UniqueResult&lt;User&gt;();</pre><p>
                (This is NHibernate's equivalent of what some <span class="emphasis"><em>ORM</em></span> solutions call a "fetch plan".)
            </p><p>
                A completely different way to avoid problems with N+1 selects is to use the
                <a href="#performance-cache" title="21.2.&nbsp;The Second Level Cache">second-level cache</a>, or to enable
                <a href="#performance-fetching-batch" title="21.1.5.&nbsp;Using batch fetching">batch fetching</a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-proxies"></a>21.1.3.&nbsp;Single-ended association proxies</h3></div></div><div></div></div><p>
                Lazy fetching for collections is implemented using NHibernate's own implementation
                of persistent collections. However, a different mechanism is needed for lazy
                behavior in single-ended associations. The target entity of the association must
                be proxied. NHibernate implements lazy initializing proxies for persistent objects
                using runtime bytecode enhancement.
            </p><p>
                By default, NHibernate generates proxies (at startup) for all persistent classes
                and uses them to enable lazy fetching of <tt class="literal">many-to-one</tt> and
                <tt class="literal">one-to-one</tt> associations.
            </p><p>
                The mapping file may declare an interface to use as the proxy interface for that
                class, with the <tt class="literal">proxy</tt> attribute. By default, NHibernate uses a subclass
                of the class. <span class="emphasis"><em>Note that the proxied class must implement a non-private default
                constructor. We recommend this constructor for all persistent classes!</em></span>
            </p><p>
                There are some gotchas to be aware of when extending this approach to polymorphic
                classes, eg.
            </p><pre class="programlisting">&lt;class name="Cat" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                Firstly, instances of <tt class="literal">Cat</tt> will never be castable to
                <tt class="literal">DomesticCat</tt>, even if the underlying instance is an
                instance of <tt class="literal">DomesticCat</tt>:
            </p><pre class="programlisting">// instantiate a proxy (does not hit the db)
Cat cat = session.Load&lt;Cat&gt;(id);
// hit the db to initialize the proxy
if ( cat.IsDomesticCat ) {
    DomesticCat dc = (DomesticCat) cat; // Error!
    ....
}</pre><p>
                Secondly, it is possible to break proxy <tt class="literal">==</tt>.
            </p><pre class="programlisting">// instantiate a Cat proxy
Cat cat = session.Load&lt;Cat&gt;(id);
DomesticCat dc =
        // acquire new DomesticCat proxy!
        session.Load&lt;DomesticCat&gt;(id);
Console.WriteLine(cat == dc); // false</pre><p>
                However, the situation is not quite as bad as it looks. Even though we now have two references
                to different proxy objects, the underlying instance will still be the same object:
            </p><pre class="programlisting">cat.Weight = 11.0;  // hit the db to initialize the proxy
Console.WriteLine( dc.Weight );  // 11.0</pre><p>
                Third, you may not use a proxy for a <tt class="literal">sealed</tt> class or a class
                with any non-overridable public members.
            </p><p>
                Finally, if your persistent object acquires any resources upon instantiation (eg. in
                initializers or default constructor), then those resources will also be acquired by
                the proxy. The proxy class is an actual subclass of the persistent class.
            </p><p>
                These problems are all due to fundamental limitations in .NET's single inheritance model.
                If you wish to avoid these problems your persistent classes must each implement an interface
                that declares its business methods. You should specify these interfaces in the mapping file. eg.
            </p><pre class="programlisting">&lt;class name="CatImpl" proxy="ICat"&gt;
    ......
    &lt;subclass name="DomesticCatImpl" proxy="IDomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                where <tt class="literal">CatImpl</tt> implements the interface <tt class="literal">ICat</tt> and
                <tt class="literal">DomesticCatImpl</tt> implements the interface <tt class="literal">IDomesticCat</tt>. Then
                proxies for instances of <tt class="literal">ICat</tt> and <tt class="literal">IDomesticCat</tt> may be returned
                by <tt class="literal">Load()</tt> or <tt class="literal">Enumerable()</tt>. (Note that <tt class="literal">List()</tt>
                does not usually return proxies.)
            </p><pre class="programlisting">ICat cat = session.Load&lt;CatImpl&gt;(catid);
using(var iter = session
    .CreateQuery("from CatImpl as cat where cat.Name='fritz'")
    .Enumerable&lt;CatImpl&gt;()
    .GetEnumerator())
{
    iter.MoveNext();
    ICat fritz = iter.Current;
}</pre><p>
                Relationships are also lazily initialized. This means you must declare any properties to be of
                type <tt class="literal">ICat</tt>, not <tt class="literal">CatImpl</tt>.
            </p><p>
                Certain operations do <span class="emphasis"><em>not</em></span> require proxy initialization
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">Equals()</tt>, if the persistent class does not override
                        <tt class="literal">Equals()</tt>
                    </p></li><li><p>
                        <tt class="literal">GetHashCode()</tt>, if the persistent class does not override
                        <tt class="literal">GetHashCode()</tt>
                    </p></li><li><p>
                        The identifier getter method
                    </p></li></ul></div><p>
                NHibernate will detect persistent classes that override <tt class="literal">Equals()</tt> or
                <tt class="literal">GetHashCode()</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-initialization"></a>21.1.4.&nbsp;Initializing collections and proxies</h3></div></div><div></div></div><p>
                A <tt class="literal">LazyInitializationException</tt> will be thrown by NHibernate if an uninitialized 
                collection or proxy is accessed outside of the scope of the <tt class="literal">ISession</tt>, ie. when 
                the entity owning the collection or having the reference to the proxy is in the detached state.
            </p><p>
                Sometimes we need to ensure that a proxy or collection is initialized before closing the
                <tt class="literal">ISession</tt>. Of course, we can alway force initialization by calling
                <tt class="literal">cat.Sex</tt> or <tt class="literal">cat.Kittens.Count</tt>, for example.
                But that is confusing to readers of the code and is not convenient for generic code.
            </p><p>
                The static methods <tt class="literal">NHibernateUtil.Initialize()</tt> and <tt class="literal">NHibernateUtil.IsInitialized()</tt>
                provide the application with a convenient way of working with lazily initialized collections or
                proxies. <tt class="literal">NHibernateUtil.Initialize(cat)</tt> will force the initialization of a proxy,
                <tt class="literal">cat</tt>, as long as its <tt class="literal">ISession</tt> is still open.
                <tt class="literal">NHibernateUtil.Initialize( cat.Kittens )</tt> has a similar effect for the collection
                of kittens.
            </p><p>
                Another option is to keep the <tt class="literal">ISession</tt> open until all needed
                collections and proxies have been loaded. In some application architectures,
                particularly where the code that accesses data using NHibernate, and the code that
                uses it are in different application layers or different physical processes, it 
                can be a problem to ensure that the <tt class="literal">ISession</tt> is open when a 
                collection is initialized. There are two basic ways to deal with this issue:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        In a web-based application, a <tt class="literal">HttpModule</tt> can be used
                        to close the <tt class="literal">ISession</tt> only at the very end of a user
                        request, once the rendering of the view is complete (the <span class="emphasis"><em>Open
                        Session in View</em></span> pattern).  Of course, this places heavy demands
                        on the correctness of the exception handling of your application infrastructure. 
                        It is vitally important that the <tt class="literal">ISession</tt> is closed and the 
                        transaction ended before returning to the user, even when an exception occurs 
                        during rendering of the view. See the NHibernate Wiki for examples of this
                        "Open Session in View" pattern.
                    </p></li><li><p>
                        In an application with a separate business tier, the business logic must
                        "prepare" all collections that will be needed by the web tier before
                        returning. This means that the business tier should load all the data and
                        return all the data already initialized to the presentation/web tier that
                        is required for a particular use case. Usually, the application calls
                        <tt class="literal">NHibernateUtil.Initialize()</tt> for each collection that will
                        be needed in the web tier (this call must occur before the session is closed)
                        or retrieves the collection eagerly using a NHibernate query with a
                        <tt class="literal">FETCH</tt> clause or a <tt class="literal">SelectMode.Fetch</tt> in
                        <tt class="literal">ICriteria</tt>. This is usually easier if you adopt the
                        <span class="emphasis"><em>Command</em></span> pattern instead of a <span class="emphasis"><em>Session Facade</em></span>.
                    </p></li><li><p>
                        You may also attach a previously loaded object to a new <tt class="literal">ISession</tt>
                        with <tt class="literal">Merge()</tt> or <tt class="literal">Lock()</tt> before
                        accessing uninitialized collections (or other proxies). No, NHibernate does not,
                        and certainly <span class="emphasis"><em>should</em></span> not do this automatically, since it 
                        would introduce ad hoc transaction semantics!
                    </p></li></ul></div><p>
                Sometimes you don't want to initialize a large collection, but still need some
                information about it (like its size) or a subset of the data.
            </p><p>
                You can use a collection filter to get the size of a collection without initializing it:
            </p><pre class="programlisting">s.CreateFilter(collection, "select count(*)").UniqueResult&lt;long&gt;()</pre><p>
                The <tt class="literal">CreateFilter()</tt> method is also used to efficiently retrieve subsets
                of a collection without needing to initialize the whole collection:
            </p><pre class="programlisting">s.CreateFilter(lazyCollection, "").SetFirstResult(0).SetMaxResults(10).List&lt;Entity&gt;();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-batch"></a>21.1.5.&nbsp;Using batch fetching</h3></div></div><div></div></div><p>
                NHibernate can make efficient use of batch fetching, that is, NHibernate can load several uninitialized
                proxies if one proxy is accessed (or collections). Batch fetching is an optimization of the lazy select
                fetching strategy. There are two ways you can tune batch fetching: on the class and the collection level.
            </p><p>
                Batch fetching for classes/entities is easier to understand. Imagine you have the following situation
                at runtime: You have 25 <tt class="literal">Cat</tt> instances loaded in an <tt class="literal">ISession</tt>, each
                <tt class="literal">Cat</tt> has a reference to its <tt class="literal">Owner</tt>, a <tt class="literal">Person</tt>.
                The <tt class="literal">Person</tt> class is mapped with a proxy, <tt class="literal">lazy="true"</tt>. If you now
                iterate through all cats and call <tt class="literal">cat.Owner</tt> on each, NHibernate will by default
                execute 25 <tt class="literal">SELECT</tt> statements, to retrieve the proxied owners. You can tune this
                behavior by specifying a <tt class="literal">batch-size</tt> in the mapping of <tt class="literal">Person</tt>:
            </p><pre class="programlisting">&lt;class name="Person" batch-size="10"&gt;...&lt;/class&gt;</pre><p>
                NHibernate will now execute only three queries, the pattern is 10, 10, 5.
            </p><p>
                You may also enable batch fetching of collections. For example, if each <tt class="literal">Person</tt> has
                a lazy collection of <tt class="literal">Cat</tt>s, and 10 persons are currently loaded in the
                <tt class="literal">ISession</tt>, iterating through all persons will generate 10 <tt class="literal">SELECT</tt>s,
                one for every call to <tt class="literal">person.Cats</tt>. If you enable batch fetching for the
                <tt class="literal">Cats</tt> collection in the mapping of <tt class="literal">Person</tt>, NHibernate can pre-fetch
                collections:
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;set name="Cats" batch-size="3"&gt;
        ...
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
                With a <tt class="literal">batch-size</tt> of 3, NHibernate will load 3, 3, 3, 1 collections in four
                <tt class="literal">SELECT</tt>s. Again, the value of the attribute depends on the expected number of
                uninitialized collections in a particular <tt class="literal">Session</tt>.
            </p><p>
                Batch fetching of collections is particularly useful if you have a nested tree of items, ie.
                the typical bill-of-materials pattern. (Although a <span class="emphasis"><em>nested set</em></span> or a
                <span class="emphasis"><em>materialized path</em></span> might be a better option for read-mostly trees.)
            </p><p>
              <span class="emphasis"><em>Note:</em></span> if you set <tt class="literal">default_batch_fetch_size</tt>
              in configuration, NHibernate will configure the batch fetch optimization for lazy fetching
              globally. Batch sizes specified at more granular level take precedence.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-subselect"></a>21.1.6.&nbsp;Using subselect fetching</h3></div></div><div></div></div><p>
                If one lazy collection or single-valued proxy has to be fetched, NHibernate loads all of
                them, re-running the original query in a subselect. This works in the same way as
                batch-fetching, without the piecemeal loading.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-cache"></a>21.2.&nbsp;The Second Level Cache</h2></div></div><div></div></div><p>
            A NHibernate <tt class="literal">ISession</tt> is a transaction-level cache of persistent data. It is
            possible to configure a cluster or process-level (<tt class="literal">ISessionFactory</tt>-level) cache on 
            a class-by-class and collection-by-collection basis. You may even plug in a clustered cache. Be 
            careful. Caches are never aware of changes made to the persistent store by another application 
            (though they may be configured to regularly expire cached data).
            <span class="emphasis"><em>In NHibernate 1.x the second level cache does not work correctly in combination with
            distributed transactions.</em></span>
        </p><p>
          The second level cache requires the use of transactions, be it through transaction scopes or NHibernate
          transactions. Interacting with the data store without an explicit transaction is discouraged, and will
          not allow the second level cache to work as intended.
        </p><p>
            By default, NHibernate uses HashtableCache for process-level caching. You may choose a different
            implementation by specifying the name of a class that implements <tt class="literal">NHibernate.Cache.ICacheProvider</tt> 
            using the property <tt class="literal">cache.provider_class</tt>.
        </p><div class="table"><a name="cacheproviders"></a><p class="title"><b>Table&nbsp;21.1.&nbsp;Cache Providers</b></p><table summary="Cache Providers" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">Provider class</th><th align="left">Type</th><th align="left">Cluster Safe</th><th align="left">Query Cache Supported</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left"><tt class="literal">NHibernate.Cache.HashtableCacheProvider</tt></td><td align="left">memory</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">ASP.NET Cache (System.Web.Cache)</td><td align="left"><tt class="literal">NHibernate.Caches.SysCache.SysCacheProvider, NHibernate.Caches.SysCache</tt></td><td align="left">memory</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">Prevalence Cache</td><td align="left"><tt class="literal">NHibernate.Caches.Prevalence.PrevalenceCacheProvider, NHibernate.Caches.Prevalence</tt></td><td align="left">memory, disk</td><td align="left">&nbsp;</td><td align="left">yes</td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-mapping"></a>21.2.1.&nbsp;Cache mappings</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;cache&gt;</tt> element of a class or collection mapping has the
                following form:
            </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="read-write|nonstrict-read-write|read-only"                <span class="co">(1)</span>
    region="RegionName"                                              <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">usage</tt> specifies the caching strategy:
                            <tt class="literal">read-write</tt>,
                            <tt class="literal">nonstrict-read-write</tt> or
                            <tt class="literal">read-only</tt>
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">region</tt> (optional, defaults to the class or
                            collection role name) specifies the name of the second level cache 
                            region
                        </p></td></tr></table></div></div><p>
                Alternatively (preferably?), you may specify <tt class="literal">&lt;class-cache&gt;</tt> and 
                <tt class="literal">&lt;collection-cache&gt;</tt> elements in <tt class="literal">hibernate.cfg.xml</tt>.
            </p><p>
                The <tt class="literal">usage</tt> attribute specifies a <span class="emphasis"><em>cache concurrency strategy</em></span>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readonly"></a>21.2.2.&nbsp;Strategy: read only</h3></div></div><div></div></div><p>
                If your application needs to read but never modify instances of a persistent class, a 
                <tt class="literal">read-only</tt> cache may be used. This is the simplest and best performing
                strategy. Its even perfectly safe for use in a cluster.
            </p><pre class="programlisting">&lt;class name="Eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readwrite"></a>21.2.3.&nbsp;Strategy: read/write</h3></div></div><div></div></div><p>
                If the application needs to update data, a <tt class="literal">read-write</tt> cache might be appropriate. 
                This cache strategy should never be used if serializable transaction isolation level is required.
                You should ensure that the transaction is completed when <tt class="literal">ISession.Close()</tt> or
                <tt class="literal">ISession.Disconnect()</tt> is called. If you wish to use this strategy in a cluster,
                you should ensure that the underlying cache implementation supports locking. The built-in cache
                providers do <span class="emphasis"><em>not</em></span>.
            </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="Kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-nonstrict"></a>21.2.4.&nbsp;Strategy: nonstrict read/write</h3></div></div><div></div></div><p>
                If the application only occasionally needs to update data (ie. if it is extremely unlikely that two 
                transactions would try to update the same item simultaneously) and strict transaction isolation is
                not required, a <tt class="literal">nonstrict-read-write</tt> cache might be appropriate.
                When using this strategy you should ensure that the transaction is completed when
                <tt class="literal">ISession.Close()</tt> or <tt class="literal">ISession.Disconnect()</tt> is called.
                
            </p></div><p>
            The following table shows which providers are compatible with which concurrency strategies.
        </p><div class="table"><a name="d0e17511"></a><p class="title"><b>Table&nbsp;21.2.&nbsp;Cache Concurrency Strategy Support</b></p><table summary="Cache Concurrency Strategy Support" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">SysCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">PrevalenceCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr></tbody></table></div><p>
            Refer to <a href="#caches" title="Chapter&nbsp;27.&nbsp;NHibernate.Caches">Chapter&nbsp;27, <i>NHibernate.Caches</i></a> for more details.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-sessioncache"></a>21.3.&nbsp;Managing the caches</h2></div></div><div></div></div><p>
            Whenever you pass an object to <tt class="literal">Save()</tt>, <tt class="literal">Update()</tt>
            or <tt class="literal">SaveOrUpdate()</tt> and whenever you retrieve an object using 
            <tt class="literal">Load()</tt>, <tt class="literal">Get()</tt>, <tt class="literal">List()</tt>,
            or <tt class="literal">Enumerable()</tt>, that object is added to the internal cache of the
            <tt class="literal">ISession</tt>.
        </p><p>
            When <tt class="literal">Flush()</tt> is subsequently called, the state of that object will
            be synchronized with the database. If you do not want this synchronization to occur or
            if you are processing a huge number of objects and need to manage memory efficiently,
            the <tt class="literal">Evict()</tt> method may be used to remove the object and its collections
            from the first-level cache.
        </p><pre class="programlisting">IEnumerable&lt;Cat&gt; cats = sess
    .CreateQuery("from Eg.Cat as cat")
    .List&lt;Cat&gt;(); //a huge result set
foreach (Cat cat in cats)
{
    DoSomethingWithACat(cat);
    sess.Evict(cat);
}</pre><p>
            NHibernate will evict associated entities automatically if the association is mapped
            with <tt class="literal">cascade="all"</tt> or <tt class="literal">cascade="all-delete-orphan"</tt>.
        </p><p>
            The <tt class="literal">ISession</tt> also provides a <tt class="literal">Contains()</tt> method
            to determine if an instance belongs to the session cache.
        </p><p>
            To completely evict all objects from the session cache, call <tt class="literal">ISession.Clear()</tt>
        </p><p>
            For the second-level cache, there are methods defined on <tt class="literal">ISessionFactory</tt> for 
            evicting the cached state of an instance, entire class, collection instance or entire collection 
            role.
        </p><pre class="programlisting">//evict a particular Cat
sessionFactory.Evict(typeof(Cat), catId);
//evict all Cats
sessionFactory.Evict(typeof(Cat));
//evict a particular collection of kittens
sessionFactory.EvictCollection("Eg.Cat.Kittens", catId);
//evict all kitten collections
sessionFactory.EvictCollection("Eg.Cat.Kittens");</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-querycache"></a>21.4.&nbsp;The Query Cache</h2></div></div><div></div></div><p>
            Query result sets may also be cached. This is only useful for queries that are run
            frequently with the same parameters. To use the query cache you must first enable it:
        </p><pre class="programlisting">&lt;property name="cache.use_query_cache"&gt;true&lt;/property&gt;&gt;</pre><p>
            This setting causes the creation of two new cache regions - one holding cached query
            result sets (<tt class="literal">NHibernate.Cache.StandardQueryCache</tt>), the other
            holding timestamps of the most recent updates to queryable tables
            (<tt class="literal">UpdateTimestampsCache</tt>). Those region names will be prefixed by the
            cache region prefix if <tt class="literal">cache.region_prefix</tt> setting is configured.
        </p><p>
            If you use a cache provider handling an expiration for cached entries, you should set
            the <tt class="literal">UpdateTimestampsCache</tt> region expiration to a value greater than
            the expiration of query cache regions. (Or disable its expiration.) Otherwise the query
            cache may yield stale data.
        </p><p>
            Note that the query cache does not cache the state of any entities in the result set;
            it caches only identifier values and results of value type. So the query cache should
            always be used in conjunction with the second-level cache.
        </p><p>
            Most queries do not benefit from caching, so by default queries are not cached. To
            enable caching, call <tt class="literal">IQuery.SetCacheable(true)</tt>. This call allows
            the query to look for existing cache results or add its results to the cache when
            it is executed.
        </p><p>
            If you require fine-grained control over query cache expiration policies, you may
            specify a named cache region for a particular query by calling 
            <tt class="literal">IQuery.SetCacheRegion()</tt>.
        </p><pre class="programlisting">var blogs = sess.CreateQuery("from Blog blog where blog.Blogger = :blogger")
    .SetEntity("blogger", blogger)
    .SetMaxResults(15)
    .SetCacheable(true)
    .SetCacheRegion("frontpages")
    .List&lt;Blog&gt;();</pre><p>
            If the query should force a refresh of its query cache region, you may call
            <tt class="literal">IQuery.SetForceCacheRefresh()</tt> to <tt class="literal">true</tt>.
            This is particularly useful in cases where underlying data may have been updated
            via a separate process (i.e., not modified through NHibernate) and allows the
            application to selectively refresh the query cache regions based on its
            knowledge of those events. This is a more efficient alternative to eviction of 
            a query cache region via <tt class="literal">ISessionFactory.EvictQueries()</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-collections"></a>21.5.&nbsp;Understanding Collection performance</h2></div></div><div></div></div><p>
            We've already spent quite some time talking about collections.
            In this section we will highlight a couple more issues about
            how collections behave at runtime.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-taxonomy"></a>21.5.1.&nbsp;Taxonomy</h3></div></div><div></div></div><p>NHibernate defines three basic kinds of collections:</p><div class="itemizedlist"><ul type="disc"><li><p>collections of values</p></li><li><p>one to many associations</p></li><li><p>many to many associations</p></li></ul></div><p>
                This classification distinguishes the various table and foreign key
                relationships but does not tell us quite everything we need to know
                about the relational model. To fully understand the relational structure
                and performance characteristics, we must also consider the structure of
                the primary key that is used by NHibernate to update or delete collection
                rows. This suggests the following classification:
            </p><div class="itemizedlist"><ul type="disc"><li><p>indexed collections</p></li><li><p>sets</p></li><li><p>bags</p></li></ul></div><p>
                All indexed collections (maps, lists, arrays) have a primary key consisting
                of the <tt class="literal">&lt;key&gt;</tt> and <tt class="literal">&lt;index&gt;</tt>
                columns. In this case collection updates are usually extremely efficient -
                the primary key may be efficiently indexed and a particular row may be efficiently
                located when NHibernate tries to update or delete it.
            </p><p>
                Sets have a primary key consisting of <tt class="literal">&lt;key&gt;</tt> and element
                columns. This may be less efficient for some types of collection element, particularly
                composite elements or large text or binary fields; the database may not be able to index
                a complex primary key as efficiently.  On the other hand, for one to many or many to many
                associations, particularly in the case of synthetic identifiers, it is likely to be just
                as efficient. (Side-note: if you want <tt class="literal">SchemaExport</tt> to actually create
                the primary key of a <tt class="literal">&lt;set&gt;</tt> for you, you must declare all columns
                as <tt class="literal">not-null="true"</tt>.)
            </p><p>
                <tt class="literal">&lt;idbag&gt;</tt> mappings define a surrogate key, so they are
                always very efficient to update. In fact, they are the best case.
            </p><p>
                Bags are the worst case. Since a bag permits duplicate element values and has no
                index column, no primary key may be defined. NHibernate has no way of distinguishing
                between duplicate rows. NHibernate resolves this problem by completely removing
                (in a single <tt class="literal">DELETE</tt>) and recreating the collection whenever it
                changes. This might be very inefficient.
            </p><p>
                Note that for a one-to-many association, the "primary key" may not be the physical
                primary key of the database table - but even in this case, the above classification
                is still useful. (It still reflects how NHibernate "locates" individual rows of the
                collection.)
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficientupdate"></a>21.5.2.&nbsp;Lists, maps, idbags and sets are the most efficient collections to update</h3></div></div><div></div></div><p>
                From the discussion above, it should be clear that indexed collections
                and (usually) sets allow the most efficient operation in terms of adding,
                removing and updating elements.
            </p><p>
                There is, arguably, one more advantage that indexed collections have over sets for
                many to many associations or collections of values. Because of the structure of an
                <tt class="literal">ISet</tt>, NHibernate doesn't ever <tt class="literal">UPDATE</tt> a row when
                an element is "changed". Changes to an <tt class="literal">ISet</tt> always work via
                <tt class="literal">INSERT</tt> and <tt class="literal">DELETE</tt> (of individual rows). Once
                again, this consideration does not apply to one to many associations.
            </p><p>
                After observing that arrays cannot be lazy, we would conclude that lists, maps and
                idbags are the most performant (non-inverse) collection types, with sets not far
                behind. Sets are expected to be the most common kind of collection in NHibernate 
                applications. This is because the "set" semantics are most natural in the relational
                model.
            </p><p>
                However, in well-designed NHibernate domain models, we usually see that most collections
                are in fact one-to-many associations with <tt class="literal">inverse="true"</tt>. For these
                associations, the update is handled by the many-to-one end of the association, and so
                considerations of collection update performance simply do not apply.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficentinverse"></a>21.5.3.&nbsp;Bags and lists are the most efficient inverse collections</h3></div></div><div></div></div><p>
                Just before you ditch bags forever, there is a particular case in which bags (and also lists)
                are much more performant than sets. For a collection with <tt class="literal">inverse="true"</tt>
                (the standard bidirectional one-to-many relationship idiom, for example) we can add elements
                to a bag or list without needing to initialize (fetch) the bag elements! This is because
                <tt class="literal">IList.Add()</tt> must always succeed for a bag or <tt class="literal">IList</tt>
                (unlike an <tt class="literal">ISet</tt>). This can make the following common code much faster.
            </p><pre class="programlisting">Parent p = sess.Load&lt;Parent&gt;(id);
    Child c = new Child();
    c.Parent = p;
    p.Children.Add(c);  //no need to fetch the collection!
    sess.Flush();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-oneshotdelete"></a>21.5.4.&nbsp;One shot delete</h3></div></div><div></div></div><p>
                Occasionally, deleting collection elements one by one can be extremely inefficient. NHibernate
                isn't completely stupid, so it knows not to do that in the case of an newly-empty collection
                (if you called <tt class="literal">list.Clear()</tt>, for example). In this case, NHibernate will
                issue a single <tt class="literal">DELETE</tt> and we are done!
            </p><p>
                Suppose we add a single element to a collection of size twenty and then remove two elements.
                NHibernate will issue one <tt class="literal">INSERT</tt> statement and two <tt class="literal">DELETE</tt>
                statements (unless the collection is a bag). This is certainly desirable.
            </p><p>
                However, suppose that we remove eighteen elements, leaving two and then add thee new elements.
                There are two possible ways to proceed:
            </p><div class="itemizedlist"><ul type="disc"><li><p>Delete eighteen rows one by one and then insert three rows</p></li><li><p>Remove the whole collection (in one SQL <tt class="literal">DELETE</tt>) and insert
                all five current elements (one by one)</p></li></ul></div><p>
                NHibernate isn't smart enough to know that the second option is probably quicker in this case.
                (And it would probably be undesirable for NHibernate to be that smart; such behaviour might
                confuse database triggers, etc.)
            </p><p>
                Fortunately, you can force this behaviour (ie. the second strategy) at any time by discarding
                (ie. dereferencing) the original collection and returning a newly instantiated collection with
                all the current elements. This can be very useful and powerful from time to time.
            </p><p>
                Of course, one-shot-delete does not apply to collections mapped <tt class="literal">inverse="true"</tt>.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-batch-updates"></a>21.6.&nbsp;Batch updates</h2></div></div><div></div></div><p>
            NHibernate supports batching SQL update commands (<tt class="literal">INSERT</tt>,
            <tt class="literal">UPDATE</tt>, <tt class="literal">DELETE</tt>) with the following limitations:
        </p><div class="itemizedlist"><ul type="disc"><li><p>the NHibernate's drive used for your RDBMS may not supports batching,</p></li><li><p>since the implementation uses reflection to access members and types
                in System.Data assembly which are not normally visible, it may not function
                in environments where necessary permissions are not granted,</p></li><li><p>optimistic concurrency checking may be impaired since ADO.NET 2.0 does not
                return the number of rows affected by each statement in the batch, only
                the total number of rows affected by the batch.</p></li></ul></div><p>
            Update batching is enabled by setting <tt class="literal">adonet.batch_size</tt>
            to a non-zero value.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-multi-query"></a>21.7.&nbsp;Query batch</h2></div></div><div></div></div><p>
            This functionality allows you to execute several queries in one round-trip
            against the database server. A simple use case is executing a paged query while
            also getting the total count of results, in a single round-trip. Here is an
            example:
        </p><pre class="programlisting">using NHibernate.Multi;

...

IQueryBatch queries = s.CreateQueryBatch()
    .Add&lt;Item&gt;(
        s.CreateQuery("from Item i where i.Id &gt; ?")
         .SetInt32(0, 50).SetFirstResult(10))
    .Add&lt;long&gt;(
        s.CreateQuery("select count(*) from Item i where i.Id &gt; :id")
         .SetInt32("id", 50));
IList&lt;Item&gt; items = queries.GetResult&lt;Item&gt;(0);
long count = queries.GetResult&lt;long&gt;(1).Single();</pre><p>
            The results are got by index, ordered according to the order of queries
            added to the query batch. Instead of relying on this ordering, a key can be
            associated with each query for later retrieval:
        </p><pre class="programlisting">using NHibernate.Multi;

...

var queries = s.CreateQueryBatch()
    .Add("list", s.Query&lt;Item&gt;().Where(i =&gt; i.Id &gt; 50))
    .Add("count", s.Query&lt;Item&gt;().Where(i =&gt; i.Id &gt; 50), q =&gt; q.Count());
var count = queries.GetResult&lt;int&gt;("count").Single();
var items = queries.GetResult&lt;Item&gt;("list");</pre><p>
            The namespace <tt class="literal">NHibernate.Multi</tt> has to be imported since most query
            batch methods are extension methods.
        </p><p>
            Criteria queries are also supported by the query batch:
        </p><pre class="programlisting">var queries = s.CreateQueryBatch()
    .Add&lt;Item&gt;(
        s.CreateCriteria(typeof(Item))
         .Add(Expression.Gt("Id", 50))
         .SetFirstResult(10))
    .Add&lt;long&gt;(
        s.CreateCriteria(typeof(Item))
         .Add(Expression.Gt("Id", 50))
         .SetProject(Projections.RowCount()));
var items = queries.GetResult&lt;Item&gt;(0);
var count = queries.GetResult&lt;long&gt;(1).Single();</pre><p>
            You can add <tt class="literal">ICriteria</tt> or <tt class="literal">DetachedCriteria</tt> to the query batch.
            In fact, using DetachedCriteria in this fashion has some interesting implications.
        </p><pre class="programlisting">DetachedCriteria customersCriteria = AuthorizationService.GetAssociatedCustomersQuery();
IQueryBatch queries = session.CreateQueryBatch()
    .Add&lt;Customer&gt;(customersCriteria)
    .Add&lt;Policy&gt;(DetachedCriteria.For&lt;Policy&gt;()
        .Add(Subqueries.PropertyIn("id",
            CriteriaTransformer.Clone(customersCriteria)
                .SetProjection(Projections.Id())
            )));

IList&lt;Customer&gt; customers = queries.GetResult&lt;Customer&gt;(0);
IList&lt;Policy&gt; policies = queries.GetResult&lt;Policy&gt;(1);</pre><p>
            We get a query that represents the customers we can access, and then we can utilize this
            query further in order to perform additional logic (getting the policies of the customers we are
            associated with), all in a single database round-trip.
        </p><p>
            The query batch also supports QueryOver and sql queries. All kind of queries can be mixed in the
            same batch.
        </p><pre class="programlisting">using NHibernate.Multi;

...

var queries = s.CreateQueryBatch()
    .Add("queryOverList", s.QueryOver&lt;Item&gt;().Where(i =&gt; i.Category == "Food"))
    .Add&lt;long&gt;("sqlCount",
        s.CreateSQLQuery("select count(*) as itemCount from Item i where i.Category = :cat")
         .AddScalar("itemCount", NHibernateUtil.Int64)
         .SetString("cat", "Food"));
var count = queries.GetResult&lt;long&gt;("sqlCount").Single();
var items = queries.GetResult&lt;Item&gt;("queryOverList");</pre><p>
            Second level cache is supported by the query batch. Queries flagged as cacheable will be retrieved
            from the cache if already cached, otherwise their results will be put in the cache.
        </p><pre class="programlisting">using NHibernate.Multi;

...

var queries = s.CreateQueryBatch()
    .Add("list",
        s.Query&lt;Item&gt;()
         .Where(i =&gt; i.Id &gt; 50)
         .WithOptions(o =&gt; o.SetCacheable(true)))
    .Add&lt;long&gt;("count",
        s.CreateQuery("select count(*) from Item i where i.Id &gt; :id")
         .SetInt32("id", 50)
         .SetCacheable(true));
var count = queries.GetResult&lt;long&gt;("count").Single();
var items = queries.GetResult&lt;Item&gt;("list");</pre><p>
            Multi query is executed by concatenating the queries and sending the query to the database
            as a single string. This means that the database should support returning several result sets
            in a single query. Otherwise each query will be individually executed instead.
        </p><p>
            The first <tt class="literal">GetResult</tt> call triggers execution of the whole query batch, which
            then stores all results. Later calls only retrieve the stored results. A query batch can be
            re-executed by calling its <tt class="literal">Execute</tt> method. Once executed, no new query can be
            added to the batch.
        </p><p>
            Note that the database server is likely to enforce a limit on the maximum number of parameters
            in a query, in which case the limit applies to the query batch as a whole. Queries using
            <tt class="literal">in</tt> with a large number of arguments passed as parameters may easily exceed
            this limit. For example, SQL Server has a limit of 2,100 parameters per round-trip, and will
            throw an exception executing this query:
        </p><pre class="programlisting">int[] allEmployeesId  = ...; // 1,500 items
var queries = s.CreateQueryBatch()
    .Add&lt;Employee&gt;(
        s.CreateQuery("from Employee e where e.Id in :empIds")
         .SetParameterList("empIds", allEmployeesId)
         .SetFirstResult(10))
    .Add&lt;long&gt;(
        s.CreateQuery("select count(*) from Employee e where e.Id in :empIds")
         .SetParameterList("empIds", allEmployeesId));
queries.Execute(); // will throw an exception from SQL Server</pre><p>
            An interesting usage of the query batch is to load several collections of an object in one
            round-trip, without an expensive cartesian product (blog * users * posts).
        </p><pre class="programlisting">Blog blog = s.CreateQueryBatch()
    .Add(
        s.CreateQuery("select b from Blog b left join fetch b.Users where b.Id = :id")
         .SetInt32("id", 123))
    .Add(
        s.CreateQuery("select b from Blog b left join fetch b.Posts where b.Id = :id")
         .SetInt32("id", 123))
    .GetResult&lt;Blog&gt;(0).FirstOrDefault();</pre><p>
            You can also add queries as future queries to a query batch:
        </p><pre class="programlisting">using NHibernate.Multi;

...

var queries = s.CreateQueryBatch();
var list = queries.AddAsFuture(s.Query&lt;Item&gt;().Where(i =&gt; i.Id &gt; 50)));
var countValue = queries.AddAsFutureValue&lt;long&gt;(
    s.CreateQuery("select count(*) from Item i where i.Id &gt; :id")
     .SetInt32("id", 50));
var count = countValue.Value;
var items = list.GetEnumerable();</pre><p>
            Futures built from a query batch are executed together the first time the result of one of
            them is accessed. They are independent of futures obtained directly from the queries.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-future"></a>21.8.&nbsp;Future results</h2></div></div><div></div></div><p>
            Queries can be converted to future results instead of being directly executed. Future
            results are not evaluated till one gets executed. At that point, all defined future
            results are evaluated in one single round-trip to the database.
        </p><p>
            Future results are an alternative to using <a href="#performance-multi-query" title="21.7.&nbsp;Query batch">Section&nbsp;21.7, &#8220;Query batch&#8221;</a>.
            They avoid the need to explicitly regroup queries, but they also hide which queries will
            get executed: any pending future results of the session will be batched together, no
            matter where they were defined, included out-of-scope pending future results.
        </p><p>
            Future results are obtained by calling <tt class="literal">Future</tt> or
            <tt class="literal">FutureValue</tt> methods of a HQL, Criteria, QueryOver or SQL query.
            For LINQ queries, the methods are named <tt class="literal">ToFuture</tt> and
            <tt class="literal">ToFutureValue</tt>, see <a href="#querylinq-futureresults" title="18.4.&nbsp;Future results">Section&nbsp;18.4, &#8220;Future results&#8221;</a> for
            an example.
        </p><pre class="programlisting">// Define queries
IFutureEnumerable&lt;Cat&gt; cats =
    session.CreateQuery("from Cat c where c.Color = :color")
        .SetString("color", "black")
        .Future();
IFutureValue&lt;int&gt; catCount =
    session.QueryOver&lt;Cat&gt;()
        .ToRowCountQuery()
        .FutureValue&lt;int&gt;();
// Execute them
foreach(Cat cat in cats.GetEnumerable())
{
    // Do something
}
if (catCount.Value &gt; 10)
{
    // Do something
}
</pre><p>
            In the above example, accessing <tt class="literal">catCount.Value</tt> does not trigger a round-trip
            to the database: it has been evaluated with <tt class="literal">cats.GetEnumerable()</tt> call. If
            instead <tt class="literal">catCount.Value</tt> was accessed first, it would have executed both
            future results and <tt class="literal">cats.GetEnumerable()</tt> would not have triggered a round-trip
            to the database.
        </p><p>
            As showcased in the previous example, <tt class="literal">Future</tt> allows to get a future enumerable
            result, and <tt class="literal">FutureValue</tt> is meant to obtain a single value result.
        </p><p>
            Note: in NHibernate v5.1 and previous versions, Criteria/QueryOver future results were batched
            separately. Since NHibernate v5.2, they are batched with other querying API future results.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="toolsetguide"></a>Chapter&nbsp;22.&nbsp;Toolset Guide</h2></div></div><div></div></div><p>
        Roundtrip engineering with NHibernate is possible using a set of commandline tools 
        maintained as part of the NHibernate project, along with NHibernate support built into
        various code generation tools (MyGeneration, CodeSmith, ObjectMapper, AndroMDA).
    </p><p>
        The NHibernate main package comes bundled with the most important tool (it can even
        be used from "inside" NHibernate on-the-fly):
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            DDL schema generation from a mapping file
            (aka <tt class="literal">SchemaExport</tt>, <tt class="literal">hbm2ddl</tt>)
        </p></li></ul></div><p>
        Other tools directly provided by the NHibernate project are delivered with a separate
        package, <span class="emphasis"><em>NHibernateContrib</em></span>. This package includes tools for
        the following tasks:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            mapping file generation from .NET classes marked with attributes
            (<tt class="literal">NHibernate.Mapping.Attributes</tt>, or NHMA for short)
        </p></li></ul></div><p>
        Third party tools with NHibernate support are:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            CodeSmith, MyGeneration, and ObjectMapper (mapping file generation from an existing
            database schema)
        </p></li><li><p>
            AndroMDA (MDA (Model-Driven Architecture) approach generating code for
            persistent classes from UML diagrams and their XML/XMI representation)
        </p></li></ul></div><p>
        These 3rd party tools are not documented in this reference. Please refer to the NHibernate
        website for up-to-date information.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s1"></a>22.1.&nbsp;Schema Generation</h2></div></div><div></div></div><p>
            The generated schema includes referential integrity constraints (primary and foreign keys) for entity
            and collection tables. Tables and sequences are also created for mapped identifier generators.
        </p><p>
            You <span class="emphasis"><em>must</em></span> specify a SQL <tt class="literal">Dialect</tt> via the 
            <tt class="literal">dialect</tt> configuration property when using this tool.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-2"></a>22.1.1.&nbsp;Customizing the schema</h3></div></div><div></div></div><p>
                Many NHibernate mapping elements define an optional attribute named <tt class="literal">length</tt>. You may set 
                the length of a column with this attribute. (Or, for numeric/decimal data types, the precision.)
            </p><p>
                Some tags also accept a <tt class="literal">not-null</tt> attribute (for generating a <tt class="literal">NOT NULL</tt>
                constraint on table columns) and a <tt class="literal">unique</tt> attribute (for generating <tt class="literal">UNIQUE</tt>
                constraint on table columns).
            </p><p>
                Some tags accept an <tt class="literal">index</tt> attribute for specifying the
                name of an index for that column. A <tt class="literal">unique-key</tt> attribute
                can be used to group columns in a single unit key constraint. Currently, the
                specified value of the <tt class="literal">unique-key</tt> attribute is
                <span class="emphasis"><em>not</em></span> used to name the constraint, only to group the
                columns in the mapping file.
            </p><p>
                Examples:
            </p><pre class="programlisting">&lt;property name="Foo" type="String" length="64" not-null="true"/&gt;

&lt;many-to-one name="Bar" foreign-key="fk_foo_bar" not-null="true"/&gt;

&lt;element column="serial_number" type="Int64" not-null="true" unique="true"/&gt;</pre><p>
                Alternatively, these elements also accept a child <tt class="literal">&lt;column&gt;</tt> element. This is
                particularly useful for multi-column types:
            </p><pre class="programlisting">&lt;property name="Foo" type="String"&gt;
    &lt;column name="foo" length="64" not-null="true" sql-type="text"/&gt;
&lt;/property&gt;

&lt;property name="Bar" type="My.CustomTypes.MultiColumnType, My.CustomTypes"/&gt;
    &lt;column name="fee" not-null="true" index="bar_idx"/&gt;
    &lt;column name="fi" not-null="true" index="bar_idx"/&gt;
    &lt;column name="fo" not-null="true" index="bar_idx"/&gt;
&lt;/property&gt;</pre><p>
                The <tt class="literal">sql-type</tt> attribute allows the user to override the default mapping
                of NHibernate type to SQL data type.
            </p><p>
                The <tt class="literal">check</tt> attribute allows you to specify a check constraint.
            </p><pre class="programlisting">&lt;property name="Foo" type="Int32"&gt;
    &lt;column name="foo" check="foo &gt; 10"/&gt;
&lt;/property&gt;

&lt;class name="Foo" table="foos" check="bar &lt; 100.0"&gt;
    ...
    &lt;property name="Bar" type="Single"/&gt;
&lt;/class&gt;</pre><div class="table"><a name="schemattributes-summary"></a><p class="title"><b>Table&nbsp;22.1.&nbsp;Summary</b></p><table summary="Summary" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Attribute</th><th>Values</th><th>Interpretation</th></tr></thead><tbody><tr><td><tt class="literal">length</tt></td><td>number</td><td>column length/decimal precision</td></tr><tr><td><tt class="literal">not-null</tt></td><td><tt class="literal">true|false</tt></td><td>specifies that the column should be non-nullable</td></tr><tr><td><tt class="literal">unique</tt></td><td><tt class="literal">true|false</tt></td><td>specifies that the column should have a unique constraint</td></tr><tr><td><tt class="literal">index</tt></td><td><tt class="literal">index_name</tt></td><td>specifies the name of a (multi-column) index</td></tr><tr><td><tt class="literal">unique-key</tt></td><td><tt class="literal">unique_key_name</tt></td><td>specifies the name of a multi-column unique constraint</td></tr><tr><td><tt class="literal">foreign-key</tt></td><td><tt class="literal">foreign_key_name</tt></td><td>
                                specifies the name of the foreign key constraint generated
                                for an association, use it on &lt;one-to-one&gt;, &lt;many-to-one&gt;,
                                &lt;key&gt;, and &lt;many-to-many&gt; mapping elements. Note that
                                <tt class="literal">inverse="true"</tt> sides will not be considered
                                by <tt class="literal">SchemaExport</tt>.
                            </td></tr><tr><td><tt class="literal">sql-type</tt></td><td><tt class="literal">column_type</tt></td><td>
                                overrides the default column type (attribute of 
                                <tt class="literal">&lt;column&gt;</tt> element only)
                            </td></tr><tr><td><tt class="literal">check</tt></td><td>SQL expression</td><td>
                                create an SQL check constraint on either column or table
                            </td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-3"></a>22.1.2.&nbsp;Running the tool</h3></div></div><div></div></div><p>
                The <tt class="literal">SchemaExport</tt> tool writes a DDL script to standard out and/or
                executes the DDL statements.
            </p><p>
                You may embed <tt class="literal">SchemaExport</tt> in your application:
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaExport(cfg).Create(false, true);</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-parentchild"></a>Chapter&nbsp;23.&nbsp;Example: Parent/Child</h2></div></div><div></div></div><p>
        One of the first things that new users want to do with NHibernate is to model a parent/child type
        relationship. There are two different approaches to this. The most convenient
        approach, especially for new users, is to model both <tt class="literal">Parent</tt> and <tt class="literal">Child</tt>
        as entity classes with a <tt class="literal">&lt;one-to-many&gt;</tt> association from <tt class="literal">Parent</tt>
        to <tt class="literal">Child</tt>. The alternative approach is to declare the <tt class="literal">Child</tt> as a
        <tt class="literal">&lt;composite-element&gt;</tt>. The default semantics of a one to many
        association in NHibernate are much less close to the usual semantics of a parent/child relationship than
        those of a composite element mapping. We will explain how to use a <span class="emphasis"><em>bidirectional one to many
        association with cascades</em></span> to model a parent/child relationship efficiently and elegantly.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-collections"></a>23.1.&nbsp;A note about collections</h2></div></div><div></div></div><p>
            NHibernate collections are considered to be a logical part of their owning entity and not of the
            contained entities. Be aware that this is a critical distinction that has the following consequences:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                When you remove/add an object from/to a collection, the version number of the collection owner
                is incremented.
            </p></li><li><p>
                If an object that was removed from a collection is an instance of a value type (e.g., a composite
                element), that object will cease to be persistent and its state will be completely removed from
                the database. Likewise, adding a value type instance to the collection will cause its state to
                be immediately persistent.
            </p></li><li><p>
                Conversely, if an entity is removed from a collection (a one-to-many or many-to-many
                association), it will not be deleted by default. This behavior is completely consistent; a
                change to the internal state of another entity should not cause the associated entity to vanish.
                Likewise, adding an entity to a collection does not cause that entity to become persistent, by
                default.
            </p></li></ul></div><p>
            Adding an entity to a collection, by default, merely creates a link between the two entities. Removing
            the entity will remove the link. This is appropriate for all sorts of cases. However, it is not
            appropriate in the case of a parent/child relationship. In this case, the life of the child is bound to
            the life cycle of the parent.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-bidir"></a>23.2.&nbsp;Bidirectional one-to-many</h2></div></div><div></div></div><p>
            Suppose we start with a simple <tt class="literal">&lt;one-to-many&gt;</tt> association from
            <tt class="literal">Parent</tt> to <tt class="literal">Child</tt>.
        </p><pre class="programlisting">&lt;set name="Children"&gt;
    &lt;key column="parent_id" /&gt;
    &lt;one-to-many class="Child" /&gt;
&lt;/set&gt;</pre><p>
            If we were to execute the following code:
        </p><pre class="programlisting">Parent p = ...;
Child c = new Child();
p.Children.Add(c);
session.Save(c);
session.Flush();</pre><p>
            NHibernate would issue two SQL statements:
        </p><div class="itemizedlist"><ul type="disc"><li><p>an <tt class="literal">INSERT</tt> to create the record for <tt class="literal">c</tt></p></li><li><p>
                    an <tt class="literal">UPDATE</tt> to create the link from <tt class="literal">p</tt> to
                    <tt class="literal">c</tt>
                </p></li></ul></div><p>
            This is not only inefficient, but also violates any <tt class="literal">NOT NULL</tt> constraint on the
            <tt class="literal">parent_id</tt> column. You can fix the nullability constraint violation by specifying
            <tt class="literal">not-null="true"</tt> in the collection mapping:
        </p><pre class="programlisting">&lt;set name="Children"&gt;
    &lt;key column="parent_id" not-null="true"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            However, this is not the recommended solution.
        </p><p>
            The underlying cause of this behavior is that the link (the foreign key
            <tt class="literal">parent_id</tt>) from <tt class="literal">p</tt> to <tt class="literal">c</tt> is not considered
            part of the state of the <tt class="literal">Child</tt> object and is therefore not created in the
            <tt class="literal">INSERT</tt>. The solution is to make the link part of the <tt class="literal">Child</tt>
            mapping.
        </p><pre class="programlisting">&lt;many-to-one name="Parent" column="parent_id" not-null="true"/&gt;</pre><p>
            You also need to add the <tt class="literal">Parent</tt> property to the <tt class="literal">Child</tt> class.
        </p><p>
            Now that the <tt class="literal">Child</tt> entity is managing the state of the link, we tell the collection not
            to update the link. We use the <tt class="literal">inverse</tt> attribute to do this:
        </p><pre class="programlisting">&lt;set name="Children" inverse="true"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            The following code would be used to add a new <tt class="literal">Child</tt>:
        </p><pre class="programlisting">Parent p = session.Load&lt;Parent&gt;(pid);
Child c = new Child();
c.Parent = p;
p.Children.Add(c);
session.Save(c);
session.Flush();</pre><p>
            Only one SQL <tt class="literal">INSERT</tt> would now be issued.
        </p><p>
            You could also create an <tt class="literal">AddChild()</tt> method of <tt class="literal">Parent</tt>.
        </p><pre class="programlisting">public void AddChild(Child c)
{
    c.Parent = this;
    children.Add(c);
}</pre><p>
            The code to add a <tt class="literal">Child</tt> looks like
        </p><pre class="programlisting">Parent p = session.Load&lt;Parent&gt;(pid);
Child c = new Child();
p.AddChild(c);
session.Save(c);
session.Flush();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-cascades"></a>23.3.&nbsp;Cascading lifecycle</h2></div></div><div></div></div><p>
            You can address the frustrations of the explicit call to <tt class="literal">Save()</tt> by using
            cascades.
        </p><pre class="programlisting">&lt;set name="Children" inverse="true" cascade="all"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            This simplifies the code above to:
        </p><pre class="programlisting">Parent p = session.Load&lt;Parent&gt;(pid);
Child c = new Child();
p.AddChild(c);
session.Flush();</pre><p>
            Similarly, we do no more need to iterate over the children when saving or deleting a
            <tt class="literal">Parent</tt>. The following removes <tt class="literal">p</tt> and all its children
            from the database.
        </p><pre class="programlisting">Parent p = session.Load&lt;Parent&gt;(pid);
session.Delete(p);
session.Flush();</pre><p>
            However, the following code:
        </p><pre class="programlisting">Parent p = session.Load&lt;Parent&gt;(pid);
// Get one child out of the set
Child c = p.Children.First();

p.Children.Remove(c);
c.Parent = null;
session.Flush();</pre><p>
            will not remove <tt class="literal">c</tt> from the database. In this case, it will only remove
            the link to <tt class="literal">p</tt> and cause a <tt class="literal">NOT NULL</tt> constraint violation.
            You need to explicitly <tt class="literal">Delete()</tt> the <tt class="literal">Child</tt>.
        </p><pre class="programlisting">Parent p = session.Load&lt;Parent&gt;(pid);
// Get one child out of the set
Child c = p.Children.First();

p.Children.Remove(c);
session.Delete(c);
session.Flush();</pre><p>
            In our case, a <tt class="literal">Child</tt> cannot exist without its parent. So if we remove a
            <tt class="literal">Child</tt> from the collection, we do want it to be deleted. To do this, we must
            use <tt class="literal">cascade="all-delete-orphan"</tt>.
        </p><pre class="programlisting">&lt;set name="Children" inverse="true" cascade="all-delete-orphan"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            Even though the collection mapping specifies <tt class="literal">inverse="true"</tt>, cascades are still
            processed by iterating the collection elements. If you need an object be saved, deleted or
            updated by cascade, you must add it to the collection. It is not enough to simply set its parent.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-update"></a>23.4.&nbsp;Using cascading <tt class="literal">Update()</tt></h2></div></div><div></div></div><p>
            Suppose we loaded up a <tt class="literal">Parent</tt> in one <tt class="literal">ISession</tt>, made some
            changes in a UI action and wanted to persist these changes in a new <tt class="literal">ISession</tt>
            by calling <tt class="literal">Update()</tt>. The <tt class="literal">Parent</tt> will contain a collection
            of children and, since the cascading update is enabled, NHibernate needs to know which children
            are newly instantiated and which represent existing rows in the database. We will also assume
            that both <tt class="literal">Parent</tt> and <tt class="literal">Child</tt> have generated identifier
            properties of type <tt class="literal">long</tt>. NHibernate will use the identifier and
            version/timestamp property value to determine which of the children are new. (See
            <a href="#manipulatingdata-updating-detached" title="10.4.2.&nbsp;Updating detached objects">Section&nbsp;10.4.2, &#8220;Updating detached objects&#8221;</a>.)
        </p><p>
            The <tt class="literal">unsaved-value</tt> attribute is used to specify the identifier value of a newly
            instantiated instance. <span class="emphasis"><em>In NHibernate it is not necessary to specify
            <tt class="literal">unsaved-value</tt> explicitly.</em></span>
        </p><p>
            The following code will update <tt class="literal">parent</tt> and <tt class="literal">child</tt> and insert
            <tt class="literal">newChild</tt>.
        </p><pre class="programlisting">//parent and child were both loaded in a previous session
parent.AddChild(child);
Child newChild = new Child();
parent.AddChild(newChild);
session.Update(parent);
session.Flush();</pre><p>
            This may be suitable for the case of a generated identifier, but what about assigned identifiers
            and composite identifiers? This is more difficult, since NHibernate cannot use the identifier
            property to distinguish between a newly instantiated object, with an identifier assigned by the
            user, and an object loaded in a previous session. In this case, NHibernate will either use the
            timestamp or version property, or will actually query the second-level cache or, worst case, the
            database, to see if the row exists.
        </p><p>
            To avoid the worst case, either:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    define an <tt class="literal">unsaved-value</tt> on a <tt class="literal">&lt;version&gt;</tt>
                    or <tt class="literal">&lt;timestamp&gt;</tt> property mapping for the class.
                </p></li><li><p>
                    set <tt class="literal">unsaved-value="none"</tt> and explicitly <tt class="literal">Save()</tt>
                    newly instantiated children before calling <tt class="literal">Update(parent)</tt>.
                </p></li><li><p>
                    set <tt class="literal">unsaved-value="any"</tt> and explicitly <tt class="literal">Update()</tt>
                    previously persistent children before calling <tt class="literal">Update(parent)</tt>.
                </p></li><li><p>
                    implement <tt class="literal">IInterceptor.IsTransient()</tt> for providing your own strategy
                    for distinguishing newly instantiated objects.
                </p></li></ul></div><p>
            For the <tt class="literal">IInterceptor</tt> solution, you could by example define a base class for
            your persistent classes:
        </p><pre class="programlisting">public class Persistent
{
    private bool _saved = false;

    public virtual void OnSave()
    {
        _saved = true;
    }

    public virtual void OnLoad()
    {
        _saved = true;
    }

    public virtual void OnDelete()
    {
        _saved = false;
    }

    ...

    public virtual bool IsSaved
    {
        get { return _saved; }
    }
}</pre><p>
            (The <tt class="literal">saved</tt> property is non-persistent.)
            Then implement in you interceptor class <tt class="literal">IsTransient()</tt>, along with
            <tt class="literal">OnLoad()</tt>, <tt class="literal">OnSave()</tt> and <tt class="literal">OnDelete()</tt>
            as follows:
        </p><pre class="programlisting">public object IsTransient(object entity)
{
    if (entity is Persistent)
    {
        return !((Persistent) entity).IsSaved;
    }
    else
    {
        return null;
    }
}

public bool OnLoad(object entity,
    object id,
    object[] state,
    string[] propertyNames,
    IType[] types)
{
    if (entity is Persistent)
        ((Persistent) entity).OnLoad();
    return false;
}

public boolean OnSave(object entity,
    object id,
    object[] state,
    string[] propertyNames,
    IType[] types)
{
    if (entity is Persistent)
        ((Persistent) entity).OnSave();
    return false;
}

public virtual void OnDelete(object entity,
    object id,
    object[] state,
    string[] propertyNames,
    IType[] types)
{
    if (entity is Persistent)
        ((Persistent) entity).OnDelete();
}</pre><p>
            See <a href="#objectstate-interceptors" title="13.1.&nbsp;Interceptors">Section&nbsp;13.1, &#8220;Interceptors&#8221;</a> for more information.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-conclusion"></a>23.5.&nbsp;Conclusion</h2></div></div><div></div></div><p>
            There is quite a bit to digest here and it might look confusing first time around. However, in practice, it
            all works out quite nicely. Most NHibernate applications use the parent / child pattern in many places.
        </p><p>
            We mentioned an alternative in the first paragraph. None of the above issues exist in the case of
            <tt class="literal">&lt;composite-element&gt;</tt> mappings, which have exactly the semantics of a parent/child
            relationship. Unfortunately, there are two big limitations to composite element classes: composite elements
            cannot own collections, and they should not be the child of any entity other than the unique parent. (However,
            they <span class="emphasis"><em>may</em></span> have a surrogate primary key, using an <tt class="literal">&lt;idbag&gt;</tt> mapping.)
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-weblog"></a>Chapter&nbsp;24.&nbsp;Example: Weblog Application</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-classes"></a>24.1.&nbsp;Persistent Classes</h2></div></div><div></div></div><p>
            The persistent classes represent a weblog, and an item posted
            in a weblog. They are to be modelled as a standard parent/child
            relationship, but we will use an ordered bag, instead of a set.
        </p><pre class="programlisting">using System;
using System.Collections.Generic;

namespace Eg
{
    public class Blog
    {
        public virtual long Id { get; set;}

        public virtual IList&lt;BlogItem&gt; Items { get; set;}

        public virtual string Name { get; set;}
    }
}</pre><pre class="programlisting">using System;

namespace Eg
{
    public class BlogItem
    {
        public virtual Blog Blog { get; set;}

        public virtual DateTime DateTime { get; set;}

        public virtual long Id { get; set;}

        public virtual string Text { get; set;}

        public virtual string Title { get; set;}
    }
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-mappings"></a>24.2.&nbsp;NHibernate Mappings</h2></div></div><div></div></div><p>
            The XML mappings should now be quite straightforward.
        </p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg"&gt;

    &lt;class 
        name="Blog" 
        table="BLOGS" 
        lazy="true"&gt;
        
        &lt;id 
            name="Id" 
            column="BLOG_ID"&gt;
            
            &lt;generator class="native"/&gt;
            
        &lt;/id&gt;
        
        &lt;property 
            name="Name" 
            column="NAME" 
            not-null="true" 
            unique="true"/&gt;
            
        &lt;bag
            name="Items" 
            inverse="true" 
            lazy="true"
            order-by="DATE_TIME" 
            cascade="all"&gt;
            
            &lt;key column="BLOG_ID"/&gt;
            &lt;one-to-many class="BlogItem"/&gt;
            
        &lt;/bag&gt;
        
    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg"&gt;
    
    &lt;class 
        name="BlogItem" 
        table="BLOG_ITEMS" 
        dynamic-update="true"&gt;
        
        &lt;id 
            name="Id" 
            column="BLOG_ITEM_ID"&gt;
            
            &lt;generator class="native"/&gt;
            
        &lt;/id&gt;
        
        &lt;property 
            name="Title" 
            column="TITLE" 
            not-null="true"/&gt;
            
        &lt;property 
            name="Text" 
            column="TEXT" 
            not-null="true"/&gt;
            
        &lt;property 
            name="DateTime" 
            column="DATE_TIME" 
            not-null="true"/&gt;
            
        &lt;many-to-one 
            name="Blog" 
            column="BLOG_ID" 
            not-null="true"/&gt;
            
    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-code"></a>24.3.&nbsp;NHibernate Code</h2></div></div><div></div></div><p>
            The following class demonstrates some of the kinds of things
            we can do with these classes, using NHibernate.
        </p><pre class="programlisting">using System;
using System.Collections.Generic;
using NHibernate;
using NHibernate.Cfg;
using NHibernate.Tool.hbm2ddl;

namespace Eg
{
    public class BlogMain
    {
        private ISessionFactory _sessions;

        public void Configure()
        {
            _sessions = new Configuration().Configure()
                .BuildSessionFactory();
        }

        public void ExportTables()
        {
            var cfg = new Configuration().Configure();
            new SchemaExport(cfg).Create(true, true);
        }

        public Blog CreateBlog(string name)
        {
            var blog = new Blog
            {
                Name = name,
                Items = new List&lt;BlogItem&gt;()
            };

            using (var session = _sessions.OpenSession())
            using (var tx = session.BeginTransaction())
            {
                session.Save(blog);
                tx.Commit();
            }

            return blog;
        }

        public BlogItem CreateBlogItem(Blog blog, string title, string text)
        {
            var item = new BlogItem
            {
                Title = title,
                Text = text,
                Blog = blog,
                DateTime = DateTime.Now
            };
            blog.Items.Add(item);

            using (var session = _sessions.OpenSession())
            using (var tx = session.BeginTransaction())
            {
                session.Update(blog);
                tx.Commit();
            }

            return item;
        }

        public BlogItem CreateBlogItem(long blogId, string title, string text)
        {
            var item = new BlogItem
            {
                Title = title,
                Text = text,
                DateTime = DateTime.Now
            };

            using (var session = _sessions.OpenSession())
            using (var tx = session.BeginTransaction())
            {
                var blog = session.Load&lt;Blog&gt;(blogId);
                item.Blog = blog;
                blog.Items.Add(item);
                tx.Commit();
            }

            return item;
        }

        public void UpdateBlogItem(BlogItem item, string text)
        {
            item.Text = text;

            using (var session = _sessions.OpenSession())
            using (var tx = session.BeginTransaction())
            {
                session.Update(item);
                tx.Commit();
            }
        }

        public void UpdateBlogItem(long itemId, string text)
        {
            using (var session = _sessions.OpenSession())
            using (var tx = session.BeginTransaction())
            {
                var item = session.Load&lt;BlogItem&gt;(itemId);
                item.Text = text;
                tx.Commit();
            }
        }

        public IList&lt;object[]&gt; ListAllBlogNamesAndItemCounts(int max)
        {
            IList&lt;object[]&gt; result;

            using (var session = _sessions.OpenSession())
            using (var tx = session.BeginTransaction())
            {
                var q = session.CreateQuery(
                    "select blog.id, blog.Name, count(blogItem) " +
                    "from Blog as blog " +
                    "left outer join blog.Items as blogItem " +
                    "group by blog.Name, blog.id " +
                    "order by max(blogItem.DateTime)"
                );
                q.SetMaxResults(max);
                result = q.List&lt;object[]&gt;();
                tx.Commit();
            }

            return result;
        }

        public Blog GetBlogAndAllItems(long blogId)
        {
            Blog blog = null;

            using (var session = _sessions.OpenSession())
            using (var tx = session.BeginTransaction())
            {
                var q = session.CreateQuery(
                    "from Blog as blog " +
                    "left outer join fetch blog.Items " +
                    "where blog.id = :blogId"
                );
                q.SetParameter("blogId", blogId);
                blog = q.UniqueResult&lt;Blog&gt;();
                tx.Commit();
            }

            return blog;
        }

        public IList&lt;object[]&gt; ListBlogsAndRecentItems()
        {
            IList&lt;object[]&gt; result = null;

            using (var session = _sessions.OpenSession())
            using (var tx = session.BeginTransaction())
            {
                var q = session.CreateQuery(
                    "from Blog as blog " +
                    "inner join blog.Items as blogItem " +
                    "where blogItem.DateTime &gt; :minDate"
                );

                var date = DateTime.Now.AddMonths(-1);
                q.SetDateTime("minDate", date);

                result = q.List&lt;object[]&gt;();
                tx.Commit();
            }

            return result;
        }
    }
}</pre><p>
            It requires some configuration settings in <tt class="literal">web.config</tt>, such as:
        </p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
  &lt;!-- Add this element --&gt;
  &lt;configSections&gt;
    &lt;section
        name="hibernate-configuration"
        type="NHibernate.Cfg.ConfigurationSectionHandler, NHibernate" /&gt;
  &lt;/configSections&gt;

  &lt;!-- Add this element --&gt;
  &lt;hibernate-configuration xmlns="urn:nhibernate-configuration-2.2"&gt;
    &lt;session-factory&gt;
      &lt;property name="dialect"&gt;NHibernate.Dialect.MsSql2012Dialect&lt;/property&gt;
      &lt;property name="connection.connection_string"&gt;
        Server=localhost\SQLEXPRESS;initial catalog=Eg;Integrated Security=True
      &lt;/property&gt;

      &lt;mapping assembly="Eg" /&gt;
    &lt;/session-factory&gt;
  &lt;/hibernate-configuration&gt;

  &lt;!-- Leave the other sections unchanged --&gt;
  &lt;system.web&gt;
    ...
  &lt;/system.web&gt;
&lt;/configuration&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-mappings"></a>Chapter&nbsp;25.&nbsp;Example: Various Mappings</h2></div></div><div></div></div><p>
        This chapter shows off some more complex association mappings.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-emp"></a>25.1.&nbsp;Employer/Employee</h2></div></div><div></div></div><p>
            The following model of the relationship between <tt class="literal">Employer</tt> and 
            <tt class="literal">Employee</tt> uses an actual entity class (<tt class="literal">Employment</tt>) 
            to represent the association. This is done because there might be more than one
            period of employment for the same two parties. Components are used to model monetary 
            values and employee names.
        </p><div class="mediaobject" align="center"><img src="../shared/images/EmployerEmployee.png" align="middle"></div><p>
            Here's a possible mapping document:
        </p><pre class="programlisting">&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="..." namespace="..."&gt;

    &lt;class name="Employer" table="employers"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employer_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="Name"/&gt;
    &lt;/class&gt;

    &lt;class name="Employment" table="employment_periods"&gt;

        &lt;id name="Id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employment_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="StartDate" column="start_date"/&gt;
        &lt;property name="EndDate" column="end_date"/&gt;

        &lt;component name="HourlyRate" class="MonetaryAmount"&gt;
            &lt;property name="Amount"&gt;
                &lt;column name="hourly_rate" sql-type="NUMERIC(12, 2)"/&gt;
            &lt;/property&gt;
            &lt;property name="Currency" length="12"/&gt;
        &lt;/component&gt;

        &lt;many-to-one name="Employer" column="employer_id" not-null="true"/&gt;
        &lt;many-to-one name="Employee" column="employee_id" not-null="true"/&gt;

    &lt;/class&gt;

    &lt;class name="Employee" table="employees"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employee_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="TaxfileNumber"/&gt;
        &lt;component name="Name" class="Name"&gt;
            &lt;property name="FirstName"/&gt;
            &lt;property name="Initial"/&gt;
            &lt;property name="LastName"/&gt;
        &lt;/component&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            And here's the table schema generated by <tt class="literal">SchemaExport</tt>.
        </p><pre class="programlisting">create table employers (
    Id BIGINT not null, 
    Name VARCHAR(255), 
    primary key (Id)
)

create table employment_periods (
    Id BIGINT not null,
    hourly_rate NUMERIC(12, 2),
    Currency VARCHAR(12), 
    employee_id BIGINT not null, 
    employer_id BIGINT not null, 
    end_date TIMESTAMP, 
    start_date TIMESTAMP, 
    primary key (Id)
)

create table employees (
    Id BIGINT not null, 
    FirstName VARCHAR(255), 
    Initial CHAR(1), 
    LastName VARCHAR(255), 
    TaxfileNumber VARCHAR(255), 
    primary key (Id)
)

alter table employment_periods 
    add constraint employment_periodsFK0 foreign key (employer_id) references employers
alter table employment_periods 
    add constraint employment_periodsFK1 foreign key (employee_id) references employees
create sequence employee_id_seq
create sequence employment_id_seq
create sequence employer_id_seq</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-authorwork"></a>25.2.&nbsp;Author/Work</h2></div></div><div></div></div><p>
            Consider the following model of the relationships between <tt class="literal">Work</tt>,
            <tt class="literal">Author</tt> and <tt class="literal">Person</tt>. We represent the relationship
            between <tt class="literal">Work</tt> and <tt class="literal">Author</tt> as a many-to-many
            association. We choose to represent the relationship between <tt class="literal">Author</tt> 
            and <tt class="literal">Person</tt> as one-to-one association. Another possibility would be to 
            have <tt class="literal">Author</tt> extend <tt class="literal">Person</tt>.  
        </p><div class="mediaobject" align="center"><img src="../shared/images/AuthorWork.png" align="middle"></div><p>
            The following mapping document correctly represents these relationships:
        </p><pre class="programlisting">&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="..." namespace="..."&gt;

    &lt;class name="Work" table="works" discriminator-value="W"&gt;

        &lt;id name="Id" column="id" generator="native" /&gt;

        &lt;discriminator column="type" type="character"/&gt;

        &lt;property name="Title"/&gt;
        &lt;set name="Authors" table="author_work" lazy="true"&gt;
            &lt;key&gt;
                &lt;column name="work_id" not-null="true"/&gt;
            &lt;/key&gt;
            &lt;many-to-many class="Author"&gt;
                &lt;column name="author_id" not-null="true"/&gt;
            &lt;/many-to-many&gt;
        &lt;/set&gt;

        &lt;subclass name="Book" discriminator-value="B"&gt;
            &lt;property name="Text" column="text" /&gt;
        &lt;/subclass&gt;

        &lt;subclass name="Song" discriminator-value="S"&gt;
            &lt;property name="Tempo" column="tempo" /&gt;
            &lt;property name="Genre" column="genre" /&gt;
        &lt;/subclass&gt;

    &lt;/class&gt;

    &lt;class name="Author" table="authors"&gt;

        &lt;id name="Id" column="id"&gt;
            &lt;!-- The Author must have the same identifier as the Person --&gt;
            &lt;generator class="assigned"/&gt; 
        &lt;/id&gt;

        &lt;property name="Alias" column="alias" /&gt;
        &lt;one-to-one name="Person" constrained="true"/&gt;

        &lt;set name="Works" table="author_work" inverse="true" lazy="true"&gt;
            &lt;key column="author_id"/&gt;
            &lt;many-to-many class="Work" column="work_id"/&gt;
        &lt;/set&gt;

    &lt;/class&gt;

    &lt;class name="Person" table="persons"&gt;
        &lt;id name="Id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="Name" column="name" /&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            There are four tables in this mapping. <tt class="literal">works</tt>, 
            <tt class="literal">authors</tt> and <tt class="literal">persons</tt> hold work, author
            and person data respectively. <tt class="literal">author_work</tt> is an association
            table linking authors to works. Here is the table schema, as generated by
            <tt class="literal">SchemaExport</tt>.
        </p><pre class="programlisting">create table works (
    id BIGINT not null generated by default as identity, 
    tempo FLOAT, 
    genre VARCHAR(255), 
    text INTEGER, 
    title VARCHAR(255), 
    type CHAR(1) not null, 
    primary key (id)
)

create table author_work (
    author_id BIGINT not null, 
    work_id BIGINT not null, 
    primary key (work_id, author_id)
)

create table authors (
    id BIGINT not null generated by default as identity, 
    alias VARCHAR(255), 
    primary key (id)
)

create table persons (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

alter table authors 
    add constraint authorsFK0 foreign key (id) references persons
alter table author_work 
    add constraint author_workFK0 foreign key (author_id) references authors
alter table author_work
    add constraint author_workFK1 foreign key (work_id) references works</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-customerorderproduct"></a>25.3.&nbsp;Customer/Order/Product</h2></div></div><div></div></div><p>
            In this section we consider a model of the relationships between <tt class="literal">Customer</tt>,
            <tt class="literal">Order</tt>, <tt class="literal">LineItem</tt> and <tt class="literal">Product</tt>.
            There is a one-to-many association between <tt class="literal">Customer</tt> and
            <tt class="literal">Order</tt>, but how can you represent <tt class="literal">Order</tt> /
            <tt class="literal">LineItem</tt> / <tt class="literal">Product</tt>? In the example,
            <tt class="literal">LineItem</tt> is mapped as an association class representing the many-to-many
            association between <tt class="literal">Order</tt> and <tt class="literal">Product</tt>. In
            NHibernate, this is called a composite element.
        </p><div class="mediaobject" align="center"><img src="../shared/images/CustomerOrderProduct.png" align="middle"></div><p>
            The mapping document:
        </p><pre class="programlisting">&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="..." namespace="..."&gt;

    &lt;class name="Customer" table="customers"&gt;
        &lt;id name="Id" column="id" generator="native" /&gt;
        &lt;property name="Name" column="name"/&gt;
        &lt;set name="Orders" inverse="true" lazy="true"&gt;
            &lt;key column="customer_id"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Order" table="orders"&gt;
        &lt;id name="Id" column="id" generator="native" /&gt;
        &lt;property name="Date" column="date"/&gt;
        &lt;many-to-one name="Customer" column="customer_id"/&gt;
        &lt;list name="LineItems" table="line_items" lazy="true"&gt;
            &lt;key column="order_id"/&gt;
            &lt;list-index column="line_number"/&gt;
            &lt;composite-element class="LineItem"&gt;
                &lt;property name="Quantity" column="quantity"/&gt;
                &lt;many-to-one name="Product" column="product_id"/&gt;
            &lt;/composite-element&gt;
        &lt;/list&gt;
    &lt;/class&gt;

    &lt;class name="Product" table="products"&gt;
        &lt;id name="Id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="SerialNumber" column="serial_number" /&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            <tt class="literal">customers</tt>, <tt class="literal">orders</tt>, <tt class="literal">line_items</tt> and 
            <tt class="literal">products</tt> hold customer, order, order line item and product data
            respectively. <tt class="literal">line_items</tt> also acts as an association table linking
            orders with products.
        </p><pre class="programlisting">create table customers (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

create table orders (
    id BIGINT not null generated by default as identity, 
    customer_id BIGINT, 
    date TIMESTAMP, 
    primary key (id)
)

create table line_items (
    line_number INTEGER not null, 
    order_id BIGINT not null, 
    product_id BIGINT, 
    quantity INTEGER, 
    primary key (order_id, line_number)
)

create table products (
    id BIGINT not null generated by default as identity, 
    serial_number VARCHAR(255), 
    primary key (id)
)

alter table orders 
    add constraint ordersFK0 foreign key (customer_id) references customers
alter table line_items
    add constraint line_itemsFK0 foreign key (product_id) references products
alter table line_items
    add constraint line_itemsFK1 foreign key (order_id) references orders</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-miscellaneous"></a>25.4.&nbsp;Miscellaneous example mappings</h2></div></div><div></div></div><p>
            These examples have been elaborated from the Hibernate test suite. You will find many other
            useful example mappings in NHibernate own test suite by searching in the test folder of the
            NHibernate sources.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-miscellaneous-typed121"></a>25.4.1.&nbsp;"Typed" one-to-one association</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Name"/&gt;
    &lt;one-to-one name="Address" cascade="all"&gt;
        &lt;formula&gt;Name&lt;/formula&gt;
        &lt;formula&gt;'HOME'&lt;/formula&gt;
    &lt;/one-to-one&gt;
    &lt;one-to-one name="MailingAddress" cascade="all"&gt;
        &lt;formula&gt;Name&lt;/formula&gt;
        &lt;formula&gt;'MAILING'&lt;/formula&gt;
    &lt;/one-to-one&gt;
&lt;/class&gt;

&lt;class name="Address" batch-size="2"
        check="addressType in ('MAILING', 'HOME', 'BUSINESS')"&gt;
    &lt;composite-id&gt;
        &lt;key-many-to-one name="Person" column="personName"/&gt;
        &lt;key-property name="Type" column="addressType"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="Street" type="text"/&gt;
    &lt;property name="State"/&gt;
    &lt;property name="Zip"/&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-miscellaneous-compositekey"></a>25.4.2.&nbsp;Composite key example</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Customer"&gt;
    &lt;id name="CustomerId" length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;

    &lt;property name="Name" not-null="true" length="100"/&gt;
    &lt;property name="Address" not-null="true" length="200"/&gt;

    &lt;list name="Orders" inverse="true" cascade="save-update"&gt;
        &lt;key column="CustomerId"/&gt;
        &lt;list-index column="OrderNumber"/&gt;
        &lt;one-to-many class="Order"/&gt;
    &lt;/list&gt;
&lt;/class&gt;

&lt;class name="Order" table="CustomerOrder"&gt;
    &lt;synchronize table="LineItem"/&gt;
    &lt;synchronize table="Product"/&gt;

    &lt;composite-id name="Id" class="Order+Id"&gt;
        &lt;key-property name="CustomerId" length="10"/&gt;
        &lt;key-property name="OrderNumber"/&gt;
    &lt;/composite-id&gt;

    &lt;property name="OrderDate" type="date" not-null="true"/&gt;

    &lt;property name="Total"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity * p.price)
            from LineItem li, Product p
            where li.productId = p.productId
                and li.customerId = customerId
                and li.orderNumber = orderNumber )
        &lt;/formula&gt;
    &lt;/property&gt;

    &lt;many-to-one name="Customer"
            column="CustomerId"
            insert="false"
            update="false"
            not-null="true"/&gt;

    &lt;bag name="LineItems"
            fetch="join"
            inverse="true"
            cascade="save-update"&gt;
        &lt;key&gt;
            &lt;column name="CustomerId"/&gt;
            &lt;column name="OrderNumber"/&gt;
        &lt;/key&gt;
        &lt;one-to-many class="LineItem"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="LineItem"&gt;
    &lt;composite-id name="id" class="LineItem+Id"&gt;
        &lt;key-property name="CustomerId" length="10"/&gt;
        &lt;key-property name="OrderNumber"/&gt;
        &lt;key-property name="ProductId" length="10"/&gt;
    &lt;/composite-id&gt;

    &lt;property name="Quantity"/&gt;

    &lt;many-to-one name="Order" insert="false" update="false" not-null="true"&gt;
        &lt;column name="CustomerId"/&gt;
        &lt;column name="OrderNumber"/&gt;
    &lt;/many-to-one&gt;

    &lt;many-to-one name="Product"
            insert="false"
            update="false"
            not-null="true"
            column="ProductId"/&gt;
&lt;/class&gt;

&lt;class name="Product"&gt;
    &lt;synchronize table="LineItem"/&gt;

    &lt;id name="ProductId" length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;

    &lt;property name="Description" not-null="true" length="200"/&gt;
    &lt;property name="Price" length="3"/&gt;
    &lt;property name="NumberAvailable"/&gt;

    &lt;property name="NumberOrdered"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity)
            from LineItem li
            where li.productId = productId )
        &lt;/formula&gt;
    &lt;/property&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-miscellaneous-m2mcomposite"></a>25.4.3.&nbsp;Many-to-many with shared composite key attribute</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="User" table="`User`"&gt;
    &lt;composite-id&gt;
        &lt;key-property name="Name"/&gt;
        &lt;key-property name="Org"/&gt;
    &lt;/composite-id&gt;
    &lt;set name="Groups" table="UserGroup"&gt;
        &lt;key&gt;
            &lt;column name="UserName"/&gt;
            &lt;column name="Org"/&gt;
        &lt;/key&gt;
        &lt;many-to-many class="Group"&gt;
            &lt;column name="GroupName"/&gt;
            &lt;formula&gt;Org&lt;/formula&gt;
        &lt;/many-to-many&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Group" table="`Group`"&gt;
    &lt;composite-id&gt;
        &lt;key-property name="Name"/&gt;
        &lt;key-property name="Org"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="Description"/&gt;
    &lt;set name="Users" table="UserGroup" inverse="true"&gt;
        &lt;key&gt;
            &lt;column name="GroupName"/&gt;
            &lt;column name="Org"/&gt;
        &lt;/key&gt;
        &lt;many-to-many class="User"&gt;
            &lt;column name="UserName"/&gt;
            &lt;formula&gt;Org&lt;/formula&gt;
        &lt;/many-to-many&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
                This case requires mixing column and formula under the <tt class="literal">&lt;many-to-many&gt;</tt>
                element, which is supported only since NHibernate 5.2.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-miscellaneous-contentdiscriminator"></a>25.4.4.&nbsp;Content based discrimination</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Person" discriminator-value="P"&gt;
    &lt;id name="Id" column="person_id"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;

    &lt;discriminator type="character"&gt;
        &lt;formula&gt;
            case
                when Title is not null then 'E'
                when Salesperson is not null then 'C'
                else 'P'
            end
        &lt;/formula&gt;
    &lt;/discriminator&gt;

    &lt;property name="Name" not-null="true" length="80"/&gt;
    &lt;property name="Sex" not-null="true" update="false"/&gt;

    &lt;component name="Address"&gt;
        &lt;property name="Address"/&gt;
        &lt;property name="Zip"/&gt;
        &lt;property name="Country"/&gt;
    &lt;/component&gt;

    &lt;subclass name="Employee" discriminator-value="E"&gt;
        &lt;property name="Title" length="20"/&gt;
        &lt;property name="Salary"/&gt;
        &lt;many-to-one name="Manager"/&gt;
    &lt;/subclass&gt;

    &lt;subclass name="Customer" discriminator-value="C"&gt;
        &lt;property name="Comments"/&gt;
        &lt;many-to-one name="Salesperson"/&gt;
    &lt;/subclass&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="example-mappings-miscellaneous-propertyref"></a>25.4.5.&nbsp;Associations on alternate keys</h3></div></div><div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;

    &lt;property name="Name" length="100"/&gt;

    &lt;one-to-one name="Address"
        property-ref="Person"
        cascade="all"
        fetch="join"/&gt;

    &lt;set name="accounts" inverse="true"&gt;
        &lt;key column="UserId" property-ref="User"/&gt;
        &lt;one-to-many class="Account"/&gt;
    &lt;/set&gt;

    &lt;property name="UserId" length="8"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="Id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;

    &lt;property name="Address" length="300"/&gt;
    &lt;property name="Zip" length="5"/&gt;
    &lt;property name="Country" length="25"/&gt;
    &lt;many-to-one name="Person" unique="true" not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Account"&gt;
    &lt;id name="AccountId" length="32"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;

    &lt;many-to-one name="User"
        column="UserId"
        property-ref="UserId"/&gt;

    &lt;property name="Type" not-null="true"/&gt;
&lt;/class&gt;</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="best-practices"></a>Chapter&nbsp;26.&nbsp;Best Practices</h2></div></div><div></div></div><div class="variablelist"><dl><dt><span class="term">Write fine-grained classes and map them using <tt class="literal">&lt;component&gt;</tt>.</span></dt><dd><p>
                    Use an <tt class="literal">Address</tt> class to encapsulate <tt class="literal">street</tt>,
                    <tt class="literal">suburb</tt>, <tt class="literal">state</tt>, <tt class="literal">postcode</tt>.
                    This encourages code reuse and simplifies refactoring.
                </p></dd><dt><span class="term">Declare identifier properties on persistent classes.</span></dt><dd><p>
                    NHibernate makes identifier properties optional. There are all sorts of reasons why
                    you should use them. We recommend that identifiers be 'synthetic' (generated, with
                    no business meaning) and of a primitive type. For maximum flexibility, use
                    <tt class="literal">Int64</tt> or <tt class="literal">String</tt>.
                </p></dd><dt><span class="term">Place each class mapping in its own file.</span></dt><dd><p>
                     Don't use a single monolithic mapping document. Map <tt class="literal">Eg.Foo</tt> in 
                     the file <tt class="literal">Eg/Foo.hbm.xml</tt>. This makes particularly good sense in 
                     a team environment.
                </p></dd><dt><span class="term">Embed mappings in assemblies.</span></dt><dd><p>
                    Place mapping files along with the classes they map and declare them as
                    <tt class="literal">Embedded Resource</tt>s in Visual Studio.
                </p></dd><dt><span class="term">Consider externalising query strings.</span></dt><dd><p>
                    This is a good practice if your queries call non-ANSI-standard SQL functions. 
                    Externalising the query strings to mapping files will make the application more portable.
                </p></dd><dt><span class="term">Use parameters.</span></dt><dd><p>
                     As in ADO.NET, always replace non-constant values by "?". Never use string manipulation to 
                     bind a non-constant value in a query! Even better, consider using named parameters in
                     queries.
                </p></dd><dt><span class="term">Don't manage your own ADO.NET connections.</span></dt><dd><p>
                    NHibernate lets the application manage ADO.NET connections. This approach should be considered 
                    a last-resort. If you can't use the built-in connections providers, consider providing your 
                    own implementation of <tt class="literal">NHibernate.Connection.IConnectionProvider</tt>.
                </p></dd><dt><span class="term">Consider using a custom type.</span></dt><dd><p>
                    Suppose you have a type, say from some library, that needs to be persisted but doesn't 
                    provide the accessors needed to map it as a component. You should consider implementing
                    <tt class="literal">NHibernate.UserTypes.IUserType</tt>. This approach frees the application
                    code from implementing transformations to / from an NHibernate type.
                </p></dd><dt><span class="term">Use hand-coded ADO.NET in bottlenecks.</span></dt><dd><p>
                    In performance-critical areas of the system, some kinds of operations (eg. mass update /
                    delete) might benefit from direct ADO.NET. But please, wait until you <span class="emphasis"><em>know</em></span> 
                    something is a bottleneck. And don't assume that direct ADO.NET is necessarily faster. If need to 
                    use direct ADO.NET, it might be worth opening a NHibernate <tt class="literal">ISession</tt> and using
                    that SQL connection. That way you can still use the same transaction strategy and underlying
                    connection provider.
                </p></dd><dt><span class="term">Understand <tt class="literal">ISession</tt> flushing.</span></dt><dd><p>
                    From time to time the ISession synchronizes its persistent state with the database. Performance will
                    be affected if this process occurs too often. You may sometimes minimize unnecessary flushing by 
                    disabling automatic flushing or even by changing the order of queries and other operations within a 
                    particular transaction.      
                </p></dd><dt><span class="term">In a three tiered architecture, consider using <tt class="literal">SaveOrUpdate()</tt>.</span></dt><dd><p>
                    When using a distributed architecture, you could pass persistent objects loaded in
                    the middle tier to and from the user interface tier. Use a new session to service each request. 
                    Use <tt class="literal">ISession.Update()</tt> or <tt class="literal">ISession.SaveOrUpdate()</tt> to update the 
                    persistent state of an object.
                </p></dd><dt><span class="term">In a two tiered architecture, consider using session disconnection.</span></dt><dd><p>
                    Database Transactions have to be as short as possible for best scalability. However, it is often
                    necessary to implement long running Application Transactions, a single unit-of-work from the
                    point of view of a user. This Application Transaction might span several client requests and
                    response cycles. Either use Detached Objects or, in two tiered architectures, simply disconnect
                    the NHibernate Session from the ADO.NET connection and reconnect it for each subsequent request.
                    Never use a single Session for more than one Application Transaction use-case, otherwise, you
                    will run into stale data.
                </p></dd><dt><span class="term">Don't treat exceptions as recoverable.</span></dt><dd><p>
                    This is more of a necessary practice than a "best" practice. When an exception occurs, roll back
                    the <tt class="literal">ITransaction</tt> and close the <tt class="literal">ISession</tt>. If you don't,
                    NHibernate can't guarantee that in-memory state accurately represents persistent state.
                    As a special case of this, do not use <tt class="literal">ISession.Load()</tt> to determine if an
                    instance with the given identifier exists on the database; use <tt class="literal">Get()</tt>
                    or a query instead.
                </p></dd><dt><span class="term">Prefer lazy fetching for associations.</span></dt><dd><p><a name="best-practices-p14"></a>
                    Use eager (outer-join) fetching sparingly. Use proxies and/or lazy collections for most associations
                    to classes that are not cached in the second-level cache. For associations to cached classes, where
                    there is a high probability of a cache hit, explicitly disable eager fetching using 
                    <tt class="literal">fetch="select"</tt>. When an outer-join fetch is appropriate to a particular use
                    case, use a query with a <tt class="literal">left join fetch</tt>.
                </p></dd><dt><span class="term">Consider abstracting your business logic from NHibernate.</span></dt><dd><p>
                    Hide (NHibernate) data-access code behind an interface. Combine the <span class="emphasis"><em>DAO</em></span> and 
                    <span class="emphasis"><em>Thread Local Session</em></span> patterns. You can even have some classes persisted by
                    hand-coded ADO.NET, associated to NHibernate via an <tt class="literal">IUserType</tt>. (This advice is 
                    intended for "sufficiently large" applications; it is not appropriate for an application with
                    five tables!)
                </p></dd><dt><span class="term">Implement <tt class="literal">Equals()</tt> and <tt class="literal">GetHashCode()</tt> using a unique business key.</span></dt><dd><p>
                    If you compare objects outside of the ISession scope, you have to implement <tt class="literal">Equals()</tt>
                    and <tt class="literal">GetHashCode()</tt>. Inside the ISession scope, object identity is guaranteed. If
                    you implement these methods, never ever use the database identifier! A transient object doesn't have
                    an identifier value and NHibernate would assign a value when the object is saved. If the object
                    is in an ISet while being saved, the hash code changes, breaking the contract. To implement
                    <tt class="literal">Equals()</tt> and <tt class="literal">GetHashCode()</tt>, use a unique business key, that is,
                    compare a unique combination of class properties. Remember that this key has to be stable and unique
                    only while the object is in an ISet, not for the whole lifetime (not as stable as a database primary
                    key). Never use collections in the <tt class="literal">Equals()</tt> comparison (lazy loading) and be careful
                    with other associated classes that might be proxied.
                </p></dd><dt><span class="term">Don't use exotic association mappings.</span></dt><dd><p>
                    Good use-cases for a real many-to-many associations are rare. Most of the time you need
                    additional information stored in the "link table". In this case, it is much better to
                    use two one-to-many associations to an intermediate link class. In fact, we think that
                    most associations are one-to-many and many-to-one, you should be careful when using any
                    other association style and ask yourself if it is really necessary.
                </p></dd></dl></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="part-contrib"></a>NHibernateContrib Documentation</h1></div></div><div></div></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="contrib-preface"></a>Preface</h2></div></div><div></div></div><p>The NHibernateContrib is various programs contributed to NHibernate by members of the NHibernate Team or by the end users. The projects in here are not considered core pieces of NHibernate but they extend it in a useful way.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="caches"></a>Chapter&nbsp;27.&nbsp;NHibernate.Caches</h2></div></div><div></div></div><div class="abstract"><a name="NHibernate.Caches-abstract"></a><p class="title"><b>What is NHibernate.Caches?</b></p><p><b>NHibernate.Caches namespace contains several second-level cache providers for NHibernate.&nbsp;</b>
				A cache is a place where entities are kept after being loaded from the database; once cached, they can be
				retrieved without going to the database. This means that they are faster to (re)load.
			</p><p>
			An NHibernate session has an internal (first-level) cache where it keeps its entities. There is no sharing
			between these caches - a first-level cache belongs to a given session and is destroyed with it. NHibernate
			provides a <span class="emphasis"><em>second-level cache</em></span> system; it works at the session factory level.
			A second-level cache is shared by all sessions created by the same session factory.
		</p><p>
			An important point is that the second-level cache <span class="emphasis"><em>does not</em></span> cache instances of the object
			type being cached; instead it caches the individual values of the properties of that object. This provides two
			benefits. One, NHibernate doesn't have to worry that your client code will manipulate the objects in a way that
			will disrupt the cache. Two, the relationships and associations do not become stale, and are easy to keep
			up-to-date because they are simply identifiers. The cache is not a tree of objects but rather a map of arrays.
		</p><p>
			With the <span class="emphasis"><em>session-per-request</em></span> model, a high number of sessions can concurrently access
			the same entity without hitting the database each time; hence the performance gain.
		</p><p>
			Depending on the chosen cache provider, the second level cache may be actually shared between different session
			factories. If you need to avoid this for some session factories, configure each of them with a different
			<tt class="literal">cache.region_prefix</tt>. See <a href="#configuration-optional" title="3.6.&nbsp;Optional configuration properties">Section&nbsp;3.6, &#8220;Optional configuration properties&#8221;</a>.
		</p><p>
			Several cache providers have been contributed by NHibernate users:
			</p><div class="variablelist"><dl><dt><span class="term"><tt class="classname">NHibernate.Caches.Prevalence</tt></span></dt><dd><p>
							Uses <tt class="classname">Bamboo.Prevalence</tt> as the cache provider. Open the
							file <tt class="filename">Bamboo.Prevalence.license.txt</tt> for more information about its license;
							you can also visit its <a href="http://bbooprevalence.sourceforge.net/" target="_top">website</a>. This
							provider is available for the .Net Framework only. Also see <a href="#NHibernate.Caches.Prevalence" title="27.3.&nbsp;Prevalence Cache Configuration">Section&nbsp;27.3, &#8220;Prevalence Cache Configuration&#8221;</a>.
						</p></dd><dt><span class="term"><tt class="classname">NHibernate.Caches.SysCache</tt></span></dt><dd><p>
							Uses <tt class="classname">System.Web.Caching.Cache</tt> as the cache provider. This means that you can
							rely on ASP.NET caching feature to understand how it works. For more information, read (on the MSDN):
							<a href="https://msdn.microsoft.com/en-us/library/6hbbsfk6.aspx" target="_top">Caching Application Data</a>.
							This provider is available for the .Net Framework only. Also see <a href="#NHibernate.Caches.SysCache" title="27.4.&nbsp;SysCache Configuration">Section&nbsp;27.4, &#8220;SysCache Configuration&#8221;</a>.
						</p></dd><dt><span class="term"><tt class="classname">NHibernate.Caches.SysCache2</tt></span></dt><dd><p>
							Similar to <tt class="classname">NHibernate.Caches.SysCache</tt>, uses ASP.NET cache. This provider also supports
							SQL dependency-based expiration, meaning that it is possible to configure certain cache regions to automatically
							expire when the relevant data in the database changes.
						</p><p>
							SysCache2 requires Microsoft SQL Server 2000 or higher. This provider is available for the .Net Framework only.
						</p><p>
							See <a href="#NHibernate.Caches.SysCache2" title="27.5.&nbsp;SysCache2 Configuration">Section&nbsp;27.5, &#8220;SysCache2 Configuration&#8221;</a>.
						</p></dd><dt><span class="term"><tt class="classname">NHibernate.Caches.EnyimMemcached</tt></span></dt><dd><p>
							Uses <tt class="literal">Memcached</tt>. See <a href="https://memcached.org/" target="_top">memcached homepage</a>
							for more information on Memcached. This provider is available for the .Net Framework only. Also see
							<a href="#NHibernate.Caches.EnyimMemcached" title="27.6.&nbsp;EnyimMemcached Configuration">Section&nbsp;27.6, &#8220;EnyimMemcached Configuration&#8221;</a>.
						</p></dd><dt><span class="term"><tt class="classname">NCache provider for NHibernate</tt></span></dt><dd><p>
							Uses <tt class="literal">NCache</tt>. NCache is a commercial distributed caching system with a provider for NHibernate. 
							The NCache Express version is free for use, see 
							<a href="http://www.alachisoft.com/ncache/" target="_top">NCache Express homepage</a>
							for more information.
						</p></dd><dt><span class="term"><tt class="classname">NHibernate.Caches.RtMemoryCache</tt></span></dt><dd><p>
							Uses <tt class="classname">System.Runtime.Caching.MemoryCache.Default</tt> as the cache provider. This provider
							is available as a .Net Standard NuGet package. See <a href="#NHibernate.Caches.RtMemoryCache" title="27.7.&nbsp;RtMemoryCache Configuration">Section&nbsp;27.7, &#8220;RtMemoryCache Configuration&#8221;</a>.
						</p></dd><dt><span class="term"><tt class="classname">NHibernate.Caches.StackExchangeRedis</tt></span></dt><dd><p>
							Uses <tt class="classname">StackExchange.Redis</tt>. This provider is available as a .Net Standard
							NuGet package. It can batch together puts and reads, reducing incurred IOs.
							See <a href="#NHibernate.Caches.StackExchangeRedis" title="27.8.&nbsp;NHibernate.Caches.StackExchangeRedis Configuration">Section&nbsp;27.8, &#8220;NHibernate.Caches.StackExchangeRedis Configuration&#8221;</a>.
						</p></dd><dt><span class="term"><tt class="classname">NHibernate.Caches.CoreMemoryCache</tt></span></dt><dd><p>
							Uses <tt class="classname">Microsoft.Extensions.Caching.Memory.MemoryCache</tt> as the cache provider. This provider
							is available as a .Net Standard NuGet package. See <a href="#NHibernate.Caches.CoreMemoryCache" title="27.9.&nbsp;CoreMemoryCache Configuration">Section&nbsp;27.9, &#8220;CoreMemoryCache Configuration&#8221;</a>.
						</p></dd><dt><span class="term"><tt class="classname">NHibernate.Caches.CoreDistributedCache</tt></span></dt><dd><p>
							Uses <tt class="classname">Microsoft.Extensions.Caching.Abstractions.IDistributedCache</tt> implementations as the cache
							provider. The implementation has to be provided through an <tt class="literal">IDistributedCacheFactory</tt>.
							Distributed cache factories for <tt class="literal">Memcached</tt>, <tt class="literal">Redis</tt>, <tt class="literal">SqlServer</tt>
							and <tt class="literal">Memory</tt> caches are available through their own package, prefixed by
							<tt class="literal">NHibernate.Caches.CoreDistributedCache.</tt>.
						</p><p>
							This provider is available as a .Net Standard NuGet package. See <a href="#NHibernate.Caches.CoreDistributedCache" title="27.10.&nbsp;CoreDistributedCache Configuration">Section&nbsp;27.10, &#8220;CoreDistributedCache Configuration&#8221;</a>.
						</p></dd></dl></div><p>
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NHibernate.Caches-howto"></a>27.1.&nbsp;How to use a cache?</h2></div></div><div></div></div><p>
			Here are the steps to follow to enable the second-level cache in NHibernate:

			</p><div class="itemizedlist"><ul type="disc"><li><p>
						Choose the cache provider you want to use and copy its assembly in your assemblies directory.
						(For example, <tt class="filename">NHibernate.Caches.Prevalence.dll</tt> or
						<tt class="filename">NHibernate.Caches.SysCache.dll</tt>.)
					</p></li><li><p>
						To tell NHibernate which cache provider to use, add in your NHibernate configuration file
						(can be <tt class="filename">YourAssembly.exe.config</tt> or <tt class="filename">web.config</tt> or a
						<tt class="filename">.cfg.xml</tt> file):
						</p><pre class="programlisting">
&lt;property name="cache.provider_class"&gt;<tt class="literal">XXX</tt>&lt;/property&gt;<a name="hibernate.cache.provider_class-co" href="#hibernate.cache.provider_class">(1)</a>
&lt;property name="cache.default_expiration"&gt;<tt class="literal">120</tt>&lt;/property&gt;<a name="nhcaches-expiration-co" href="#nhcaches-expiration">(2)</a>
&lt;property name="cache.use_sliding_expiration"&gt;<tt class="literal">true</tt>&lt;/property&gt;<a name="nhcaches-sliding-co" href="#nhcaches-sliding">(3)</a>
						</pre><p>
						</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><a name="hibernate.cache.provider_class"></a><a href="#hibernate.cache.provider_class-co">(1)</a> </td><td valign="top" align="left"><p>
									"<tt class="literal">XXX</tt>" is the assembly-qualified class name of a class
									implementing <tt class="classname">ICacheProvider</tt>, eg.
									"<tt class="classname">NHibernate.Caches.SysCache.SysCacheProvider,
									NHibernate.Caches.SysCache</tt>".
								</p></td></tr><tr><td width="5%" valign="top" align="left"><a name="nhcaches-expiration"></a><a href="#nhcaches-expiration-co">(2)</a> </td><td valign="top" align="left"><p>
									The <tt class="literal">expiration</tt> value is the number of seconds you wish
									to cache each entry (here two minutes). Not all providers support this setting, it may
									be ignored. Check their respective documentation.
								</p></td></tr><tr><td width="5%" valign="top" align="left"><a name="nhcaches-sliding"></a><a href="#nhcaches-sliding-co">(3)</a> </td><td valign="top" align="left"><p>
									The <tt class="literal">use_sliding_expiration</tt> value is whether you wish to use a
									sliding expiration or not. Defaults to <tt class="literal">false</tt>.
									Not all providers support this setting, it may be ignored. Check their respective documentation.
								</p></td></tr></table></div><p>
					</p></li><li><p>
						Add <tt class="literal">&lt;cache usage="read-write|nonstrict-read-write|read-only"/&gt;</tt> (just
						after <tt class="literal">&lt;class&gt;</tt>) in the mapping of the entities you want to cache. It
						also works for collections (bag, list, map, set, ...).
					</p></li></ul></div><p>
		</p><p><b>Be careful.&nbsp;</b>
				</p><div class="itemizedlist"><ul type="disc"><li><p>
							Most caches are never aware of changes made to the persistent store by another process (though they may be
							configured to regularly expire cached data). As the caches are created at the session factory level,
							they are destroyed with the SessionFactory instance; so you must keep them alive as long as you need
							them.
						</p></li><li><p>
							The second level cache requires the use of transactions, be it through transaction scopes or NHibernate
							transactions. Interacting with the data store without an explicit transaction is discouraged, and will
							not allow the second level cache to work as intended.
						</p></li><li><p>
							To avoid issues with composite ids and some cache providers, <tt class="literal">ToString()</tt> needs to
							be overridden on composite id classes. It should yield an unique string representing the id. If the
							composite id is mapped as a component, overriding the component <tt class="literal">ToString()</tt>
							is enough. See <a href="#components-compositeid" title="8.4.&nbsp;Components as composite identifiers">Section&nbsp;8.4, &#8220;Components as composite identifiers&#8221;</a>.
						</p></li></ul></div><p>
			</p><p>
			See also <a href="#performance-cache" title="21.2.&nbsp;The Second Level Cache">Section&nbsp;21.2, &#8220;The Second Level Cache&#8221;</a>.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NHibernate.Caches.ConfigurationProvider"></a>27.2.&nbsp;Using a custom configuration provider</h2></div></div><div></div></div><p>
			Most caches have their own configuration section. By default, the cache attempts to read its configuration section
			through the .Net <tt class="literal">ConfigurationManager</tt>. Some environments do not support it, especially when
			running under .Net Core. The .Net Core compatible caches provide a way to set a custom configuration provider, through
			their <tt class="literal">NHibernate.Caches. cache specific namespace .ConfigurationProvider</tt> class.
		</p><p>
			To disable the configuration provider, in case you configure the cache entirely programmatically,
			set its <tt class="literal">ConfigurationProvider.Current</tt> property to <tt class="literal">null</tt>.
		</p><pre class="programlisting">ConfigurationProvider.Current = null;</pre><p>
			To provide directly the <tt class="literal">System.Configuration.Configuration</tt> instance to use, call
			the cache <tt class="literal">ConfigurationProvider.SetConfiguration</tt> method.
		</p><pre class="programlisting">ConfigurationProvider.SetConfiguration(yourConfig);</pre><p>
			You may also derive a custom provider from the <tt class="literal">ConfigurationProvider</tt> of the cache,
			implements its abstract method <tt class="literal">GetConfiguration</tt>, and assign an instance of your
			custom provider to the cache <tt class="literal">ConfigurationProvider.Current</tt> property.
		</p><p>
			Changes of the <tt class="literal">ConfigurationProvider.Current</tt> property value are to be done very
			early in the application lifecycle, before building any session factory using the cache provider or
			before any other call on the cache API. Otherwise they will not be taken into account.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NHibernate.Caches.Prevalence"></a>27.3.&nbsp;Prevalence Cache Configuration</h2></div></div><div></div></div><p>
			There is only one configurable parameter: <tt class="literal">prevalenceBase</tt>. This is the directory on the
			file system where the Prevalence engine will save data. It can be relative to the current directory or a
			full path. If the directory doesn't exist, it will be created.
		</p><p>
			The <tt class="literal">prevalenceBase</tt> setting can only be set programmatically through the NHibernate
			configuration object, by example with <tt class="literal">Configuration.SetProperty</tt>.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NHibernate.Caches.SysCache"></a>27.4.&nbsp;SysCache Configuration</h2></div></div><div></div></div><p>
			SysCache relies on <tt class="classname">System.Web.Caching.Cache</tt> for the underlying implementation.
			This is a .Net Framework only library, since <tt class="literal">System.Web.Caching</tt> is available neither
			in the .Net Standard nor in .Net Core.
		</p><p>
			The following NHibernate configuration settings are available:
		</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">cache.default_expiration</tt></span></dt><dd>
					Number of seconds to wait before expiring each item.
					Defaults to <tt class="literal">300</tt>. It can also be set programmatically on the NHibernate
					configuration object under the name <tt class="literal">expiration</tt>, which then takes precedence
					over <tt class="literal">cache.default_expiration</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.use_sliding_expiration</tt></span></dt><dd>
					Should the expiration be sliding? A sliding expiration is reinitialized at each get.
					Defaults to <tt class="literal">false</tt>.
				</dd><dt><span class="term"><tt class="literal">priority</tt></span></dt><dd>
					A numeric cost of expiring each item, where 1 is a low cost, 5 is the highest, and 3 is normal.
					Only values 1 through 6 are valid. 6 is a special value corresponding to
					<tt class="literal">NotRemovable</tt>. This setting can only be set programmatically through on the
					NHibernate configuration object, by example with <tt class="literal">Configuration.SetProperty</tt>.
				</dd></dl></div><p>
			SysCache has a config file section handler to allow configuring different expirations and priorities for
			different regions. Here is an example:
		</p><div class="example"><a name="d0e19463"></a><p class="title"><b>Example&nbsp;27.1.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
  &lt;configSections&gt;
    &lt;section name="syscache"
      type="NHibernate.Caches.SysCache.SysCacheSectionHandler,NHibernate.Caches.SysCache" /&gt;
  &lt;/configSections&gt;

  &lt;syscache&gt;
    &lt;cache region="foo" expiration="500" priority="4" /&gt;
    &lt;cache region="bar" expiration="300" priority="3" sliding="true" /&gt;
  &lt;/syscache&gt;
&lt;/configuration&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NHibernate.Caches.SysCache2"></a>27.5.&nbsp;SysCache2 Configuration</h2></div></div><div></div></div><p>
			SysCache2 uses <tt class="literal">System.Web.Caching</tt> like SysCache, but can use <tt class="literal">SqlCacheDependencies</tt>
			to invalidate cache regions when data in an underlying SQL Server
			table or query changes. Query dependencies are only available for SQL Server 2005 or higher. To use the cache
			provider, the application must be setup and configured to support SQL notifications as described in the
			MSDN documentation.
		</p><p>
			This is a .Net Framework only library, since <tt class="literal">System.Web.Caching</tt> is available neither
			in the .Net Standard nor in .Net Core.
		</p><p>
			The following NHibernate configuration settings are available:
		</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">cache.default_expiration</tt></span></dt><dd>
					Number of seconds to wait before expiring each item.
					Defaults to <tt class="literal">300</tt>. It can also be set programmatically on the NHibernate
					configuration object under the name <tt class="literal">expiration</tt>, which then takes precedence
					over <tt class="literal">cache.default_expiration</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.use_sliding_expiration</tt></span></dt><dd>
					Should the expiration be sliding? A sliding expiration is reinitialized at each get.
					Defaults to <tt class="literal">false</tt>.
				</dd></dl></div><p>
			To configure cache regions with SqlCacheDependencies a <tt class="literal">syscache2</tt> config section must be
			defined in the application's configuration file. See the sample below.
		</p><div class="example"><a name="d0e19514"></a><p class="title"><b>Example&nbsp;27.2.&nbsp;</b></p><pre class="programlisting">
&lt;configSections&gt;
  &lt;section name="syscache2"
    type="NHibernate.Caches.SysCache2.SysCacheSection, NHibernate.Caches.SysCache2"/&gt;
&lt;/configSections&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="NHibernate.Caches.SysCache2-Table"></a>27.5.1.&nbsp;Table-based Dependency</h3></div></div><div></div></div><p>
				A table-based dependency will monitor the data in a database table for changes. Table-based
				dependencies are generally used for a SQL Server 2000 database but will work with SQL Server 2005 or superior as
				well. Before you can use SQL Server cache invalidation with table based dependencies, you need to
				enable notifications for the database. This task is performed with the <span><b class="command">aspnet_regsql</b></span>
				command. With table-based notifications, the application will poll the database for changes at a
				predefined interval. A cache region will not be invalidated immediately when data in the table changes.
				The cache will be invalidated the next time the application polls the database for changes.
			</p><p>
				To configure the data in a cache region to be invalidated when data in an underlying table is changed,
				a cache region must be configured in the application's configuration file. See the sample below.
			</p><div class="example"><a name="d0e19527"></a><p class="title"><b>Example&nbsp;27.3.&nbsp;</b></p><pre class="programlisting">&lt;syscache2&gt;
  &lt;cacheRegion name="Product"&gt;
    &lt;dependencies&gt;
      &lt;tables&gt;
        &lt;add name="price"
          databaseEntryName="Default"
          tableName="VideoTitle" /&gt;
      &lt;/tables&gt;
    &lt;/dependencies&gt;
  &lt;/cacheRegion&gt;
&lt;/syscache2&gt;</pre></div></div><div class="variablelist"><p class="title"><b>Table-based Dependency Configuration Properties</b></p><dl><dt><span class="term"><tt class="literal">name</tt></span></dt><dd>Unique name for the dependency</dd><dt><span class="term"><tt class="literal">tableName</tt></span></dt><dd>
					The name of the database table that the dependency is associated with. The table must be enabled
					for notification support with the <tt class="literal">AspNet_SqlCacheRegisterTableStoredProcedure</tt>.
				</dd><dt><span class="term"><tt class="literal">databaseEntryName</tt></span></dt><dd>
					The name of a database defined in the <tt class="literal">databases</tt> element for
					<tt class="literal">sqlCacheDependency</tt> for caching (ASP.NET Settings Schema) element of the
					application's <tt class="literal">Web.config</tt> file.
				</dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="NHibernate.Caches.SysCache2-Command"></a>27.5.2.&nbsp;Command-Based Dependencies</h3></div></div><div></div></div><p>
				A command-based dependency will use a SQL command to identify records to monitor for data changes.
				Command-based dependencies work only with SQL Server 2005.
			</p><p>
				Before you can use SQL Server cache invalidation with command-based dependencies, you need to enable
				the Service Broker for query notifications. The application must also start the listener for receiving
				change notifications from SQL Server. With command based notifications, SQL Server will notify the
				application when the data of a record returned in the results of a SQL query has changed. Note that a
				change will be indicated if the data in any of the columns of a record change, not just the columns
				returned by a query. The query is a way to limit the number of records monitored for changes, not the
				columns.  As soon as data in one of the records is modified, the data in the cache region will be
				invalidated immediately.
			</p><p>
				To configure the data in a cache region to be invalidated based on a SQL command, a cache region must
				be configured in the application's configuration file. See the samples below.
			</p><div class="example"><a name="d0e19572"></a><p class="title"><b>Example&nbsp;27.4.&nbsp;Stored Procedure</b></p><pre class="programlisting">&lt;cacheRegion name="Product" priority="High" &gt;
  &lt;dependencies&gt;
    &lt;commands&gt;
      &lt;add name="price"
        command="ActiveProductsStoredProcedure" 
        isStoredProcedure="true"/&gt;
    &lt;/commands&gt;
  &lt;/dependencies&gt;
&lt;/cacheRegion&gt;</pre></div><div class="example"><a name="d0e19577"></a><p class="title"><b>Example&nbsp;27.5.&nbsp;SELECT Statement</b></p><pre class="programlisting">&lt;cacheRegion name="Product" priority="High"&gt;
  &lt;dependencies&gt;
    &lt;commands&gt;
      &lt;add name="price"
        command="Select VideoTitleId from dbo.VideoTitle where Active = 1"
        connectionName="default"
        connectionStringProviderType="NHibernate.Caches.SysCache2.ConfigConnectionStringProvider, NHibernate.Caches.SysCache2"/&gt;
    &lt;/commands&gt;
  &lt;/dependencies&gt;
&lt;/cacheRegion&gt;</pre></div><div class="variablelist"><p class="title"><b>Command Configuration Properties</b></p><dl><dt><span class="term"><tt class="literal">name</tt></span></dt><dd>Unique name for the dependency</dd><dt><span class="term"><tt class="literal">command</tt> (required)</span></dt><dd>SQL command that returns results which should be monitored for data changes</dd><dt><span class="term"><tt class="literal">isStoredProcedure</tt> (optional)</span></dt><dd>
						Indicates if command is a stored procedure. The default is <tt class="literal">false</tt>.
					</dd><dt><span class="term"><tt class="literal">connectionName</tt> (optional)</span></dt><dd>
						The name of the connection in the applications configuration file to use for registering the
						cache dependency for change notifications. If no value is supplied for <tt class="literal">connectionName
						</tt> or <tt class="literal">connectionStringProviderType</tt>, the connection properties from
						the NHibernate configuration will be used.
					</dd><dt><span class="term"><tt class="literal">connectionStringProviderType</tt> (optional)</span></dt><dd><tt class="classname">IConnectionStringProvider</tt> to use for retrieving the connection string to
						use for registering the cache dependency for change notifications.  If no value is supplied for
						<tt class="literal">connectionName</tt>, the unnamed connection supplied by the provider will be
						used.
					</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="NHibernate.Caches.SysCache2-Aggregate"></a>27.5.3.&nbsp;Aggregate Dependencies</h3></div></div><div></div></div><p>
				Multiple cache dependencies can be specified.  If any of the dependencies triggers a change
				notification, the data in the cache region will be invalidated.  See the samples below.
			</p><div class="example"><a name="d0e19638"></a><p class="title"><b>Example&nbsp;27.6.&nbsp;Multiple commands</b></p><pre class="programlisting">&lt;cacheRegion name="Product"&gt;
  &lt;dependencies&gt;
    &lt;commands&gt;
      &lt;add name="price"
        command="ActiveProductsStoredProcedure" 
        isStoredProcedure="true"/&gt;
      &lt;add name="quantity"
        command="Select quantityAvailable from dbo.VideoAvailability"/&gt;
    &lt;/commands&gt;
  &lt;/dependencies&gt;
&lt;/cacheRegion&gt;</pre></div><div class="example"><a name="d0e19643"></a><p class="title"><b>Example&nbsp;27.7.&nbsp;Mixed</b></p><pre class="programlisting">&lt;cacheRegion name="Product"&gt;
  &lt;dependencies&gt;
    &lt;commands&gt;
      &lt;add name="price"
        command="ActiveProductsStoredProcedure" 
        isStoredProcedure="true"/&gt;
    &lt;/commands&gt;
    &lt;tables&gt;
      &lt;add name="quantity"
        databaseEntryName="Default"
        tableName=" VideoAvailability" /&gt;
    &lt;/tables&gt;
  &lt;/dependencies&gt;
&lt;/cacheRegion&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="NHibernate.Caches.SysCache2-AdditionalSettings"></a>27.5.4.&nbsp;Additional Settings</h3></div></div><div></div></div><p>
				In addition to data dependencies for the cache regions, time based expiration policies can be specified
				for each item added to the cache.  Time based expiration policies will not invalidate the data
				dependencies for the whole cache region, but serve as a way to remove items from the cache after they
				have been in the cache for a specified amount of time.  See the samples below.
			</p><div class="example"><a name="d0e19653"></a><p class="title"><b>Example&nbsp;27.8.&nbsp;Relative Expiration</b></p><pre class="programlisting">&lt;cacheRegion name="Product" relativeExpiration="300" priority="High" useSlidingExpiration="true" /&gt;</pre></div><div class="example"><a name="d0e19658"></a><p class="title"><b>Example&nbsp;27.9.&nbsp;Time of Day Expiration</b></p><pre class="programlisting">&lt;cacheRegion name="Product" timeOfDayExpiration="2:00:00" priority="High" /&gt;</pre></div><div class="variablelist"><p class="title"><b>Additional Configuration Properties</b></p><dl><dt><span class="term"><tt class="literal">relativeExpiration</tt></span></dt><dd><p>
							Number of seconds that an individual item will exist in the cache before being removed.
							Defaults to <tt class="literal">300</tt> if neither <tt class="literal">relativeExpiration</tt> nor
							<tt class="literal">timeOfDayExpiration</tt> are defined, and if no expiration settings are
							defined in NHibernate configuration.
						</p></dd><dt><span class="term"><tt class="literal">useSlidingExpiration</tt></span></dt><dd><p>
							Should the expiration be sliding? A sliding expiration is reinitialized at each get.
							Defaults to <tt class="literal">false</tt> if not defined in NHibernate configuration.
						</p></dd><dt><span class="term"><tt class="literal">timeOfDayExpiration</tt></span></dt><dd><p>
							24 hour based time of day that an item will exist in the cache until. 12am is specified as
							00:00:00; 10pm is specified as 22:00:00. Only valid if relativeExpiration is not specified.
							Time of Day Expiration is useful for scenarios where items should be expired from the cache
							after a daily process completes. 
						</p></dd><dt><span class="term"><tt class="literal">priority</tt></span></dt><dd><tt class="classname">System.Web.Caching.CacheItemPriority</tt> that identifies the relative
						priority of items stored in the cache.
					</dd></dl></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NHibernate.Caches.EnyimMemcached"></a>27.6.&nbsp;EnyimMemcached Configuration</h2></div></div><div></div></div><p>
			Its configuration relies on the EnyimMemcached library own configuration, through its
			<tt class="literal">enyim.com/memcached</tt> configuration section. See
			<a href="https://github.com/enyim/EnyimMemcached" target="_top">project site</a>.
			This is a .Net Framework only library.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NHibernate.Caches.RtMemoryCache"></a>27.7.&nbsp;RtMemoryCache Configuration</h2></div></div><div></div></div><p>
			RtMemoryCache relies on <tt class="classname">System.Runtime.Caching.MemoryCache</tt> for the
			underlying implementation.
		</p><p>
			The following NHibernate configuration settings are available:
		</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">cache.default_expiration</tt></span></dt><dd>
					Number of seconds to wait before expiring each item.
					Defaults to <tt class="literal">300</tt>. It can also be set programmatically on the NHibernate
					configuration object under the name <tt class="literal">expiration</tt>, which then takes precedence
					over <tt class="literal">cache.default_expiration</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.use_sliding_expiration</tt></span></dt><dd>
					Should the expiration be sliding? A sliding expiration is reinitialized at each get.
					Defaults to <tt class="literal">false</tt>.
				</dd></dl></div><p>
			RtMemoryCache has a config file section handler to allow configuring different expirations for
			different regions. Here is an example:
		</p><div class="example"><a name="d0e19755"></a><p class="title"><b>Example&nbsp;27.10.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
  &lt;configSections&gt;
    &lt;section name="rtmemorycache"
      type="NHibernate.Caches.RtMemoryCache.RtMemoryCacheSectionHandler,NHibernate.Caches.RtMemoryCache" /&gt;
  &lt;/configSections&gt;

  &lt;rtmemorycache&gt;
    &lt;cache region="foo" expiration="500" /&gt;
    &lt;cache region="bar" expiration="300" sliding="true" /&gt;
  &lt;/rtmemorycache&gt;
&lt;/configuration&gt;</pre></div><p>
			The loading of this section can be customized with the
			<tt class="literal">NHibernate.Caches.RtMemoryCache.ConfigurationProvider</tt> class. See
			<a href="#NHibernate.Caches.ConfigurationProvider" title="27.2.&nbsp;Using a custom configuration provider">Section&nbsp;27.2, &#8220;Using a custom configuration provider&#8221;</a>.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NHibernate.Caches.StackExchangeRedis"></a>27.8.&nbsp;NHibernate.Caches.StackExchangeRedis Configuration</h2></div></div><div></div></div><p>
			NHibernate.Caches.StackExchangeRedis relies on <tt class="classname">StackExchange.Redis</tt> for the
			underlying implementation.
		</p><p>
			The following NHibernate configuration settings are available (also defined in
			<tt class="literal">NHibernate.Caches.StackExchangeRedis.RedisEnvironment</tt>):
		</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">cache.default_expiration</tt></span></dt><dd>
					Number of seconds to wait before expiring each item.
					Defaults to <tt class="literal">300</tt>. It can also be set programmatically on the NHibernate
					configuration object under the name <tt class="literal">expiration</tt>, which then takes precedence
					over <tt class="literal">cache.default_expiration</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.use_sliding_expiration</tt></span></dt><dd>
					Should the expiration be sliding? A sliding expiration is reinitialized at each get. Can be overriden for each region by using
					<tt class="literal">sliding</tt> attribute.
					Defaults to <tt class="literal">false</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.database</tt></span></dt><dd>
					The default Redis database index, that can be overriden for each region by using <tt class="literal">database</tt> attribute.
					Defaults to <tt class="literal">-1</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.strategy</tt></span></dt><dd>
					The assembly qualified name of the region strategy, that can be overriden for each region by using <tt class="literal">strategy</tt> attribute.
					<tt class="literal">NHibernate.Caches.StackExchangeRedis</tt> provides the following strategies:
				<div class="itemizedlist"><ul type="disc"><li><tt class="literal">NHibernate.Caches.StackExchangeRedis.DefaultRegionStrategy</tt><p>
						Uses a special key that contains the region current version number which is appended after the region prefix.
						Each time a clear operation is performed the version number is increased and an event is send to all clients
						so that they can update their local versions. Even if the event was not sent to all clients, each operation has a
						version check in order to prevent working with stale data. This strategy has additional settings:
						<dt><span class="term"><tt class="literal">cache.region_strategy.default.max_allowed_version</tt></span></dt><dd>
							The max allowed version number. When the max value is reached, the next value will be reset to zero.
							Defaults to <tt class="literal">10000</tt>.
							</dd>
						<dt><span class="term"><tt class="literal">cache.region_strategy.default.use_pubsub</tt></span></dt><dd>
							Whether to use Redis pub/sub mechanism in order to notify other cache instances when the clear operation was performed.
							Defaults to <tt class="literal">true</tt>.
							</dd>
						<dt><span class="term"><tt class="literal">cache.region_strategy.default.retry_times</tt></span></dt><dd>
							Total retry times for read and lock operations, when concurrent clear operations are performed.
							Defaults to <tt class="literal">1</tt>.
							</dd>
						</p></li><li><tt class="literal">NHibernate.Caches.StackExchangeRedis.FastRegionStrategy</tt><p>
						Uses very simple read/write operations but does not support <tt class="literal">ICache.Clear</tt> operation.
						</p></li><li><tt class="literal">NHibernate.Caches.StackExchangeRedis.TwoLayerCacheRegionStrategy</tt><p>
						Extends <tt class="literal">NHibernate.Caches.StackExchangeRedis.DefaultRegionStrategy</tt> and uses
						an additional local memory cache for faster readings. The local caches are invalidated by using Redis pub/sub mechanism.
						This strategy should be used only for regions that have few write operations and a high expiration time.
						This strategy inherits additional settings from <tt class="literal">DefaultRegionStrategy</tt> and also has its own settings:
						<dt><span class="term"><tt class="literal">cache.region_strategy.two_layer_cache.use_pipelining</tt></span></dt><dd>
							Whether to use <tt class="literal">StackExchange.Redis</tt> pipelining feature.
							Defaults to <tt class="literal">false</tt>.
							</dd>
						<dt><span class="term"><tt class="literal">cache.region_strategy.two_layer_cache.client_id</tt></span></dt><dd>
							The client id used for cache invalidation.
							Defaults to a random number.
							</dd>
						<dt><span class="term"><tt class="literal">cache.region_strategy.two_layer_cache.max_synchronization_time</tt></span></dt><dd>
							The max synchronization time between caches in seconds.
							Defaults to <tt class="literal">10</tt>.
							</dd>
						</p></li><li><tt class="literal">NHibernate.Caches.StackExchangeRedis.FastTwoLayerCacheRegionStrategy</tt><p>
						Extends <tt class="literal">NHibernate.Caches.StackExchangeRedis.FastRegionStrategy</tt> and uses
						an additional local memory cache for faster readings. The local caches are invalidated by using Redis pub/sub mechanism.
						This strategy does not support <tt class="literal">ICache.Clear</tt> operation and should be used only for regions that have
						few write operations and a high expiration time. This strategy has additional settings:
						<dt><span class="term"><tt class="literal">cache.region_strategy.fast_two_layer_cache.use_pipelining</tt></span></dt><dd>
							Whether to use <tt class="literal">StackExchange.Redis</tt> pipelining feature.
							Defaults to <tt class="literal">false</tt>.
							</dd>
						<dt><span class="term"><tt class="literal">cache.region_strategy.fast_two_layer_cache.client_id</tt></span></dt><dd>
							The client id used for cache invalidation.
							Defaults to a random number.
							</dd>
						<dt><span class="term"><tt class="literal">cache.region_strategy.fast_two_layer_cache.max_synchronization_time</tt></span></dt><dd>
							The max synchronization time between caches in seconds.
							Defaults to <tt class="literal">10</tt>.
							</dd>
						</p></li><li><tt class="literal">NHibernate.Caches.StackExchangeRedis.DistributedLocalCacheRegionStrategy</tt><p>
						Uses only a memory cache to store the values and uses Redis pub/sub mechanism to synchronize data between other local caches.
						The synchronization between caches is done by comparing the UTC <tt class="literal">DateTime.Ticks</tt>, which represent when the
						operation was performed. When two operations have the same <tt class="literal">DateTime.Ticks</tt>, then the client with the highest
						id wins. This strategy should be used only for regions that have few write operations and a high expiration time. It is recommended
						to use <tt class="literal">NHibernate.Caches.StackExchangeRedis.TwoLayerCacheRegionStrategy</tt>, when the instances where the strategy
						would run are often restarted/recycled. In order to use this strategy a custom <tt class="literal">ICacheRegionStrategyFactory</tt>
						has to be provided (see <tt class="literal">cache.region_strategy_factory</tt> setting), where the strategy is created with a custom
						<tt class="literal">RegionMemoryCacheBase</tt> implementation. This strategy has additional settings:
						<dt><span class="term"><tt class="literal">cache.region_strategy.distributed_local_cache.use_pipelining</tt></span></dt><dd>
							Whether to use <tt class="literal">StackExchange.Redis</tt> pipelining feature.
							Defaults to <tt class="literal">false</tt>.
							</dd>
						<dt><span class="term"><tt class="literal">cache.region_strategy.distributed_local_cache.client_id</tt></span></dt><dd>
							The client id used for cache invalidation.
							Defaults to a random number.
							</dd>
						<dt><span class="term"><tt class="literal">cache.region_strategy.distributed_local_cache.max_synchronization_time</tt></span></dt><dd>
							The max synchronization time between caches in seconds.
							Defaults to <tt class="literal">10</tt>.
							</dd>
						</p></li></ul></div>
					Defaults to <tt class="literal">NHibernate.Caches.StackExchangeRedis.DefaultRegionStrategy</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.append_hashcode</tt></span></dt><dd>
					Whether the hash code of the key should be added to the cache key. Can be overriden for each region by using <tt class="literal">append-hashcode</tt> attribute.
					Defaults to <tt class="literal">false</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.key_prefix</tt></span></dt><dd>
					The prefix that will be prepended before each cache key in order to avoid having collisions when multiple clients uses the same Redis database.
					Defaults to <tt class="literal">NHibernate-Cache:</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.environment_name</tt></span></dt><dd>
					The name of the environment that will be prepended before each cache key in order to allow having multiple environments on the same Redis database.
					Defaults to <tt class="literal">null</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.serializer</tt></span></dt><dd>
					The assembly qualified name of the serializer that is used to serialize/deserialize the key values. Optionally, a faster json serializer can be
					used by installing <tt class="literal">NHibernate.Caches.Util.JsonSerializer</tt> package and setting
					<tt class="literal">NHibernate.Caches.Util.JsonSerializer.JsonCacheSerializer, NHibernate.Caches.Util.JsonSerializer</tt> value instead.
					Defaults to <tt class="literal">NHibernate.Caches.Common.BinaryCacheSerializer, NHibernate.Caches.Common</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.region_strategy_factory</tt></span></dt><dd>
					The assembly qualified name of the region strategy factory.
					Defaults to <tt class="literal">NHibernate.Caches.StackExchangeRedis.DefaultCacheRegionStrategyFactory</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.connection_multiplexer_provider</tt></span></dt><dd>
					The assembly qualified name of the connection multiplexer provider.
					Defaults to <tt class="literal">NHibernate.Caches.StackExchangeRedis.DefaultConnectionMultiplexerProvider</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.database_provider</tt></span></dt><dd>
					The assembly qualified name of the database provider.
					Defaults to <tt class="literal">NHibernate.Caches.StackExchangeRedis.DefaultDatabaseProvider</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.lock.key_timeout</tt></span></dt><dd>
					The timeout for a lock key to expire in seconds.
					Defaults to <tt class="literal">5</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.lock.acquire_timeout</tt></span></dt><dd>
					The time limit to acquire the lock in seconds.
					Defaults to <tt class="literal">5</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.lock.retry_times</tt></span></dt><dd>
					The number of retries for acquiring the lock.
					Defaults to <tt class="literal">3</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.lock.max_retry_delay</tt></span></dt><dd>
					The maximum delay before retrying to acquire the lock in milliseconds.
					Defaults to <tt class="literal">400</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.lock.min_retry_delay</tt></span></dt><dd>
					The minimum delay before retrying to acquire the lock in milliseconds.
					Defaults to <tt class="literal">10</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.lock.value_provider</tt></span></dt><dd>
					The assembly qualified name of the lock value provider.
					Defaults to <tt class="literal">NHibernate.Caches.StackExchangeRedis.DefaultCacheLockValueProvider</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.lock.retry_delay_provider</tt></span></dt><dd>
					The assembly qualified name of the lock retry delay provider.
					Defaults to <tt class="literal">NHibernate.Caches.StackExchangeRedis.DefaultCacheLockRetryDelayProvider</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.lock.key_suffix</tt></span></dt><dd>
					The suffix for the lock key.
					Defaults to <tt class="literal">:lock</tt>.
				</dd></dl></div><p>
			NHibernate.Caches.StackExchangeRedis has a config file section handler to allow configuring different expirations for
			different regions. Here is an example:
		</p><div class="example"><a name="d0e20159"></a><p class="title"><b>Example&nbsp;27.11.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
  &lt;configSections&gt;
    &lt;section name="redis"
      type="NHibernate.Caches.StackExchangeRedis.RedisSectionHandler, NHibernate.Caches.StackExchangeRedis" /&gt;
  &lt;/configSections&gt;

  &lt;redis&gt;
    &lt;cache region="foo" expiration="500" database="1" /&gt;
    &lt;cache region="bar" sliding="true" append-hashcode="true" /&gt;
    &lt;cache region="baz"
      strategy="NHibernate.Caches.StackExchangeRedis.FastRegionStrategy, NHibernate.Caches" /&gt;
  &lt;/redis&gt;
&lt;/configuration&gt;</pre></div><p>
			The loading of this section can be customized with the
			<tt class="literal">NHibernate.Caches.StackExchangeRedis.ConfigurationProvider</tt> class. See
			<a href="#NHibernate.Caches.ConfigurationProvider" title="27.2.&nbsp;Using a custom configuration provider">Section&nbsp;27.2, &#8220;Using a custom configuration provider&#8221;</a>.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NHibernate.Caches.CoreMemoryCache"></a>27.9.&nbsp;CoreMemoryCache Configuration</h2></div></div><div></div></div><p>
			CoreMemoryCache relies on <tt class="classname">Microsoft.Extensions.Caching.Memory.MemoryCache</tt> for the
			underlying implementation.
		</p><p>
			The following NHibernate configuration settings are available:
		</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">cache.default_expiration</tt></span></dt><dd>
					Number of seconds to wait before expiring each item.
					Defaults to <tt class="literal">300</tt>. It can also be set programmatically on the NHibernate
					configuration object under the name <tt class="literal">expiration</tt>, which then takes precedence
					over <tt class="literal">cache.default_expiration</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.use_sliding_expiration</tt></span></dt><dd>
					Should the expiration be sliding? A sliding expiration is reinitialized at each get.
					Defaults to <tt class="literal">false</tt>.
				</dd></dl></div><p>
			CoreMemoryCache has a config file section handler to allow configuring different expirations for
			different regions, and configuring the <tt class="literal">MemoryCache</tt> expiration scan frequency.
			Here is an example:
		</p><div class="example"><a name="d0e20209"></a><p class="title"><b>Example&nbsp;27.12.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
  &lt;configSections&gt;
    &lt;section name="corememorycache"
      type="NHibernate.Caches.CoreMemoryCache.CoreMemoryCacheSectionHandler,NHibernate.Caches.CoreMemoryCache"
    /&gt;
  &lt;/configSections&gt;

  &lt;corememorycache expiration-scan-frequency="00:05:00"&gt;
    &lt;cache region="foo" expiration="500" /&gt;
    &lt;cache region="bar" expiration="300" sliding="true" /&gt;
  &lt;/corememorycache&gt;
&lt;/configuration&gt;</pre></div><p>
			The loading of this section can be customized with the
			<tt class="literal">NHibernate.Caches.CoreMemoryCache.ConfigurationProvider</tt> class. See
			<a href="#NHibernate.Caches.ConfigurationProvider" title="27.2.&nbsp;Using a custom configuration provider">Section&nbsp;27.2, &#8220;Using a custom configuration provider&#8221;</a>.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NHibernate.Caches.CoreDistributedCache"></a>27.10.&nbsp;CoreDistributedCache Configuration</h2></div></div><div></div></div><p>
			CoreDistributedCache relies on <tt class="classname">Microsoft.Extensions.Caching.Abstractions.IDistributedCache</tt>
			implementations. The implementation has to be provided through an <tt class="literal">IDistributedCacheFactory</tt>, either
			supplied through configuration or programmatically by affecting
			<tt class="literal">CoreDistributedCacheProvider.CacheFactory</tt> before building a session factory.
		</p><p>
			The following NHibernate configuration settings are available:
		</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">cache.default_expiration</tt></span></dt><dd>
					Number of seconds to wait before expiring each item.
					Defaults to <tt class="literal">300</tt>. It can also be set programmatically on the NHibernate
					configuration object under the name <tt class="literal">expiration</tt>, which then takes precedence
					over <tt class="literal">cache.default_expiration</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.use_sliding_expiration</tt></span></dt><dd>
					Should the expiration be sliding? A sliding expiration is reinitialized at each get.
					Defaults to <tt class="literal">false</tt>.
				</dd><dt><span class="term"><tt class="literal">cache.serializer</tt></span></dt><dd>
					The assembly qualified name of the serializer that is used to serialize/deserialize the key values. Optionally, a faster json serializer can be
					used by installing <tt class="literal">NHibernate.Caches.Util.JsonSerializer</tt> package and setting
					<tt class="literal">NHibernate.Caches.Util.JsonSerializer.JsonCacheSerializer, NHibernate.Caches.Util.JsonSerializer</tt> value instead.
					Defaults to <tt class="literal">NHibernate.Caches.Common.BinaryCacheSerializer, NHibernate.Caches.Common</tt>.
					This setting is available since the 5.7 version of CoreDistributedCache.
				</dd></dl></div><p>
			CoreDistributedCache has a config file section handler to allow configuring different expirations for
			different regions, configuring the <tt class="literal">IDistributedCacheFactory</tt> to use, and configuring
			additional properties specific to the chosen <tt class="literal">IDistributedCache</tt> implementation.
			Here is an example:
		</p><div class="example"><a name="d0e20283"></a><p class="title"><b>Example&nbsp;27.13.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
  &lt;configSections&gt;
    &lt;section name="coredistributedcache"
      type="NHibernate.Caches.CoreDistributedCache.CoreDistributedCacheSectionHandler,
            NHibernate.Caches.CoreDistributedCache" /&gt;
  &lt;/configSections&gt;

  &lt;coredistributedcache
    factory-class="NHibernate.Caches.CoreDistributedCache.Memory.MemoryFactory,
                   NHibernate.Caches.CoreDistributedCache.Memory"&gt;
    &lt;properties&gt;
      &lt;property name="expiration-scan-frequency"&gt;00:10:00&lt;/property&gt;
      &lt;property name="size-limit"&gt;1048576&lt;/property&gt;
      &lt;property name="cache.serializer"
        &gt;NHibernate.Caches.Util.JsonSerializer.JsonCacheSerializer, NHibernate.Caches.Util.JsonSerializer&lt;/property&gt;
    &lt;/properties&gt;
    &lt;cache region="foo" expiration="500" sliding="true" /&gt;
    &lt;cache region="noExplicitExpiration" sliding="true" /&gt;
    &lt;cache region="specificSerializer"
      serializer="NHibernate.Caches.Common.BinaryCacheSerializer, NHibernate.Caches.Common" /&gt;
  &lt;/coredistributedcache&gt;
&lt;/configuration&gt;</pre></div><p>
			The loading of this section can be customized with the
			<tt class="literal">NHibernate.Caches.CoreDistributedCache.ConfigurationProvider</tt> class. See
			<a href="#NHibernate.Caches.ConfigurationProvider" title="27.2.&nbsp;Using a custom configuration provider">Section&nbsp;27.2, &#8220;Using a custom configuration provider&#8221;</a>.
		</p><p>
			CoreDistributedCache does not support <tt class="literal">NHibernate.Cache.ICache.Clear</tt>. Clearing the NHibernate
			cache has no effects with CoreDistributedCache.
		</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="NHibernate.Caches.CoreDistributedCache.Memcached"></a>27.10.1.&nbsp;Memcached distributed cache factory</h3></div></div><div></div></div><p>
				<tt class="literal">NHibernate.Caches.CoreDistributedCache.Memcached</tt> provides a Memcached distributed cache factory.
				This factory yields a <tt class="literal">Enyim.Caching.MemcachedClient</tt> from <tt class="literal">EnyimMemcachedCore</tt>.
				For using it, reference the cache factory package and set the <tt class="literal">factory-class</tt> attribute of the
				<tt class="literal">coredistributedcache</tt> configuration section to
				<tt class="literal">NHibernate.Caches.CoreDistributedCache.Memcached.MemcachedFactory, NHibernate.Caches.CoreDistributedCache.Memcached</tt>.
			</p><p>
				Memcached does not support sliding expirations. <tt class="literal">cache.use_sliding_expiration</tt> setting or
				<tt class="literal">sliding</tt> region setting do not have any effect with Memcached.
			</p><p>
				The following additional properties can be configured:
			</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">configuration</tt></span></dt><dd>
						The JSON configuration of <tt class="literal">EnyimMemcachedCore</tt>, see its
						<a href="https://github.com/cnblogs/EnyimMemcachedCore" target="_top">project website</a>. It has to be structured
						like the value part of the <tt class="literal">"enyimMemcached"</tt> property in an
						<tt class="literal">appsettings.json</tt> file.
						<div class="example"><a name="d0e20350"></a><p class="title"><b>Example&nbsp;27.14.&nbsp;</b></p><pre class="programlisting">{
  "Servers": [
    {
      "Address": "localhost",
      "Port": 11211
    }
  ]
}</pre></div></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="NHibernate.Caches.CoreDistributedCache.Redis"></a>27.10.2.&nbsp;Redis distributed cache factory</h3></div></div><div></div></div><p>
				<tt class="literal">NHibernate.Caches.CoreDistributedCache.Redis</tt> provides a Redis distributed cache factory.
				This factory yields a <tt class="literal">Microsoft.Extensions.Caching.Redis.RedisCache</tt>. For using it,
				reference the cache factory package and set the <tt class="literal">factory-class</tt> attribute of the
				<tt class="literal">coredistributedcache</tt> configuration section to
				<tt class="literal">NHibernate.Caches.CoreDistributedCache.Redis.RedisFactory, NHibernate.Caches.CoreDistributedCache.Redis</tt>.
			</p><p>
				The following additional properties can be configured:
			</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">configuration</tt></span></dt><dd>
						Its value will be used to set the <tt class="literal">Configuration</tt> property of the
						<tt class="literal">RedisCache</tt> options (<tt class="literal">RedisCacheOptions</tt>).
					</dd><dt><span class="term"><tt class="literal">instance-name</tt></span></dt><dd>
						Its value will be used to set the <tt class="literal">InstanceName</tt> property of the
						<tt class="literal">RedisCache</tt> options (<tt class="literal">RedisCacheOptions</tt>).
					</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="NHibernate.Caches.CoreDistributedCache.SqlServer"></a>27.10.3.&nbsp;SQL Server distributed cache factory</h3></div></div><div></div></div><p>
				<tt class="literal">NHibernate.Caches.CoreDistributedCache.SqlServer</tt> provides a SQL Server distributed cache factory.
				This factory yields a <tt class="literal">Microsoft.Extensions.Caching.SqlServer.SqlServerCache</tt>. For using it,
				reference the cache factory package and set the <tt class="literal">factory-class</tt> attribute of the
				<tt class="literal">coredistributedcache</tt> configuration section to
				<tt class="literal">NHibernate.Caches.CoreDistributedCache.SqlServer.SqlServerFactory, NHibernate.Caches.CoreDistributedCache.SqlServer</tt>.
			</p><p>
				The following additional properties can be configured:
			</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">connection-string</tt></span></dt><dd>
						Its value will be used to set the <tt class="literal">ConnectionString</tt> property of the
						<tt class="literal">SqlServerCache</tt> options (<tt class="literal">SqlServerCacheOptions</tt>).
					</dd><dt><span class="term"><tt class="literal">schema-name</tt></span></dt><dd>
						Its value will be used to set the <tt class="literal">SchemaName</tt> property of the
						<tt class="literal">SqlServerCache</tt> options (<tt class="literal">SqlServerCacheOptions</tt>).
					</dd><dt><span class="term"><tt class="literal">table-name</tt></span></dt><dd>
						Its value will be used to set the <tt class="literal">TableName</tt> property of the
						<tt class="literal">SqlServerCache</tt> options (<tt class="literal">SqlServerCacheOptions</tt>).
					</dd><dt><span class="term"><tt class="literal">expired-items-deletion-interval</tt></span></dt><dd>
						Its value will be used to set the <tt class="literal">ExpiredItemsDeletionInterval</tt> property of the
						<tt class="literal">SqlServerCache</tt> options (<tt class="literal">SqlServerCacheOptions</tt>). It can be
						provided either as an integer being a number of minutes or as a <tt class="literal">TimeSpan</tt> string
						representation.
					</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="NHibernate.Caches.CoreDistributedCache.Memory"></a>27.10.4.&nbsp;Memory distributed cache factory</h3></div></div><div></div></div><p>
				<tt class="literal">NHibernate.Caches.CoreDistributedCache.Memory</tt> provides a memory "distributed" cache factory.
				This factory yields a <tt class="literal">Microsoft.Extensions.Caching.Memory.MemoryDistributedCache</tt>. For using it,
				reference the cache factory package and set the <tt class="literal">factory-class</tt> attribute of the
				<tt class="literal">coredistributedcache</tt> configuration section to
				<tt class="literal">NHibernate.Caches.CoreDistributedCache.Memory.MemoryFactory, NHibernate.Caches.CoreDistributedCache.Memory</tt>.
			</p><p>
				As implied by its name, this cache is not actually distributed. It is meant for testing purpose. For other usages, consider
				using another memory cache provider, like <tt class="literal">CoreMemoryCache</tt>. Due to the distributed cache implementation, using
				the <tt class="literal">MemoryDistributedCache</tt> has some drawbacks compared to most other memory cache providers: it will
				serialize cached objects, incurring some overhead; it does not support clearing the cache. But due to the serialization of
				cached objects, it is able of computing its consumed memory size, thus the availability of the <tt class="literal">SizeLimit</tt>
				option.
			</p><p>
				The following additional properties can be configured:
			</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">expiration-scan-frequency</tt></span></dt><dd>
						Its value will be used to set the <tt class="literal">ExpirationScanFrequency</tt> property of the
						<tt class="literal">MemoryDistributedCache</tt> options (<tt class="literal">MemoryDistributedCacheOptions</tt>). It can be
						provided either as an integer being a number of minutes or as a <tt class="literal">TimeSpan</tt> string
						representation.
					</dd><dt><span class="term"><tt class="literal">size-limit</tt></span></dt><dd>
						Its value will be used to set the <tt class="literal">SizeLimit</tt> property of the
						<tt class="literal">MemoryDistributedCache</tt> options (<tt class="literal">MemoryDistributedCacheOptions</tt>).
						Its value is an integer, representing the maximal bytes count to be stored in the cache.
					</dd></dl></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mapping-attributes"></a>Chapter&nbsp;28.&nbsp;NHibernate.Mapping.Attributes</h2></div></div><div></div></div><div class="abstract"><a name="mapping-attributes-abstract"></a><p class="title"><b>What is NHibernate.Mapping.Attributes?</b></p><p><b>NHibernate.Mapping.Attributes is an add-in for <a href="http://nhibernate.info/" target="_top">NHibernate</a> contributed by Pierre Henri Kuat&eacute;
			(aka <span class="emphasis"><em>KPixel</em></span>); the former implementation was made by John Morris.&nbsp;</b>NHibernate require mapping streams to bind your domain model to your database. Usually, they are written (and maintained) in separated hbm.xml files.</p><p>With NHibernate.Mapping.Attributes, you can use .NET attributes to decorate your entities and these attributes will be used to generate these mapping .hbm.xml (as files or streams). So you will no longer have to bother with these <span class="emphasis"><em>nasty</em></span> xml files ;).</p><p>
			<span class="emphasis"><em>Content of this library <a href="https://github.com/nhibernate/NHibernate.Mapping.Attributes" target="_top">project</a>:</em></span>
		</p><p>
			</p><div class="orderedlist"><ol type="1"><li><p>
						<span class="strong">NHibernate.Mapping.Attributes</span>: that is the only assembly you need (as an end-user).</p></li><li><p>
						<span class="strong">Test</span>: a working sample using attributes and HbmSerializer for a NUnit TestFixture.</p></li><li><p>
						<span class="strong">Generator</span>: the program used to generate the attributes and the HbmWriter of
						the end-user assembly.</p></li><li><p>
						<a href="http://mbunit.tigris.org/" target="_top">
							<span class="strong">Refly</span>
						</a>: thanks to <a href="http://www.dotnetwiki.org/" target="_top">Jonathan de Halleux</a> for this library which makes it so easy to generate code.</p></li></ol></div><p>
		</p><p>
			</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
					This library is generated using the file <tt class="filename">/src/NHibernate.Mapping.Attributes/nhibernate-mapping.xsd</tt>
					(which is embedded in the assembly to be able to validate generated XML streams).
					As this file can change at each new release of NHibernate, a new release of NHibernate.Mapping.Attributes
					should be regenerated before using it with a different version. It can be done by opening the Generator solution,
					compiling and running the Generator project.
				</p></div><p>
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-attributes-new"></a>28.1.&nbsp;What's new?</h2></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>It is possible to import classes by simply decorating them with <tt class="literal">[Import] class ImportedClass1 {}</tt>. Note that you must use <tt class="literal">HbmSerializer.Serialize(assembly)</tt>; The <tt class="literal">&lt;import/&gt;</tt> mapping will be added before the classes mapping. If you prefer to keep these imports in the class using them, you can specify them all on the class: <tt class="literal">[Import(ClassType=typeof(ImportedClass1))] class Query {}</tt>.</p></li><li><p><tt class="classname">[RawXmlAttribute]</tt> is a new attribute allowing to insert xml as-is in the mapping. This feature can be very useful to do complex mapping (eg: components). It may also be used to quickly move the mapping from xml files to attributes. Usage: <tt class="literal">[RawXml(After=typeof(ComponentAttribute), Content="&lt;component name="..."&gt;...&lt;/component&gt;")]</tt>. <tt class="methodname">After</tt> tells after which kind of mapping the xml should be inserted (generally, it is the type of the mapping you are inserting); it is optional (in which case the xml is inserted on the top of the mapping). Note: At the moment, all raw xmls are prefixed by a <tt class="literal">&lt;!----&gt;</tt> (in the generated stream); this is a known side-effect.</p></li><li><p><tt class="classname">[AttributeIdentifierAttribute]</tt> is a new attribute allowing to provide the value of a defined "place holder". Eg: </p><pre class="programlisting">
public class Base {
    [Id(..., Column="{{Id.Column}}")]
    [AttributeIdentifier(Name="Id.Column", Value="ID")] // Default value
    public int Id { ... }
}

[AttributeIdentifier(Name="Id.Column", Value="SUB_ID")]
[Class]
public class MappedSubClass : Base { }</pre><p>
				The idea is that, when you have a mapping which is shared by many subclasses but which has minor differences (like different column names), you can put the mapping in the base class with place holders on these fields and give their values in subclasses. Note that this is possible for any mapping field taking a string (column, name, type, access, etc.). And, instead of <tt class="methodname">Value</tt>, you can use <tt class="methodname">ValueType</tt> or <tt class="methodname">ValueObject</tt> (if you use an enum, you can control its formatting with <tt class="methodname">ValueObject</tt>).
				</p><p>The "place holder" is defined like this: <tt class="literal">{{XXX}}</tt>. If you don't want to use these double curly brackets, you can change them using the properties <tt class="methodname">StartQuote</tt> and <tt class="methodname">EndQuote</tt> of the class <tt class="classname">HbmWriter</tt>.</p></li><li><p>
					It is possible to register patterns (using Regular Expressions) to automatically transform fully qualified names of properties types
					into something else. Eg: <tt class="literal">HbmSerializer.Default.HbmWriter.Patterns.Add(@"Namespace\.(\S+), Assembly", "$1");</tt> will
					map all properties with a not-qualified type name.
				</p></li><li><p>
					Two methods have been added to the <tt class="literal">HbmSerializer</tt> class, allowing generating mappings from a type or an assembly:
					<tt class="literal">HbmSerializer.Default.Serialize(typeof(XXX))</tt> and
					<tt class="literal">HbmSerializer.Default.Serialize(typeof(XXX).Assembly)</tt>. So it is no longer required to create a MemoryStream for
					these simple cases. The output of these call can be directly added to your NHibernate <tt class="literal">Configuration</tt> instance:
					<tt class="literal">cfg.AddInputStream(HbmSerializer.Default.Serialize(typeof(XXX)))</tt>.
				</p></li><li><p>Two <tt class="methodname">WriteUserDefinedContent()</tt> methods have been added to <tt class="classname">HbmWriter</tt>. They improve the extensibility of this library; it is now very easy to create a .NET attribute and integrate it in the mapping.</p></li><li><p>Attributes <tt class="classname">[(Jcs)Cache]</tt>, <tt class="classname">[Discriminator]</tt> and <tt class="classname">[Key]</tt> can be specified at class-level.</p></li><li><p>Interfaces can be mapped (just like classes and structs).</p></li><li><p>
					A notable "bug" fix is the re-ordering of (joined-)subclasses. This operation may be required when a subclass extends another subclass.
					In this case, the extended class mapping must come before the extending class mapping. Note that the re-ordering takes place only for
					"top-level" classes (that is not nested in other mapped classes). Anyway, it is quite unusual to put an interdependent mapped subclasses
					in a mapped class.
				</p></li><li><p>There are also many other little changes: refer to the release notes for more details.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-attributes-howto"></a>28.2.&nbsp;How to use it?</h2></div></div><div></div></div><p><b>The <span class="emphasis"><em>end-user class</em></span> is <tt class="classname">NHibernate.Mapping.Attributes.HbmSerializer</tt>.&nbsp;</b>
				This class <span class="emphasis"><em>serialize</em></span> your domain model to mapping streams. You can either serialize classes one by one,
				or serialize a whole assembly. Look at <tt class="classname">NHibernate.Mapping.Attributes.Test</tt> project for a working sample.
			</p><p>
			The first step is to decorate your entities with attributes. You can use: <tt class="classname">[Class]</tt>,
			<tt class="classname">[Subclass]</tt>, <tt class="classname">[JoinedSubclass]</tt> or <tt class="classname">[Component]</tt>. Then, you decorate
			your members (fields/properties); they can take as many attributes as required by your mapping. Eg:
		</p><pre class="programlisting">
[NHibernate.Mapping.Attributes.Class]
public class Example
{
	[NHibernate.Mapping.Attributes.Property]
	public string Name;
}</pre><p>
			After this step, you use <tt class="classname">NHibernate.Mapping.Attributes.HbmSerializer</tt> (here, we use its
			<tt class="methodname">Default</tt> property, which is an instance you can use if you don't need/want to create it yourself):
		</p><pre class="programlisting">var cfg = new NHibernate.Cfg.Configuration();
cfg.Configure();
// Enable validation (optional)
HbmSerializer.Default.Validate = true;
// Here, we serialize all decorated classes (but you can also do it class by class)
cfg.AddInputStream(HbmSerializer.Default.Serialize(
	System.Reflection.Assembly.GetExecutingAssembly()));
// Now you can use this configuration to build your SessionFactory...</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
				As you can see here, NHibernate.Mapping.Attributes is <span class="strong">not</span> (really) intrusive.
				Setting attributes on your objects doesn't force you to use them with NHibernate and doesn't break any constraint on your architecture.
				Attributes are purely informative (like documentation)!
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-attributes-tips"></a>28.3.&nbsp;Tips</h2></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>
					In production, you may want to generate a XML mapping file from NHibernate.Mapping.Attributes and use this file each time
					the SessionFactory need to be built. Use: <tt class="literal">HbmSerializer.Default.Serialize(typeof(XXX).Assembly, "DomainModel.hbm.xml");</tt>.
					It is slightly faster.
				</p></li><li><p>
					Use <tt class="methodname">HbmSerializer.Validate</tt> to enable/disable the validation of generated xml streams (against
					NHibernate mapping schema). This is useful to quickly find errors. (They are written in the StringBuilder property 
					<tt class="methodname">HbmSerializer.Error</tt>.) If the error is due to this library, then see if it is a known issue and report it.
					You are welcome to contribute a solution if you solve the trouble :).</p></li><li><p>Your classes, fields and properties (members) can be private; just make sure that you have the permission to access private members using reflection (<tt class="methodname">ReflectionPermissionFlag.MemberAccess</tt>).</p></li><li><p>Members of a mapped classes are also seek in its base classes (until we reach <span class="emphasis"><em>mapped</em></span> base class). So you can decorate some members of a (not mapped) base class and use it in its (mapped) sub class(es).</p></li><li><p>For a Name taking a <tt class="classname">System.Type</tt>, set the type with <tt class="methodname">Name</tt><tt class="literal">="xxx"</tt> (as <tt class="classname">string</tt>) or <tt class="methodname">Name</tt><tt class="literal">Type=typeof(xxx)</tt>; (add "<tt class="literal">Type</tt>" to "<tt class="methodname">Name</tt>")</p></li><li><p>By default, .NET attributes don't keep the order of attributes; so you need to set it yourself when the order matter (using the first parameter of each attribute); it is <span class="emphasis"><em>highly</em></span> recommended to set it when you have more than one attribute on the same member.</p></li><li><p>
					As long as there is no ambiguity, you can decorate a member with many unrelated attributes. A good example is to put
					class-related attributes (like <tt class="literal">&lt;discriminator&gt;</tt>) on the identifier member. But don't forget
					that the order matters (the <tt class="literal">&lt;discriminator&gt;</tt> must be after the <tt class="literal">&lt;id&gt;</tt>).
					The order to use comes from the order of elements in the NHibernate mapping schema. Personally, I prefer using negative
					numbers for these attributes (if they come first!).</p></li><li><p>You can add <tt class="classname">[HibernateMapping]</tt> on your classes to specify <tt class="literal">&lt;hibernate-mapping&gt;</tt> attributes (used when serializing the class in its stream). You can also use <tt class="methodname">HbmSerializer.Hbm*</tt> properties (used when serializing an assembly or a type that is not decorated with <tt class="classname">[HibernateMapping]</tt>).</p></li><li><p>Instead of using a string for <tt class="methodname">DiscriminatorValue</tt> (in <tt class="classname">[Class]</tt> and <tt class="classname">[Subclass]</tt>), you can use any object you want. Example: </p><pre class="programlisting">[Subclass(DiscriminatorValueEnumFormat="d", DiscriminatorValueObject=DiscEnum.Val1)]</pre><p> Here, the object is an Enum, and you can set the format you want (the default value is "g"). Note that you must put it <span class="strong">before</span>! For others types, It simply use the <tt class="methodname">ToString()</tt> method of the object.</p></li><li><p>Each stream generated by NHibernate.Mapping.Attributes can contain a comment with the date of the generation; You may enable/disable this by using the property <tt class="methodname">HbmSerializer.WriteDateComment</tt>.</p></li><li><p>If you forget to provide a required xml attribute, it will obviously throw an exception while generating the mapping.</p></li><li><p>The recommended and easiest way to map <tt class="classname">[Component]</tt> is to use <tt class="classname">[ComponentProperty]</tt>. The first step is to put <tt class="classname">[Component]</tt> on the component class and map its fields/properties. Note that you shouldn't set the <tt class="methodname">Name</tt> in <tt class="classname">[Component]</tt>. Then, on each member in your classes, add <tt class="classname">[ComponentProperty]</tt>. But you can't override <tt class="methodname">Access</tt>, <tt class="methodname">Update</tt> or <tt class="methodname">Insert</tt> for each member.</p><p>There is a working example in <span class="emphasis"><em>NHibernate.Mapping.Attributes.Test</em></span> (look for the class <tt class="classname">CompAddress</tt> and its usage in others classes).</p></li><li><p>Another way to map <tt class="classname">[Component]</tt> is to use the way this library works: If a mapped class contains a mapped component, then this component will be include in the class. <span class="emphasis"><em>NHibernate.Mapping.Attributes.Test</em></span> contains the classes <tt class="classname">JoinedBaz</tt> and <tt class="classname">Stuff</tt> which both use the component <tt class="classname">Address</tt>.</p><p>Basically, it is done by adding </p><pre class="programlisting">[Component(Name = "MyComp")] private class SubComp : Comp {}</pre><p> in each class. One of the advantages is that you can override <tt class="methodname">Access</tt>, <tt class="methodname">Update</tt> or <tt class="methodname">Insert</tt> for each member. But you have to add the component subclass in <span class="strong">each</span> class (and it can not be inherited). Another advantage is that you can use <tt class="classname">[AttributeIdentifier]</tt>.</p></li><li><p>Finally, whenever you think that it is easier to write the mapping in XML (this is often the case for <tt class="classname">[Component]</tt>), you can use <tt class="classname">[RawXml]</tt>.</p></li><li><p><b>About customization.&nbsp;</b><tt class="classname">HbmSerializer</tt> uses <tt class="classname">HbmWriter</tt> to serialize each kind of attributes. Their methods are virtual; so you can create a subclass and override any method you want (to change its default behavior).</p><p>Use the property <tt class="methodname">HbmSerializer.HbmWriter</tt> to change the writer used (you may set a subclass of <tt class="classname">HbmWriter</tt>).</p></li></ol></div><p>Example using some of these tips: (0, 1 and 2 are position indexes)
</p><pre class="programlisting">// Don't put it after [ManyToOne] !!!
[NHibernate.Mapping.Attributes.Id(0, TypeType=typeof(int))]
	[NHibernate.Mapping.Attributes.Generator(1, Class="uuid.hex")]
[NHibernate.Mapping.Attributes.ManyToOne(2,
	ClassType=typeof(Foo), OuterJoin=OuterJoinStrategy.True)]
private Foo Entity;</pre><p>
			Generates:
</p><pre class="programlisting">
&lt;id type="Int32"&gt;
	&lt;generator class="uuid.hex" /&gt;
&lt;/id&gt;
&lt;many-to-one name="Entity" class="Namespaces.Foo, SampleAssembly" outer-join="true" /&gt;
</pre><p>
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-attributes-todo"></a>28.4.&nbsp;Known issues and TODOs</h2></div></div><div></div></div><p>First, read TODOs in the source code ;)</p><p>A <tt class="methodname">Position</tt> property has been added to all attributes to order them. But there is still a problem:</p><p>When a parent element "p" has a child element "x" that is also the child element of another child element "c" of "p" (preceding "x") :D
Illustration:</p><pre class="programlisting">&lt;p&gt;
  &lt;c&gt;
    &lt;x /&gt;
  &lt;/c&gt;
  &lt;x /&gt;
&lt;/p&gt;</pre><p>
		</p><p>In this case, when writing:
			</p><pre class="programlisting">[Attributes.P(0)]
[Attributes.C(1)]
	[Attributes.X(2)]
[Attributes.X(3)]
public MyType MyProperty;</pre><p>
		X(3) will always belong to C(1) ! (as X(2)).
		</p><p>It is the case for <tt class="literal">&lt;dynamic-component&gt;</tt> and <tt class="literal">&lt;nested-composite-element&gt;</tt>.</p><p>Another bad news is that, currently, XML elements coming after this elements can not be included in them. Eg: There is no way put a collection in <tt class="literal">&lt;dynamic-component&gt;</tt>. The reason is that the file <tt class="filename">nhibernate-mapping.xsd</tt> tells how elements are built and in which order, and NHibernate.Mapping.Attributes use this order.</p><p>Anyway, the solution would be to add a <tt class="methodname">int ParentNode</tt> property to BaseAttribute so that you can create a real graph...</p><p>For now, you can fallback on <tt class="classname">[RawXml]</tt>.</p><p>Actually, there is no other know issue nor planned modification. This library should be stable and complete. But if you find a bug or think of an useful improvement, contact us!</p><p>As a side note, it would be nice to write a better TestFixture than <span class="emphasis"><em>NHibernate.Mapping.Attributes.Test</em></span> :D.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-attributes-devnotes"></a>28.5.&nbsp;Developer Notes</h2></div></div><div></div></div><p>Any change to the schema (<tt class="filename">nhibernate-mapping.xsd</tt>) implies:</p><div class="orderedlist"><ol type="1"><li><p>
					Checking if there is any change to do in the Generator (like updating <tt class="literal">KnowEnums</tt> /
					<tt class="literal">AllowMultipleValue</tt> / <tt class="literal">IsRoot</tt> / <tt class="literal">IsSystemType</tt> /
					<tt class="literal">IsSystemEnum</tt> / <tt class="literal">CanContainItself</tt>).
				</p></li><li><p>
					Updating <tt class="filename">/src/NHibernate.Mapping.Attributes/nhibernate-mapping.xsd</tt> (copy/paste)
					and running the Generator again (even if it wasn't modified).
				</p></li><li><p>
					Running the Test project and make sure that no exception is thrown. A class/property should be modified/added
					in this project to be sure that any new breaking change will be caught (=&gt; update the reference hbm.xml files
					and/or the project <tt class="filename">NHibernate.Mapping.Attributes.csproj</tt>).
				</p></li></ol></div><p>This implementation is based on NHibernate mapping schema. So there is probably lot of "standard schema features" that are not supported...</p><p>The version of NHibernate.Mapping.Attributes should be the version of the NHibernate schema used to generate it (=&gt; the version of NHibernate library).</p><p>
			In the design of this project, performance is a (<span class="emphasis"><em>very</em></span>) minor goal :). Easier implementation and maintenance
			are far more important because you can use this library to generate statically the mapping files and use them instead in production.
			(Cf. the first tip in <a href="#mapping-attributes-tips" title="28.3.&nbsp;Tips">Section&nbsp;28.3, &#8220;Tips&#8221;</a>.)
		</p></div></div></div></div></body></html>