---
layout:
---
<!doctype html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <title>Chapter&nbsp;21.&nbsp;Improving performance</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="NHibernate - Relational Persistence for Idiomatic .NET"><link rel="up" href="index.html" title="NHibernate - Relational Persistence for Idiomatic .NET"><link rel="previous" href="filters.html" title="Chapter&nbsp;20.&nbsp;Filtering data"><link rel="next" href="toolsetguide.html" title="Chapter&nbsp;22.&nbsp;Toolset Guide"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;21.&nbsp;Improving performance</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="filters.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="toolsetguide.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="performance"></a>Chapter&nbsp;21.&nbsp;Improving performance</h2></div></div><div></div></div>{% include google_adsense.html %}<div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-fetching"></a>21.1.&nbsp;Fetching strategies</h2></div></div><div></div></div><p>
            A <span class="emphasis"><em>fetching strategy</em></span> is the strategy NHibernate will use for 
            retrieving associated objects if the application needs to navigate the association. 
            Fetch strategies may be declared in the O/R mapping metadata, or overridden by a 
            particular HQL or <tt class="literal">Criteria</tt> query.
        </p><p>
            NHibernate defines the following fetching strategies:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Join fetching</em></span> - NHibernate retrieves the
                    associated instance or collection in the same <tt class="literal">SELECT</tt>,
                    using an <tt class="literal">OUTER JOIN</tt>.
                </p></li><li><p>
                    <span class="emphasis"><em>Select fetching</em></span> - a second <tt class="literal">SELECT</tt>
                    is used to retrieve the associated entity or collection. Unless
                    you explicitly disable lazy fetching by specifying <tt class="literal">lazy="false"</tt>, 
                    this second select will only be executed when you actually access the
                    association.
                </p></li><li><p>
                    <span class="emphasis"><em>Subselect fetching</em></span> - a second <tt class="literal">SELECT</tt>
                    is used to retrieve the associated collections for all entities retrieved in a
                    previous query or fetch. Unless you explicitly disable lazy fetching by specifying 
                    <tt class="literal">lazy="false"</tt>, this second select will only be executed when you 
                    actually access the association.
                </p></li><li><p>
                    <span class="emphasis"><em>"Extra-lazy" collection fetching</em></span> - individual
                    elements of the collection are accessed from the database as needed.
                    NHibernate tries not to fetch the whole collection into memory unless
                    absolutely needed (suitable for very large collections)
                </p></li><li><p>
                    <span class="emphasis"><em>Batch fetching</em></span> - an optimization strategy
                    for select fetching - NHibernate retrieves a batch of entity instances 
                    or collections in a single <tt class="literal">SELECT</tt>, by specifying 
                    a list of primary keys or foreign keys.
                </p></li></ul></div><p>
            NHibernate also distinguishes between:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Immediate fetching</em></span> - an association, collection or
                    attribute is fetched immediately, when the owner is loaded.
                </p></li><li><p>
                    <span class="emphasis"><em>Lazy collection fetching</em></span> - a collection is fetched 
                    when the application invokes an operation upon that collection. (This
                    is the default for collections.)
                </p></li><li><p>
                    <span class="emphasis"><em>Proxy fetching</em></span> - a single-valued association is 
                    fetched when a method other than the identifier getter is invoked
                    upon the associated object.
                </p></li></ul></div><p>
            We have two orthogonal notions here: <span class="emphasis"><em>when</em></span> is the association
            fetched, and <span class="emphasis"><em>how</em></span> is it fetched (what SQL is used). Don't
            confuse them! We use <tt class="literal">fetch</tt> to tune performance. We may use 
            <tt class="literal">lazy</tt> to define a contract for what data is always available 
            in any detached instance of a particular class.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-lazy"></a>21.1.1.&nbsp;Working with lazy associations</h3></div></div><div></div></div><p>
                By default, NHibernate uses lazy select fetching for collections and lazy proxy
                fetching for single-valued associations. These defaults make sense for almost
                all associations in almost all applications. 
            </p><p>
                However, lazy fetching poses one problem that you must be aware of. Access to a 
                lazy association outside of the context of an open NHibernate session will result 
                in an exception. For example:
            </p><pre class="programlisting">IDictionary&lt;string, int&gt; permissions;
using (var s = sessions.OpenSession())
using (Transaction tx = s.BeginTransaction())
{
    User u = s.CreateQuery("from User u where u.Name=:userName")
        .SetString("userName", userName).UniqueResult&lt;User&gt;();
    permissions = u.Permissions;

    tx.Commit();
}

int accessLevel = permissions["accounts"];  // Error!</pre><p>
                Since the <tt class="literal">permissions</tt> collection was not initialized
                when the <tt class="literal">ISession</tt> was closed, the collection will not
                be able to load its state. <span class="emphasis"><em>NHibernate does not support lazy
                initialization for detached objects</em></span>. The fix is to move the
                code that reads from the collection to just before the transaction
                is committed.
            </p><p>
                Alternatively, we could use a non-lazy collection or association, 
                by specifying <tt class="literal">lazy="false"</tt> for the association mapping.
                However, it is intended that lazy initialization be used for almost all 
                collections and associations. If you define too many non-lazy associations 
                in your object model, NHibernate will end up needing to fetch the entire 
                database into memory in every transaction!
            </p><p>
                On the other hand, we often want to choose join fetching (which is non-lazy by 
                nature) instead of select fetching in a particular transaction. We'll now see
                how to customize the fetching strategy. In NHibernate, the mechanisms for
                choosing a fetch strategy are identical for single-valued associations and
                collections.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-custom"></a>21.1.2.&nbsp;Tuning fetch strategies</h3></div></div><div></div></div><p>
                Select fetching (the default) is extremely vulnerable to N+1 selects problems, 
                so we might want to enable join fetching in the mapping document:
            </p><pre class="programlisting">&lt;set name="Permissions" 
            fetch="join"&gt;
    &lt;key column="userId"/&gt;
    &lt;one-to-many class="Permission"/&gt;
&lt;/set</pre><pre class="programlisting">&lt;many-to-one name="Mother" class="Cat" fetch="join"/&gt;</pre><p>
                The <tt class="literal">fetch</tt> strategy defined in the mapping document affects:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        retrieval via <tt class="literal">Get()</tt> or <tt class="literal">Load()</tt>
                    </p></li><li><p>
                        retrieval that happens implicitly when an association is navigated
                    </p></li><li><p>
                        <tt class="literal">ICriteria</tt> queries
                    </p></li><li><p>
                        HQL queries if <tt class="literal">subselect</tt> fetching is used
                    </p></li></ul></div><p>
                No matter what fetching strategy you use, the defined non-lazy graph is guaranteed
                to be loaded into memory. Note that this might result in several immediate selects
                being used to execute a particular HQL query.
            </p><p>
                Usually, we don't use the mapping document to customize fetching. Instead, we
                keep the default behavior, and override it for a particular transaction, using 
                <tt class="literal">left join fetch</tt> in HQL. This tells NHibernate to fetch 
                the association eagerly in the first select, using an outer join. In the
                <tt class="literal">ICriteria</tt> query API, you would use
                <tt class="literal">Fetch()</tt>.
            </p><p>
                If you ever feel like you wish you could change the fetching strategy used by
                <tt class="literal">Get()</tt> or <tt class="literal">Load()</tt>, simply use a 
                <tt class="literal">ICriteria</tt> query, for example:
            </p><pre class="programlisting">User user = session.CreateCriteria(typeof(User))
    .Fetch(SelectMode.Fetch, "Permissions")
    .Add( Expression.Eq("Id", userId) )
    .UniqueResult&lt;User&gt;();</pre><p>
                (This is NHibernate's equivalent of what some <span class="emphasis"><em>ORM</em></span> solutions call a "fetch plan".)
            </p><p>
                A completely different way to avoid problems with N+1 selects is to use the
                <a href="performance.html#performance-cache" title="21.2.&nbsp;The Second Level Cache">second-level cache</a>, or to enable
                <a href="performance.html#performance-fetching-batch" title="21.1.5.&nbsp;Using batch fetching">batch fetching</a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-proxies"></a>21.1.3.&nbsp;Single-ended association proxies</h3></div></div><div></div></div><p>
                Lazy fetching for collections is implemented using NHibernate's own implementation
                of persistent collections. However, a different mechanism is needed for lazy
                behavior in single-ended associations. The target entity of the association must
                be proxied. NHibernate implements lazy initializing proxies for persistent objects
                using runtime bytecode enhancement.
            </p><p>
                By default, NHibernate generates proxies (at startup) for all persistent classes
                and uses them to enable lazy fetching of <tt class="literal">many-to-one</tt> and
                <tt class="literal">one-to-one</tt> associations.
            </p><p>
                The mapping file may declare an interface to use as the proxy interface for that
                class, with the <tt class="literal">proxy</tt> attribute. By default, NHibernate uses a subclass
                of the class. <span class="emphasis"><em>Note that the proxied class must implement a non-private default
                constructor. We recommend this constructor for all persistent classes!</em></span>
            </p><p>
                There are some gotchas to be aware of when extending this approach to polymorphic
                classes, eg.
            </p><pre class="programlisting">&lt;class name="Cat" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                Firstly, instances of <tt class="literal">Cat</tt> will never be castable to
                <tt class="literal">DomesticCat</tt>, even if the underlying instance is an
                instance of <tt class="literal">DomesticCat</tt>:
            </p><pre class="programlisting">// instantiate a proxy (does not hit the db)
Cat cat = session.Load&lt;Cat&gt;(id);
// hit the db to initialize the proxy
if ( cat.IsDomesticCat ) {
    DomesticCat dc = (DomesticCat) cat; // Error!
    ....
}</pre><p>
                Secondly, it is possible to break proxy <tt class="literal">==</tt>.
            </p><pre class="programlisting">// instantiate a Cat proxy
Cat cat = session.Load&lt;Cat&gt;(id);
DomesticCat dc =
        // acquire new DomesticCat proxy!
        session.Load&lt;DomesticCat&gt;(id);
Console.WriteLine(cat == dc); // false</pre><p>
                However, the situation is not quite as bad as it looks. Even though we now have two references
                to different proxy objects, the underlying instance will still be the same object:
            </p><pre class="programlisting">cat.Weight = 11.0;  // hit the db to initialize the proxy
Console.WriteLine( dc.Weight );  // 11.0</pre><p>
                Third, you may not use a proxy for a <tt class="literal">sealed</tt> class or a class
                with any non-overridable public members.
            </p><p>
                Finally, if your persistent object acquires any resources upon instantiation (eg. in
                initializers or default constructor), then those resources will also be acquired by
                the proxy. The proxy class is an actual subclass of the persistent class.
            </p><p>
                These problems are all due to fundamental limitations in .NET's single inheritance model.
                If you wish to avoid these problems your persistent classes must each implement an interface
                that declares its business methods. You should specify these interfaces in the mapping file. eg.
            </p><pre class="programlisting">&lt;class name="CatImpl" proxy="ICat"&gt;
    ......
    &lt;subclass name="DomesticCatImpl" proxy="IDomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                where <tt class="literal">CatImpl</tt> implements the interface <tt class="literal">ICat</tt> and
                <tt class="literal">DomesticCatImpl</tt> implements the interface <tt class="literal">IDomesticCat</tt>. Then
                proxies for instances of <tt class="literal">ICat</tt> and <tt class="literal">IDomesticCat</tt> may be returned
                by <tt class="literal">Load()</tt> or <tt class="literal">Enumerable()</tt>. (Note that <tt class="literal">List()</tt>
                does not usually return proxies.)
            </p><pre class="programlisting">ICat cat = session.Load&lt;CatImpl&gt;(catid);
using(var iter = session
    .CreateQuery("from CatImpl as cat where cat.Name='fritz'")
    .Enumerable&lt;CatImpl&gt;()
    .GetEnumerator())
{
    iter.MoveNext();
    ICat fritz = iter.Current;
}</pre><p>
                Relationships are also lazily initialized. This means you must declare any properties to be of
                type <tt class="literal">ICat</tt>, not <tt class="literal">CatImpl</tt>.
            </p><p>
                Certain operations do <span class="emphasis"><em>not</em></span> require proxy initialization
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">Equals()</tt>, if the persistent class does not override
                        <tt class="literal">Equals()</tt>
                    </p></li><li><p>
                        <tt class="literal">GetHashCode()</tt>, if the persistent class does not override
                        <tt class="literal">GetHashCode()</tt>
                    </p></li><li><p>
                        The identifier getter method
                    </p></li></ul></div><p>
                NHibernate will detect persistent classes that override <tt class="literal">Equals()</tt> or
                <tt class="literal">GetHashCode()</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-initialization"></a>21.1.4.&nbsp;Initializing collections and proxies</h3></div></div><div></div></div><p>
                A <tt class="literal">LazyInitializationException</tt> will be thrown by NHibernate if an uninitialized 
                collection or proxy is accessed outside of the scope of the <tt class="literal">ISession</tt>, ie. when 
                the entity owning the collection or having the reference to the proxy is in the detached state.
            </p><p>
                Sometimes we need to ensure that a proxy or collection is initialized before closing the
                <tt class="literal">ISession</tt>. Of course, we can alway force initialization by calling
                <tt class="literal">cat.Sex</tt> or <tt class="literal">cat.Kittens.Count</tt>, for example.
                But that is confusing to readers of the code and is not convenient for generic code.
            </p><p>
                The static methods <tt class="literal">NHibernateUtil.Initialize()</tt> and <tt class="literal">NHibernateUtil.IsInitialized()</tt>
                provide the application with a convenient way of working with lazily initialized collections or
                proxies. <tt class="literal">NHibernateUtil.Initialize(cat)</tt> will force the initialization of a proxy,
                <tt class="literal">cat</tt>, as long as its <tt class="literal">ISession</tt> is still open.
                <tt class="literal">NHibernateUtil.Initialize( cat.Kittens )</tt> has a similar effect for the collection
                of kittens.
            </p><p>
                Another option is to keep the <tt class="literal">ISession</tt> open until all needed
                collections and proxies have been loaded. In some application architectures,
                particularly where the code that accesses data using NHibernate, and the code that
                uses it are in different application layers or different physical processes, it 
                can be a problem to ensure that the <tt class="literal">ISession</tt> is open when a 
                collection is initialized. There are two basic ways to deal with this issue:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        In a web-based application, a <tt class="literal">HttpModule</tt> can be used
                        to close the <tt class="literal">ISession</tt> only at the very end of a user
                        request, once the rendering of the view is complete (the <span class="emphasis"><em>Open
                        Session in View</em></span> pattern).  Of course, this places heavy demands
                        on the correctness of the exception handling of your application infrastructure. 
                        It is vitally important that the <tt class="literal">ISession</tt> is closed and the 
                        transaction ended before returning to the user, even when an exception occurs 
                        during rendering of the view. See the NHibernate Wiki for examples of this
                        "Open Session in View" pattern.
                    </p></li><li><p>
                        In an application with a separate business tier, the business logic must
                        "prepare" all collections that will be needed by the web tier before
                        returning. This means that the business tier should load all the data and
                        return all the data already initialized to the presentation/web tier that
                        is required for a particular use case. Usually, the application calls
                        <tt class="literal">NHibernateUtil.Initialize()</tt> for each collection that will
                        be needed in the web tier (this call must occur before the session is closed)
                        or retrieves the collection eagerly using a NHibernate query with a
                        <tt class="literal">FETCH</tt> clause or a <tt class="literal">SelectMode.Fetch</tt> in
                        <tt class="literal">ICriteria</tt>. This is usually easier if you adopt the
                        <span class="emphasis"><em>Command</em></span> pattern instead of a <span class="emphasis"><em>Session Facade</em></span>.
                    </p></li><li><p>
                        You may also attach a previously loaded object to a new <tt class="literal">ISession</tt>
                        with <tt class="literal">Merge()</tt> or <tt class="literal">Lock()</tt> before
                        accessing uninitialized collections (or other proxies). No, NHibernate does not,
                        and certainly <span class="emphasis"><em>should</em></span> not do this automatically, since it 
                        would introduce ad hoc transaction semantics!
                    </p></li></ul></div><p>
                Sometimes you don't want to initialize a large collection, but still need some
                information about it (like its size) or a subset of the data.
            </p><p>
                You can use a collection filter to get the size of a collection without initializing it:
            </p><pre class="programlisting">s.CreateFilter(collection, "select count(*)").UniqueResult&lt;long&gt;()</pre><p>
                The <tt class="literal">CreateFilter()</tt> method is also used to efficiently retrieve subsets
                of a collection without needing to initialize the whole collection:
            </p><pre class="programlisting">s.CreateFilter(lazyCollection, "").SetFirstResult(0).SetMaxResults(10).List&lt;Entity&gt;();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-batch"></a>21.1.5.&nbsp;Using batch fetching</h3></div></div><div></div></div><p>
                NHibernate can make efficient use of batch fetching, that is, NHibernate can load several uninitialized
                proxies if one proxy is accessed (or collections). Batch fetching is an optimization of the lazy select
                fetching strategy. There are two ways you can tune batch fetching: on the class and the collection level.
            </p><p>
                Batch fetching for classes/entities is easier to understand. Imagine you have the following situation
                at runtime: You have 25 <tt class="literal">Cat</tt> instances loaded in an <tt class="literal">ISession</tt>, each
                <tt class="literal">Cat</tt> has a reference to its <tt class="literal">Owner</tt>, a <tt class="literal">Person</tt>.
                The <tt class="literal">Person</tt> class is mapped with a proxy, <tt class="literal">lazy="true"</tt>. If you now
                iterate through all cats and call <tt class="literal">cat.Owner</tt> on each, NHibernate will by default
                execute 25 <tt class="literal">SELECT</tt> statements, to retrieve the proxied owners. You can tune this
                behavior by specifying a <tt class="literal">batch-size</tt> in the mapping of <tt class="literal">Person</tt>:
            </p><pre class="programlisting">&lt;class name="Person" batch-size="10"&gt;...&lt;/class&gt;</pre><p>
                NHibernate will now execute only three queries, the pattern is 10, 10, 5.
            </p><p>
                You may also enable batch fetching of collections. For example, if each <tt class="literal">Person</tt> has
                a lazy collection of <tt class="literal">Cat</tt>s, and 10 persons are currently loaded in the
                <tt class="literal">ISession</tt>, iterating through all persons will generate 10 <tt class="literal">SELECT</tt>s,
                one for every call to <tt class="literal">person.Cats</tt>. If you enable batch fetching for the
                <tt class="literal">Cats</tt> collection in the mapping of <tt class="literal">Person</tt>, NHibernate can pre-fetch
                collections:
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;set name="Cats" batch-size="3"&gt;
        ...
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
                With a <tt class="literal">batch-size</tt> of 3, NHibernate will load 3, 3, 3, 1 collections in four
                <tt class="literal">SELECT</tt>s. Again, the value of the attribute depends on the expected number of
                uninitialized collections in a particular <tt class="literal">Session</tt>.
            </p><p>
                Batch fetching of collections is particularly useful if you have a nested tree of items, ie.
                the typical bill-of-materials pattern. (Although a <span class="emphasis"><em>nested set</em></span> or a
                <span class="emphasis"><em>materialized path</em></span> might be a better option for read-mostly trees.)
            </p><p>
              <span class="emphasis"><em>Note:</em></span> if you set <tt class="literal">default_batch_fetch_size</tt>
              in configuration, NHibernate will configure the batch fetch optimization for lazy fetching
              globally. Batch sizes specified at more granular level take precedence.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-subselect"></a>21.1.6.&nbsp;Using subselect fetching</h3></div></div><div></div></div><p>
                If one lazy collection or single-valued proxy has to be fetched, NHibernate loads all of
                them, re-running the original query in a subselect. This works in the same way as
                batch-fetching, without the piecemeal loading.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-cache"></a>21.2.&nbsp;The Second Level Cache</h2></div></div><div></div></div><p>
            A NHibernate <tt class="literal">ISession</tt> is a transaction-level cache of persistent data. It is
            possible to configure a cluster or process-level (<tt class="literal">ISessionFactory</tt>-level) cache on 
            a class-by-class and collection-by-collection basis. You may even plug in a clustered cache. Be 
            careful. Caches are never aware of changes made to the persistent store by another application 
            (though they may be configured to regularly expire cached data).
            <span class="emphasis"><em>In NHibernate 1.x the second level cache does not work correctly in combination with
            distributed transactions.</em></span>
        </p><p>
          The second level cache requires the use of transactions, be it through transaction scopes or NHibernate
          transactions. Interacting with the data store without an explicit transaction is discouraged, and will
          not allow the second level cache to work as intended.
        </p><p>
            By default, NHibernate uses HashtableCache for process-level caching. You may choose a different
            implementation by specifying the name of a class that implements <tt class="literal">NHibernate.Cache.ICacheProvider</tt> 
            using the property <tt class="literal">cache.provider_class</tt>.
        </p><div class="table"><a name="cacheproviders"></a><p class="title"><b>Table&nbsp;21.1.&nbsp;Cache Providers</b></p><table summary="Cache Providers" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">Provider class</th><th align="left">Type</th><th align="left">Cluster Safe</th><th align="left">Query Cache Supported</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left"><tt class="literal">NHibernate.Cache.HashtableCacheProvider</tt></td><td align="left">memory</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">ASP.NET Cache (System.Web.Cache)</td><td align="left"><tt class="literal">NHibernate.Caches.SysCache.SysCacheProvider, NHibernate.Caches.SysCache</tt></td><td align="left">memory</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">Prevalence Cache</td><td align="left"><tt class="literal">NHibernate.Caches.Prevalence.PrevalenceCacheProvider, NHibernate.Caches.Prevalence</tt></td><td align="left">memory, disk</td><td align="left">&nbsp;</td><td align="left">yes</td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-mapping"></a>21.2.1.&nbsp;Cache mappings</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;cache&gt;</tt> element of a class or collection mapping has the
                following form:
            </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="read-write|nonstrict-read-write|read-only"                <span class="co">(1)</span>
    region="RegionName"                                              <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">usage</tt> specifies the caching strategy:
                            <tt class="literal">read-write</tt>,
                            <tt class="literal">nonstrict-read-write</tt> or
                            <tt class="literal">read-only</tt>
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">region</tt> (optional, defaults to the class or
                            collection role name) specifies the name of the second level cache 
                            region
                        </p></td></tr></table></div></div><p>
                Alternatively (preferably?), you may specify <tt class="literal">&lt;class-cache&gt;</tt> and 
                <tt class="literal">&lt;collection-cache&gt;</tt> elements in <tt class="literal">hibernate.cfg.xml</tt>.
            </p><p>
                The <tt class="literal">usage</tt> attribute specifies a <span class="emphasis"><em>cache concurrency strategy</em></span>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readonly"></a>21.2.2.&nbsp;Strategy: read only</h3></div></div><div></div></div><p>
                If your application needs to read but never modify instances of a persistent class, a 
                <tt class="literal">read-only</tt> cache may be used. This is the simplest and best performing
                strategy. Its even perfectly safe for use in a cluster.
            </p><pre class="programlisting">&lt;class name="Eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readwrite"></a>21.2.3.&nbsp;Strategy: read/write</h3></div></div><div></div></div><p>
                If the application needs to update data, a <tt class="literal">read-write</tt> cache might be appropriate. 
                This cache strategy should never be used if serializable transaction isolation level is required.
                You should ensure that the transaction is completed when <tt class="literal">ISession.Close()</tt> or
                <tt class="literal">ISession.Disconnect()</tt> is called. If you wish to use this strategy in a cluster,
                you should ensure that the underlying cache implementation supports locking. The built-in cache
                providers do <span class="emphasis"><em>not</em></span>.
            </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="Kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-nonstrict"></a>21.2.4.&nbsp;Strategy: nonstrict read/write</h3></div></div><div></div></div><p>
                If the application only occasionally needs to update data (ie. if it is extremely unlikely that two 
                transactions would try to update the same item simultaneously) and strict transaction isolation is
                not required, a <tt class="literal">nonstrict-read-write</tt> cache might be appropriate.
                When using this strategy you should ensure that the transaction is completed when
                <tt class="literal">ISession.Close()</tt> or <tt class="literal">ISession.Disconnect()</tt> is called.
                
            </p></div><p>
            The following table shows which providers are compatible with which concurrency strategies.
        </p><div class="table"><a name="d0e17511"></a><p class="title"><b>Table&nbsp;21.2.&nbsp;Cache Concurrency Strategy Support</b></p><table summary="Cache Concurrency Strategy Support" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">SysCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">PrevalenceCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr></tbody></table></div><p>
            Refer to <a href="caches.html" title="Chapter&nbsp;27.&nbsp;NHibernate.Caches">Chapter&nbsp;27, <i>NHibernate.Caches</i></a> for more details.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-sessioncache"></a>21.3.&nbsp;Managing the caches</h2></div></div><div></div></div><p>
            Whenever you pass an object to <tt class="literal">Save()</tt>, <tt class="literal">Update()</tt>
            or <tt class="literal">SaveOrUpdate()</tt> and whenever you retrieve an object using 
            <tt class="literal">Load()</tt>, <tt class="literal">Get()</tt>, <tt class="literal">List()</tt>,
            or <tt class="literal">Enumerable()</tt>, that object is added to the internal cache of the
            <tt class="literal">ISession</tt>.
        </p><p>
            When <tt class="literal">Flush()</tt> is subsequently called, the state of that object will
            be synchronized with the database. If you do not want this synchronization to occur or
            if you are processing a huge number of objects and need to manage memory efficiently,
            the <tt class="literal">Evict()</tt> method may be used to remove the object and its collections
            from the first-level cache.
        </p><pre class="programlisting">IEnumerable&lt;Cat&gt; cats = sess
    .CreateQuery("from Eg.Cat as cat")
    .List&lt;Cat&gt;(); //a huge result set
foreach (Cat cat in cats)
{
    DoSomethingWithACat(cat);
    sess.Evict(cat);
}</pre><p>
            NHibernate will evict associated entities automatically if the association is mapped
            with <tt class="literal">cascade="all"</tt> or <tt class="literal">cascade="all-delete-orphan"</tt>.
        </p><p>
            The <tt class="literal">ISession</tt> also provides a <tt class="literal">Contains()</tt> method
            to determine if an instance belongs to the session cache.
        </p><p>
            To completely evict all objects from the session cache, call <tt class="literal">ISession.Clear()</tt>
        </p><p>
            For the second-level cache, there are methods defined on <tt class="literal">ISessionFactory</tt> for 
            evicting the cached state of an instance, entire class, collection instance or entire collection 
            role.
        </p><pre class="programlisting">//evict a particular Cat
sessionFactory.Evict(typeof(Cat), catId);
//evict all Cats
sessionFactory.Evict(typeof(Cat));
//evict a particular collection of kittens
sessionFactory.EvictCollection("Eg.Cat.Kittens", catId);
//evict all kitten collections
sessionFactory.EvictCollection("Eg.Cat.Kittens");</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-querycache"></a>21.4.&nbsp;The Query Cache</h2></div></div><div></div></div><p>
            Query result sets may also be cached. This is only useful for queries that are run
            frequently with the same parameters. To use the query cache you must first enable it:
        </p><pre class="programlisting">&lt;property name="cache.use_query_cache"&gt;true&lt;/property&gt;&gt;</pre><p>
            This setting causes the creation of two new cache regions - one holding cached query
            result sets (<tt class="literal">NHibernate.Cache.StandardQueryCache</tt>), the other
            holding timestamps of the most recent updates to queryable tables
            (<tt class="literal">UpdateTimestampsCache</tt>). Those region names will be prefixed by the
            cache region prefix if <tt class="literal">cache.region_prefix</tt> setting is configured.
        </p><p>
            If you use a cache provider handling an expiration for cached entries, you should set
            the <tt class="literal">UpdateTimestampsCache</tt> region expiration to a value greater than
            the expiration of query cache regions. (Or disable its expiration.) Otherwise the query
            cache may yield stale data.
        </p><p>
            Note that the query cache does not cache the state of any entities in the result set;
            it caches only identifier values and results of value type. So the query cache should
            always be used in conjunction with the second-level cache.
        </p><p>
            Most queries do not benefit from caching, so by default queries are not cached. To
            enable caching, call <tt class="literal">IQuery.SetCacheable(true)</tt>. This call allows
            the query to look for existing cache results or add its results to the cache when
            it is executed.
        </p><p>
            If you require fine-grained control over query cache expiration policies, you may
            specify a named cache region for a particular query by calling 
            <tt class="literal">IQuery.SetCacheRegion()</tt>.
        </p><pre class="programlisting">var blogs = sess.CreateQuery("from Blog blog where blog.Blogger = :blogger")
    .SetEntity("blogger", blogger)
    .SetMaxResults(15)
    .SetCacheable(true)
    .SetCacheRegion("frontpages")
    .List&lt;Blog&gt;();</pre><p>
            If the query should force a refresh of its query cache region, you may call
            <tt class="literal">IQuery.SetForceCacheRefresh()</tt> to <tt class="literal">true</tt>.
            This is particularly useful in cases where underlying data may have been updated
            via a separate process (i.e., not modified through NHibernate) and allows the
            application to selectively refresh the query cache regions based on its
            knowledge of those events. This is a more efficient alternative to eviction of 
            a query cache region via <tt class="literal">ISessionFactory.EvictQueries()</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-collections"></a>21.5.&nbsp;Understanding Collection performance</h2></div></div><div></div></div><p>
            We've already spent quite some time talking about collections.
            In this section we will highlight a couple more issues about
            how collections behave at runtime.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-taxonomy"></a>21.5.1.&nbsp;Taxonomy</h3></div></div><div></div></div><p>NHibernate defines three basic kinds of collections:</p><div class="itemizedlist"><ul type="disc"><li><p>collections of values</p></li><li><p>one to many associations</p></li><li><p>many to many associations</p></li></ul></div><p>
                This classification distinguishes the various table and foreign key
                relationships but does not tell us quite everything we need to know
                about the relational model. To fully understand the relational structure
                and performance characteristics, we must also consider the structure of
                the primary key that is used by NHibernate to update or delete collection
                rows. This suggests the following classification:
            </p><div class="itemizedlist"><ul type="disc"><li><p>indexed collections</p></li><li><p>sets</p></li><li><p>bags</p></li></ul></div><p>
                All indexed collections (maps, lists, arrays) have a primary key consisting
                of the <tt class="literal">&lt;key&gt;</tt> and <tt class="literal">&lt;index&gt;</tt>
                columns. In this case collection updates are usually extremely efficient -
                the primary key may be efficiently indexed and a particular row may be efficiently
                located when NHibernate tries to update or delete it.
            </p><p>
                Sets have a primary key consisting of <tt class="literal">&lt;key&gt;</tt> and element
                columns. This may be less efficient for some types of collection element, particularly
                composite elements or large text or binary fields; the database may not be able to index
                a complex primary key as efficiently.  On the other hand, for one to many or many to many
                associations, particularly in the case of synthetic identifiers, it is likely to be just
                as efficient. (Side-note: if you want <tt class="literal">SchemaExport</tt> to actually create
                the primary key of a <tt class="literal">&lt;set&gt;</tt> for you, you must declare all columns
                as <tt class="literal">not-null="true"</tt>.)
            </p><p>
                <tt class="literal">&lt;idbag&gt;</tt> mappings define a surrogate key, so they are
                always very efficient to update. In fact, they are the best case.
            </p><p>
                Bags are the worst case. Since a bag permits duplicate element values and has no
                index column, no primary key may be defined. NHibernate has no way of distinguishing
                between duplicate rows. NHibernate resolves this problem by completely removing
                (in a single <tt class="literal">DELETE</tt>) and recreating the collection whenever it
                changes. This might be very inefficient.
            </p><p>
                Note that for a one-to-many association, the "primary key" may not be the physical
                primary key of the database table - but even in this case, the above classification
                is still useful. (It still reflects how NHibernate "locates" individual rows of the
                collection.)
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficientupdate"></a>21.5.2.&nbsp;Lists, maps, idbags and sets are the most efficient collections to update</h3></div></div><div></div></div><p>
                From the discussion above, it should be clear that indexed collections
                and (usually) sets allow the most efficient operation in terms of adding,
                removing and updating elements.
            </p><p>
                There is, arguably, one more advantage that indexed collections have over sets for
                many to many associations or collections of values. Because of the structure of an
                <tt class="literal">ISet</tt>, NHibernate doesn't ever <tt class="literal">UPDATE</tt> a row when
                an element is "changed". Changes to an <tt class="literal">ISet</tt> always work via
                <tt class="literal">INSERT</tt> and <tt class="literal">DELETE</tt> (of individual rows). Once
                again, this consideration does not apply to one to many associations.
            </p><p>
                After observing that arrays cannot be lazy, we would conclude that lists, maps and
                idbags are the most performant (non-inverse) collection types, with sets not far
                behind. Sets are expected to be the most common kind of collection in NHibernate 
                applications. This is because the "set" semantics are most natural in the relational
                model.
            </p><p>
                However, in well-designed NHibernate domain models, we usually see that most collections
                are in fact one-to-many associations with <tt class="literal">inverse="true"</tt>. For these
                associations, the update is handled by the many-to-one end of the association, and so
                considerations of collection update performance simply do not apply.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficentinverse"></a>21.5.3.&nbsp;Bags and lists are the most efficient inverse collections</h3></div></div><div></div></div><p>
                Just before you ditch bags forever, there is a particular case in which bags (and also lists)
                are much more performant than sets. For a collection with <tt class="literal">inverse="true"</tt>
                (the standard bidirectional one-to-many relationship idiom, for example) we can add elements
                to a bag or list without needing to initialize (fetch) the bag elements! This is because
                <tt class="literal">IList.Add()</tt> must always succeed for a bag or <tt class="literal">IList</tt>
                (unlike an <tt class="literal">ISet</tt>). This can make the following common code much faster.
            </p><pre class="programlisting">Parent p = sess.Load&lt;Parent&gt;(id);
    Child c = new Child();
    c.Parent = p;
    p.Children.Add(c);  //no need to fetch the collection!
    sess.Flush();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-oneshotdelete"></a>21.5.4.&nbsp;One shot delete</h3></div></div><div></div></div><p>
                Occasionally, deleting collection elements one by one can be extremely inefficient. NHibernate
                isn't completely stupid, so it knows not to do that in the case of an newly-empty collection
                (if you called <tt class="literal">list.Clear()</tt>, for example). In this case, NHibernate will
                issue a single <tt class="literal">DELETE</tt> and we are done!
            </p><p>
                Suppose we add a single element to a collection of size twenty and then remove two elements.
                NHibernate will issue one <tt class="literal">INSERT</tt> statement and two <tt class="literal">DELETE</tt>
                statements (unless the collection is a bag). This is certainly desirable.
            </p><p>
                However, suppose that we remove eighteen elements, leaving two and then add thee new elements.
                There are two possible ways to proceed:
            </p><div class="itemizedlist"><ul type="disc"><li><p>Delete eighteen rows one by one and then insert three rows</p></li><li><p>Remove the whole collection (in one SQL <tt class="literal">DELETE</tt>) and insert
                all five current elements (one by one)</p></li></ul></div><p>
                NHibernate isn't smart enough to know that the second option is probably quicker in this case.
                (And it would probably be undesirable for NHibernate to be that smart; such behaviour might
                confuse database triggers, etc.)
            </p><p>
                Fortunately, you can force this behaviour (ie. the second strategy) at any time by discarding
                (ie. dereferencing) the original collection and returning a newly instantiated collection with
                all the current elements. This can be very useful and powerful from time to time.
            </p><p>
                Of course, one-shot-delete does not apply to collections mapped <tt class="literal">inverse="true"</tt>.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-batch-updates"></a>21.6.&nbsp;Batch updates</h2></div></div><div></div></div><p>
            NHibernate supports batching SQL update commands (<tt class="literal">INSERT</tt>,
            <tt class="literal">UPDATE</tt>, <tt class="literal">DELETE</tt>) with the following limitations:
        </p><div class="itemizedlist"><ul type="disc"><li><p>the NHibernate's drive used for your RDBMS may not supports batching,</p></li><li><p>since the implementation uses reflection to access members and types
                in System.Data assembly which are not normally visible, it may not function
                in environments where necessary permissions are not granted,</p></li><li><p>optimistic concurrency checking may be impaired since ADO.NET 2.0 does not
                return the number of rows affected by each statement in the batch, only
                the total number of rows affected by the batch.</p></li></ul></div><p>
            Update batching is enabled by setting <tt class="literal">adonet.batch_size</tt>
            to a non-zero value.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-multi-query"></a>21.7.&nbsp;Query batch</h2></div></div><div></div></div><p>
            This functionality allows you to execute several queries in one round-trip
            against the database server. A simple use case is executing a paged query while
            also getting the total count of results, in a single round-trip. Here is an
            example:
        </p><pre class="programlisting">using NHibernate.Multi;

...

IQueryBatch queries = s.CreateQueryBatch()
    .Add&lt;Item&gt;(
        s.CreateQuery("from Item i where i.Id &gt; ?")
         .SetInt32(0, 50).SetFirstResult(10))
    .Add&lt;long&gt;(
        s.CreateQuery("select count(*) from Item i where i.Id &gt; :id")
         .SetInt32("id", 50));
IList&lt;Item&gt; items = queries.GetResult&lt;Item&gt;(0);
long count = queries.GetResult&lt;long&gt;(1).Single();</pre><p>
            The results are got by index, ordered according to the order of queries
            added to the query batch. Instead of relying on this ordering, a key can be
            associated with each query for later retrieval:
        </p><pre class="programlisting">using NHibernate.Multi;

...

var queries = s.CreateQueryBatch()
    .Add("list", s.Query&lt;Item&gt;().Where(i =&gt; i.Id &gt; 50))
    .Add("count", s.Query&lt;Item&gt;().Where(i =&gt; i.Id &gt; 50), q =&gt; q.Count());
var count = queries.GetResult&lt;int&gt;("count").Single();
var items = queries.GetResult&lt;Item&gt;("list");</pre><p>
            The namespace <tt class="literal">NHibernate.Multi</tt> has to be imported since most query
            batch methods are extension methods.
        </p><p>
            Criteria queries are also supported by the query batch:
        </p><pre class="programlisting">var queries = s.CreateQueryBatch()
    .Add&lt;Item&gt;(
        s.CreateCriteria(typeof(Item))
         .Add(Expression.Gt("Id", 50))
         .SetFirstResult(10))
    .Add&lt;long&gt;(
        s.CreateCriteria(typeof(Item))
         .Add(Expression.Gt("Id", 50))
         .SetProject(Projections.RowCount()));
var items = queries.GetResult&lt;Item&gt;(0);
var count = queries.GetResult&lt;long&gt;(1).Single();</pre><p>
            You can add <tt class="literal">ICriteria</tt> or <tt class="literal">DetachedCriteria</tt> to the query batch.
            In fact, using DetachedCriteria in this fashion has some interesting implications.
        </p><pre class="programlisting">DetachedCriteria customersCriteria = AuthorizationService.GetAssociatedCustomersQuery();
IQueryBatch queries = session.CreateQueryBatch()
    .Add&lt;Customer&gt;(customersCriteria)
    .Add&lt;Policy&gt;(DetachedCriteria.For&lt;Policy&gt;()
        .Add(Subqueries.PropertyIn("id",
            CriteriaTransformer.Clone(customersCriteria)
                .SetProjection(Projections.Id())
            )));

IList&lt;Customer&gt; customers = queries.GetResult&lt;Customer&gt;(0);
IList&lt;Policy&gt; policies = queries.GetResult&lt;Policy&gt;(1);</pre><p>
            We get a query that represents the customers we can access, and then we can utilize this
            query further in order to perform additional logic (getting the policies of the customers we are
            associated with), all in a single database round-trip.
        </p><p>
            The query batch also supports QueryOver and sql queries. All kind of queries can be mixed in the
            same batch.
        </p><pre class="programlisting">using NHibernate.Multi;

...

var queries = s.CreateQueryBatch()
    .Add("queryOverList", s.QueryOver&lt;Item&gt;().Where(i =&gt; i.Category == "Food"))
    .Add&lt;long&gt;("sqlCount",
        s.CreateSQLQuery("select count(*) as itemCount from Item i where i.Category = :cat")
         .AddScalar("itemCount", NHibernateUtil.Int64)
         .SetString("cat", "Food"));
var count = queries.GetResult&lt;long&gt;("sqlCount").Single();
var items = queries.GetResult&lt;Item&gt;("queryOverList");</pre><p>
            Second level cache is supported by the query batch. Queries flagged as cacheable will be retrieved
            from the cache if already cached, otherwise their results will be put in the cache.
        </p><pre class="programlisting">using NHibernate.Multi;

...

var queries = s.CreateQueryBatch()
    .Add("list",
        s.Query&lt;Item&gt;()
         .Where(i =&gt; i.Id &gt; 50)
         .WithOptions(o =&gt; o.SetCacheable(true)))
    .Add&lt;long&gt;("count",
        s.CreateQuery("select count(*) from Item i where i.Id &gt; :id")
         .SetInt32("id", 50)
         .SetCacheable(true));
var count = queries.GetResult&lt;long&gt;("count").Single();
var items = queries.GetResult&lt;Item&gt;("list");</pre><p>
            Multi query is executed by concatenating the queries and sending the query to the database
            as a single string. This means that the database should support returning several result sets
            in a single query. Otherwise each query will be individually executed instead.
        </p><p>
            The first <tt class="literal">GetResult</tt> call triggers execution of the whole query batch, which
            then stores all results. Later calls only retrieve the stored results. A query batch can be
            re-executed by calling its <tt class="literal">Execute</tt> method. Once executed, no new query can be
            added to the batch.
        </p><p>
            Note that the database server is likely to enforce a limit on the maximum number of parameters
            in a query, in which case the limit applies to the query batch as a whole. Queries using
            <tt class="literal">in</tt> with a large number of arguments passed as parameters may easily exceed
            this limit. For example, SQL Server has a limit of 2,100 parameters per round-trip, and will
            throw an exception executing this query:
        </p><pre class="programlisting">int[] allEmployeesId  = ...; // 1,500 items
var queries = s.CreateQueryBatch()
    .Add&lt;Employee&gt;(
        s.CreateQuery("from Employee e where e.Id in :empIds")
         .SetParameterList("empIds", allEmployeesId)
         .SetFirstResult(10))
    .Add&lt;long&gt;(
        s.CreateQuery("select count(*) from Employee e where e.Id in :empIds")
         .SetParameterList("empIds", allEmployeesId));
queries.Execute(); // will throw an exception from SQL Server</pre><p>
            An interesting usage of the query batch is to load several collections of an object in one
            round-trip, without an expensive cartesian product (blog * users * posts).
        </p><pre class="programlisting">Blog blog = s.CreateQueryBatch()
    .Add(
        s.CreateQuery("select b from Blog b left join fetch b.Users where b.Id = :id")
         .SetInt32("id", 123))
    .Add(
        s.CreateQuery("select b from Blog b left join fetch b.Posts where b.Id = :id")
         .SetInt32("id", 123))
    .GetResult&lt;Blog&gt;(0).FirstOrDefault();</pre><p>
            You can also add queries as future queries to a query batch:
        </p><pre class="programlisting">using NHibernate.Multi;

...

var queries = s.CreateQueryBatch();
var list = queries.AddAsFuture(s.Query&lt;Item&gt;().Where(i =&gt; i.Id &gt; 50)));
var countValue = queries.AddAsFutureValue&lt;long&gt;(
    s.CreateQuery("select count(*) from Item i where i.Id &gt; :id")
     .SetInt32("id", 50));
var count = countValue.Value;
var items = list.GetEnumerable();</pre><p>
            Futures built from a query batch are executed together the first time the result of one of
            them is accessed. They are independent of futures obtained directly from the queries.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-future"></a>21.8.&nbsp;Future results</h2></div></div><div></div></div><p>
            Queries can be converted to future results instead of being directly executed. Future
            results are not evaluated till one gets executed. At that point, all defined future
            results are evaluated in one single round-trip to the database.
        </p><p>
            Future results are an alternative to using <a href="performance.html#performance-multi-query" title="21.7.&nbsp;Query batch">Section&nbsp;21.7, &#8220;Query batch&#8221;</a>.
            They avoid the need to explicitly regroup queries, but they also hide which queries will
            get executed: any pending future results of the session will be batched together, no
            matter where they were defined, included out-of-scope pending future results.
        </p><p>
            Future results are obtained by calling <tt class="literal">Future</tt> or
            <tt class="literal">FutureValue</tt> methods of a HQL, Criteria, QueryOver or SQL query.
            For LINQ queries, the methods are named <tt class="literal">ToFuture</tt> and
            <tt class="literal">ToFutureValue</tt>, see <a href="querylinq.html#querylinq-futureresults" title="18.4.&nbsp;Future results">Section&nbsp;18.4, &#8220;Future results&#8221;</a> for
            an example.
        </p><pre class="programlisting">// Define queries
IFutureEnumerable&lt;Cat&gt; cats =
    session.CreateQuery("from Cat c where c.Color = :color")
        .SetString("color", "black")
        .Future();
IFutureValue&lt;int&gt; catCount =
    session.QueryOver&lt;Cat&gt;()
        .ToRowCountQuery()
        .FutureValue&lt;int&gt;();
// Execute them
foreach(Cat cat in cats.GetEnumerable())
{
    // Do something
}
if (catCount.Value &gt; 10)
{
    // Do something
}
</pre><p>
            In the above example, accessing <tt class="literal">catCount.Value</tt> does not trigger a round-trip
            to the database: it has been evaluated with <tt class="literal">cats.GetEnumerable()</tt> call. If
            instead <tt class="literal">catCount.Value</tt> was accessed first, it would have executed both
            future results and <tt class="literal">cats.GetEnumerable()</tt> would not have triggered a round-trip
            to the database.
        </p><p>
            As showcased in the previous example, <tt class="literal">Future</tt> allows to get a future enumerable
            result, and <tt class="literal">FutureValue</tt> is meant to obtain a single value result.
        </p><p>
            Note: in NHibernate v5.1 and previous versions, Criteria/QueryOver future results were batched
            separately. Since NHibernate v5.2, they are batched with other querying API future results.
        </p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="filters.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="toolsetguide.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;20.&nbsp;Filtering data&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;22.&nbsp;Toolset Guide</td></tr></table></div>{% include google_analytics.html %}{% include metrika_yandex_ru.html %}</body></html>