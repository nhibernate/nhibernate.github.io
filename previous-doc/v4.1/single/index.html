---
layout: 
---
<!doctype html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />
    <link rel="canonical" href="https://nhibernate.info/doc/nhibernate-reference/index.html" />
   <title>NHibernate - Relational Persistence for Idiomatic .NET</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>NHibernate - Relational Persistence for Idiomatic .NET</h1></div><div><h2 class="subtitle">NHibernate Reference Documentation</h2></div><div><p class="releaseinfo">4.1</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#quickstart">1. Quickstart with IIS and Microsoft SQL Server</a></span></dt><dd><dl><dt><span class="sect1"><a href="#quickstart-intro">1.1. Getting started with NHibernate</a></span></dt><dt><span class="sect1"><a href="#quickstart-persistentclass">1.2. First persistent class</a></span></dt><dt><span class="sect1"><a href="#quickstart-mapping">1.3. Mapping the cat</a></span></dt><dt><span class="sect1"><a href="#quickstart-playingwithcats">1.4. Playing with cats</a></span></dt><dt><span class="sect1"><a href="#quickstart-summary">1.5. Finally</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">2. Architecture</a></span></dt><dd><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. Overview</a></span></dt><dt><span class="sect1"><a href="#architecture-states">2.2. Instance states</a></span></dt><dt><span class="sect1"><a href="#architecture-current-session">2.3. Contextual Sessions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#session-configuration">3. ISessionFactory Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. Programmatic Configuration</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. Obtaining an ISessionFactory</a></span></dt><dt><span class="sect1"><a href="#configuration-userjdbc">3.3. User provided ADO.NET connection</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.4. NHibernate provided ADO.NET connection</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.5. Optional configuration properties</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.5.1. SQL Dialects</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.5.2. Outer Join Fetching</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.5.3. Custom ICacheProvider</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.5.4. Query Language Substitution</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.6. Logging</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.7. Implementing an INamingStrategy</a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.8. XML Configuration File</a></span></dt></dl></dd><dt><span class="chapter"><a href="#persistent-classes">4. Persistent Classes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#persistent-classes-poco">4.1. A simple POCO example</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-poco-accessors">4.1.1. Declare properties for persistent fields</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-poco-constructor">4.1.2. Implement a default constructor</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-poco-identifier">4.1.3. Provide an identifier property (optional)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-poco-sealed">4.1.4. Prefer non-sealed classes and virtual methods (optional)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. Implementing inheritance</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. Implementing Equals() and GetHashCode()</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-dynamicmodels">4.4. Dynamic models</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-tuplizers">4.5. Tuplizers</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-lifecycle">4.6. Lifecycle Callbacks</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-validatable">4.7. IValidatable callback</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mapping">5. Basic O/R Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. Mapping declaration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-xmlns">5.1.1. XML Namespace</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subselect">5.1.4. subselect</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.5. id</a></span></dt><dd><dl><dt><span class="sect3"><a href="#mapping-declaration-id-generator">5.1.5.1. generator</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-hilo">5.1.5.2. Hi/Lo Algorithm</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-uuid-hex">5.1.5.3. UUID Hex Algorithm</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-uuid-string">5.1.5.4. UUID String Algorithm</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-guid">5.1.5.5. GUID Algorithms</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-sequences">5.1.5.6. Identity columns and Sequences</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-assigned">5.1.5.7. Assigned Identifiers</a></span></dt><dt><span class="sect3"><a href="#mapping-declaration-id-enhanced">5.1.5.8. Enhanced identifier generators</a></span></dt></dl></dd><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.6. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.7. discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.8. version (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.9. timestamp (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.10. property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.11. many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.12. one-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-naturalid">5.1.13. natural-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.14. component, dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-properties">5.1.15. properties</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.16. subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.17. joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-unionsubclass">5.1.18. union-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-join">5.1.19. join</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-collections">5.1.20. map, set, list, bag</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.21. import</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. NHibernate Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. Entities and values</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. Basic value types</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.3. Custom value types</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.2.4. Any type mappings</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.3. SQL quoted identifiers</a></span></dt><dt><span class="sect1"><a href="#mapping-modularfiles">5.4. Modular mapping files</a></span></dt><dt><span class="sect1"><a href="#mapping-generated">5.5. Generated Properties</a></span></dt><dt><span class="sect1"><a href="#mapping-database-object">5.6. Auxiliary Database Objects</a></span></dt></dl></dd><dt><span class="chapter"><a href="#collections">6. Collection Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. Persistent Collections</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. Mapping a Collection</a></span></dt><dt><span class="sect1"><a href="#collections-ofvalues">6.3. Collections of Values and Many-To-Many Associations</a></span></dt><dt><span class="sect1"><a href="#collections-onetomany">6.4. One-To-Many Associations</a></span></dt><dt><span class="sect1"><a href="#collections-lazy">6.5. Lazy Initialization</a></span></dt><dt><span class="sect1"><a href="#collections-sorted">6.6. Sorted Collections</a></span></dt><dt><span class="sect1"><a href="#collections-idbag">6.7. Using an &lt;idbag&gt;</a></span></dt><dt><span class="sect1"><a href="#collections-bidirectional">6.8. Bidirectional Associations</a></span></dt><dt><span class="sect1"><a href="#collections-ternary">6.9. Ternary Associations</a></span></dt><dt><span class="sect1"><a href="#collections-heterogeneous">6.10. Heterogeneous Associations</a></span></dt><dt><span class="sect1"><a href="#collections-example">6.11. Collection examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#components">7. Component Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#components-dependentobjects">7.1. Dependent objects</a></span></dt><dt><span class="sect1"><a href="#components-incollections">7.2. Collections of dependent objects</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">7.3. Components as IDictionary indices</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">7.4. Components as composite identifiers</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">7.5. Dynamic components</a></span></dt></dl></dd><dt><span class="chapter"><a href="#inheritance">8. Inheritance Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#inheritance-strategies">8.1. The Three Strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#inheritance-tableperclass">8.1.1. Table per class hierarchy</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass">8.1.2. Table per subclass</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass-discriminator">8.1.3. Table per subclass, using a discriminator</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixing-tableperclass-tablepersubclass">8.1.4. Mixing table per class hierarchy with table per subclass</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcrete">8.1.5. Table per concrete class</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcreate-polymorphism">8.1.6. Table per concrete class, using implicit polymorphism</a></span></dt><dt><span class="sect2"><a href="#inheritace-mixingpolymorphism">8.1.7. Mixing implicit polymorphism with other inheritance mappings</a></span></dt></dl></dd><dt><span class="sect1"><a href="#inheritance-limitations">8.2. Limitations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#manipulatingdata">9. Manipulating Persistent Data</a></span></dt><dd><dl><dt><span class="sect1"><a href="#manipulatingdata-creating">9.1. Creating a persistent object</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-loading">9.2. Loading an object</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-querying">9.3. Querying</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-scalarqueries">9.3.1. Scalar queries</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-queryinterface">9.3.2. The IQuery interface</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-filtering">9.3.3. Filtering collections</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-criteria">9.3.4. Criteria queries</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-nativesql">9.3.5. Queries in native SQL</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-updating">9.4. Updating objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-updating-insession">9.4.1. Updating in the same ISession</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-updating-detached">9.4.2. Updating detached objects</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-update-lock">9.4.3. Reattaching detached objects</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-deleting">9.5. Deleting persistent objects</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-flushing">9.6. Flush</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-endingsession">9.7. Ending a Session</a></span></dt><dd><dl><dt><span class="sect2"><a href="#manipulatingdata-endingsession-flushing">9.7.1. Flushing the Session</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-endingsession-commit">9.7.2. Committing the database transaction</a></span></dt><dt><span class="sect2"><a href="#manipulatingdata-endingsession-close">9.7.3. Closing the ISession</a></span></dt></dl></dd><dt><span class="sect1"><a href="#manipulatingdata-exceptions">9.8. Exception handling</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-graphs">9.9. Lifecyles and object graphs</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-interceptors">9.10. Interceptors</a></span></dt><dt><span class="sect1"><a href="#manipulatingdata-metadata">9.11. Metadata API</a></span></dt></dl></dd><dt><span class="chapter"><a href="#readonly">10. Read-only entities</a></span></dt><dd><dl><dt><span class="section"><a href="#readonly-api">10.1. Making persistent entities read-only</a></span></dt><dd><dl><dt><span class="section"><a href="#readonly-api-immutable">10.1.1. Entities of immutable classes</a></span></dt><dt><span class="section"><a href="#readonly-api-loaddefault">10.1.2. Loading persistent entities as read-only</a></span></dt><dt><span class="section"><a href="#readonly-api-querycriteria">10.1.3. Loading read-only entities from an HQL query/criteria</a></span></dt><dt><span class="section"><a href="#readonly-api-entity">10.1.4. Making a persistent entity read-only</a></span></dt></dl></dd><dt><span class="section"><a href="#readonly-proptypes">10.2. Read-only affect on property type</a></span></dt><dd><dl><dt><span class="section"><a href="#readonly-proptypes-simple">10.2.1. Simple properties</a></span></dt><dt><span class="section"><a href="#readonly-prop-types-unidir">10.2.2. Unidirectional associations</a></span></dt><dd><dl><dt><span class="section"><a href="#readonly-proptypes-singleended-unidir">10.2.2.1. Unidirectional one-to-one and many-to-one</a></span></dt><dt><span class="section"><a href="#readonly-proptypes-manyended-unidir">10.2.2.2. Unidirectional one-to-many and many-to-many</a></span></dt></dl></dd><dt><span class="section"><a href="#readonly-proptypes-bidir">10.2.3. Bidirectional associations</a></span></dt><dd><dl><dt><span class="section"><a href="#readonly-proptypes-onetoone-bidir">10.2.3.1. Bidirectional one-to-one</a></span></dt><dt><span class="section"><a href="#readonly-proptypes-onetomany-manytoone">10.2.3.2. Bidirectional one-to-many/many-to-one</a></span></dt><dt><span class="section"><a href="#readonly-proptypes-manytomany-bidir">10.2.3.3. Bidirectional many-to-many</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#transactions">11. Transactions And Concurrency</a></span></dt><dd><dl><dt><span class="sect1"><a href="#transactions-basics">11.1. Configurations, Sessions and Factories</a></span></dt><dt><span class="sect1"><a href="#transactions-threads">11.2. Threads and connections</a></span></dt><dt><span class="sect1"><a href="#transactions-identity">11.3. Considering object identity</a></span></dt><dt><span class="sect1"><a href="#transactions-optimistic">11.4. Optimistic concurrency control</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-longsession">11.4.1. Long session with automatic versioning</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">11.4.2. Many sessions with automatic versioning</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-customizing">11.4.3. Customizing automatic versioning</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-manual">11.4.4. Application version checking</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-disconnection">11.5. Session disconnection</a></span></dt><dt><span class="sect1"><a href="#transactions-locking">11.6. Pessimistic Locking</a></span></dt><dt><span class="sect1"><a href="#transactions-connection-release">11.7. Connection Release Modes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#events">12. Interceptors and events</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-interceptors">12.1. Interceptors</a></span></dt><dt><span class="sect1"><a href="#objectstate-events">12.2. Event system</a></span></dt></dl></dd><dt><span class="chapter"><a href="#batch">13. Batch processing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#batch-inserts">13.1. Batch inserts</a></span></dt><dt><span class="sect1"><a href="#batch-statelesssession">13.2. The StatelessSession interface</a></span></dt><dt><span class="sect1"><a href="#batch-direct">13.3. DML-style operations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queryhql">14. HQL: The Hibernate Query Language</a></span></dt><dd><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">14.1. Case Sensitivity</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">14.2. The from clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">14.3. Associations and joins</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">14.4. The select clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">14.5. Aggregate functions</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">14.6. Polymorphic queries</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">14.7. The where clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">14.8. Expressions</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">14.9. The order by clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">14.10. The group by clause</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">14.11. Subqueries</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">14.12. HQL examples</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">14.13. Tips &amp; Tricks</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querycriteria">15. Criteria Queries</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querycriteria-creating">15.1. Creating an ICriteria instance</a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">15.2. Narrowing the result set</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">15.3. Ordering the results</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">15.4. Associations</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">15.5. Dynamic association fetching</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">15.6. Example queries</a></span></dt><dt><span class="sect1"><a href="#querycriteria-projection">15.7. Projections, aggregation and grouping</a></span></dt><dt><span class="sect1"><a href="#querycriteria-detachedqueries">15.8. Detached queries and subqueries</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queryqueryover">16. QueryOver Queries</a></span></dt><dd><dl><dt><span class="sect1"><a href="#queryqueryover-querystructure">16.1. Structure of a Query</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-simpleexpressions">16.2. Simple Expressions</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-additionalrestrictions">16.3. Additional Restrictions</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-associations">16.4. Associations</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-aliases">16.5. Aliases</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-projections">16.6. Projections</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-projectionfunctions">16.7. Projection Functions</a></span></dt><dt><span class="sect1"><a href="#queryqueryover-subqueries">16.8. Subqueries</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querysql">17. Native SQL</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querysql-creating">17.1. Using an ISQLQuery</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e11290">17.1.1. Scalar queries</a></span></dt><dt><span class="sect2"><a href="#d0e11311">17.1.2. Entity queries</a></span></dt><dt><span class="sect2"><a href="#d0e11347">17.1.3. Handling associations and collections</a></span></dt><dt><span class="sect2"><a href="#d0e11378">17.1.4. Returning multiple entities</a></span></dt><dd><dl><dt><span class="sect3"><a href="#querysql-aliasreferences">17.1.4.1. Alias and property references</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e11519">17.1.5. Returning non-managed entities</a></span></dt><dt><span class="sect2"><a href="#d0e11554">17.1.6. Handling inheritance</a></span></dt><dt><span class="sect2"><a href="#d0e11559">17.1.7. Parameters</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-namedqueries">17.2. Named SQL queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#propertyresults">17.2.1. Using return-property to explicitly specify column/alias
      names</a></span></dt><dt><span class="sect2"><a href="#sp_query">17.2.2. Using stored procedures for querying</a></span></dt><dd><dl><dt><span class="sect3"><a href="#querysql-limits-storedprocedures">17.2.2.1. Rules/limitations for using stored procedures</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#querysql-cud">17.3. Custom SQL for create, update and delete</a></span></dt><dt><span class="sect1"><a href="#querysql-load">17.4. Custom SQL for loading</a></span></dt></dl></dd><dt><span class="chapter"><a href="#filters">18. Filtering data</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-filters">18.1. NHibernate filters</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">19. Improving performance</a></span></dt><dd><dl><dt><span class="sect1"><a href="#performance-fetching">19.1. Fetching strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-fetching-lazy">19.1.1. Working with lazy associations</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-custom">19.1.2. Tuning fetch strategies</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-proxies">19.1.3. Single-ended association proxies</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-initialization">19.1.4. Initializing collections and proxies</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-batch">19.1.5. Using batch fetching</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-subselect">19.1.6. Using subselect fetching</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-cache">19.2. The Second Level Cache</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">19.2.1. Cache mappings</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">19.2.2. Strategy: read only</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">19.2.3. Strategy: read/write</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">19.2.4. Strategy: nonstrict read/write</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">19.3. Managing the caches</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">19.4. The Query Cache</a></span></dt><dt><span class="sect1"><a href="#performance-collections">19.5. Understanding Collection performance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">19.5.1. Taxonomy</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">19.5.2. Lists, maps, idbags and sets are the most efficient collections to update</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">19.5.3. Bags and lists are the most efficient inverse collections</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">19.5.4. One shot delete</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-batch-updates">19.6. Batch updates</a></span></dt><dt><span class="sect1"><a href="#performance-multi-query">19.7. Multi Query</a></span></dt><dt><span class="sect1"><a href="#performance-multi-criteria">19.8. Multi Criteria</a></span></dt></dl></dd><dt><span class="chapter"><a href="#toolsetguide">20. Toolset Guide</a></span></dt><dd><dl><dt><span class="sect1"><a href="#toolsetguide-s1">20.1. Schema Generation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">20.1.1. Customizing the schema</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">20.1.2. Running the tool</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">20.1.3. Properties</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">20.1.4. Using Ant</a></span></dt></dl></dd><dt><span class="sect1"><a href="#toolsetguide-s2">20.2. Code Generation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-parentchild">21. Example: Parent/Child</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-parentchild-collections">21.1. A note about collections</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">21.2. Bidirectional one-to-many</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">21.3. Cascading lifecycle</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">21.4. Using cascading Update()</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">21.5. Conclusion</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-weblog">22. Example: Weblog Application</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-weblog-classes">22.1. Persistent Classes</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">22.2. NHibernate Mappings</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">22.3. NHibernate Code</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-mappings">23. Example: Various Mappings</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-mappings-emp">23.1. Employer/Employee</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">23.2. Author/Work</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">23.3. Customer/Order/Product</a></span></dt></dl></dd><dt><span class="chapter"><a href="#best-practices">24. Best Practices</a></span></dt><dt><span class="part"><a href="#part-contrib">I. NHibernateContrib Documentation</a></span></dt><dd><dl><dt><span class="preface"><a href="#contrib-preface">Preface</a></span></dt><dt><span class="chapter"><a href="#caches">25. NHibernate.Caches</a></span></dt><dd><dl><dt><span class="section"><a href="#NHibernate.Caches-howto">25.1. How to use a cache?</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.Prevalence">25.2. Prevalence Cache Configuration</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.SysCache">25.3. SysCache Configuration</a></span></dt><dt><span class="section"><a href="#NHibernate.Caches.SysCache2">25.4. SysCache2 Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14394">25.4.1. Table-based Dependency</a></span></dt><dt><span class="section"><a href="#d0e14440">25.4.2. Command-Based Dependencies</a></span></dt><dt><span class="section"><a href="#d0e14510">25.4.3. Aggregate Dependencies</a></span></dt><dt><span class="section"><a href="#d0e14525">25.4.4. Additional Settings</a></span></dt><dt><span class="section"><a href="#d0e14565">25.4.5. Patches</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#mapping-attributes">26. NHibernate.Mapping.Attributes</a></span></dt><dd><dl><dt><span class="section"><a href="#mapping-attributes-new">26.1. What's new?</a></span></dt><dt><span class="section"><a href="#mapping-attributes-howto">26.2. How to use it?</a></span></dt><dt><span class="section"><a href="#mapping-attributes-tips">26.3. Tips</a></span></dt><dt><span class="section"><a href="#mapping-attributes-todo">26.4. Known issues and TODOs</a></span></dt><dt><span class="section"><a href="#mapping-attributes-devnotes">26.5. Developer Notes</a></span></dt></dl></dd></dl></dd></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div><div></div></div><p>
		Working with object-oriented software and a relational database can be cumbersome
		and time consuming in today's enterprise environments. NHibernate is an object/relational
		mapping tool for .NET environments. The term object/relational mapping (ORM) refers to
		the technique of mapping a data representation from an object model to a relational
		data model with a SQL-based schema.
	</p><p>
		NHibernate not only takes care of the mapping from .NET classes to
		database tables (and from .NET data types to SQL data types), but also provides data
		query and retrieval facilities and can significantly reduce development time otherwise
		spent with manual data handling in SQL and ADO.NET.
	</p><p>
		NHibernate's goal is to relieve the developer from 95 percent of common data persistence
		related programming tasks. NHibernate may not be the best solution for data-centric
		applications that only use stored-procedures to implement the business logic in the
		database, it is most useful with object-oriented domain models and business logic in
		the .NET-based middle-tier. However, NHibernate can certainly help you to remove or
		encapsulate vendor-specific SQL code and will help with the common task of result set
		translation from a tabular representation to a graph of objects.
	</p><p>
		If you are new to NHibernate and Object/Relational Mapping or even .NET Framework,
		please follow these steps:
	</p><div class="orderedlist"><ol type="1"><li><p>
				Read <a href="#quickstart" title="Chapter&nbsp;1.&nbsp;Quickstart with IIS and Microsoft SQL Server">Chapter&nbsp;1, <i>Quickstart with IIS and Microsoft SQL Server</i></a> for a 30 minute tutorial,
				using Internet Information Services (IIS) web server.
			</p></li><li><p>
				Read <a href="#architecture" title="Chapter&nbsp;2.&nbsp;Architecture">Chapter&nbsp;2, <i>Architecture</i></a> to understand the environments where
				NHibernate can be used.
			</p></li><li><p>
				Use this reference documentation as your primary source of information.
				Consider reading <span class="emphasis"><em>Hibernate in Action</em></span>
				(java <a href="http://www.manning.com/bauer/" target="_top">http://www.manning.com/bauer/</a>)
				or <span class="emphasis"><em>NHibernate in Action</em></span>
				(<a href="http://www.manning.com/kuate/" target="_top">http://www.manning.com/kuate/</a>)
        or <span class="emphasis"><em>NHibernate 3.0 Cookbook</em></span>
        (<a href="https://www.packtpub.com/nhibernate-3-0-cookbook/book" target="_top">https://www.packtpub.com/nhibernate-3-0-cookbook/book</a>)
        or <span class="emphasis"><em>NHibernate 2 Beginner's Guide</em></span>
        (<a href="http://www.packtpub.com/nhibernate-2-x-beginners-guide/book" target="_top">http://www.packtpub.com/nhibernate-2-x-beginners-guide/book</a>)if you need more help
        with application design or if you prefer a step-by-step tutorial. Also visit
        <a href="http://nhibernate.sourceforge.net/NHibernateEg/" target="_top">http://nhibernate.sourceforge.net/NHibernateEg/</a> for NHibernate
				tutorial with examples.
			</p></li><li><p>
        FAQs are answered on the <a href="http://groups.google.com/group/nhusers" target="_top">NHibernate users group</a>.
      </p></li><li><p>
				The Community Area on the <a href="https://nhibernate.info/" target="_top">NHibernate website</a> is a good source for
				design patterns and various integration solutions (ASP.NET, Windows	Forms).
			</p></li></ol></div><p>
		 If you have questions, use the
		 <a href="http://groups.google.com/group/nhusers" target="_top">NHibernate user forum</a>.
		 We also provide a <a href="https://nhibernate.jira.com/" target="_top">JIRA issue trackings system</a>
		 for bug reports and feature requests.
		 If you are interested in the development of NHibernate, join the developer mailing list.
		 If you are interested in translating this documentation into your language, contact us
		 on the <a href="http://groups.google.com/group/nhibernate-development" target="_top">developer mailing list</a>.
	 </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="quickstart"></a>Chapter&nbsp;1.&nbsp;Quickstart with IIS and Microsoft SQL Server</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-intro"></a>1.1.&nbsp;Getting started with NHibernate</h2></div></div><div></div></div><p>
            This tutorial explains a setup of NHibernate 4.1 within a Microsoft
            environment. The tools used in this tutorial are:
        </p><div class="orderedlist"><ol type="1"><li>
                Microsoft Internet Information Services (IIS) - web server supporting
                ASP.NET.
            </li><li>
                Microsoft SQL Server (at least, 2005, but can be 2008, 2008 R2, 2012 or 2014) - the database server. This tutorial uses
                the desktop edition (SQL Express), a free download from Microsoft. Support
                for other databases is only a matter of changing the NHibernate SQL
                dialect and driver configuration.
            </li><li>
                Microsoft Visual Studio .NET (at least, 2005, but can be 2008, 2010, 2012 or 2013, including the Express and Community editions) - the development environment.
            </li></ol></div><p>
            First, we have to create a new Web project. We use the name <tt class="literal">QuickStart</tt>,
            the project web virtual directory will <tt class="literal">http://localhost/QuickStart</tt>. 
            Download NHibernate, either from SourceForge (http://sourceforge.net/projects/nhibernate/) or NuGet (<tt class="literal">Install-Package NHibernate</tt>).
            In the project, add a reference to <tt class="literal">NHibernate.dll</tt> (NuGet already does this). Visual Studio
            will automatically copy the library and its dependencies to the project output directory.
            If you are using a database other than SQL Server, add a reference to its driver assembly
            to your project.
        </p><p>
            We now set up the database connection information for NHibernate. To do this, open
            the file <tt class="literal">Web.config</tt> automatically generated for your project and add
            configuration elements according to the listing below:
        </p><pre class="programlisting">
				&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
    &lt;!-- Add this element --&gt;
    &lt;configSections&gt;
        &lt;section
            name="hibernate-configuration"
            type="NHibernate.Cfg.ConfigurationSectionHandler, NHibernate"
        /&gt;
    &lt;/configSections&gt;

    &lt;!-- Add this element --&gt;
    &lt;hibernate-configuration xmlns="urn:nhibernate-configuration-2.2"&gt;
        &lt;session-factory&gt;
            &lt;property name="dialect"&gt;NHibernate.Dialect.MsSql2005Dialect&lt;/property&gt;
            &lt;property name="connection.provider"&gt;NHibernate.Connection.DriverConnectionProvider&lt;/property&gt;
            &lt;property name="connection.connection_string"&gt;Server=localhost\SQLEXPRESS;initial catalog=quickstart;Integrated Security=True&lt;/property&gt;
            &lt;mapping assembly="QuickStart" /&gt;
        &lt;/session-factory&gt;
    &lt;/hibernate-configuration&gt;

    &lt;!-- Leave the system.web section unchanged --&gt;
    &lt;system.web&gt;
        ...
    &lt;/system.web&gt;
&lt;/configuration&gt;</pre><p>
            The <tt class="literal">&lt;configSections&gt;</tt> element contains definitions of
            sections that follow and handlers to use to process their content. We declare
            the handler for the configuration section here. The <tt class="literal">
            &lt;hibernate-configuration&gt;</tt> section contains the configuration
            itself, telling NHibernate that we will use a Microsoft SQL Server 2005
            database and connect to it through the specified connection string.
            The dialect is a required setting, databases differ in their interpretation
            of the SQL "standard". NHibernate will take care of the differences and comes
            bundled with dialects for several major commercial and open source databases.
        </p><p>
            An <tt class="literal">ISessionFactory</tt> is NHibernate's concept of a single
            datastore, multiple databases can be used by creating multiple XML
            configuration files and creating multiple <tt class="literal">Configuration</tt>
            and <tt class="literal">ISessionFactory</tt> objects in your application.
        </p><p>
            The last element of the <tt class="literal">&lt;hibernate-configuration&gt;</tt>
            section declares <tt class="literal">QuickStart</tt> as the name of an assembly
            containing class declarations and mapping files. The mapping files
            contain the metadata for the mapping of the POCO class to a database table
            (or multiple tables). We'll come back to mapping files soon. Let's write the
            POCO class first and then declare the mapping metadata for it.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-persistentclass"></a>1.2.&nbsp;First persistent class</h2></div></div><div></div></div><p>
            NHibernate works best with the Plain Old CLR Objects (POCOs, sometimes
            called Plain Ordinary CLR Objects) programming model for persistent classes.
            A POCO has its data accessible through the standard .NET property mechanisms,
            shielding the internal representation from the publicly visible interface:
        </p><pre class="programlisting">namespace QuickStart
{
    public class Cat
    {
        private string id;
        private string name;
        private char   sex;
        private float  weight;

        public Cat()
        {
        }

        public virtual string Id
        {
            get { return id; }
            set { id = value; }
        }

        public virtual string Name
        {
            get { return name; }
            set { name = value; }
        }

        public virtual char Sex
        {
            get { return sex; }
            set { sex = value; }
        }

        public virtual float Weight
        {
            get { return weight; }
            set { weight = value; }
        }
    }
}</pre><p>
            NHibernate is not restricted in its usage of property types, all .NET
            types and primitives (like <tt class="literal">string</tt>, <tt class="literal">char</tt>
            and <tt class="literal">DateTime</tt>) can be mapped, including classes from the
            <tt class="literal">System.Collections</tt> namespace. You can map them as values,
            collections of values, or associations to other entities. The <tt class="literal">Id</tt>
            is a special property that represents the database identifier (primary key) of
            that class, it is highly recommended for entities like a <tt class="literal">Cat</tt>.
            NHibernate can use identifiers only internally, without having to declare them
            on the class, but we would lose some of the flexibility in our application
            architecture.
        </p><p>
            No special interface has to be implemented for persistent classes nor do we have
            to subclass from a special root persistent class. NHibernate also doesn't use any
            build time processing, such as IL manipulation, it relies solely on
            .NET reflection and runtime class enhancement.
            So, without any dependency in the POCO class on NHibernate, we can map it to
            a database table.
        </p><p>
            For the above mentioned runtime class enhancement to work, NHibernate requires that all
            public properties of an entity class are declared as <tt class="literal">virtual</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-mapping"></a>1.3.&nbsp;Mapping the cat</h2></div></div><div></div></div><p>
            The <tt class="literal">Cat.hbm.xml</tt> mapping file contains the metadata
            required for the object/relational mapping. The metadata includes declaration
            of persistent classes and the mapping of properties (to columns and
            foreign key relationships to other entities) to database tables.
        </p><p>
			Please note that the <tt class="literal">Cat.hbm.xml</tt> should be set to an embedded resource.
        </p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    namespace="QuickStart" assembly="QuickStart"&gt;

    &lt;class name="Cat" table="Cat"&gt;

        &lt;!-- A 32 hex character is our surrogate key. It's automatically
            generated by NHibernate with the UUID pattern. --&gt;
        &lt;id name="Id"&gt;
            &lt;column name="CatId" sql-type="char(32)" not-null="true"/&gt;
            &lt;generator class="uuid.hex" /&gt;
        &lt;/id&gt;

        &lt;!-- A cat has to have a name, but it shouldn' be too long. --&gt;
        &lt;property name="Name"&gt;
            &lt;column name="Name" length="16" not-null="true" /&gt;
        &lt;/property&gt;
        &lt;property name="Sex" /&gt;
        &lt;property name="Weight" /&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Every persistent class should have an identifer attribute (actually, only
            classes representing entities, not dependent value objects, which
            are mapped as components of an entity). This property is used to distinguish
            persistent objects: Two cats are equal if
            <tt class="literal">catA.Id.Equals(catB.Id)</tt> is true, this concept is
            called <span class="emphasis"><em>database identity</em></span>. NHibernate comes bundled with
            various identifer generators for different scenarios (including native generators
            for database sequences, hi/lo identifier tables, and application assigned
            identifiers). We use the UUID generator (only recommended for testing, as integer
            surrogate keys generated by the database should be prefered) and also specify the
            column <tt class="literal">CatId</tt> of the table <tt class="literal">Cat</tt> for the
            NHibernate generated identifier value (as a primary key of the table).
        </p><p>
            All other properties of <tt class="literal">Cat</tt> are mapped to the same table. In
            the case of the <tt class="literal">Name</tt> property, we mapped it with an explicit
            database column declaration. This is especially useful when the database
            schema is automatically generated (as SQL DDL statements) from the mapping
            declaration with NHibernate's <span class="emphasis"><em>SchemaExport</em></span> tool. All other
            properties are mapped using NHibernate's default settings, which is what you
            need most of the time. The table <tt class="literal">Cat</tt> in the database looks
            like this:
        </p><pre class="programlisting"> Column |     Type     | Modifiers
--------+--------------+----------------------
 CatId  | char(32)     | not null, primary key
 Name   | nvarchar(16) | not null
 Sex    | nchar(1)     |
 Weight | real         |</pre><p>
            You should now create the database and this table manually, and later read
            <a href="#toolsetguide" title="Chapter&nbsp;20.&nbsp;Toolset Guide">Chapter&nbsp;20, <i>Toolset Guide</i></a> if you want to automate this step with the
            SchemaExport tool. This tool can create a full SQL DDL, including table
            definition, custom column type constraints, unique constraints and indexes.
            If you are using SQL Server, you should also make sure the <tt class="literal">ASPNET</tt>
            user has permissions to use the database.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-playingwithcats"></a>1.4.&nbsp;Playing with cats</h2></div></div><div></div></div><p>
            We're now ready to start NHibernate's <tt class="literal">ISession</tt>. It is the
            <span class="emphasis"><em>persistence manager</em></span> interface, we use it
            to store and retrieve <tt class="literal">Cat</tt>s to and from the database.
            But first, we've to get an <tt class="literal">ISession</tt> (NHibernate's unit-of-work)
            from the <tt class="literal">ISessionFactory</tt>:
        </p><pre class="programlisting">ISessionFactory sessionFactory =
            new Configuration().Configure().BuildSessionFactory();</pre><p>
            An <tt class="literal">ISessionFactory</tt> is responsible for one database and
            may only use one XML configuration file (<tt class="literal">Web.config</tt> or
            <tt class="literal">hibernate.cfg.xml</tt>).
            You can set other properties (and even change the mapping metadata) by
            accessing the <tt class="literal">Configuration</tt> <span class="emphasis"><em>before</em></span>
            you build the <tt class="literal">ISessionFactory</tt> (it is immutable). Where
            do we create the <tt class="literal">ISessionFactory</tt> and how can we access
            it in our application?
        </p><p>
            An <tt class="literal">ISessionFactory</tt> is usually only built once,
            e.g. at startup inside <tt class="literal">Application_Start</tt> event handler.
            This also means you should not keep it in an instance variable in your
            ASP.NET pages, but in some other location. Furthermore, we need some kind of
            <span class="emphasis"><em>Singleton</em></span>, so we can access the
            <tt class="literal">ISessionFactory</tt> easily in application code. The approach
            shown next solves both problems: configuration and easy access to a
            <tt class="literal">ISessionFactory</tt>.
        </p><p>
            We implement a <tt class="literal">NHibernateHelper</tt> helper class:
        </p><pre class="programlisting">using System;
using System.Web;
using NHibernate;
using NHibernate.Cfg;

namespace QuickStart
{
    public sealed class NHibernateHelper
    {
        private const string CurrentSessionKey = "nhibernate.current_session";
        private static readonly ISessionFactory sessionFactory;

        static NHibernateHelper()
        {
            sessionFactory = new Configuration().Configure().BuildSessionFactory();
        }

        public static ISession GetCurrentSession()
        {
            HttpContext context = HttpContext.Current;
            ISession currentSession = context.Items[CurrentSessionKey] as ISession;

            if (currentSession == null)
            {
                currentSession = sessionFactory.OpenSession();
                context.Items[CurrentSessionKey] = currentSession;
            }

            return currentSession;
        }

        public static void CloseSession()
        {
            HttpContext context = HttpContext.Current;
            ISession currentSession = context.Items[CurrentSessionKey] as ISession;

            if (currentSession == null)
            {
                // No current session
                return;
            }

            currentSession.Close();
            context.Items.Remove(CurrentSessionKey);
        }

        public static void CloseSessionFactory()
        {
            if (sessionFactory != null)
            {
                sessionFactory.Close();
            }
        }
    }
}</pre><p>
            This class does not only take care of the <tt class="literal">ISessionFactory</tt>
            with its static attribute, but also has code to remember the <tt class="literal">ISession</tt>
            for the current HTTP request.
        </p><p>
            An <tt class="literal">ISessionFactory</tt> is threadsafe, many threads can access
            it concurrently and request <tt class="literal">ISession</tt>s. An <tt class="literal">ISession</tt>
            is a non-threadsafe object that represents a single unit-of-work with the database.
            <tt class="literal">ISession</tt>s are opened by an <tt class="literal">ISessionFactory</tt> and
            are closed when all work is completed:
        </p><pre class="programlisting">ISession session = NHibernateHelper.GetCurrentSession();

ITransaction tx = session.BeginTransaction();

Cat princess = new Cat();
princess.Name = "Princess";
princess.Sex = 'F';
princess.Weight = 7.4f;

session.Save(princess);
tx.Commit();

NHibernateHelper.CloseSession();</pre><p>
            In an <tt class="literal">ISession</tt>, every database operation occurs inside a
            transaction that isolates the database operations (even read-only operations).
            We use NHibernate's <tt class="literal">ITransaction</tt> API to abstract from the underlying
            transaction strategy (in our case, ADO.NET transactions). Please note that the example
            above does not handle any exceptions.
        </p><p>
            Also note that you may call <tt class="literal">NHibernateHelper.GetCurrentSession();</tt>
            as many times as you like, you will always get the current <tt class="literal">ISession</tt>
            of this HTTP request. You have to make sure the <tt class="literal">ISession</tt> is closed
            after your unit-of-work completes, either in <tt class="literal">Application_EndRequest</tt>
            event handler in your application class or in a <tt class="literal">HttpModule</tt> before
            the HTTP response is sent. The nice side effect of the latter is easy lazy
            initialization: the <tt class="literal">ISession</tt> is still open when the view is
            rendered, so NHibernate can load unitialized objects while you navigate the graph.
        </p><p>
            NHibernate has various methods that can be used to retrieve objects from the
            database. The most flexible way is using the Hibernate Query Language (HQL),
            which is an easy to learn and powerful object-oriented extension to SQL:
        </p><pre class="programlisting">ITransaction tx = session.BeginTransaction();

IQuery query = session.CreateQuery("select c from Cat as c where c.Sex = :sex");
query.SetCharacter("sex", 'F');
foreach (Cat cat in query.List&lt;Cat&gt;())
{
    Console.Out.WriteLine("Female Cat: " + cat.Name);
}

tx.Commit();</pre><p>
            NHibernate also offers an object-oriented <span class="emphasis"><em>query by criteria</em></span> API
            that can be used to formulate type-safe queries as well as a strongly-typed LINQ API, 
            which translates internally to HQL. NHibernate of course uses <tt class="literal">IDbCommand</tt>
            s and parameter binding for all SQL communication with the database. You may also use 
            NHibernate's direct SQL query feature or get a plain ADO.NET connection from an 
            <tt class="literal">ISession</tt> in rare cases.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart-summary"></a>1.5.&nbsp;Finally</h2></div></div><div></div></div><p>
            We only scratched the surface of NHibernate in this small tutorial. Please note that
            we don't include any ASP.NET specific code in our examples. You have to create an
            ASP.NET page yourself and insert the NHibernate code as you see fit.
        </p><p>
            Keep in mind that NHibernate, as a data access layer, is tightly integrated into
            your application. Usually, all other layers depend on the persistence mechanism.
            Make sure you understand the implications of this design.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="architecture"></a>Chapter&nbsp;2.&nbsp;Architecture</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-overview"></a>2.1.&nbsp;Overview</h2></div></div><div></div></div><p>
            A (very) high-level view of the NHibernate architecture:
        </p><div class="mediaobject" align="center"><img src="../shared/images/overview.png" align="middle"></div><p>
            This diagram shows NHibernate using the database and configuration data to
            provide persistence services (and persistent objects) to the application.
        </p><p>
            We would like to show a more detailed view of the runtime architecture.
            Unfortunately, NHibernate is flexible and supports several approaches. We will
            show the two extremes. The "lite" architecture has the application
            provide its own ADO.NET connections and manage its own transactions. This approach
            uses a minimal subset of NHibernate's APIs:
        </p><div class="mediaobject" align="center"><img src="../shared/images/lite.png" align="middle"></div><p>
            The "full cream" architecture abstracts the application away from the
            underlying ADO.NET APIs and lets NHibernate take care of the details.
        </p><div class="mediaobject" align="center"><img src="../shared/images/fullcream.png" align="middle"></div><p>
            Heres some definitions of the objects in the diagrams:

            </p><div class="variablelist"><dl><dt><span class="term">ISessionFactory (<tt class="literal">NHibernate.ISessionFactory</tt>)</span></dt><dd><p>
                            A threadsafe (immutable) cache of compiled mappings for a single database.
                            A factory for <tt class="literal">ISession</tt> and a client of
                            <tt class="literal">IConnectionProvider</tt>. Might hold an optional (second-level)
                            cache of data that is reusable between transactions, at a
                            process- or cluster-level.
                        </p></dd><dt><span class="term">ISession (<tt class="literal">NHibernate.ISession</tt>)</span></dt><dd><p>
                            A single-threaded, short-lived object representing a conversation between
                            the application and the persistent store. Wraps an ADO.NET connection. Factory
                            for <tt class="literal">ITransaction</tt>. Holds a mandatory (first-level) cache
                            of persistent objects, used when navigating the object graph or looking up
                            objects by identifier.
                        </p></dd><dt><span class="term">Persistent Objects and Collections</span></dt><dd><p>
                            Short-lived, single threaded objects containing persistent state and business
                            function. These might be ordinary POCOs, the only special thing about
                            them is that they are currently associated with (exactly one)
                            <tt class="literal">ISession</tt>. As soon as the <tt class="literal">Session</tt> is closed,
                            they will be detached and free to use in any application layer (e.g. directly
                            as data transfer objects to and from presentation).
                        </p></dd><dt><span class="term">Transient Objects and Collections</span></dt><dd><p>
                            Instances of persistent classes that are not currently associated with a
                            <tt class="literal">ISession</tt>. They may have been instantiated by
                            the application and not (yet) persisted or they may have been instantiated by a
                            closed <tt class="literal">ISession</tt>.
                        </p></dd><dt><span class="term">ITransaction (<tt class="literal">NHibernate.ITransaction</tt>)</span></dt><dd><p>
                            (Optional) A single-threaded, short-lived object used by the application to
                            specify atomic units of work. Abstracts application from underlying ADO.NET
                            transaction. An <tt class="literal">ISession</tt> might span several
                            <tt class="literal">ITransaction</tt>s in some cases.
                        </p></dd><dt><span class="term">IConnectionProvider (<tt class="literal">NHibernate.Connection.IConnectionProvider</tt>)</span></dt><dd><p>
                            (Optional) A factory for ADO.NET connections and commands. Abstracts application
                            from the concrete vendor-specific implementations of <tt class="literal">IDbConnection</tt>
                            and <tt class="literal">IDbCommand</tt>. Not exposed to application, but can be
                            extended/implemented by the developer.
                        </p></dd><dt><span class="term">IDriver (<tt class="literal">NHibernate.Driver.IDriver</tt>)</span></dt><dd><p>
                            (Optional) An interface encapsulating differences between ADO.NET providers, such
                            as parameter naming conventions and supported ADO.NET features.
                        </p></dd><dt><span class="term">ITransactionFactory (<tt class="literal">NHibernate.Transaction.ITransactionFactory</tt>)</span></dt><dd><p>
                            (Optional) A factory for <tt class="literal">ITransaction</tt> instances. Not exposed to the
                            application, but can be extended/implemented by the developer.
                        </p></dd></dl></div><p>
        </p><p>
            Given a "lite" architecture, the application bypasses the
            <tt class="literal">ITransaction</tt>/<tt class="literal">ITransactionFactory</tt> and/or
            <tt class="literal">IConnectionProvider</tt> APIs to talk to ADO.NET directly.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-states"></a>2.2.&nbsp;Instance states</h2></div></div><div></div></div><p>
            An instance of a persistent classes may be in one of three different states,
            which are defined with respect to a <span class="emphasis"><em>persistence context</em></span>.
            The NHibernate <tt class="literal">ISession</tt> object is the persistence context:
        </p><div class="variablelist"><dl><dt><span class="term">transient</span></dt><dd><p>
                        The instance is not, and has never been associated with
                        any persistence context. It has no persistent identity
                        (primary key value).
                    </p></dd><dt><span class="term">persistent</span></dt><dd><p>
                        The instance is currently associated with a persistence 
                        context. It has a persistent identity (primary key value)
                        and, perhaps, a corresponding row in the database. For a
                        particular persistence context, NHibernate 
                        <span class="emphasis"><em>guarantees</em></span> that persistent identity
                        is equivalent to CLR identity (in-memory location of the
                        object).
                    </p></dd><dt><span class="term">detached</span></dt><dd><p>
                        The instance was once associated with a persistence
                        context, but that context was closed, or the instance
                        was serialized to another process. It has a persistent 
                        identity and, perhaps, a corrsponding row in the database.
                        For detached instances, NHibernate makes no guarantees 
                        about the relationship between persistent identity and
                        CLR identity.
                    </p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-current-session"></a>2.3.&nbsp;Contextual Sessions</h2></div></div><div></div></div><p>
            Most applications using NHibernate need some form of "contextual" sessions, where a given
            session is in effect throughout the scope of a given context. However, across applications
            the definition of what constitutes a context is typically different; and different contexts
            define different scopes to the notion of current.
        </p><p>
            Starting with version 1.2, NHibernate added the <tt class="literal">ISessionFactory.GetCurrentSession()</tt>
            method. The processing behind <tt class="literal">ISessionFactory.GetCurrentSession()</tt> is pluggable.
            An extension interface (<tt class="literal">NHibernate.Context.ICurrentSessionContext</tt>) and a new
            configuration parameter (<tt class="literal">hibernate.current_session_context_class</tt>) have been added
            to allow pluggability of the scope and context of defining current sessions.
        </p><p>
            See the API documentation for the <tt class="literal">NHibernate.Context.ICurrentSessionContext</tt>
            interface for a detailed discussion of its contract.  It defines a single method,
            <tt class="literal">CurrentSession()</tt>, by which the implementation is responsible for
            tracking the current contextual session.  Out-of-the-box, NHibernate comes with several
            implementations of this interface:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <tt class="literal">NHibernate.Context.CallSessionContext</tt> - current sessions are tracked
                    by <tt class="literal">CallContext</tt>. You are responsible to bind and unbind an <tt class="literal">
                    ISession</tt> instance with static methods of class <tt class="literal">CurrentSessionContext
                    </tt>.
                </p></li><li><p>
                    <tt class="literal">NHibernate.Context.ThreadStaticSessionContext</tt> - current session is
                    stored in a thread-static variable. This context only supports one session factory.
                    You are responsible to bind and unbind an <tt class="literal">ISession</tt> instance with
                    static methods of class <tt class="literal">CurrentSessionContext</tt>.
                </p></li><li><p>
                    <tt class="literal">NHibernate.Context.WebSessionContext</tt> - 
					stores the current session in <tt class="literal">HttpContext</tt>. 
					You are responsible to bind and unbind an <tt class="literal">ISession</tt> 
					instance with static methods of class <tt class="literal">CurrentSessionContext</tt>.
                </p></li><li><p>
                    <tt class="literal">NHibernate.Context.WcfOperationSessionContext</tt> - current sessions are tracked
                    by WCF <tt class="literal">OperationContext</tt>. You need to register the <tt class="literal">WcfStateExtension</tt>
                    extension in WCF. You are responsible to bind and unbind an <tt class="literal">ISession
                    </tt> instance with static methods of class <tt class="literal">CurrentSessionContext</tt>.
                </p></li><li><p>
                    <tt class="literal">NHibernate.Context.ManagedWebSessionContext</tt> - current
                    sessions are tracked by <tt class="literal">HttpContext</tt>. Removed in NHibernate 4.0 
					- <tt class="literal">NHibernate.Context.WebSessionContext</tt> should be used instead.
					You are responsible to bind and unbind an <tt class="literal">ISession</tt> instance with static methods
                    on this class, it never opens, flushes, or closes an <tt class="literal">ISession</tt> itself.
                </p></li></ul></div><p>
            The <tt class="literal">hibernate.current_session_context_class</tt> configuration parameter
            defines which <tt class="literal">NHibernate.Context.ICurrentSessionContext</tt> implementation
            should be used. Typically, the value of this parameter would just name the implementation
            class to use (including the assembly name); for the out-of-the-box implementations, however,
            there are corresponding short names: "call", "thread_static", "web" and "wcf_operation",
            respectively.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="session-configuration"></a>Chapter&nbsp;3.&nbsp;ISessionFactory Configuration</h2></div></div><div></div></div><p>
        Because NHibernate is designed to operate in many different environments, there
        are a large number of configuration parameters. Fortunately, most have sensible
        default values and NHibernate is distributed with an example 
        <tt class="literal">App.config</tt> file (found in <tt class="literal">src\NHibernate.Test</tt>)
        that shows the various options. You usually only have to put that file in your
        project and customize it.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-programmatic"></a>3.1.&nbsp;Programmatic Configuration</h2></div></div><div></div></div><p>
            An instance of <tt class="literal">NHibernate.Cfg.Configuration</tt>
            represents an entire set of mappings of an application's .NET types to a
            SQL database. The <tt class="literal">Configuration</tt> is used to build an
            (immutable) <tt class="literal">ISessionFactory</tt>. The mappings are compiled
            from various XML mapping files.
        </p><p>
            You may obtain a <tt class="literal">Configuration</tt> instance by
            instantiating it directly. Heres an example of setting up a datastore from 
            mappings defined in two XML configuration files:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .AddFile("Item.hbm.xml")
    .AddFile("Bid.hbm.xml");</pre><p>
            An alternative (sometimes better) way is to let NHibernate load a mapping file
            from an embedded resource:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .AddClass(typeof(NHibernate.Auction.Item))
    .AddClass(typeof(NHibernate.Auction.Bid));</pre><p>
            Then NHibernate will look for mapping files named
            <tt class="literal">NHibernate.Auction.Item.hbm.xml</tt> and
            <tt class="literal">NHibernate.Auction.Bid.hbm.xml</tt> embedded as resources in the
            assembly that the types are contained in. This approach eliminates any hardcoded
            filenames.
        </p><p>
            Another alternative (probably the best) way is to let NHibernate load all of 
            the mapping files contained in an Assembly:
        </p><pre class="programlisting">Configuration cfg = new Configuration()
    .AddAssembly( "NHibernate.Auction" );</pre><p>
            Then NHibernate will look through the assembly for any resources that
            end with <tt class="literal">.hbm.xml</tt>.  This approach eliminates 
            any hardcoded filenames and ensures the mapping files in the assembly
            get added.
        </p><p>
            If a tool like Visual Studio .NET or NAnt is used to build the assembly,
            then make sure that the <tt class="literal">.hbm.xml</tt> files are compiled
            into the assembly as <tt class="literal">Embedded Resources</tt>.
        </p><p>
            A <tt class="literal">Configuration</tt> also specifies various optional properties:
        </p><pre class="programlisting">IDictionary props = new Hashtable();
...
Configuration cfg = new Configuration()
    .AddClass(typeof(NHibernate.Auction.Item))
    .AddClass(typeof(NHibernate.Auction.Bind))
    .SetProperties(props);</pre><p>
            A <tt class="literal">Configuration</tt> is intended as a configuration-time object, to be
            discarded once an <tt class="literal">ISessionFactory</tt> is built.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-sessionfactory"></a>3.2.&nbsp;Obtaining an ISessionFactory</h2></div></div><div></div></div><p>
            When all mappings have been parsed by the <tt class="literal">Configuration</tt>, the application
            must obtain a factory for <tt class="literal">ISession</tt> instances. This factory is intended
            to be shared by all application threads:
        </p><pre class="programlisting">ISessionFactory sessions = cfg.BuildSessionFactory();</pre><p>
            However, NHibernate does allow your application to instantiate more than one
            <tt class="literal">ISessionFactory</tt>. This is useful if you are using more than one database.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-userjdbc"></a>3.3.&nbsp;User provided ADO.NET connection</h2></div></div><div></div></div><p>
            An <tt class="literal">ISessionFactory</tt> may open an <tt class="literal">ISession</tt> on 
            a user-provided ADO.NET connection. This design choice frees the application to 
            obtain ADO.NET connections wherever it pleases:
        </p><pre class="programlisting">IDbConnection conn = myApp.GetOpenConnection();
ISession session = sessions.OpenSession(conn);

// do some data access work</pre><p>
            The application must be careful not to open two concurrent
            <tt class="literal">ISession</tt>s on the same ADO.NET connection!
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-hibernatejdbc"></a>3.4.&nbsp;NHibernate provided ADO.NET connection</h2></div></div><div></div></div><p>
            Alternatively, you can have the <tt class="literal">ISessionFactory</tt>
            open connections for you. The <tt class="literal">ISessionFactory</tt>
            must be provided with ADO.NET connection properties in one of the
            following ways:
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    Pass an instance of <tt class="literal">IDictionary</tt> mapping
                    property names to property values to
                    <tt class="literal">Configuration.SetProperties()</tt>.
                </p></li><li><p>
                    Add the properties to a configuration section in the application
                    configuration file. The section should be named <tt class="literal">nhibernate</tt>
                    and its handler set to <tt class="literal">System.Configuration.NameValueSectionHandler</tt>.
                </p></li><li><p>
                    Include <tt class="literal">&lt;property&gt;</tt> elements in a configuration
                    section in the application configuration file. The section should be named
                    <tt class="literal">hibernate-configuration</tt> and its handler set to
                    <tt class="literal">NHibernate.Cfg.ConfigurationSectionHandler</tt>.
                    The XML namespace of the section should be set to
                    <tt class="literal">urn:nhibernate-configuration-2.2</tt>.
                </p></li><li><p>
                    Include <tt class="literal">&lt;property&gt;</tt> elements in
                    <tt class="literal">hibernate.cfg.xml</tt> (discussed later).
                </p></li></ol></div><p>
            If you take this approach, opening an <tt class="literal">ISession</tt> is as simple as:
        </p><pre class="programlisting">ISession session = sessions.OpenSession(); // open a new Session
// do some data access work, an ADO.NET connection will be used on demand</pre><p>
            All NHibernate property names and semantics are defined on the class 
            <tt class="literal">NHibernate.Cfg.Environment</tt>. We will now describe the most
            important settings for ADO.NET connection configuration.
        </p><p>
            NHibernate will obtain (and pool) connections using an ADO.NET data provider
            if you set the following properties:
        </p><div class="table"><a name="d0e854"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;NHibernate ADO.NET Properties</b></p><table summary="NHibernate ADO.NET Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">connection.provider_class</tt></td><td>
                    The type of a custom <tt class="literal">IConnectionProvider</tt> implementation.
                    <p>
                        <span class="strong">eg.</span> 
                        <tt class="literal">full.classname.of.ConnectionProvider</tt> if the Provider 
                        is built into NHibernate, or <tt class="literal">full.classname.of.ConnectionProvider, 
                        assembly</tt> if using an implementation of <tt class="literal">IConnectionProvider</tt>
                        not included in NHibernate. The default is <tt class="literal">NHibernate.Connection.DriverConnectionProvider</tt>.
                    </p></td></tr><tr><td><tt class="literal">connection.driver_class</tt></td><td>
                    The type of a custom <tt class="literal">IDriver</tt>, if using <tt class="literal">DriverConnectionProvider</tt>.
                    <p>
                        <tt class="literal">full.classname.of.Driver</tt> if the Driver 
                        is built into NHibernate, or <tt class="literal">full.classname.of.Driver, assembly</tt> 
                        if using an implementation of IDriver not included in NHibernate.
                    </p><p>
                        This is usually not needed, most of the time the <tt class="literal">dialect</tt> will
                        take care of setting the <tt class="literal">IDriver</tt> using a sensible default.  See the API
                        documentation of the specific dialect for the defaults.
                    </p></td></tr><tr><td><tt class="literal">connection.connection_string</tt></td><td>
                    Connection string to use to obtain the connection.
                </td></tr><tr><td><tt class="literal">connection.connection_string_name</tt></td><td>
                    The name of the connection string (defined in <tt class="literal">&lt;connectionStrings&gt;</tt>
                    configuration file element) to use to obtain the connection.
                </td></tr><tr><td><tt class="literal">connection.isolation</tt></td><td>
                    Set the ADO.NET transaction isolation level. Check
                    <tt class="literal">System.Data.IsolationLevel</tt> for meaningful values 
                    and the database's documentation to ensure that level is supported.
                    <p>
                        <span class="strong">eg.</span> 
                        <tt class="literal">Chaos, ReadCommitted, ReadUncommitted, RepeatableRead, Serializable, Unspecified </tt>
                    </p></td></tr><tr><td><tt class="literal">connection.release_mode</tt></td><td>
                    Specify when NHibernate should release ADO.NET connections.
                    See <a href="#transactions-connection-release" title="11.7.&nbsp;Connection Release Modes">Section&nbsp;11.7, &#8220;Connection Release Modes&#8221;</a>.
                    <p>
                        <span class="strong">eg.</span> 
                        <tt class="literal">auto</tt> (default) | <tt class="literal">on_close</tt> |
                        <tt class="literal">after_transaction</tt>
                    </p><p>
                        Note that this setting only affects <tt class="literal">ISession</tt>s returned from
                        <tt class="literal">ISessionFactory.OpenSession</tt>.  For <tt class="literal">ISession</tt>s
                        obtained through <tt class="literal">ISessionFactory.GetCurrentSession</tt>, the
                        <tt class="literal">ICurrentSessionContext</tt> implementation configured for use
                        controls the connection release mode for those <tt class="literal">ISession</tt>s.
                        See <a href="#architecture-current-session" title="2.3.&nbsp;Contextual Sessions">Section&nbsp;2.3, &#8220;Contextual Sessions&#8221;</a>.
                    </p></td></tr><tr><td><tt class="literal">command_timeout</tt></td><td>
                    Specify the default timeout of <tt class="literal">IDbCommands</tt>
                    generated by NHibernate.
                </td></tr><tr><td><tt class="literal">adonet.batch_size</tt></td><td>
                    Specify the batch size to use when batching update statements. Setting this to 0
                    (the default) disables the functionality.
                    See <a href="#performance-batch-updates" title="19.6.&nbsp;Batch updates">Section&nbsp;19.6, &#8220;Batch updates&#8221;</a>.
                </td></tr></tbody></table></div><p>
            This is an example of how to specify the database connection properties inside a 
            <tt class="literal">web.config</tt>:
        </p><a name="we-config-configuration"></a><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
	&lt;configSections&gt;
		&lt;section name="hibernate-configuration"
				 type="NHibernate.Cfg.ConfigurationSectionHandler, NHibernate" /&gt;
	&lt;/configSections&gt;

	&lt;hibernate-configuration xmlns="urn:nhibernate-configuration-2.2"&gt;
		&lt;session-factory&gt;
			&lt;property name="dialect"&gt;NHibernate.Dialect.MsSql2005Dialect&lt;/property&gt;
			&lt;property name="connection.connection_string"&gt;
				Server=(local);initial catalog=theDb;Integrated Security=SSPI
			&lt;/property&gt;
			&lt;property name="connection.isolation"&gt;ReadCommitted&lt;/property&gt;
		&lt;/session-factory&gt;
	&lt;/hibernate-configuration&gt;

    &lt;!-- other app specific config follows --&gt;
&lt;/configuration&gt;</pre><p>
            NHibernate relies on the ADO.NET data provider implementation of connection pooling.
        </p><p>
            You may define your own plugin strategy for obtaining ADO.NET connections by implementing the
            interface <tt class="literal">NHibernate.Connection.IConnectionProvider</tt>. You may select
            a custom implementation by setting <tt class="literal">connection.provider_class</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-optional"></a>3.5.&nbsp;Optional configuration properties</h2></div></div><div></div></div><p>
            There are a number of other properties that control the behaviour of NHibernate
            at runtime. All are optional and have reasonable default values.
        </p><p>
            System-level properties can only be set manually by setting static properties of
            <tt class="literal">NHibernate.Cfg.Environment</tt> class or be defined in the
            <tt class="literal">&lt;nhibernate&gt;</tt> section of the application
            configuration file. These properties cannot be set using
            <tt class="literal">Configuration.SetProperties</tt> or be defined in the
            <tt class="literal">&lt;hibernate-configuration&gt;</tt> section of the application configuration
            file.
        </p><div class="table"><a name="configuration-optional-properties"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;NHibernate Configuration Properties</b></p><table summary="NHibernate Configuration Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td><tt class="literal">dialect</tt></td><td>
                            The classname of a NHibernate <tt class="literal">Dialect</tt> - enables
                            certain platform dependent features.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">full.classname.of.Dialect, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">default_schema</tt></td><td>
                            Qualify unqualified tablenames with the given schema/tablespace
                            in generated SQL.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">SCHEMA_NAME</tt>
                            </p></td></tr><tr><td><tt class="literal">max_fetch_depth</tt></td><td>
                            Set a maximum "depth" for the outer join fetch tree
                            for single-ended associations (one-to-one, many-to-one).
                            A <tt class="literal">0</tt> disables default outer join fetching.
                            <p>
                                <span class="strong">eg.</span> 
                                recommended values between <tt class="literal">0</tt> and <tt class="literal">3</tt>
                            </p></td></tr><tr><td><tt class="literal">use_reflection_optimizer</tt></td><td>
                            Enables use of a runtime-generated class to set or get properties of an entity
                            or component instead of using runtime reflection (System-level property).
                            The use of the reflection optimizer inflicts a certain startup cost on the
                            application but should lead to better performance in the long run.
                            You can not set this property in <tt class="literal">hibernate.cfg.xml</tt>
                            or <tt class="literal">&lt;hibernate-configuration&gt;</tt> section of the application
                            configuration file.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">bytecode.provider</tt></td><td>
                            Specifies the bytecode provider to use to optimize the use of reflection in NHibernate.
                            Use <tt class="literal">null</tt> to disable the optimization completely, <tt class="literal">lcg</tt>
                            to use lightweight code generation. 
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">null</tt> | <tt class="literal">lcg</tt>
                            </p></td></tr><tr><td><tt class="literal">cache.provider_class</tt></td><td>
                            The classname of a custom <tt class="literal">ICacheProvider</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.CacheProvider, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">cache.use_minimal_puts</tt></td><td>
                            Optimize second-level cache operation to minimize writes, at the
                            cost of more frequent reads (useful for clustered caches).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">cache.use_query_cache</tt></td><td>
                            Enable the query cache, individual queries still have to be set cacheable.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">cache.query_cache_factory</tt></td><td>
                            The classname of a custom <tt class="literal">IQueryCacheFactory</tt> interface,
                            defaults to the built-in <tt class="literal">StandardQueryCacheFactory</tt>.
                            <p>
                                <span class="strong">eg.</span>
                                <tt class="literal">classname.of.QueryCacheFactory, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">cache.region_prefix</tt></td><td>
                            A prefix to use for second-level cache region names.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">prefix</tt>
                            </p></td></tr><tr><td><tt class="literal">query.substitutions</tt></td><td>
                            Mapping from tokens in NHibernate queries to SQL tokens
                            (tokens might be function or literal names, for example).
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</tt>
                            </p></td></tr><tr><td><tt class="literal">query.linq_provider_class</tt></td><td>
                            The classname of a custom LINQ provider class, one that 
                            implements <tt class="literal">INhQueryProvider</tt>. The default 
                            is <tt class="literal">DefaultQueryProvider</tt><p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">show_sql</tt></td><td>
                            Write all SQL statements to console.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">hbm2ddl.auto</tt></td><td>
                            Automatically export schema DDL to the database when the
                            <tt class="literal">ISessionFactory</tt> is created. With
                            <tt class="literal">create-drop</tt>, the database schema
                            will be dropped when the <tt class="literal">ISessionFactory</tt>
                            is closed explicitly.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">create</tt> | <tt class="literal">create-drop</tt>
                            </p></td></tr><tr><td><tt class="literal">hbm2ddl.keywords</tt></td><td>
                      Automatically import <tt class="literal">reserved/keywords</tt> from the database when the
                      <tt class="literal">ISessionFactory</tt> is created.
                      <p>
                        <span class="strong">none :</span>
                        disable any operation regarding RDBMS KeyWords
                      </p><p>
                        <span class="strong">keywords :</span>
                        imports all RDBMS KeyWords where the <tt class="literal">Dialect</tt> can provide the implementation of <tt class="literal">IDataBaseSchema</tt>.
                      </p><p>
                        <span class="strong">auto-quote :</span>
                        imports all RDBMS KeyWords and auto-quote all table-names/column-names .
                      </p><p>
                        <span class="strong">eg.</span>
                        <tt class="literal">none</tt> | <tt class="literal">keywords</tt> | <tt class="literal">auto-quote</tt>
                      </p></td></tr><tr><td><tt class="literal">use_proxy_validator</tt></td><td>
                            Enables or disables validation of interfaces or classes specified
                            as proxies. Enabled by default.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">true</tt> | <tt class="literal">false</tt>
                            </p></td></tr><tr><td><tt class="literal">transaction.factory_class</tt></td><td>
                            The classname of a custom <tt class="literal">ITransactionFactory</tt> implementation,
                            defaults to the built-in <tt class="literal">AdoNetWithDistributedTransactionFactory</tt>.
                            <p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">classname.of.TransactionFactory, assembly</tt>
                            </p></td></tr><tr><td><tt class="literal">default_flush_mode</tt></td><td>
                            The default <tt class="literal">FlushMode</tt>, defaults to <tt class="literal">Unspecified</tt><p>
                                <span class="strong">eg.</span> 
                                <tt class="literal">Unspecified</tt> | <tt class="literal">Never</tt> | <tt class="literal">Commit</tt> | <tt class="literal">Auto</tt> | <tt class="literal">Always</tt> 
                            </p></td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-dialects"></a>3.5.1.&nbsp;SQL Dialects</h3></div></div><div></div></div><p>
                You should always set the <tt class="literal">dialect</tt> property to the correct
                <tt class="literal">NHibernate.Dialect.Dialect</tt> subclass for your database. This is not
                strictly essential unless you wish to use <tt class="literal">native</tt> or
                <tt class="literal">sequence</tt> primary key generation or pessimistic locking (with, eg.
                <tt class="literal">ISession.Lock()</tt> or <tt class="literal">IQuery.SetLockMode()</tt>).
                However, if you specify a dialect, NHibernate will use sensible defaults for some of the
                other properties listed above, saving you the effort of specifying them manually.
            </p><div class="table"><a name="sql-dialects"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;NHibernate SQL Dialects (<tt class="literal">dialect</tt>)</b></p><table summary="NHibernate SQL Dialects (dialect)" border="1"><colgroup><col><col></colgroup><thead><tr><th>RDBMS</th><th>Dialect</th><th>Remarks</th></tr></thead><tbody><tr><td>DB2</td><td><tt class="literal">NHibernate.Dialect.DB2Dialect</tt></td><td>&nbsp;</td></tr><tr><td>DB2 for iSeries (OS/400)</td><td><tt class="literal">NHibernate.Dialect.DB2400Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Ingres</td><td><tt class="literal">NHibernate.Dialect.IngresDialect</tt></td><td>&nbsp;</td></tr><tr><td>PostgreSQL</td><td><tt class="literal">NHibernate.Dialect.PostgreSQLDialect</tt></td><td>&nbsp;</td></tr><tr><td>PostgreSQL 8.1</td><td><tt class="literal">NHibernate.Dialect.PostgreSQL81Dialect</tt></td><td>
                                This dialect supports <tt class="literal">FOR UPDATE NOWAIT</tt>
                                available in PostgreSQL 8.1.
                            </td></tr><tr><td>PostgreSQL 8.2</td><td><tt class="literal">NHibernate.Dialect.PostgreSQL82Dialect</tt></td><td>
                                This dialect supports <tt class="literal">IF EXISTS</tt> keyword in
                                <tt class="literal">DROP TABLE</tt> and <tt class="literal">DROP SEQUENCE</tt>
                                available in PostgreSQL 8.2.
                            </td></tr><tr><td>MySQL 3 or 4</td><td><tt class="literal">NHibernate.Dialect.MySQLDialect</tt></td><td>&nbsp;</td></tr><tr><td>MySQL 5</td><td><tt class="literal">NHibernate.Dialect.MySQL5Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Oracle</td><td><tt class="literal">NHibernate.Dialect.Oracle8iDialect</tt></td><td>&nbsp;</td></tr><tr><td>Oracle 9i</td><td><tt class="literal">NHibernate.Dialect.Oracle9iDialect</tt></td><td>&nbsp;</td></tr><tr><td>Oracle 10g, Oracle 11g</td><td><tt class="literal">NHibernate.Dialect.Oracle10gDialect</tt></td><td>&nbsp;</td></tr><tr><td>Oracle 12c</td><td><tt class="literal">NHibernate.Dialect.Oracle12cDialect</tt></td><td>&nbsp;</td></tr><tr><td>Sybase Adaptive Server Enterprise 15</td><td><tt class="literal">NHibernate.Dialect.SybaseASE15Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Sybase Adaptive Server Anywhere 9</td><td><tt class="literal">NHibernate.Dialect.SybaseASA9Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Sybase SQL Anywhere 10</td><td><tt class="literal">NHibernate.Dialect.SybaseSQLAnywhere10Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Sybase SQL Anywhere 11</td><td><tt class="literal">NHibernate.Dialect.SybaseSQLAnywhere11Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Microsoft SQL Server 7</td><td><tt class="literal">NHibernate.Dialect.MsSql7Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Microsoft SQL Server 2000</td><td><tt class="literal">NHibernate.Dialect.MsSql2000Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Microsoft SQL Server 2005</td><td><tt class="literal">NHibernate.Dialect.MsSql2005Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Microsoft SQL Server 2008</td><td><tt class="literal">NHibernate.Dialect.MsSql2008Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Microsoft SQL Server 2012</td><td><tt class="literal">NHibernate.Dialect.MsSql2012Dialect</tt></td><td>&nbsp;</td></tr><tr><td>Microsoft SQL Server Compact Edition</td><td><tt class="literal">NHibernate.Dialect.MsSqlCeDialect</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>Microsoft SQL Server Compact Edition 4</td><td><tt class="literal">NHibernate.Dialect.MsSqlCe40Dialect</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td>Firebird</td><td><tt class="literal">NHibernate.Dialect.FirebirdDialect</tt></td><td>
                                Set <tt class="literal">driver_class</tt> to
                                <tt class="literal">NHibernate.Driver.FirebirdClientDriver</tt>
                                for Firebird ADO.NET provider 2.0.
                            </td></tr><tr><td>SQLite</td><td><tt class="literal">NHibernate.Dialect.SQLiteDialect</tt></td><td>
                                Set <tt class="literal">driver_class</tt> to
                                <tt class="literal">NHibernate.Driver.SQLite20Driver</tt>
                                for System.Data.SQLite provider for .NET 2.0.
                            </td></tr></tbody></table></div><p>
                Additional dialects may be available in the NHibernate.Dialect namespace.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-outerjoin"></a>3.5.2.&nbsp;Outer Join Fetching</h3></div></div><div></div></div><p>
                If your database supports ANSI or Oracle style outer joins, <span class="emphasis"><em>outer join
                fetching</em></span> might increase performance by limiting the number of round
                trips to and from the database (at the cost of possibly more work performed by
                the database itself). Outer join fetching allows a graph of objects connected
                by many-to-one, one-to-many or one-to-one associations to be retrieved in a single
                SQL <tt class="literal">SELECT</tt>.
            </p><p>
                By default, the fetched graph when loading an objects ends at leaf objects,
                collections, objects with proxies, or where circularities occur.
            </p><p>
                For a <span class="emphasis"><em>particular  association</em></span>, fetching may be configured
                (and the default behaviour overridden) by setting the <tt class="literal">fetch</tt>
                attribute in the XML mapping.
            </p><p>
                Outer join fetching may be disabled <span class="emphasis"><em>globally</em></span> by setting
                the property <tt class="literal">max_fetch_depth</tt> to <tt class="literal">0</tt>.
                A setting of <tt class="literal">1</tt> or higher enables outer join fetching for
                one-to-one and many-to-one associations which have been mapped with
                <tt class="literal">fetch="join"</tt>.
            </p><p>
                See <a href="#performance-fetching" title="19.1.&nbsp;Fetching strategies">Section&nbsp;19.1, &#8220;Fetching strategies&#8221;</a> for more information.
            </p><p>
                In NHibernate 1.0, <tt class="literal">outer-join</tt> attribute could be used to achieve
                a similar effect. This attribute is now deprecated in favor of <tt class="literal">fetch</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-cacheprovider"></a>3.5.3.&nbsp;Custom <tt class="literal">ICacheProvider</tt></h3></div></div><div></div></div><p>
                You may integrate a process-level (or clustered) second-level cache system by
                implementing the interface <tt class="literal">NHibernate.Cache.ICacheProvider</tt>.
                You may select the custom implementation by setting
                <tt class="literal">cache.provider_class</tt>. See the 
                <a href="#performance-cache" title="19.2.&nbsp;The Second Level Cache">Section&nbsp;19.2, &#8220;The Second Level Cache&#8221;</a> for more details.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-optional-querysubstitution"></a>3.5.4.&nbsp;Query Language Substitution</h3></div></div><div></div></div><p>
                You may define new NHibernate query tokens using <tt class="literal">query.substitutions</tt>.
                For example:
            </p><pre class="programlisting">query.substitutions true=1, false=0</pre><p>
                would cause the tokens <tt class="literal">true</tt> and <tt class="literal">false</tt> to be translated to
                integer literals in the generated SQL.
            </p><pre class="programlisting">query.substitutions toLowercase=LOWER</pre><p>
                would allow you to rename the SQL <tt class="literal">LOWER</tt> function.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-logging"></a>3.6.&nbsp;Logging</h2></div></div><div></div></div><p>
            NHibernate logs various events using Apache log4net.
        </p><p>
            You may download log4net from <tt class="literal">http://logging.apache.org/log4net/</tt>.
            To use log4net you will need a <tt class="literal">log4net</tt> configuration section in
            the application configuration file.  An example of the configuration section is
            distributed with NHibernate in the <tt class="literal">src/NHibernate.Test</tt> project.
        </p><p>
            We strongly recommend that you familiarize yourself with NHibernate's log
            messages. A lot of work has been put into making the NHibernate log as
            detailed as possible, without making it unreadable. It is an essential
            troubleshooting device. Also don't forget to enable SQL logging as
            described above (<tt class="literal">show_sql</tt>), it is your first
            step when looking for performance problems.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-namingstrategy"></a>3.7.&nbsp;Implementing an <tt class="literal">INamingStrategy</tt></h2></div></div><div></div></div><p>
            The interface <tt class="literal">NHibernate.Cfg.INamingStrategy</tt> allows you
            to specify a "naming standard" for database objects and schema elements.
        </p><p>
            You may provide rules for automatically generating database identifiers from
            .NET identifiers or for processing "logical" column and table names given in
            the mapping file into  "physical" table and column names. This feature helps
            reduce the verbosity of the mapping document, eliminating repetitive noise
            (<tt class="literal">TBL_</tt> prefixes, for example). The default strategy used by
            NHibernate is quite minimal.
        </p><p>
            You may specify a different strategy by calling
            <tt class="literal">Configuration.SetNamingStrategy()</tt> before adding mappings:
        </p><pre class="programlisting">ISessionFactory sf = new Configuration()
    .SetNamingStrategy(ImprovedNamingStrategy.Instance)
    .AddFile("Item.hbm.xml")
    .AddFile("Bid.hbm.xml")
    .BuildSessionFactory();</pre><p>
            <tt class="literal">NHibernate.Cfg.ImprovedNamingStrategy</tt> is a built-in
            strategy that might be a useful starting point for some applications.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-xmlconfig"></a>3.8.&nbsp;XML Configuration File</h2></div></div><div></div></div><p>
            An alternative approach is to specify a full configuration in a file named
            <tt class="literal">hibernate.cfg.xml</tt>. This file can be used as a replacement
            for the <tt class="literal">&lt;nhibernate;&gt;</tt> or <tt class="literal">&lt;hibernate-configuration&gt;</tt>
            sections of the application configuration file.
        </p><p>
            The XML configuration file is by default expected to be in your application directory.
            Here is an example:
        </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;hibernate-configuration xmlns="urn:nhibernate-configuration-2.2"&gt;

    &lt;!-- an ISessionFactory instance --&gt;
    &lt;session-factory&gt;

        &lt;!-- properties --&gt;
        &lt;property name="connection.provider"&gt;NHibernate.Connection.DriverConnectionProvider&lt;/property&gt;
        &lt;property name="connection.driver_class"&gt;NHibernate.Driver.SqlClientDriver&lt;/property&gt;
        &lt;property name="connection.connection_string"&gt;Server=localhost;initial catalog=nhibernate;User Id=;Password=&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="dialect"&gt;NHibernate.Dialect.MsSql2000Dialect&lt;/property&gt;

        &lt;!-- mapping files --&gt;
        &lt;mapping resource="NHibernate.Auction.Item.hbm.xml" assembly="NHibernate.Auction" /&gt;
        &lt;mapping resource="NHibernate.Auction.Bid.hbm.xml" assembly="NHibernate.Auction" /&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>
           Configuring NHibernate is then as simple as
       </p><pre class="programlisting">ISessionFactory sf = new Configuration().Configure().BuildSessionFactory();</pre><p>
           You can pick a different XML configuration file using
       </p><a name="configuration-xmlconfig-ex3"></a><pre class="programlisting">ISessionFactory sf = new Configuration()
    .Configure("/path/to/config.cfg.xml")
    .BuildSessionFactory();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="persistent-classes"></a>Chapter&nbsp;4.&nbsp;Persistent Classes</h2></div></div><div></div></div><p>
        Persistent classes are classes in an application that implement the entities
        of the business problem (e.g. Customer and Order in an E-commerce application).
        Persistent classes have, as the name implies, transient and also persistent
        instance stored in the database.
    </p><p>
        NHibernate works best if these classes follow some simple rules, also known
        as the Plain Old CLR Object (POCO) programming model.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-poco"></a>4.1.&nbsp;A simple POCO example</h2></div></div><div></div></div><p>
            Most .NET applications require a persistent class representing felines.
        </p><pre class="programlisting">using System;
using System.Collections.Generic;

namespace Eg
{
    public class Cat
    {
        long id; // identifier
    
        public virtual long Id
        {
            get { return id; }
            protected set { id = value; }
        }

        public virtual string Name { get; set; } 
        public virtual Cat Mate { get; set; } 
        public virtual DateTime Birthdate { get; set; } 
        public virtual float Weight { get; set; } 
        public virtual Color Color { get; set; } 
        public virtual ISet&lt;Cat&gt; Kittens { get; set; } 
        public virtual char Sex { get; set; } 

        // AddKitten not needed by NHibernate
        public virtual void AddKitten(Cat kitten)
        {
            kittens.Add(kitten);
        }
    }
}</pre><p>
            There are four main rules to follow here:
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-poco-accessors"></a>4.1.1.&nbsp;Declare properties for persistent fields</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> declares properties for all the persistent fields.
                Many other ORM tools directly persist instance variables. We believe 
                it is far better to decouple this implementation detail from the persistence 
                mechanism. NHibernate persists properties, using their getter and setter methods.
            </p><p>
                Properties need <span class="emphasis"><em>not</em></span> be declared public - NHibernate can
                persist a property with an <tt class="literal">internal</tt>, <tt class="literal">protected</tt>,
                <tt class="literal">protected internal</tt> or <tt class="literal">private</tt> visibility.
            </p><p>
                As shown in the example, both automatic properties and properties with a
                backing field are supported.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-poco-constructor"></a>4.1.2.&nbsp;Implement a default constructor</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> has an implicit default (no-argument) constructor. All 
                persistent classes must have a default constructor (which may be non-public) so 
                NHibernate can instantiate them using <tt class="literal">Activator.CreateInstance()</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-poco-identifier"></a>4.1.3.&nbsp;Provide an identifier property (optional)</h3></div></div><div></div></div><p>
                <tt class="literal">Cat</tt> has a property called <tt class="literal">Id</tt>. This property 
                holds the primary key column of a database table. The property might have been called 
                anything, and its type might have been any primitive type, <tt class="literal">string</tt>
                or <tt class="literal">System.DateTime</tt>. (If your legacy database table has composite
                keys, you can even use a user-defined class with properties of these types - see the
                section on composite identifiers below.)
            </p><p>
                The identifier property is optional. You can leave it off and let NHibernate keep track 
                of object identifiers internally. However, for many applications it is still
                a good (and very popular) design decision.
            </p><p>
                What's more, some functionality is available only to classes which declare an
                identifier property:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        Cascaded updates (see "Lifecycle Objects")
                    </p></li><li><p>
                        <tt class="literal">ISession.SaveOrUpdate()</tt>
                    </p></li></ul></div><p>
                We recommend you declare consistently-named identifier properties on persistent
                classes.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="persistent-classes-poco-sealed"></a>4.1.4.&nbsp;Prefer non-sealed classes and virtual methods (optional)</h3></div></div><div></div></div><p>
                A central feature of NHibernate, <span class="emphasis"><em>proxies</em></span>, depends upon the
                persistent class being non-sealed and all its public methods, properties and
                events declared as virtual. Another possibility is for the class to implement
                an interface that declares all public members.
            </p><p>
                You can persist <tt class="literal">sealed</tt> classes that do not implement an interface
                and don't have virtual members with NHibernate, but you won't be able to use proxies
                - which will limit your options for performance tuning.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-inheritance"></a>4.2.&nbsp;Implementing inheritance</h2></div></div><div></div></div><p>
            A subclass must also observe the first and second rules. It inherits its
            identifier property from <tt class="literal">Cat</tt>.
        </p><pre class="programlisting">using System;
namespace Eg
{
    public class DomesticCat : Cat
    {
        public virtual string Name { get; set; }
    }
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-equalshashcode"></a>4.3.&nbsp;Implementing <tt class="literal">Equals()</tt> and <tt class="literal">GetHashCode()</tt></h2></div></div><div></div></div><p>
            You have to override the <tt class="literal">Equals()</tt> and <tt class="literal">GetHashCode()</tt>
            methods if you intend to mix objects of persistent classes (e.g. in an <tt class="literal">ISet&lt;T&gt;</tt>).
        </p><p>
            <span class="emphasis"><em>This only applies if these objects are loaded in two different
            <tt class="literal">ISession</tt>s, as NHibernate only guarantees identity (<tt class="literal"> a == b </tt>,
            the default implementation of <tt class="literal">Equals()</tt>) inside a single
            <tt class="literal">ISession</tt>!</em></span>
        </p><p>
            Even if both objects <tt class="literal">a</tt> and <tt class="literal">b</tt> are the same database row
            (they have the same primary key value as their identifier), we can't guarantee that they are
            the same object instance outside of a particular <tt class="literal">ISession</tt> context.
        </p><p>
            The most obvious way is to implement <tt class="literal">Equals()</tt>/<tt class="literal">GetHashCode()</tt>
            by comparing the identifier value of both objects. If the value is the same, both must
            be the same database row, they are therefore equal (if both are added to an <tt class="literal">ISet&lt;T&gt;</tt>,
            we will only have one element in the <tt class="literal">ISet&lt;T&gt;</tt>). Unfortunately, we can't use that
            approach. NHibernate will only assign identifier values to objects that are persistent,
            a newly created instance will not have any identifier value! We recommend implementing
            <tt class="literal">Equals()</tt> and <tt class="literal">GetHashCode()</tt> using
            <span class="emphasis"><em>Business key equality</em></span>.
        </p><p>
            Business key equality means that the <tt class="literal">Equals()</tt>
            method compares only the properties that form the business key, a key that would
            identify our instance in the real world (a <span class="emphasis"><em>natural</em></span> candidate key):
        </p><pre class="programlisting">public class Cat
{

    ...
    public override bool Equals(object other)
    {
        if (this == other) return true;
        
        Cat cat = other as Cat;
        if (cat == null) return false; // null or not a cat

        if (Name != cat.Name) return false;
        if (!Birthday.Equals(cat.Birthday)) return false;

        return true;
    }

    public override int GetHashCode()
    {
        unchecked
        {
            int result;
            result = Name.GetHashCode();
            result = 29 * result + Birthday.GetHashCode();
            return result;
        }
    }

}</pre><p>
            Keep in mind that our candidate key (in this case a composite of name and birthday)
            has to be only valid for a particular comparison operation (maybe even only in a
            single use case). We don't need the stability criteria we usually apply to a real
            primary key!
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-dynamicmodels"></a>4.4.&nbsp;Dynamic models</h2></div></div><div></div></div><p>
            <span class="emphasis"><em>Note that the following features are currently considered
                experimental and may change in the near future.</em></span>
        </p><p>
            Persistent entities don't necessarily have to be represented as POCO classes
            at runtime. NHibernate also supports dynamic models
            (using <tt class="literal">Dictionaries</tt> of <tt class="literal">Dictionary</tt>s at runtime) . With this approach, you don't
            write persistent classes, only mapping files.
        </p><p>
            By default, NHibernate works in normal POCO mode. You may set a default entity
            representation mode for a particular <tt class="literal">ISessionFactory</tt> using the
            <tt class="literal">default_entity_mode</tt> configuration option (see
            <a href="#configuration-optional-properties" title="Table&nbsp;3.2.&nbsp;NHibernate Configuration Properties">Table&nbsp;3.2, &#8220;NHibernate Configuration Properties&#8221;</a>.
        </p><p>
            The following examples demonstrates the representation using <tt class="literal">Map</tt>s (Dictionary).
            First, in the mapping file, an <tt class="literal">entity-name</tt> has to be declared
            instead of (or in addition to) a class name:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class entity-name="Customer"&gt;

        &lt;id name="id"
            type="long"
            column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;property name="name"
            column="NAME"
            type="string"/&gt;

        &lt;property name="address"
            column="ADDRESS"
            type="string"/&gt;

        &lt;many-to-one name="organization"
            column="ORGANIZATION_ID"
            class="Organization"/&gt;

        &lt;bag name="orders"
            inverse="true"
            lazy="false"
            cascade="all"&gt;
            &lt;key column="CUSTOMER_ID"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/bag&gt;

    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre><p>
            
            Note that even though associations are declared using target class names,
            the target type of an associations may also be a dynamic entity instead
            of a POCO.
        </p><p>
            After setting the default entity mode to <tt class="literal">dynamic-map</tt>
            for the <tt class="literal">ISessionFactory</tt>, we can at runtime work with
            <tt class="literal">Dictionaries</tt> of <tt class="literal">Dictionaries</tt>:
        </p><pre class="programlisting">using(ISession s = OpenSession())
using(ITransaction tx = s.BeginTransaction())
{
    // Create a customer
    var frank = new Dictionary&lt;string, object&gt;();
    frank["name"] = "Frank";

    // Create an organization
    var foobar = new Dictionary&lt;string, object&gt;();
    foobar["name"] = "Foobar Inc.";

    // Link both
    frank["organization"] =  foobar;

    // Save both
    s.Save("Customer", frank);
    s.Save("Organization", foobar);

    tx.Commit();
}</pre><p>
            The advantages of a dynamic mapping are quick turnaround time for prototyping
            without the need for entity class implementation. However, you lose compile-time
            type checking and will very likely deal with many exceptions at runtime. Thanks
            to the NHibernate mapping, the database schema can easily be normalized and sound,
            allowing to add a proper domain model implementation on top later on.
        </p><p>
            Entity representation modes can also be set on a per <tt class="literal">ISession</tt>
            basis:
        </p><pre class="programlisting">using (ISession dynamicSession = pocoSession.GetSession(EntityMode.Map))
{
    // Create a customer
    var frank = new Dictionary&lt;string, object&gt;();
    frank["name"] = "Frank";
    dynamicSession.Save("Customer", frank);
    ...
}
// Continue on pocoSession
</pre><p>
            Please note that the call to <tt class="literal">GetSession()</tt> using an
            <tt class="literal">EntityMode</tt> is on the <tt class="literal">ISession</tt> API, not the
            <tt class="literal">ISessionFactory</tt>. That way, the new <tt class="literal">ISession</tt>
            shares the underlying ADO connection, transaction, and other context
            information. This means you don't have tocall <tt class="literal">Flush()</tt>
            and <tt class="literal">Close()</tt> on the secondary <tt class="literal">ISession</tt>, and
            also leave the transaction and connection handling to the primary unit of work.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-tuplizers"></a>4.5.&nbsp;Tuplizers</h2></div></div><div></div></div><p>
            <tt class="literal">NHibernate.Tuple.Tuplizer</tt>, and its sub-interfaces, are responsible
            for managing a particular representation of a piece of data, given that representation's
            <tt class="literal">NHibernate.EntityMode</tt>.  If a given piece of data is thought of as
            a data structure, then a tuplizer is the thing which knows how to create such a data structure
            and how to extract values from and inject values into such a data structure.  For example,
            for the POCO entity mode, the correpsonding tuplizer knows how create the POCO through its
            constructor and how to access the POCO properties using the defined property accessors.
            There are two high-level types of Tuplizers, represented by the
            <tt class="literal">NHibernate.Tuple.Entity.IEntityTuplizer</tt> and <tt class="literal">NHibernate.Tuple.Component.IComponentTuplizer</tt>
            interfaces.  <tt class="literal">IEntityTuplizer</tt>s are responsible for managing the above mentioned
            contracts in regards to entities, while <tt class="literal">IComponentTuplizer</tt>s do the same for
            components.
        </p><p>
            Users may also plug in their own tuplizers.  Perhaps you require that a <tt class="literal">System.Collections.IDictionary</tt>
            implementation other than <tt class="literal">System.Collections.Hashtable</tt> be used while in the
            dynamic-map entity-mode; or perhaps you need to define a different proxy generation strategy
            than the one used by default.  Both would be achieved by defining a custom tuplizer
            implementation.  Tuplizers definitions are attached to the entity or component mapping they
            are meant to manage.  Going back to the example of our customer entity:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    &lt;class entity-name="Customer"&gt;
        &lt;!--
            Override the dynamic-map entity-mode
            tuplizer for the customer entity
        --&gt;
        &lt;tuplizer entity-mode="dynamic-map"
                class="CustomMapTuplizerImpl"/&gt;

        &lt;id name="id" type="long" column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;!-- other properties --&gt;
        ...
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;


public class CustomMapTuplizerImpl : NHibernate.Tuple.Entity.DynamicMapEntityTuplizer
{
    // override the BuildInstantiator() method to plug in our custom map...
    protected override IInstantiator BuildInstantiator(NHibernate.Mapping.PersistentClass mappingInfo)
    {
        return new CustomMapInstantiator(mappingInfo);
    }

    private sealed class CustomMapInstantiator : NHibernate.Tuple.DynamicMapInstantiator
    {
        // override the generateMap() method to return our custom map...
        protected override IDictionary GenerateMap()
        {
            return new CustomMap();
        }
    }
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-lifecycle"></a>4.6.&nbsp;Lifecycle Callbacks</h2></div></div><div></div></div><p>
            Optionally, a persistent class might implement the interface 
            <tt class="literal">ILifecycle</tt> which provides some callbacks that allow
            the persistent object to perform necessary initialization/cleanup after
            save or load and before deletion or update.
        </p><p>
            
            The NHibernate <tt class="literal">IInterceptor</tt> offers a less intrusive
            alternative, however.
        </p><div class="programlistingco"><pre class="programlisting">public interface ILifecycle
{                                                                    <span class="co">(1)</span>
        LifecycleVeto OnSave(ISession s);                            <span class="co">(2)</span>
        LifecycleVeto OnUpdate(ISession s);                          <span class="co">(3)</span>
        LifecycleVeto OnDelete(ISession s);                          <span class="co">(4)</span>
        void OnLoad(ISession s, object id);
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">OnSave</tt> - called just before the object is saved or
                        inserted
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">OnUpdate</tt> - called just before an object is updated 
                        (when the object is passed to <tt class="literal">ISession.Update()</tt>)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">OnDelete</tt> - called just before an object is deleted
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">OnLoad</tt> - called just after an object is loaded
                    </p></td></tr></table></div></div><p>
            <tt class="literal">OnSave()</tt>, <tt class="literal">OnDelete()</tt> and
            <tt class="literal">OnUpdate()</tt> may be used to cascade saves and
            deletions of dependent objects. This is an alternative to declaring cascaded
            operations in the mapping file. <tt class="literal">OnLoad()</tt> may
            be used to initialize transient properties of the object from its persistent
            state. It may not be used to load dependent objects since the
            <tt class="literal">ISession</tt> interface may not be invoked from
            inside this method. A further intended usage of <tt class="literal">OnLoad()</tt>, 
            <tt class="literal">OnSave()</tt> and <tt class="literal">OnUpdate()</tt> is to store a 
            reference to the current <tt class="literal">ISession</tt> for later use.
        </p><p>
            Note that <tt class="literal">OnUpdate()</tt> is not called every time the object's
            persistent state is updated. It is called only when a transient object is passed
            to <tt class="literal">ISession.Update()</tt>.
        </p><p>
            If <tt class="literal">OnSave()</tt>, <tt class="literal">OnUpdate()</tt> or
            <tt class="literal">OnDelete()</tt> return <tt class="literal">LifecycleVeto.Veto</tt>, the operation is 
            silently vetoed. If a <tt class="literal">CallbackException</tt> is thrown, the operation 
            is vetoed and the exception is passed back to the application.
        </p><p>
            Note that <tt class="literal">OnSave()</tt> is called after an identifier is assigned to 
            the object, except when native key generation is used.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistent-classes-validatable"></a>4.7.&nbsp;IValidatable callback</h2></div></div><div></div></div><p>
            If the persistent class needs to check invariants before its state is
            persisted, it may implement the following interface:
        </p><pre class="programlisting">public interface IValidatable
{
        void Validate();
}</pre><p>
            The object should throw a <tt class="literal">ValidationFailure</tt> if an invariant 
            was violated. An instance of <tt class="literal">Validatable</tt> should not change 
            its state from inside <tt class="literal">Validate()</tt>.
        </p><p>
            Unlike the callback methods of the <tt class="literal">ILifecycle</tt> interface, 
            <tt class="literal">Validate()</tt> might be called at unpredictable times. The
            application should not rely upon calls to <tt class="literal">Validate()</tt> for
            business functionality.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mapping"></a>Chapter&nbsp;5.&nbsp;Basic O/R Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-declaration"></a>5.1.&nbsp;Mapping declaration</h2></div></div><div></div></div><p>
            Object/relational mappings are defined in an XML document. The mapping document
            is designed to be readable and hand-editable. The mapping language is object-centric,
            meaning that mappings are constructed around persistent class declarations, not
            table declarations.
        </p><p>
            Note that, even though many NHibernate users choose to define XML mappings by hand,
            a number of tools exist to generate the mapping document, including
            NHibernate.Mapping.Attributes library and various template-based code
            generators (CodeSmith, MyGeneration).
        </p><p>
            Let's kick off with an example mapping:
        </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2" assembly="Eg"
    namespace="Eg"&gt;

        &lt;class name="Cat" table="CATS" discriminator-value="C"&gt;
                &lt;id name="Id" column="uid" type="Int64"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;discriminator column="subclass" type="Char"/&gt;
                &lt;property name="BirthDate" type="Date"/&gt;
                &lt;property name="Color" not-null="true"/&gt;
                &lt;property name="Sex" not-null="true" update="false"/&gt;
                &lt;property name="Weight"/&gt;
                &lt;many-to-one name="Mate" column="mate_id"/&gt;
                &lt;set name="Kittens"&gt;
                        &lt;key column="mother_id"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;subclass name="DomesticCat" discriminator-value="D"&gt;
                        &lt;property name="Name" type="String"/&gt;
                &lt;/subclass&gt;
        &lt;/class&gt;

        &lt;class name="Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
             We will now discuss the content of the mapping document. We will only describe the 
             document elements and attributes that are used by NHibernate at runtime. The mapping 
             document also contains some extra optional attributes and elements that affect the 
             database schemas exported by the schema export tool. (For example the <tt class="literal">
             not-null</tt> attribute.)
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-xmlns"></a>5.1.1.&nbsp;XML Namespace</h3></div></div><div></div></div><p>
                All XML mappings should declare the XML namespace shown. The actual schema definition
                may be found in the <tt class="literal">src\nhibernate-mapping.xsd</tt> file in the
                NHibernate distribution.
            </p><p><span class="emphasis"><em>
                Tip: to enable IntelliSense for mapping and configuration files, copy the appropriate
                <tt class="literal">.xsd</tt> files as part of any project in your solution,
                (<tt class="literal">Build Action</tt> can be "None") or as "Solution Files" or in your
              <tt class="literal">"Lib"</tt> folder and then add it to the <tt class="literal">Schemas</tt> property of the xml file.
              You can copy it in <tt class="literal">&lt;VS installation directory&gt;\Xml\Schemas</tt>, take care because you will have to deal
              with different version of the xsd for different versions of NHibernate.
            </em></span>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-mapping"></a>5.1.2.&nbsp;hibernate-mapping</h3></div></div><div></div></div><p>
                This element has several optional attributes. The <tt class="literal">schema</tt> attribute
                specifies that tables referred to by this mapping belong to the named schema. If specified, 
                tablenames will be qualified by the given schema name. If missing, tablenames will be 
                unqualified. The <tt class="literal">default-cascade</tt> attribute specifies what cascade style
                should be assumed for properties and collections which do not specify a 
                <tt class="literal">cascade</tt> attribute. The <tt class="literal">auto-import</tt> attribute lets us
                use unqualified class names in the query language, by default. The <tt class="literal">assembly</tt>
                and <tt class="literal">namespace</tt> attributes specify the assembly where persistent classes
                are located and the namespace they are declared in.
            </p><div class="programlistingco"><pre class="programlisting">
           &lt;hibernate-mapping                         <span class="co">(1)</span>
         schema="schemaName"                          <span class="co">(2)</span>
         default-cascade="none|save-update"           <span class="co">(3)</span>
         auto-import="true|false"                     <span class="co">(4)</span>
         assembly="Eg"                                <span class="co">(5)</span>
         namespace="Eg"                               <span class="co">(6)</span>
         default-access="field|property|field.camecase<span class="co">(7)</span>..."
         default-lazy="true|false"
 /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                             <tt class="literal">schema</tt> (optional): The name of a database schema.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                             <tt class="literal">default-cascade</tt> (optional - defaults to <tt class="literal">none</tt>): 
                             A default cascade style.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                             <tt class="literal">auto-import</tt> (optional - defaults to <tt class="literal">true</tt>):
                             Specifies whether we can use unqualified class names (of classes in this mapping)
                             in the query language.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(4)(5)</td><td valign="top" align="left"><p>
                             <tt class="literal">assembly</tt> and <tt class="literal">namespace</tt>(optional): Specify
                             assembly and namespace to assume for unqualified class names in the mapping
                             document.
                         </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                       <tt class="literal">default-access</tt> (optional - defaults to property): 
                       The strategy NHibernate should use for accessing a property value
                     </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                       <tt class="literal">default-lazy</tt> (optional - defaults to <tt class="literal">true</tt>):
                       Lazy fetching may be completely disabled by setting default-lazy="false".
                     </p></td></tr></table></div></div><p>
                 If you are not using <tt class="literal">assembly</tt> and <tt class="literal">namespace</tt>
                 attributes, you have to specify fully-qualified class names, including the name
                 of the assembly that classes are declared in.
             </p><p>
                 If you have two persistent classes with the same (unqualified) name, you should set 
                 <tt class="literal">auto-import="false"</tt>. NHibernate will throw an exception if you attempt
                 to assign two classes to the same "imported" name.
             </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-class"></a>5.1.3.&nbsp;class</h3></div></div><div></div></div><p>
                You may declare a persistent class using the <tt class="literal">class</tt> element:
            </p><div class="programlistingco"><pre class="programlisting">&lt;class
        name="ClassName"                              <span class="co">(1)</span>
        table="tableName"                             <span class="co">(2)</span>
        discriminator-value="discriminator_value"     <span class="co">(3)</span>
        mutable="true|false"                          <span class="co">(4)</span>
        schema="owner"                                <span class="co">(5)</span>
        proxy="ProxyInterface"                        <span class="co">(6)</span>
        dynamic-update="true|false"                   <span class="co">(7)</span>
        dynamic-insert="true|false"                   <span class="co">(8)</span>
        select-before-update="true|false"             <span class="co">(9)</span>
        polymorphism="implicit|explicit"              <span class="co">(10)</span>
        where="arbitrary sql where condition"         <span class="co">(11)</span>
        persister="PersisterClass"                    <span class="co">(12)</span>
        batch-size="N"                                <span class="co">(13)</span>
        optimistic-lock="none|version|dirty|all"      <span class="co">(14)</span>
        lazy="true|false"                             <span class="co">(15)</span>
        abstract="true|false"                         <span class="co">(16)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified .NET class name of the persistent class 
                            (or interface), including its assembly name.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt>(optional - defaults to the unqualified class name): The name of its database table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (optional - defaults to the class name): A value
                            that distiguishes individual subclasses, used for polymorphic behaviour. Acceptable
                            values include <tt class="literal">null</tt> and <tt class="literal">not null</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">mutable</tt> (optional, defaults to <tt class="literal">true</tt>): Specifies 
                            that instances of the class are (not) mutable.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (optional): Override the schema name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies an interface to use for lazy
                            initializing proxies. You may specify the name of the class itself.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-update</tt> (optional, defaults to <tt class="literal">false</tt>): 
                            Specifies that <tt class="literal">UPDATE</tt> SQL should be generated at runtime and 
                            contain only those columns whose values have changed.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">dynamic-insert</tt> (optional, defaults to <tt class="literal">false</tt>): 
                            Specifies that <tt class="literal">INSERT</tt> SQL should be generated at runtime and 
                            contain only the columns whose values are not null.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">select-before-update</tt> (optional, defaults to <tt class="literal">false</tt>): 
                            Specifies that NHibernate should <span class="emphasis"><em>never</em></span> perform an SQL <tt class="literal">UPDATE</tt> 
                            unless it is certain that an object is actually modified. In certain cases (actually, only
                            when a transient object has been associated with a new session using <tt class="literal">update()</tt>),
                            this means that NHibernate will perform an extra SQL <tt class="literal">SELECT</tt> to determine
                            if an <tt class="literal">UPDATE</tt> is actually required.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">polymorphism</tt> (optional, defaults to <tt class="literal">implicit</tt>): 
                            Determines whether implicit or explicit query polymorphism is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">where</tt> (optional) specify an arbitrary SQL <tt class="literal">WHERE</tt> 
                            condition to be used when retrieving objects of this class
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                            <tt class="literal">persister</tt> (optional): Specifies a custom <tt class="literal">IClassPersister</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                            <tt class="literal">batch-size</tt> (optional, defaults to <tt class="literal">1</tt>) specify a "batch size" 
                            for fetching instances of this class by identifier.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional, defaults to <tt class="literal">version</tt>): 
                            Determines the optimistic locking strategy.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(15)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional): Lazy fetching may be completely disabled by setting
                            <tt class="literal">lazy="false"</tt>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(16)</td><td valign="top" align="left"><p>
                            <tt class="literal">abstract</tt> (optional): Used to mark abstract superclasses in
                            <tt class="literal">&lt;union-subclass&gt;</tt> hierarchies.
                        </p></td></tr></table></div></div><p>
                It is perfectly acceptable for the named persistent class to be an interface. You would then
                declare implementing classes of that interface using the <tt class="literal">&lt;subclass&gt;</tt>
                element. You may persist any inner class. You should specify the
                class name using the standard form ie. <tt class="literal">Eg.Foo+Bar, Eg</tt>.
                Due to an HQL parser limitation inner classes can not be used in queries in NHibernate 1.0.
            </p><p>
                Changes to immutable classes, <tt class="literal">mutable="false"</tt>, will not be
                persisted. This allows NHibernate to make some minor performance optimizations.
            </p><p>
                The optional <tt class="literal">proxy</tt> attribute enables lazy initialization of persistent
                instances of the class. NHibernate will initially return proxies which implement 
                the named interface. The actual persistent object will be loaded when a method of the 
                proxy is invoked. See "Proxies for Lazy Initialization" below.
            </p><p><span class="emphasis"><em>Implicit</em></span> polymorphism means that instances of the class will be returned
                by a query that names any superclass or implemented interface or the class and that instances
                of any subclass of the class will be returned by a query that names the class itself. 
                <span class="emphasis"><em>Explicit</em></span> polymorphism means that class instances will be returned only
                be queries that explicitly name that class and that queries that name the class will return
                only instances of subclasses mapped inside this <tt class="literal">&lt;class&gt;</tt> declaration
                as a <tt class="literal">&lt;subclass&gt;</tt> or <tt class="literal">&lt;joined-subclass&gt;</tt>. For
                most purposes the default, <tt class="literal">polymorphism="implicit"</tt>, is appropriate.
                Explicit polymorphism is useful when two different classes are mapped to the same table
                (this allows a "lightweight" class that contains a subset of the table columns).
            </p><p>
                The <tt class="literal">persister</tt> attribute lets you customize the persistence strategy used for
                the class. You may, for example, specify your own subclass of 
                <tt class="literal">NHibernate.Persister.EntityPersister</tt> or you might even provide a
                completely new implementation of the interface 
                <tt class="literal">NHibernate.Persister.IClassPersister</tt> that implements persistence via,
                for example, stored procedure calls, serialization to flat files or LDAP. See
                <tt class="literal">NHibernate.DomainModel.CustomPersister</tt> for a simple example (of "persistence"
                to a <tt class="literal">Hashtable</tt>).
            </p><p>
                Note that the <tt class="literal">dynamic-update</tt> and <tt class="literal">dynamic-insert</tt>
                settings are not inherited by subclasses and so may also be specified on the
                <tt class="literal">&lt;subclass&gt;</tt> or <tt class="literal">&lt;joined-subclass&gt;</tt> elements. 
                These settings may increase performance in some cases, but might actually decrease 
                performance in others. Use judiciously.
            </p><p>
                Use of <tt class="literal">select-before-update</tt> will usually decrease performance. It is very
                useful to prevent a database update trigger being called unnecessarily.
            </p><p>
                If you enable <tt class="literal">dynamic-update</tt>, you will have a choice of optimistic
                locking strategies:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">version</tt> check the version/timestamp columns
                    </p></li><li><p>
                        <tt class="literal">all</tt> check all columns
                    </p></li><li><p>
                        <tt class="literal">dirty</tt> check the changed columns
                    </p></li><li><p>
                        <tt class="literal">none</tt> do not use optimistic locking
                    </p></li></ul></div><p>
                We <span class="emphasis"><em>very</em></span> strongly recommend that you use version/timestamp
                columns for optimistic locking with NHibernate. This is the optimal strategy with
                respect to performance and is the only strategy that correctly handles modifications
                made outside of the session (ie. when <tt class="literal">ISession.Update()</tt> is used).
                Keep in mind that a version or timestamp property should never be null, no matter
                what <tt class="literal">unsaved-value</tt> strategy, or an instance will be detected as
                transient.
            </p><p>
                Beginning with NHibernate 1.2.0, version numbers start with 1, not 0 as in previous
                versions. This was done to allow using 0 as <tt class="literal">unsaved-value</tt> for the
                version property.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-subselect"></a>5.1.4.&nbsp;subselect</h3></div></div><div></div></div><p>
                An alternative to mapping a class is to map a <span class="emphasis"><em>query</em></span>. For that, we use the 
                <tt class="literal">&lt;subselect&gt;</tt> element, which is mutually exclusive with <tt class="literal">&lt;class&gt;</tt>, 
                <tt class="literal">&lt;subclass&gt;</tt>, <tt class="literal">&lt;joined-subclass&gt;</tt> and <tt class="literal">&lt;union-subclass&gt;</tt>. 
                The content of the <tt class="literal">subselect</tt> element is a SQL query:
            </p><pre class="programlisting">&lt;subselect&gt;
    SELECT cat.ID, cat.NAME, cat.SEX, cat.MATE FROM cat
&lt;/subselect&gt;</pre><p>
                Normally, when mapping a query using <tt class="literal">subselect</tt> you will want to mark the class 
                as not mutable (<tt class="literal">mutable="false"</tt>), unless you specify custom SQL for performing 
                the UPDATE, DELETE and INSERT operations.
            </p><p>
                Also, it makes sense to force synchronization of the tables affected by the query, using one or 
                more <tt class="literal">&lt;synchronize&gt;</tt> entries:
            </p><pre class="programlisting">&lt;subselect&gt;
    SELECT cat.ID, cat.NAME, cat.SEX, cat.MATE FROM cat
&lt;/subselect&gt;
&lt;syncronize table="cat"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-id"></a>5.1.5.&nbsp;id</h3></div></div><div></div></div><p>
                Mapped classes <span class="emphasis"><em>must</em></span> declare the primary key column of the database 
                table. Most classes will also have a property holding the unique identifier 
                of an instance. The <tt class="literal">&lt;id&gt;</tt> element defines the mapping from that
                property to the primary key column.
            </p><div class="programlistingco"><pre class="programlisting">&lt;id
        name="PropertyName"                      <span class="co">(1)</span>
        type="typename"                          <span class="co">(2)</span>
        column="column_name"                     <span class="co">(3)</span>
        unsaved-value="any|none|null|id_value"   <span class="co">(4)</span>
        access="field|property|nosetter|ClassName<span class="co">(5)</span>"&gt;

        &lt;generator class="generatorClass"/&gt;
&lt;/id&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt> (optional): The name of the identifier property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional): A name that indicates the NHibernate type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The
                            name of the primary key column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to a "sensible" value): 
                            An identifier property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr></table></div></div><p>
                If the <tt class="literal">name</tt> attribute is missing, it is assumed that the class has no 
                identifier property.
            </p><p>
                The <tt class="literal">unsaved-value</tt> attribute is almost never needed in NHibernate 1.0.
            </p><p>
                There is an alternative <tt class="literal">&lt;composite-id&gt;</tt> declaration to allow access to
                legacy data with composite keys. We strongly discourage its use for anything else.
            </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-generator"></a>5.1.5.1.&nbsp;generator</h4></div></div><div></div></div><p>
                    The required <tt class="literal">generator</tt> names a .NET class used to generate unique identifiers
					for instances of the persistent class.
				</p><p>
					The generator can be declared using the <tt class="literal">&lt;generator&gt;</tt> child element. If 
					any parameters are required to configure or initialize the generator instance, they are passed 
					using <tt class="literal">&lt;param&gt;</tt> elements.
                </p><pre class="programlisting">&lt;id name="Id" type="Int64" column="uid" unsaved-value="0"&gt;
        &lt;generator class="NHibernate.Id.TableHiLoGenerator"&gt;
                &lt;param name="table"&gt;uid_table&lt;/param&gt;
                &lt;param name="column"&gt;next_hi_value_column&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    If no parameters are required, the generator can be declared using a <tt class="literal">generator</tt>
					attribute directly on the <tt class="literal">&lt;id&gt;</tt> element, as follows:
                 </p><pre class="programlisting">&lt;id name="Id" type="Int64" column="uid" unsaved-value="0" generator="native" /&gt;</pre><p>
                    All generators implement the interface <tt class="literal">NHibernate.Id.IIdentifierGenerator</tt>.
                    This is a very simple interface; some applications may choose to provide their own specialized
                    implementations. However, NHibernate provides a range of built-in implementations. There are shortcut
                    names for the built-in generators:

                    </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">increment</tt></span></dt><dd><p>
                                generates identifiers of any integral type that are unique only when
                                no other process is inserting data into the same table.
                                <span class="emphasis"><em>Do not use in a cluster.</em></span>
                            </p></dd><dt><span class="term"><tt class="literal">identity</tt></span></dt><dd><p>
                                supports identity columns in DB2, MySQL, MS SQL Server and Sybase. The identifier
                                returned by the database is converted to the property type using <tt class="literal">
                                Convert.ChangeType</tt>. Any integral property type is thus supported.
                            </p></dd><dt><span class="term"><tt class="literal">sequence</tt></span></dt><dd><p>
                                uses a sequence in DB2, PostgreSQL, Oracle or a generator
                                in Firebird. The identifier returned by the database is converted to the property
                                type using <tt class="literal">Convert.ChangeType</tt>. Any integral property type is
                                thus supported.
                            </p></dd><dt><span class="term"><tt class="literal">hilo</tt></span></dt><dd><p><a name="mapping-declaration-id-hilodescription"></a>
                                uses a hi/lo algorithm to efficiently generate identifiers of any integral type,
                                given a table and column (by default <tt class="literal">hibernate_unique_key</tt> and
                                <tt class="literal">next_hi</tt> respectively) as a source of hi values. The hi/lo algorithm
                                generates identifiers that are unique only for a particular database. <span class="emphasis"><em>Do not
                                use this generator with a user-supplied connection.</em></span>
                            </p><p>
								You can use the "where" parameter to specify the row to use in a table. This is useful
								if you want to use a single tabel for your identifiers, with different rows for each table.
                            </p></dd><dt><span class="term"><tt class="literal">seqhilo</tt></span></dt><dd><p>
                                uses a hi/lo algorithm to efficiently generate identifiers of any integral type,
                                given a named database sequence.
                            </p></dd><dt><span class="term"><tt class="literal">uuid.hex</tt></span></dt><dd><p>
                                uses <tt class="literal">System.Guid</tt> and its <tt class="literal">ToString(string format)</tt> method
                                to generate identifiers of type string.  The length of the string returned depends on the 
                                configured <tt class="literal">format</tt>.
                            </p></dd><dt><span class="term"><tt class="literal">uuid.string</tt></span></dt><dd><p>
                                uses a new <tt class="literal">System.Guid</tt> to create a <tt class="literal">byte[]</tt> that is
                                converted to a string.
                            </p></dd><dt><span class="term"><tt class="literal">guid</tt></span></dt><dd><p>
                                uses a new <tt class="literal">System.Guid</tt> as the identifier.
                            </p></dd><dt><span class="term"><tt class="literal">guid.comb</tt></span></dt><dd><p>
                                uses the algorithm to generate a new <tt class="literal">System.Guid</tt>
                                described by Jimmy Nilsson in the article 
                                http://www.informit.com/articles/article.asp?p=25862.
                            </p></dd><dt><span class="term"><tt class="literal">native</tt></span></dt><dd><p>
                                picks <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> or
                                <tt class="literal">hilo</tt> depending upon the capabilities of the
                                underlying database.
                            </p></dd><dt><span class="term"><tt class="literal">assigned</tt></span></dt><dd><p>
                                lets the application to assign an identifier to the object before
                                <tt class="literal">Save()</tt> is called.
                            </p></dd><dt><span class="term"><tt class="literal">foreign</tt></span></dt><dd><p>
                                uses the identifier of another associated object. Usually used in conjunction
                                with a <tt class="literal">&lt;one-to-one&gt;</tt> primary key association.
                            </p></dd></dl></div><p>

                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-hilo"></a>5.1.5.2.&nbsp;Hi/Lo Algorithm</h4></div></div><div></div></div><p>
                    The <tt class="literal">hilo</tt> and <tt class="literal">seqhilo</tt> generators provide two alternate
                    implementations of the hi/lo algorithm, a favorite approach to identifier generation. The
                    first implementation requires a "special" database table to hold the next available "hi" value.
                    The second uses an Oracle-style sequence (where supported).
                </p><pre class="programlisting">&lt;id name="Id" type="Int64" column="cat_id"&gt;
        &lt;generator class="hilo"&gt;
                &lt;param name="table"&gt;hi_value&lt;/param&gt;
                &lt;param name="column"&gt;next_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="Id" type="Int64" column="cat_id"&gt;
        &lt;generator class="seqhilo"&gt;
                &lt;param name="sequence"&gt;hi_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    Unfortunately, you can't use <tt class="literal">hilo</tt> when supplying your own
                    <tt class="literal">IDbConnection</tt> to NHibernate. NHibernate must be able to
                    fetch the "hi" value in a new transaction.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-uuid-hex"></a>5.1.5.3.&nbsp;UUID Hex Algorithm</h4></div></div><div></div></div><pre class="programlisting">&lt;id name="Id" type="String" column="cat_id"&gt;
        &lt;generator class="uuid.hex"&gt;
            &lt;param name="format"&gt;format_value&lt;/param&gt;
            &lt;param name="separator"&gt;separator_value&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>
                    The UUID is generated by calling <tt class="literal">Guid.NewGuid().ToString(format)</tt>.
                    The valid values for <tt class="literal">format</tt> are described in the MSDN documentation.
                    The default <tt class="literal">separator</tt> is <tt class="literal">-</tt> and should rarely be
                    modified.  The <tt class="literal">format</tt> determines if the configured
                    <tt class="literal">separator</tt> can replace the default separator used by
                    the <tt class="literal">format</tt>.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-uuid-string"></a>5.1.5.4.&nbsp;UUID String Algorithm</h4></div></div><div></div></div><p>
                    The UUID is generated by calling <tt class="literal">Guid.NewGuid().ToByteArray()</tt> and 
                    then converting the <tt class="literal">byte[]</tt> into a <tt class="literal">char[]</tt>.  The
                    <tt class="literal">char[]</tt> is returned as a <tt class="literal">String</tt> consisting of
                    16 characters.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-guid"></a>5.1.5.5.&nbsp;GUID Algorithms</h4></div></div><div></div></div><p>
                    The <tt class="literal">guid</tt> identifier is generated by calling <tt class="literal">Guid.NewGuid()</tt>.
                    To address some of the performance concerns with using Guids as primary keys, foreign keys, and
                    as part of indexes with MS SQL the <tt class="literal">guid.comb</tt> can be used.  The benefit of using  
                    the <tt class="literal">guid.comb</tt> with other databases that support GUIDs has not been measured.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-sequences"></a>5.1.5.6.&nbsp;Identity columns and Sequences</h4></div></div><div></div></div><p>
                    For databases which support identity columns (DB2, MySQL, Sybase, MS SQL), you
                    may use <tt class="literal">identity</tt> key generation. For databases that support
                    sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you may use
                    <tt class="literal">sequence</tt> style key generation. Both these strategies require
                    two SQL queries to insert a new object.
                </p><pre class="programlisting">&lt;id name="Id" type="Int64" column="uid"&gt;
        &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;uid_sequence&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="Id" type="Int64" column="uid" unsaved-value="0"&gt;
        &lt;generator class="identity"/&gt;
&lt;/id&gt;</pre><p>
                    For cross-platform development, the <tt class="literal">native</tt> strategy will
                    choose from the <tt class="literal">identity</tt>, <tt class="literal">sequence</tt> and
                    <tt class="literal">hilo</tt> strategies, dependent upon the capabilities of the
                    underlying database.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-assigned"></a>5.1.5.7.&nbsp;Assigned Identifiers</h4></div></div><div></div></div><p>
                    If you want the application to assign identifiers (as opposed to having
                    NHibernate generate them), you may use the <tt class="literal">assigned</tt> generator.
                    This special generator will use the identifier value already assigned to the
                    object's identifier property. Be very careful when using this feature to assign
                    keys with business meaning (almost always a terrible design decision).
                </p><p>
                    Due to its inherent nature, entities that use this generator cannot be saved
                    via the ISession's SaveOrUpdate() method. Instead you have to explicitly specify to
                    NHibernate if the object should be saved or updated by calling either the
                    <tt class="literal">Save()</tt> or <tt class="literal">Update()</tt> method of the ISession.
                </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mapping-declaration-id-enhanced"></a>5.1.5.8.&nbsp;Enhanced identifier generators</h4></div></div><div></div></div><p>Starting with NHibernate release 3.3.0, there are 2 new generators which
                represent a re-thinking of 2 different aspects of identifier
                generation. The first aspect is database portability; the second is
                optimization Optimization means that you do not have to query the
                database for every request for a new identifier value. These two new
                generators are intended to take the place of some of the named
                generators described above, starting in 3.3.x. However, they are
                included in the current releases and can be referenced by FQN.</p><p>The first of these new generators is
                <tt class="literal">NHibernate.Id.Enhanced.SequenceStyleGenerator</tt>
				(short name <tt class="literal">enhanced-sequence</tt>)
                which is intended, firstly, as a replacement for the
                <tt class="literal">sequence</tt> generator and, secondly, as a better
                portability generator than <tt class="literal">native</tt>. This is because
                <tt class="literal">native</tt> generally chooses between
                <tt class="literal">identity</tt> and <tt class="literal">sequence</tt> which have
                largely different semantics that can cause subtle issues in
                applications eyeing portability.
                <tt class="literal">NHibernate.Id.Enhanced.SequenceStyleGenerator</tt>,
                however, achieves portability in a different manner. It chooses
                between a table or a sequence in the database to store its
                incrementing values, depending on the capabilities of the dialect
                being used. The difference between this and <tt class="literal">native</tt>
                is that table-based and sequence-based storage have the same exact
                semantic. In fact, sequences are exactly what NHibernate tries to
                emulate with its table-based generators. This generator has a number
                of configuration parameters: </p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">sequence_name</tt> (optional, defaults to
                      <tt class="literal">hibernate_sequence</tt>): the name of the sequence
                      or table to be used.</p></li><li><p><tt class="literal">initial_value</tt> (optional, defaults to
                      <tt class="literal">1</tt>): the initial value to be retrieved from
                      the sequence/table. In sequence creation terms, this is
                      analogous to the clause typically named "STARTS WITH".</p></li><li><p><tt class="literal">increment_size</tt> (optional - defaults to
                      <tt class="literal">1</tt>): the value by which subsequent calls to
                      the sequence/table should differ. In sequence creation terms,
                      this is analogous to the clause typically named "INCREMENT
                      BY".</p></li><li><p><tt class="literal">force_table_use</tt> (optional - defaults to
                      <tt class="literal">false</tt>): should we force the use of a table as
                      the backing structure even though the dialect might support
                      sequence?</p></li><li><p><tt class="literal">value_column</tt> (optional - defaults to
                      <tt class="literal">next_val</tt>): only relevant for table
                      structures, it is the name of the column on the table which is
                      used to hold the value.</p></li><li><p><tt class="literal">prefer_sequence_per_entity</tt> (optional -
                      defaults to <tt class="literal">false</tt>): should we create
                      separate sequence for each entity that share current generator
                      based on its name?</p></li><li><p><tt class="literal">sequence_per_entity_suffix</tt> (optional -
                      defaults to <tt class="literal">_SEQ</tt>): suffix added to the name
                      of a dedicated sequence.</p></li><li><p><tt class="literal">optimizer</tt> (optional - defaults to
                      <tt class="literal">none</tt>): See <a href="#mapping-declaration-id-enhanced-optimizers" title="5.1.5.8.1.&nbsp;Identifier generator optimization">Section&nbsp;5.1.5.8.1, &#8220;Identifier generator optimization&#8221;</a></p></li></ul></div><p>The second of these new generators is
                <tt class="literal">NHibernate.Id.Enhanced.TableGenerator</tt> (short name <tt class="literal">enhanced-table</tt>), which is
                intended, firstly, as a replacement for the <tt class="literal">table</tt>
                generator, even though it actually functions much more like
                <tt class="literal">org.hibernate.id.MultipleHiLoPerTableGenerator</tt> (not available in NHibernate), and
                secondly, as a re-implementation of
                <tt class="literal">org.hibernate.id.MultipleHiLoPerTableGenerator</tt> (not available in NHibernate) that
                utilizes the notion of pluggable optimizers. Essentially this
                generator defines a table capable of holding a number of different
                increment values simultaneously by using multiple distinctly keyed
                rows. This generator has a number of configuration parameters:
                </p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">table_name</tt> (optional - defaults to
                      <tt class="literal">hibernate_sequences</tt>): the name of the table
                      to be used.</p></li><li><p><tt class="literal">value_column_name</tt> (optional - defaults
                      to <tt class="literal">next_val</tt>): the name of the column on the
                      table that is used to hold the value.</p></li><li><p><tt class="literal">segment_column_name</tt> (optional -
                      defaults to <tt class="literal">sequence_name</tt>): the name of the
                      column on the table that is used to hold the "segment key". This
                      is the value which identifies which increment value to
                      use.</p></li><li><p><tt class="literal">segment_value</tt> (optional - defaults to
                      <tt class="literal">default</tt>): The "segment key" value for the
                      segment from which we want to pull increment values for this
                      generator.</p></li><li><p><tt class="literal">segment_value_length</tt> (optional -
                      defaults to <tt class="literal">255</tt>): Used for schema generation;
                      the column size to create this segment key column.</p></li><li><p><tt class="literal">initial_value</tt> (optional - defaults to
                      <tt class="literal">1</tt>): The initial value to be retrieved from
                      the table.</p></li><li><p><tt class="literal">increment_size</tt> (optional - defaults to
                      <tt class="literal">1</tt>): The value by which subsequent calls to
                      the table should differ.</p></li><li><p><tt class="literal">optimizer</tt> (optional - defaults to
                      <tt class="literal">??</tt>): See <a href="#mapping-declaration-id-enhanced-optimizers" title="5.1.5.8.1.&nbsp;Identifier generator optimization">Section&nbsp;5.1.5.8.1, &#8220;Identifier generator optimization&#8221;</a>.</p></li></ul></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="mapping-declaration-id-enhanced-optimizers"></a>5.1.5.8.1.&nbsp;Identifier generator optimization</h5></div></div><div></div></div><p>For identifier generators that store values in the database,
                  it is inefficient for them to hit the database on each and every
                  call to generate a new identifier value. Instead, you can group a
                  bunch of them in memory and only hit the database when you have
                  exhausted your in-memory value group. This is the role of the
                  pluggable optimizers. Currently only the two enhanced generators
                  (<a href="#mapping-declaration-id-enhanced" title="5.1.5.8.&nbsp;Enhanced identifier generators">Section&nbsp;5.1.5.8, &#8220;Enhanced identifier generators&#8221;</a> support this
                  operation.</p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">none</tt> (generally this is the default if
                      no optimizer was specified): this will not perform any
                      optimizations and hit the database for each and every
                      request.</p></li><li><p><tt class="literal">hilo</tt>: applies a hi/lo algorithm around
                      the database retrieved values. The values from the database for
                      this optimizer are expected to be sequential. The values
                      retrieved from the database structure for this optimizer
                      indicates the "group number". The
                      <tt class="literal">increment_size</tt> is multiplied by that value in
                      memory to define a group "hi value".</p></li><li><p><tt class="literal">pooled</tt>: as with the case of
                      <tt class="literal">hilo</tt>, this optimizer attempts to minimize the
                      number of hits to the database. Here, however, we simply store
                      the starting value for the "next group" into the database
                      structure rather than a sequential value in combination with an
                      in-memory grouping algorithm. Here,
                      <tt class="literal">increment_size</tt> refers to the values coming
                      from the database.</p></li><li><p><tt class="literal">pooled-lo</tt>: similar to
                      <tt class="literal">pooled</tt>, except that it's the starting value of
					  the "current group" that is stored into the database structure.
					  Here,
                      <tt class="literal">increment_size</tt> refers to the values coming
                      from the database.</p></li></ul></div></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-compositeid"></a>5.1.6.&nbsp;composite-id</h3></div></div><div></div></div><pre class="programlisting">&lt;composite-id
        name="PropertyName"
        class="ClassName"
        unsaved-value="any|none"
        access="field|property|nosetter|ClassName"&gt;

        &lt;key-property name="PropertyName" type="typename" column="column_name"/&gt;
        &lt;key-many-to-one name="PropertyName class="ClassName" column="column_name"/&gt;
        ......
&lt;/composite-id&gt;</pre><p>
                For a table with a composite key, you may map multiple properties of the class
                as identifier properties. The <tt class="literal">&lt;composite-id&gt;</tt> element
                accepts <tt class="literal">&lt;key-property&gt;</tt> property mappings and
                <tt class="literal">&lt;key-many-to-one&gt;</tt> mappings as child elements.
            </p><pre class="programlisting">&lt;composite-id&gt;
        &lt;key-property name="MedicareNumber"/&gt;
        &lt;key-property name="Dependent"/&gt;
&lt;/composite-id&gt;</pre><p>
                Your persistent class <span class="emphasis"><em>must</em></span> override <tt class="literal">Equals()</tt>
                and <tt class="literal">GetHashCode()</tt> to implement composite identifier equality. It must
                also be marked with the <tt class="literal">Serializable</tt> attribute.
            </p><p>
                Unfortunately, this approach to composite identifiers means that a persistent object 
                is its own identifier. There is no convenient "handle" other than the object itself. 
                You must instantiate an instance of the persistent class itself and populate its 
                identifier properties before you can <tt class="literal">Load()</tt> the persistent state
                associated with a composite key. We will describe a much more
                convenient approach where the composite identifier is implemented as a saparate class
                in <a href="#components-compositeid" title="7.4.&nbsp;Components as composite identifiers">Section&nbsp;7.4, &#8220;Components as composite identifiers&#8221;</a>. The attributes described below apply only
                to this alternative approach:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">name</tt> (optional, required for this approach): A property of
                        component type that holds the composite identifier (see next section).
                    </p></li><li><p>
                        <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>):
                        The strategy NHibernate should use for accessing the property value.
                    </p></li><li><p>
                        <tt class="literal">class</tt> (optional - defaults to the property type determined by 
                        reflection): The component class used as a composite identifier (see next section).
                    </p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-discriminator"></a>5.1.7.&nbsp;discriminator</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;discriminator&gt;</tt> element is required for polymorphic persistence 
                using the table-per-class-hierarchy mapping strategy and declares a discriminator column of the 
                table. The discriminator column contains marker values that tell the persistence layer what 
                subclass to instantiate for a particular row. A restricted set of types may be used: 
                <tt class="literal">String</tt>, <tt class="literal">Char</tt>, <tt class="literal">Int32</tt>, 
                <tt class="literal">Byte</tt>, <tt class="literal">Short</tt>, <tt class="literal">Boolean</tt>, 
                <tt class="literal">YesNo</tt>, <tt class="literal">TrueFalse</tt>.
            </p><div class="programlistingco"><pre class="programlisting">&lt;discriminator
        column="discriminator_column"  <span class="co">(1)</span>
        type="discriminator_type"      <span class="co">(2)</span>
        force="true|false"             <span class="co">(3)</span>
        insert="true|false"            <span class="co">(4)</span>
        formula="arbitrary SQL expressi<span class="co">(5)</span>on"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to <tt class="literal">class</tt>) the
                            name of the discriminator column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional - defaults to <tt class="literal">String</tt>) a
                            name that indicates the NHibernate type
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">force</tt> (optional - defaults to <tt class="literal">false</tt>) 
                            "force" NHibernate to specify allowed discriminator values even when retrieving 
                            all instances of the root class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt> (optional - defaults to <tt class="literal">true</tt>)
                            set this to <tt class="literal">false</tt> if your discriminator column is also part
                            of a mapped composite identifier.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional) an arbitrary SQL expression that is 
                            executed when a type has to be evaluated. Allows content-based discrimination.
                        </p></td></tr></table></div></div><p>
                Actual values of the discriminator column are specified by the
                <tt class="literal">discriminator-value</tt> attribute of the <tt class="literal">&lt;class&gt;</tt> and
                <tt class="literal">&lt;subclass&gt;</tt> elements.
            </p><p>
                The <tt class="literal">force</tt> attribute is (only) useful if the table contains rows with
                "extra" discriminator values that are not mapped to a persistent class. This will not
                usually be the case.
            </p><p>
                Using the <tt class="literal">formula</tt> attribute you can declare an arbitrary SQL expression
                that will be used to evaluate the type of a row:
            </p><pre class="programlisting">&lt;discriminator
    formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
    type="Int32"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-version"></a>5.1.8.&nbsp;version (optional)</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;version&gt;</tt> element is optional and indicates that
                the table contains versioned data. This is particularly useful if you plan to
                use <span class="emphasis"><em>long transactions</em></span> (see below).
            </p><div class="programlistingco"><pre class="programlisting">&lt;version
        column="version_column"                            <span class="co">(1)</span>
        name="PropertyName"                                <span class="co">(2)</span>
        type="typename"                                    <span class="co">(3)</span>
        access="field|property|nosetter|ClassName"         <span class="co">(4)</span>
        unsaved-value="null|negative|undefined|value"      <span class="co">(5)</span>
        generated="never|always"                           <span class="co">(6)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The name
                            of the column holding the version number.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of a property  of the persistent class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional - defaults to <tt class="literal">Int32</tt>): 
                            The type of the version number.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to a "sensible" value): 
                            A version property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session. (<tt class="literal">undefined</tt> specifies that the identifier
                            property value should be used.)
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">generated</tt> (optional - defaults to <tt class="literal">never</tt>):
                            Specifies that this version property value is actually generated by the database.
                            See the discussion of <a href="#mapping-generated" title="5.5.&nbsp;Generated Properties">Section&nbsp;5.5, &#8220;Generated Properties&#8221;</a>.
                        </p></td></tr></table></div></div><p>
                Version numbers may be of type <tt class="literal">Int64</tt>, <tt class="literal">Int32</tt>,
                <tt class="literal">Int16</tt>, <tt class="literal">Ticks</tt>, <tt class="literal">Timestamp</tt>, 
                or <tt class="literal">TimeSpan</tt> (or their nullable counterparts in .NET 2.0).
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-timestamp"></a>5.1.9.&nbsp;timestamp (optional)</h3></div></div><div></div></div><p>
                The optional <tt class="literal">&lt;timestamp&gt;</tt> element indicates that the table contains 
                timestamped data. This is intended as an alternative to versioning. Timestamps are by nature
                a less safe implementation of optimistic locking. However, sometimes the application might
                use the timestamps in other ways.
            </p><div class="programlistingco"><pre class="programlisting">&lt;timestamp
        column="timestamp_column"           <span class="co">(1)</span>
        name="PropertyName"                 <span class="co">(2)</span>
        access="field|property|nosetter|Clas<span class="co">(3)</span>sName"
        unsaved-value="null|undefined|value"<span class="co">(4)</span>
        generated="never|always"            <span class="co">(5)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): The name
                            of a column holding the timestamp.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of a property of .NET type
                            <tt class="literal">DateTime</tt> of the persistent class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">unsaved-value</tt> (optional - defaults to <tt class="literal">null</tt>): 
                            A timestamp property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session. (<tt class="literal">undefined</tt> specifies that the identifier
                            property value should be used.)
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">generated</tt> (optional - defaults to <tt class="literal">never</tt>):
                            Specifies that this timestamp property value is actually generated by the database.
                            See the discussion of <a href="#mapping-generated" title="5.5.&nbsp;Generated Properties">Section&nbsp;5.5, &#8220;Generated Properties&#8221;</a>.
                        </p></td></tr></table></div></div><p>
                Note that <tt class="literal">&lt;timestamp&gt;</tt> is equivalent to 
                <tt class="literal">&lt;version type="timestamp"&gt;</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-property"></a>5.1.10.&nbsp;property</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;property&gt;</tt> element declares a persistent property
                of the class.
            </p><div class="programlistingco"><pre class="programlisting">&lt;property
        name="propertyName"                 <span class="co">(1)</span>
        column="column_name"                <span class="co">(2)</span>
        type="typename"                     <span class="co">(3)</span>
        update="true|false"                 <span class="co">(4)</span>
        insert="true|false"                 <span class="co">(4)</span>
        formula="arbitrary SQL expression"  <span class="co">(5)</span>
        access="field|property|ClassName"   <span class="co">(6)</span>
        optimistic-lock="true|false"        <span class="co">(7)</span>
        generated="never|insert|always"     <span class="co">(8)</span>
        lazy="true|false"                   <span class="co">(9)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: the name of the property of your class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional - defaults to the property name): the name
                            of the mapped database table column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">type</tt> (optional): a name that indicates the NHibernate type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (optional - defaults to <tt class="literal">true</tt>) :
                            specifies that the mapped columns should be included in SQL <tt class="literal">UPDATE</tt> 
                            and/or <tt class="literal">INSERT</tt> statements. Setting both to <tt class="literal">false</tt>
                            allows a pure "derived" property whose value is initialized from some other
                            property that maps to the same column(s) or by a trigger or other application.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">formula</tt> (optional): an SQL expression that defines the value for a
                            <span class="emphasis"><em>computed</em></span> property. Computed properties do not have a column
                            mapping of their own.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>): 
                            Specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, determines if a version increment should occur when 
                            this property is dirty.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">generated</tt> (optional - defaults to <tt class="literal">never</tt>):
                            Specifies that this property value is actually generated by the database.
                            See the discussion of <a href="#mapping-generated" title="5.5.&nbsp;Generated Properties">Section&nbsp;5.5, &#8220;Generated Properties&#8221;</a>.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">false</tt>):
                            Specifies that this property is lazy. A lazy property is not loaded when
                            the object is initially loaded, unless the fetch mode has been overriden
                            in a specific query. Values for lazy properties are loaded when any lazy
                            property of the object is accessed.
                        </p></td></tr></table></div></div><p>
                <span class="emphasis"><em>typename</em></span> could be:
            </p><div class="orderedlist"><ol type="1" compact><li><p>
                        The name of a NHibernate basic type (eg. <tt class="literal">Int32, String, Char,
                        DateTime, Timestamp, Single, Byte[], Object, ...</tt>).
                    </p></li><li><p>
                        The name of a .NET type with a default basic type (eg. <tt class="literal">System.Int16, System.Single,
                        System.Char, System.String, System.DateTime, System.Byte[], ...</tt>).
                    </p></li><li><p>
                        The name of an enumeration type (eg. <tt class="literal">Eg.Color, Eg</tt>).
                    </p></li><li><p>
                        The name of a serializable .NET type.
                    </p></li><li><p>
                        The class name of a custom type (eg. <tt class="literal">Illflow.Type.MyCustomType</tt>).
                    </p></li></ol></div><p>
                Note that you have to specify full <span class="emphasis"><em>assembly-qualified</em></span> names for all
                except basic NHibernate types (unless you set <tt class="literal">assembly</tt>
                and/or <tt class="literal">namespace</tt> attributes of the
                <tt class="literal">&lt;hibernate-mapping&gt;</tt> element).
            </p><p>
                NHibernate supports .NET 2.0 <tt class="literal">Nullable</tt> types. These types are
                mostly treated the same as plain non-<tt class="literal">Nullable</tt> types internally.
                For example, a property of type <tt class="literal">Nullable&lt;Int32&gt;</tt> can be mapped
                using <tt class="literal">type="Int32"</tt> or <tt class="literal">type="System.Int32"</tt>.
            </p><p>
                If you do not specify a type, NHibernate will use reflection upon the named
                property to take a guess at the correct NHibernate type. NHibernate will try to
                interpret the name of the return class of the property getter using rules 2, 3,
                4 in that order. However, this is not always enough.
                In certain cases you will still need the <tt class="literal">type</tt>
                attribute. (For example, to distinguish between <tt class="literal">NHibernateUtil.DateTime</tt> and
                <tt class="literal">NHibernateUtil.Timestamp</tt>, or to specify a custom type.)
            </p><p>
                The <tt class="literal">access</tt> attribute lets you control how NHibernate will access
                the value of the property at runtime.  The value of the <tt class="literal">access</tt> attribute should
                be text formatted as <tt class="literal">access-strategy.naming-strategy</tt>.  The 
                <tt class="literal">.naming-strategy</tt> is not always required.
                </p><div class="table"><a name="d0e3932"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;Access Strategies</b></p><table summary="Access Strategies" border="1"><colgroup><col><col></colgroup><thead><tr><th>Access Strategy Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">property</tt></td><td><p>
                                        The default implementation.  NHibernate uses the get/set accessors of
                                        the property.  No naming strategy should be used with this access strategy
                                        because the value of the <tt class="literal">name</tt> attribute is the name
                                        of the property.
                                    </p></td></tr><tr><td><tt class="literal">field</tt></td><td><p>
                                        NHibernate will access the field directly.  NHibernate uses the value
                                        of the <tt class="literal">name</tt> attribute as the name of the field.
                                        This can be used when a property's getter and setter contain extra actions
                                        that you don't want to occur when NHibernate is populating or reading
                                        the object. If you want the name of the property and not the field to
                                        be what the consumers of your API use with HQL, then a naming strategy
                                        is needed.
                                    </p></td></tr><tr><td><tt class="literal">nosetter</tt></td><td><p>
                                        NHibernate will access the field directly when setting the value and will use the
                                        Property when getting the value.  This can be used when a property only exposes
                                        a get accessor because the consumers of your API can't change the value directly.
                                        A naming strategy is required because NHibernate uses the value of the
                                        <tt class="literal">name</tt> attribute as the property name and needs to 
                                        be told what the name of the field is.
                                    </p></td></tr><tr><td><tt class="literal">ClassName</tt></td><td><p>
                                        If NHibernate's built in access strategies are not what is needed for your situation
                                        then you can build your own by implementing the interface 
                                        <tt class="literal">NHibernate.Property.IPropertyAccessor</tt>.  The value of the 
                                        <tt class="literal">access</tt> attribute should be an assembly-qualified name that can be 
                                        loaded with <tt class="literal">Activator.CreateInstance(string assemblyQualifiedName)</tt>.
                                    </p></td></tr></tbody></table></div><p>
            </p><p>
                </p><div class="table"><a name="d0e3992"></a><p class="title"><b>Table&nbsp;5.2.&nbsp;Naming Strategies</b></p><table summary="Naming Strategies" border="1"><colgroup><col><col></colgroup><thead><tr><th>Naming Strategy Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">camelcase</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is converted to camel case to find the field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">fooBar</tt>.
                                    </p></td></tr><tr><td><tt class="literal">camelcase-underscore</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is converted to camel case and prefixed with an
                                        underscore to find the field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">_fooBar</tt>.
                                    </p></td></tr><tr><td><tt class="literal">camelcase-m-underscore</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is converted to camel case and prefixed with
                                        the character <tt class="literal">m</tt> and an underscore to find the field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">m_fooBar</tt>.
                                    </p></td></tr><tr><td><tt class="literal">lowercase</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is converted to lower case to find the Field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">foobar</tt>.
                                    </p></td></tr><tr><td><tt class="literal">lowercase-underscore</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is converted to lower case and prefixed with an
                                        underscore to find the Field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">_foobar</tt>.
                                    </p></td></tr><tr><td><tt class="literal">pascalcase-underscore</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is prefixed with an underscore to find the field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">_FooBar</tt>.
                                    </p></td></tr><tr><td><tt class="literal">pascalcase-m</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is prefixed with the character
                                        <tt class="literal">m</tt> to find the field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">mFooBar</tt>.
                                    </p></td></tr><tr><td><tt class="literal">pascalcase-m-underscore</tt></td><td><p>
                                        The <tt class="literal">name</tt> attribute is prefixed with the character
                                        <tt class="literal">m</tt> and an underscore to find the field.
                                        <tt class="literal">&lt;property name="FooBar" ... &gt;</tt> uses the field <tt class="literal">m_FooBar</tt>.
                                    </p></td></tr></tbody></table></div><p>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-manytoone"></a>5.1.11.&nbsp;many-to-one</h3></div></div><div></div></div><p>
                An ordinary association to another persistent class is declared using a
                <tt class="literal">many-to-one</tt> element. The relational model is a
                many-to-one association. (It's really just an object reference.)
            </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-one
        name="PropertyName"                                <span class="co">(1)</span>
        column="column_name"                               <span class="co">(2)</span>
        class="ClassName"                                  <span class="co">(3)</span>
        cascade="all|none|save-update|delete|delete-orphan|<span class="co">(4)</span>all-delete-orphan"
        fetch="join|select"                                <span class="co">(5)</span>
        update="true|false"                                <span class="co">(6)</span>
        insert="true|false"                                <span class="co">(6)</span>
        property-ref="PropertyNameFromAssociatedClass"     <span class="co">(7)</span>
        access="field|property|nosetter|ClassName"         <span class="co">(8)</span>
        unique="true|false"                                <span class="co">(9)</span>
        optimistic-lock="true|false"                       <span class="co">(10)</span>
        not-found="ignore|exception"                       <span class="co">(11)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">column</tt> (optional): The name of the column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional): Specifies which operations should
                            be cascaded from the parent object to the associated object.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optional - defaults to <tt class="literal">select</tt>): 
                            Chooses between outer-join fetching or sequential select fetching.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">update, insert</tt> (optional - defaults to <tt class="literal">true</tt>) 
                            specifies that the mapped columns should be included in SQL <tt class="literal">UPDATE</tt> 
                            and/or <tt class="literal">INSERT</tt> statements. Setting both to <tt class="literal">false</tt>
                            allows a pure "derived" association whose value is initialized from some other
                            property that maps to the same colum(s) or by a trigger or other application.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt>: (optional) The name of a property of the associated 
                            class that is joined to this foreign key. If not specified, the primary key of
                            the associated class is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                            <tt class="literal">unique</tt> (optional): Enable the DDL generation of a unique
                            constraint for the foreign-key column.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>): 
                            Specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, dertermines if a version increment should occur when 
                            this property is dirty.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                            <tt class="literal">not-found</tt> (optional - defaults to <tt class="literal">exception</tt>):
                            Specifies how foreign keys that reference missing rows will be handled:
                            <tt class="literal">ignore</tt> will treat a missing row as a null association.
                        </p></td></tr></table></div></div><p>
                The <tt class="literal">cascade</tt> attribute permits the following values: 
                <tt class="literal">all</tt>, <tt class="literal">save-update</tt>, <tt class="literal">delete</tt>,
                <tt class="literal">none</tt>. Setting a value other than <tt class="literal">none</tt>
                will propagate certain operations to the associated (child) object.
                See "Lifecycle Objects" below.
            </p><p>
                The <tt class="literal">fetch</tt> attribute accepts two different values:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">join</tt> Fetch the association using an outer join
                    </p></li><li><p>
                        <tt class="literal">select</tt> Fetch the association using a separate query
                    </p></li></ul></div><p>
                A typical <tt class="literal">many-to-one</tt> declaration looks as simple as
            </p><pre class="programlisting">&lt;many-to-one name="product" class="Product" column="PRODUCT_ID"/&gt;</pre><p>
                The <tt class="literal">property-ref</tt> attribute should only be used for mapping legacy
                data where a foreign key refers to a unique key of the associated table other than
                the primary key. This is an ugly relational model. For example, suppose the 
                <tt class="literal">Product</tt> class had a unique serial number, that is not the primary 
                key. (The <tt class="literal">unique</tt> attribute controls NHibernate's DDL generation with
                the SchemaExport tool.)
            </p><pre class="programlisting">&lt;property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/&gt;</pre><p>
                Then the mapping for <tt class="literal">OrderItem</tt> might use:
            </p><pre class="programlisting">&lt;many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/&gt;</pre><p>
                This is certainly not encouraged, however.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-onetoone"></a>5.1.12.&nbsp;one-to-one</h3></div></div><div></div></div><p>
                A one-to-one association to another persistent class is declared using a 
                <tt class="literal">one-to-one</tt> element.
            </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-one
        name="PropertyName"                                <span class="co">(1)</span>
        class="ClassName"                                  <span class="co">(2)</span>
        cascade="all|none|save-update|delete|delete-orphan|<span class="co">(3)</span>all-delete-orphan"
        constrained="true|false"                           <span class="co">(4)</span>
        fetch="join|select"                                <span class="co">(5)</span>
        property-ref="PropertyNameFromAssociatedClass"     <span class="co">(6)</span>
        access="field|property|nosetter|ClassName"         <span class="co">(7)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the associated class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional) specifies which operations should
                            be cascaded from the parent object to the associated object.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">constrained</tt> (optional) specifies that a foreign key constraint
                            on the primary key of the mapped table references the table of the associated
                            class. This option affects the order in which <tt class="literal">Save()</tt> and
                            <tt class="literal">Delete()</tt> are cascaded (and is also used by the schema export
                            tool).
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optional - defaults to <tt class="literal">select</tt>): 
                            Chooses between outer-join fetching or sequential select fetching.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">property-ref</tt>: (optional) The name of a property of the associated class
                            that is joined to the primary key of this class. If not specified, the primary key of
                            the associated class is used.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr></table></div></div><p>
                There are two varieties of one-to-one association:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                primary key associations
            </p></li><li><p>
                unique foreign key associations
            </p></li></ul></div><p>
                Primary key associations don't need an extra table column; if two rows are related by
                the association then the two table rows share the same primary key value. So if you want 
                two objects to be related by a primary key association, you must make sure that they
                are assigned the same identifier value!
            </p><p>
                For a primary key association, add the following mappings to <tt class="literal">Employee</tt> and 
                <tt class="literal">Person</tt>, respectively.
            </p><pre class="programlisting">&lt;one-to-one name="Person" class="Person"/&gt;</pre><pre class="programlisting">&lt;one-to-one name="Employee" class="Employee" constrained="true"/&gt;</pre><p>
                Now we must ensure that the primary keys of related rows in the PERSON and
                EMPLOYEE tables are equal. We use a special NHibernate identifier generation strategy
                called <tt class="literal">foreign</tt>:
            </p><pre class="programlisting">&lt;class name="Person" table="PERSON"&gt;
    &lt;id name="Id" column="PERSON_ID"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;Employee&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    ...
    &lt;one-to-one name="Employee"
        class="Employee"
        constrained="true"/&gt;
&lt;/class&gt;</pre><p>
                A newly saved instance of <tt class="literal">Person</tt> is then assigned the same primar
                key value as the <tt class="literal">Employee</tt> instance refered with the <tt class="literal">Employee</tt>
                property of that <tt class="literal">Person</tt>.
            </p><p>
                Alternatively, a foreign key with a unique constraint, from <tt class="literal">Employee</tt> to 
                <tt class="literal">Person</tt>, may be expressed as:
            </p><pre class="programlisting">&lt;many-to-one name="Person" class="Person" column="PERSON_ID" unique="true"/&gt;</pre><p>
                And this association may be made bidirectional by adding the following to the 
                <tt class="literal">Person</tt> mapping:
            </p><pre class="programlisting">&lt;one-to-one name="Employee" class="Employee" property-ref="Person"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-naturalid"></a>5.1.13.&nbsp;natural-id</h3></div></div><div></div></div><pre class="programlisting">&lt;natural-id mutable="true|false"/&gt;
        &lt;property ... /&gt;
        &lt;many-to-one ... /&gt;
        ......
&lt;/natural-id&gt;</pre><p>
                Even though we recommend the use of surrogate keys as primary keys, you should still try
                to identify natural keys for all entities. A natural key is a property or combination of
                properties that is unique and non-null. If it is also immutable, even better. Map the
                properties of the natural key inside the <tt class="literal">&lt;natural-id&gt;</tt> element.
                NHibernate will generate the necessary unique key and nullability constraints, and your
                mapping will be more self-documenting.
            </p><p>
                We strongly recommend that you implement <tt class="literal">Equals()</tt> and
                <tt class="literal">GetHashCode()</tt> to compare the natural key properties of the entity.
            </p><p>
                This mapping is not intended for use with entities with natural primary keys.
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">mutable</tt> (optional, defaults to <tt class="literal">false</tt>):
                        By default, natural identifier properties as assumed to be immutable (constant).
                    </p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-component"></a>5.1.14.&nbsp;component, dynamic-component</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;component&gt;</tt> element maps properties of a
                child object to columns of the table of a parent class. Components may, in
                turn, declare their own properties, components or collections. See
                "Components" below.
            </p><div class="programlistingco"><pre class="programlisting">&lt;component 
        name="PropertyName"                                <span class="co">(1)</span>
        class="ClassName"                                  <span class="co">(2)</span>
        insert="true|false"                                <span class="co">(3)</span>
        upate="true|false"                                 <span class="co">(4)</span>
        access="field|property|nosetter|ClassName"         <span class="co">(5)</span>
        optimistic-lock="true|false"&gt;                      <span class="co">(6)</span>
        
        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/component&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The name of the property.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt> (optional - defaults to the property type
                            determined by reflection): The name of the component (child) class.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">insert</tt>: Do the mapped columns appear in SQL 
                            <tt class="literal">INSERT</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">update</tt>: Do the mapped columns appear in SQL 
                            <tt class="literal">UPDATE</tt>s?
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>):
                            Specifies that updates to this component do or do not require acquisition of the
                            optimistic lock. In other words, determines if a version increment should occur when 
                            this property is dirty.
                        </p></td></tr></table></div></div><p>
                The child <tt class="literal">&lt;property&gt;</tt> tags map properties of the
                child class to table columns.
            </p><p>
                The <tt class="literal">&lt;component&gt;</tt> element allows a <tt class="literal">&lt;parent&gt;</tt>
                subelement that maps a property of the component class as a reference back to the
                containing entity.
            </p><p>
                The <tt class="literal">&lt;dynamic-component&gt;</tt> element allows an <tt class="literal">IDictionary</tt>
                to be mapped as a component, where the property names refer to keys of the dictionary.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-properties"></a>5.1.15.&nbsp;properties</h3></div></div><div></div></div><p>
            The <tt class="literal">&lt;properties&gt;</tt> element allows the
            definition of a named, logical grouping of the properties of a class.
            The most important use of the construct is that it allows a combination
            of properties to be the target of a <tt class="literal">property-ref</tt>. It
            is also a convenient way to define a multi-column unique constraint. For
            example:
          </p><div class="programlistingco"><pre class="programlisting">&lt;properties
      name="logicalName"                                   <span class="co">(1)</span>
      insert="true|false"                                  <span class="co">(2)</span>
      update="true|false"                                  <span class="co">(3)</span>
      optimistic-lock="true|false"                         <span class="co">(4)</span>
      unique="true|false"&gt;                                 <span class="co">(5)</span>

      &lt;property .../&gt;
      &lt;many-to-one .../&gt;
      ........
&lt;/properties&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                  <tt class="literal">name</tt>: the logical name of the grouping.
                  It is <span class="emphasis"><em>not</em></span> an actual property name.
                </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                  <tt class="literal">insert</tt>: do the mapped columns appear in
                  SQL <tt class="literal">INSERTs</tt>?
                </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                  <tt class="literal">update</tt>: do the mapped columns appear in
                  SQL <tt class="literal">UPDATEs</tt>?
                </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                  <tt class="literal">optimistic-lock</tt> (optional - defaults to
                  <tt class="literal">true</tt>): specifies that updates to these
                  properties either do or do not require acquisition of the
                  optimistic lock. It determines if a version increment should occur
                  when these properties are dirty.
                </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                  <tt class="literal">unique</tt> (optional - defaults to
                  <tt class="literal">false</tt>): specifies that a unique constraint
                  exists upon all mapped columns of the component.
                </p></td></tr></table></div></div><p>
            For example, if we have the following
            <tt class="literal">&lt;properties&gt;</tt> mapping:
          </p><pre class="programlisting">&lt;class name="Person"&gt;
      &lt;id name="personNumber" /&gt;
      &lt;properties name="name" unique="true" update="false"&gt;
          &lt;property name="firstName" /&gt;
          &lt;property name="lastName" /&gt;
          &lt;property name="initial" /&gt;
      &lt;/properties&gt;
&lt;/class&gt;</pre><p>
            You might have some legacy data association that refers to this
            unique key of the <tt class="literal">Person</tt> table, instead of to the
            primary key:
          </p><pre class="programlisting">&lt;many-to-one name="owner" class="Person" property-ref="name"&gt;
        &lt;column name="firstName" /&gt;
        &lt;column name="lastName" /&gt;
        &lt;column name="initial" /&gt;
&lt;/many-to-one&gt;</pre><p>
            The use of this outside the context of mapping legacy data is not
            recommended.
          </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-subclass"></a>5.1.16.&nbsp;subclass</h3></div></div><div></div></div><p>
                Finally, polymorphic persistence requires the declaration of each subclass of
                the root persistent class. For the (recommended) table-per-class-hierarchy
                mapping strategy, the <tt class="literal">&lt;subclass&gt;</tt> declaration is used.
            </p><div class="programlistingco"><pre class="programlisting">&lt;subclass
        name="ClassName"                              <span class="co">(1)</span>
        discriminator-value="discriminator_value"     <span class="co">(2)</span>
        proxy="ProxyInterface"                        <span class="co">(3)</span>
        lazy="true|false"                             <span class="co">(4)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"&gt;

        &lt;property .... /&gt;
        &lt;properties .... /&gt;
        .....
&lt;/subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified .NET class name of the
                            subclass, including its assembly name.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">discriminator-value</tt> (optional - defaults to the class name): A
                            value that distiguishes individual subclasses.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies a class or interface to use for 
                            lazy initializing proxies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional, defaults to <tt class="literal">true</tt>): Setting
                            <tt class="literal">lazy="false"</tt> disables the use of lazy fetching.
                        </p></td></tr></table></div></div><p>
                Each subclass should declare its own persistent properties and subclasses.
                <tt class="literal">&lt;version&gt;</tt> and <tt class="literal">&lt;id&gt;</tt> properties
                are assumed to be inherited from the root class. Each subclass in a hierarchy must
                define a unique <tt class="literal">discriminator-value</tt>. If none is specified, the
                fully qualified .NET class name is used.
            </p><p>
                For information about inheritance mappings, see <a href="#inheritance" title="Chapter&nbsp;8.&nbsp;Inheritance Mapping">Chapter&nbsp;8, <i>Inheritance Mapping</i></a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-joinedsubclass"></a>5.1.17.&nbsp;joined-subclass</h3></div></div><div></div></div><p>
                Alternatively, a subclass that is persisted to its own table (table-per-subclass 
                mapping strategy) is declared using a <tt class="literal">&lt;joined-subclass&gt;</tt>
                element.
            </p><div class="programlistingco"><pre class="programlisting">&lt;joined-subclass
        name="ClassName"                    <span class="co">(1)</span>
        proxy="ProxyInterface"              <span class="co">(2)</span>
        lazy="true|false"                   <span class="co">(3)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"&gt;

        &lt;key .... &gt;

        &lt;property .... /&gt;
        &lt;properties .... /&gt;
        .....
&lt;/joined-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified class name of the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies a class or interface to use 
                            for lazy initializing proxies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional): Setting <tt class="literal">lazy="true"</tt> is a shortcut 
                            equalivalent to specifying the name of the class itself as the <tt class="literal">proxy</tt>
                            interface.
                        </p></td></tr></table></div></div><p>
                No discriminator column is required for this mapping strategy. Each subclass must,
                however, declare a table column holding the object identifier using the
                <tt class="literal">&lt;key&gt;</tt> element. The mapping at the start of the chapter
                would be re-written as:
            </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2" assembly="Eg"
    namespace="Eg"&gt;

        &lt;class name="Cat" table="CATS"&gt;
                &lt;id name="Id" column="uid" type="Int64"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;property name="BirthDate" type="Date"/&gt;
                &lt;property name="Color" not-null="true"/&gt;
                &lt;property name="Sex" not-null="true"/&gt;
                &lt;property name="Weight"/&gt;
                &lt;many-to-one name="Mate"/&gt;
                &lt;set name="Kittens"&gt;
                        &lt;key column="MOTHER"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;joined-subclass name="DomesticCat" table="DOMESTIC_CATS"&gt;
                    &lt;key column="CAT"/&gt;
                        &lt;property name="Name" type="String"/&gt;
                &lt;/joined-subclass&gt;
        &lt;/class&gt;

        &lt;class name="Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
                For information about inheritance mappings, see <a href="#inheritance" title="Chapter&nbsp;8.&nbsp;Inheritance Mapping">Chapter&nbsp;8, <i>Inheritance Mapping</i></a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-unionsubclass"></a>5.1.18.&nbsp;union-subclass</h3></div></div><div></div></div><p>
               A third option is to map only the concrete classes of an inheritance hierarchy
               to tables, (the table-per-concrete-class strategy) where each table defines all
               persistent state of the class, including inherited state. In NHibernate, it is
               not absolutely necessary to explicitly map such inheritance hierarchies. You
               can simply map each class with a separate <tt class="literal">&lt;class&gt;</tt>
               declaration. However, if you wish use polymorphic associations (e.g. an association
               to the superclass of your hierarchy), you need to
               use the <tt class="literal">&lt;union-subclass&gt;</tt> mapping.
           </p><div class="programlistingco"><pre class="programlisting">&lt;union-subclass
        name="ClassName"                    <span class="co">(1)</span>
        table="tablename"                   <span class="co">(2)</span>
        proxy="ProxyInterface"              <span class="co">(3)</span>
        lazy="true|false"                   <span class="co">(4)</span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        abstract="true|false"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name"&gt;

        &lt;property .... /&gt;
        &lt;properties .... /&gt;
        .....
&lt;/union-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: The fully qualified class name of the subclass.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt>: The name of the subclass table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">proxy</tt> (optional): Specifies a class or interface to use
                            for lazy initializing proxies.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">lazy</tt> (optional, defaults to <tt class="literal">true</tt>): Setting
                            <tt class="literal">lazy="false"</tt> disables the use of lazy fetching.
                         </p></td></tr></table></div></div><p>
                No discriminator column or key column is required for this mapping strategy.
            </p><p>
                For information about inheritance mappings, see <a href="#inheritance" title="Chapter&nbsp;8.&nbsp;Inheritance Mapping">Chapter&nbsp;8, <i>Inheritance Mapping</i></a>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-join"></a>5.1.19.&nbsp;join</h3></div></div><div></div></div><p>
                Using the <tt class="literal">&lt;join&gt;</tt> element, it is possible to map
                properties of one class to several tables, when there's a 1-to-1 relationship between the tables.
            </p><div class="programlistingco"><pre class="programlisting">&lt;join
        table="tablename"                        <span class="co">(1)</span>
        schema="owner"                           <span class="co">(2)</span>
        fetch="join|select"                      <span class="co">(3)</span>
        inverse="true|false"                     <span class="co">(4)</span>
        optional="true|false"&gt;                   <span class="co">(5)</span>

        &lt;key ... /&gt;

        &lt;property ... /&gt;
        ...
&lt;/join&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">table</tt>: The name of the joined table.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">schema</tt> (optional): Override the schema name specified by
                            the root <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">fetch</tt> (optional - defaults to <tt class="literal">join</tt>):
                            If set to <tt class="literal">join</tt>, the default, NHibernate will use an inner join
                            to retrieve a <tt class="literal">&lt;join&gt;</tt> defined by a class or its superclasses
                            and an outer join for a <tt class="literal">&lt;join&gt;</tt> defined by a subclass.
                            If set to <tt class="literal">select</tt> then NHibernate will use a sequential select for
                            a <tt class="literal">&lt;join&gt;</tt> defined on a subclass, which will be issued only
                            if a row turns out to represent an instance of the subclass. Inner joins will still
                            be used to retrieve a <tt class="literal">&lt;join&gt;</tt> defined by the class and its
                            superclasses.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">inverse</tt> (optional - defaults to <tt class="literal">false</tt>):
                            If enabled, NHibernate will not try to insert or update the properties defined
                            by this join.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">optional</tt> (optional - defaults to <tt class="literal">false</tt>):
                            If enabled, NHibernate will insert a row only if the properties defined by this
                            join are non-null and will always use an outer join to retrieve the properties.
                        </p></td></tr></table></div></div><p>
                For example, the address information for a person can be mapped to a separate
                table (while preserving value type semantics for all properties):
            </p><pre class="programlisting">&lt;class name="Person"
    table="PERSON"&gt;

    &lt;id name="id" column="PERSON_ID"&gt;...&lt;/id&gt;

    &lt;join table="ADDRESS"&gt;
        &lt;key column="ADDRESS_ID"/&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/join&gt;
    ...</pre><p>
                This feature is often only useful for legacy data models, we recommend fewer
                tables than classes and a fine-grained domain model. However, it is useful
                for switching between inheritance mapping strategies in a single hierarchy, as
                explained later.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-collections"></a>5.1.20.&nbsp;map, set, list, bag</h3></div></div><div></div></div><p>
                Collections are discussed later.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-declaration-import"></a>5.1.21.&nbsp;import</h3></div></div><div></div></div><p>
                Suppose your application has two persistent classes with the same name, and you don't want to
                specify the fully qualified name in NHibernate queries. Classes may be "imported" 
                explicitly, rather than relying upon <tt class="literal">auto-import="true"</tt>. You may even import 
                classes and interfaces that are not explicitly mapped.
            </p><pre class="programlisting">&lt;import class="System.Object" rename="Universe"/&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;import
        class="ClassName"              <span class="co">(1)</span>
        rename="ShortName"             <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">class</tt>: The fully qualified class name of any .NET class, including
                            its assembly name.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">rename</tt> (optional - defaults to the unqualified class name):
                            A name that may be used in the query language.
                        </p></td></tr></table></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-types"></a>5.2.&nbsp;NHibernate Types</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-entitiesvalues"></a>5.2.1.&nbsp;Entities and values</h3></div></div><div></div></div><p>
                To understand the behaviour of various .NET language-level objects with respect
                to the persistence service, we need to classify them into two groups:
            </p><p>
                An <span class="emphasis"><em>entity</em></span> exists independently of any other objects holding
                references to the entity. Contrast this with the usual .NET model where an
                unreferenced object is garbage collected. Entities must be explicitly saved and
                deleted (except that saves and deletions may be <span class="emphasis"><em>cascaded</em></span>
                from a parent entity to its children). This is different from the ODMG model of
                object persistence by reachability - and corresponds more closely to how
                application objects are usually used in large systems. Entities support
                circular and shared references. They may also be versioned.
            </p><p>
                An entity's persistent state consists of references to other entities and
                instances of <span class="emphasis"><em>value</em></span> types. Values are primitives,
                collections, components and certain immutable objects. Unlike entities, values
                (in particular collections and components) <span class="emphasis"><em>are</em></span>
                persisted and deleted by reachability. Since value objects (and primitives) are
                persisted and deleted along with their containing entity they may not be
                independently versioned. Values have no independent identity, so they cannot be
                shared by two entities or collections.
            </p><p>
                All NHibernate types except collections support null semantics if the .NET type
                is nullable (i.e. not derived from <tt class="literal">System.ValueType</tt>).
            </p><p>
                Up until now, we've been using the term "persistent class" to refer to
                entities. We will continue to do that. Strictly speaking, however, not all
                user-defined classes with persistent state are entities. A
                <span class="emphasis"><em>component</em></span> is a user defined class with value semantics.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-basictypes"></a>5.2.2.&nbsp;Basic value types</h3></div></div><div></div></div><p>
                The <span class="emphasis"><em>basic types</em></span> may be roughly categorized into three groups - <tt class="literal">System.ValueType</tt> 
                types, <tt class="literal">System.Object</tt> types, and <tt class="literal">System.Object</tt> types for large objects.  Just like
                the .NET Types, columns for System.ValueType types <span class="emphasis"><em>can not</em></span> store <tt class="literal">null</tt> values 
                and System.Object types	<span class="emphasis"><em>can</em></span> store <tt class="literal">null</tt> values.
            </p><div class="table"><a name="d0e5012"></a><p class="title"><b>Table&nbsp;5.3.&nbsp;System.ValueType Mapping Types</b></p><table summary="System.ValueType Mapping Types" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>NHibernate Type</th><th>.NET Type</th><th>Database Type</th><th>Remarks</th></tr></thead><tbody><tr><td><tt class="literal">AnsiChar</tt></td><td><tt class="literal">System.Char</tt></td><td><tt class="literal">DbType.AnsiStringFixedLength - 1 char</tt></td><td>&nbsp;</td></tr><tr><td><tt class="literal">Boolean</tt></td><td><tt class="literal">System.Boolean</tt></td><td><tt class="literal">DbType.Boolean</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Byte</tt></td><td><tt class="literal">System.Byte</tt></td><td><tt class="literal">DbType.Byte</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Char</tt></td><td><tt class="literal">System.Char</tt></td><td><tt class="literal">DbType.StringFixedLength - 1 char</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Date</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.Date</tt></td><td><tt class="literal">type="Date"</tt> must be specified.</td></tr><tr><td><tt class="literal">DateTime</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime</tt> - ignores the milliseconds</td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">DateTime2</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime2</tt></td><td><tt class="literal">type="DateTime2"</tt> must be specified.</td></tr><tr><td><tt class="literal">DbTimestamp</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime</tt> - as specific as database supports.</td><td><tt class="literal">type="DbTimestamp"</tt> must be specified.  When used as a <tt class="literal">version</tt> field, uses the database's current time rather than the client's current time.</td></tr><tr><td><tt class="literal">LocalDateTime</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime</tt> - ignores the milliseconds</td><td>Ensures the <tt class="literal">DateTimeKind</tt> is set to <tt class="literal">DateTimeKind.Local</tt></td></tr><tr><td><tt class="literal">UtcDateTime</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime</tt> - ignores the milliseconds</td><td>Ensures the <tt class="literal">DateTimeKind</tt> is set to <tt class="literal">DateTimeKind.Utc</tt></td></tr><tr><td><tt class="literal">Decimal</tt></td><td><tt class="literal">System.Decimal</tt></td><td><tt class="literal">DbType.Decimal</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Double</tt></td><td><tt class="literal">System.Double</tt></td><td><tt class="literal">DbType.Double</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Guid</tt></td><td><tt class="literal">System.Guid</tt></td><td><tt class="literal">DbType.Guid</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Int16</tt></td><td><tt class="literal">System.Int16</tt></td><td><tt class="literal">DbType.Int16</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Int32</tt></td><td><tt class="literal">System.Int32</tt></td><td><tt class="literal">DbType.Int32</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Int64</tt></td><td><tt class="literal">System.Int64</tt></td><td><tt class="literal">DbType.Int64</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">PersistentEnum</tt></td><td>A <tt class="literal">System.Enum</tt></td><td>The <tt class="literal">DbType</tt> for the underlying value.</td><td>Do not specify <tt class="literal">type="PersistentEnum"</tt> in the mapping.  Instead 
                            specify the Assembly Qualified Name of the Enum or let NHibernate use Reflection to "guess" the Type.  
                            The UnderlyingType of the Enum is used to determine the correct <tt class="literal">DbType</tt>.</td></tr><tr><td><tt class="literal">Single</tt></td><td><tt class="literal">System.Single</tt></td><td><tt class="literal">DbType.Single</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Ticks</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.Int64</tt></td><td><tt class="literal">type="Ticks"</tt> must be specified.</td></tr><tr><td><tt class="literal">Time</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.Time</tt></td><td><tt class="literal">type="Time"</tt> must be specified.</td></tr><tr><td><tt class="literal">TimeAsTimeSpan</tt></td><td><tt class="literal">System.TimeSpan</tt></td><td><tt class="literal">DbType.Time</tt></td><td><tt class="literal">type="TimeAsTimeSpan"</tt> must be specified.</td></tr><tr><td><tt class="literal">TimeSpan</tt></td><td><tt class="literal">System.TimeSpan</tt></td><td><tt class="literal">DbType.Int64</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Timestamp</tt></td><td><tt class="literal">System.DateTime</tt></td><td><tt class="literal">DbType.DateTime</tt> - as specific as database supports.</td><td><tt class="literal">type="Timestamp"</tt> must be specified.</td></tr><tr><td><tt class="literal">TrueFalse</tt></td><td><tt class="literal">System.Boolean</tt></td><td><tt class="literal">DbType.AnsiStringFixedLength</tt> - 1 char either 'T' or 'F'</td><td><tt class="literal">type="TrueFalse"</tt> must be specified.</td></tr><tr><td><tt class="literal">YesNo</tt></td><td><tt class="literal">System.Boolean</tt></td><td><tt class="literal">DbType.AnsiStringFixedLength</tt> - 1 char either 'Y' or 'N'</td><td><tt class="literal">type="YesNo"</tt> must be specified.</td></tr></tbody></table></div><div class="table"><a name="d0e5409"></a><p class="title"><b>Table&nbsp;5.4.&nbsp;System.Object Mapping Types</b></p><table summary="System.Object Mapping Types" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>NHibernate Type</th><th>.NET Type</th><th>Database Type</th><th>Remarks</th></tr></thead><tbody><tr><td><tt class="literal">AnsiString</tt></td><td><tt class="literal">System.String</tt></td><td><tt class="literal">DbType.AnsiString</tt></td><td><tt class="literal">type="AnsiString"</tt> must be specified.</td></tr><tr><td><tt class="literal">CultureInfo</tt></td><td><tt class="literal">System.Globalization.CultureInfo</tt></td><td><tt class="literal">DbType.String</tt> - 5 chars for culture</td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Binary</tt></td><td><tt class="literal">System.Byte[]</tt></td><td><tt class="literal">DbType.Binary</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">Type</tt></td><td><tt class="literal">System.Type</tt></td><td><tt class="literal">DbType.String</tt> holding Assembly Qualified Name.</td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr><tr><td><tt class="literal">String</tt></td><td><tt class="literal">System.String</tt></td><td><tt class="literal">DbType.String</tt></td><td>Default when no <tt class="literal">type</tt> attribute specified.</td></tr></tbody></table></div><div class="table"><a name="d0e5500"></a><p class="title"><b>Table&nbsp;5.5.&nbsp;Large Object Mapping Types</b></p><table summary="Large Object Mapping Types" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>NHibernate Type</th><th>.NET Type</th><th>Database Type</th><th>Remarks</th></tr></thead><tbody><tr><td><tt class="literal">StringClob</tt></td><td><tt class="literal">System.String</tt></td><td><tt class="literal">DbType.String</tt></td><td><tt class="literal">type="StringClob"</tt> must be specified.  Entire field is read into memory.</td></tr><tr><td><tt class="literal">BinaryBlob</tt></td><td><tt class="literal">System.Byte[]</tt></td><td><tt class="literal">DbType.Binary</tt></td><td><tt class="literal">type="BinaryBlob"</tt> must be specified.  Entire field is read into memory.</td></tr><tr><td><tt class="literal">Serializable</tt></td><td>Any <tt class="literal">System.Object</tt> that is marked with SerializableAttribute.</td><td><tt class="literal">DbType.Binary</tt></td><td><tt class="literal">type="Serializable"</tt> should be specified.  This is the fallback type
                            if no NHibernate Type can be found for the Property.</td></tr></tbody></table></div><p>
                NHibernate supports some additional type names for compatibility with Java's Hibernate (useful for those coming over from
                Hibernate or using some of the tools to generate <tt class="literal">hbm.xml</tt> files).
                A <tt class="literal">type="integer"</tt> or <tt class="literal">type="int"</tt> will map to an <tt class="literal">Int32</tt>
                NHibernate type, <tt class="literal">type="short"</tt> to an <tt class="literal">Int16</tt> NHibernateType.
                To see all of the conversions you can view the source of static constructor of the class
                <tt class="literal">NHibernate.Type.TypeFactory</tt>. 
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-custom"></a>5.2.3.&nbsp;Custom value types</h3></div></div><div></div></div><p>
                It is relatively easy for developers to create their own value types. For example,
                you might want to persist properties of type <tt class="literal">Int64</tt>
                to <tt class="literal">VARCHAR</tt> columns. NHibernate does not provide a built-in type 
                for this. But custom types are not limited to mapping a property (or collection element) 
                to a single table column. So, for example, you might have a property 
                <tt class="literal">Name { get; set; }</tt> of type
                <tt class="literal">String</tt> that is persisted to the columns 
                <tt class="literal">FIRST_NAME</tt>, <tt class="literal">INITIAL</tt>, <tt class="literal">SURNAME</tt>. 
            </p><p>
                To implement a custom type, implement either <tt class="literal">NHibernate.UserTypes.IUserType</tt> 
                or <tt class="literal">NHibernate.UserTypes.ICompositeUserType</tt> and declare properties using the 
                fully qualified name of the type. Check out 
                <tt class="literal">NHibernate.DomainModel.DoubleStringType</tt> to see the kind of things that 
                are possible.
            </p><pre class="programlisting">&lt;property name="TwoStrings" type="NHibernate.DomainModel.DoubleStringType, NHibernate.DomainModel"&gt;
    &lt;column name="first_string"/&gt;
    &lt;column name="second_string"/&gt;
&lt;/property&gt;</pre><p>
                Notice the use of <tt class="literal">&lt;column&gt;</tt> tags to map a property to multiple
                columns.
            </p><p>
                The <tt class="literal">ICompositeUserType</tt>, <tt class="literal">IEnhancedUserType</tt>,
                <tt class="literal">INullableUserType</tt>, <tt class="literal">IUserCollectionType</tt>,
                and <tt class="literal">IUserVersionType</tt> interfaces provide support for more specialized
                uses.
            </p><p>
                You may even supply parameters to an <tt class="literal">IUserType</tt> in the mapping file. To 
                do this, your <tt class="literal">IUserType</tt> must implement the 
                <tt class="literal">NHibernate.UserTypes.IParameterizedType</tt> interface. To supply parameters 
                to your custom type, you can use the <tt class="literal">&lt;type&gt;</tt> element in your mapping 
                files.
            </p><pre class="programlisting">&lt;property name="priority"&gt;
    &lt;type name="MyCompany.UserTypes.DefaultValueIntegerType"&gt;
        &lt;param name="default"&gt;0&lt;/param&gt;
    &lt;/type&gt;
&lt;/property&gt;</pre><p>
                The <tt class="literal">IUserType</tt> can now retrieve the value for the parameter named 
                <tt class="literal">default</tt> from the <tt class="literal">IDictionary</tt> object passed to it.
            </p><p>
                If you use a certain <tt class="literal">UserType</tt> very often, it may be useful to define a
                shorter name for it. You can do this using the <tt class="literal">&lt;typedef&gt;</tt> element.
                Typedefs assign a name to a custom type, and may also contain a list of default
                parameter values if the type is parameterized.
            </p><pre class="programlisting">&lt;typedef class="MyCompany.UserTypes.DefaultValueIntegerType" name="default_zero"&gt;
    &lt;param name="default"&gt;0&lt;/param&gt;
&lt;/typedef&gt;</pre><pre class="programlisting">&lt;property name="priority" type="default_zero"/&gt;</pre><p>
                It is also possible to override the parameters supplied in a typedef on a case-by-case basis
                by using type parameters on the property mapping.
            </p><p>
                Even though NHibernate's rich range of built-in types and support for components means you
                will very rarely <span class="emphasis"><em>need</em></span> to use a custom type, it is nevertheless
                considered good form to use custom types for (non-entity) classes that occur frequently
                in your application. For example, a <tt class="literal">MonetaryAmount</tt> class is a good
                candidate for an <tt class="literal">ICompositeUserType</tt>, even though it could easily be mapped 
                as a component. One motivation for this is abstraction. With a custom type, your mapping 
                documents would be future-proofed against possible changes in your way of representing 
                monetary values.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mapping-types-anymapping"></a>5.2.4.&nbsp;Any type mappings</h3></div></div><div></div></div><p>
                There is one further type of property mapping. The <tt class="literal">&lt;any&gt;</tt> mapping element 
                defines a polymorphic association to classes from multiple tables. This type of mapping always
                requires more than one column. The first column holds the type of the associated entity. 
                The remaining columns hold the identifier. It is impossible to specify a foreign key constraint
                for this kind of association, so this is most certainly not meant as the usual way of mapping 
                (polymorphic) associations. You should use this only in very special cases (eg. audit logs,
                user session data, etc).
            </p><pre class="programlisting">&lt;any name="AnyEntity" id-type="Int64" meta-type="Eg.Custom.Class2TablenameType"&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><p>
                 The <tt class="literal">meta-type</tt> attribute lets the application specify a custom type that 
                 maps database column values to persistent classes which have identifier properties of the 
                 type specified by <tt class="literal">id-type</tt>. If the meta-type returns instances of 
                 <tt class="literal">System.Type</tt>, nothing else is required. On the other hand, if it is
                 a basic type like <tt class="literal">String</tt> or <tt class="literal">Char</tt>, you must
                 specify the mapping from values to classes.
            </p><pre class="programlisting">&lt;any name="AnyEntity" id-type="Int64" meta-type="String"&gt;
    &lt;meta-value value="TBL_ANIMAL" class="Animal"/&gt;
    &lt;meta-value value="TBL_HUMAN" class="Human"/&gt;
    &lt;meta-value value="TBL_ALIEN" class="Alien"/&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;any
        name="PropertyName"                                <span class="co">(1)</span>
        id-type="idtypename"                               <span class="co">(2)</span>
        meta-type="metatypename"                           <span class="co">(3)</span>
        cascade="none|all|save-update"                     <span class="co">(4)</span>
        access="field|property|nosetter|ClassName"         <span class="co">(5)</span>
        optimistic-lock="true|false"                       <span class="co">(6)</span>
&gt;
        &lt;meta-value ... /&gt;
        &lt;meta-value ... /&gt;
        .....
        &lt;column .... /&gt;
        &lt;column .... /&gt;
        .....
&lt;/any&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">name</tt>: the property name.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">id-type</tt>: the identifier type.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                            <tt class="literal">meta-type</tt> (optional - defaults to <tt class="literal">Type</tt>): 
                            a type that maps <tt class="literal">System.Type</tt> to a single database column
                            or, alternatively, a type that is allowed for a discriminator mapping.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                            <tt class="literal">cascade</tt> (optional - defaults to <tt class="literal">none</tt>): 
                            the cascade style.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                            <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                            strategy NHibernate should use for accessing the property value.
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                            <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>): 
                            Specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, define if a version increment should occur if this
                            property is dirty.
                        </p></td></tr></table></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-quotedidentifiers"></a>5.3.&nbsp;SQL quoted identifiers</h2></div></div><div></div></div><p>
                You may force NHibernate to quote an identifier in the generated SQL by enclosing the table or
                column name in backticks in the mapping document. NHibernate will use the correct quotation
                style for the SQL <tt class="literal">Dialect</tt> (usually double quotes, but brackets for SQL
                Server and backticks for MySQL).
            </p><pre class="programlisting">&lt;class name="LineItem" table="`Line Item`"&gt;
    &lt;id name="Id" column="`Item Id`"/&gt;&lt;generator class="assigned"/&gt;&lt;/id&gt;
    &lt;property name="ItemNumber" column="`Item #`"/&gt;
    ...
&lt;/class&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-modularfiles"></a>5.4.&nbsp;Modular mapping files</h2></div></div><div></div></div><p>
            It is possible to define <tt class="literal">subclass</tt> and <tt class="literal">joined-subclass</tt>
            mappings in saparate mapping documents, directly beneath <tt class="literal">hibernate-mapping</tt>.
            This allows you to extend a class hierachy just by adding a new mapping file. You must
            specify an <tt class="literal">extends</tt> attribute in the subclass mapping, naming a previously
            mapped superclass. Use of this feature makes the ordering of the mapping documents important!
        </p><pre class="programlisting">
&lt;hibernate-mapping&gt;
        &lt;subclass name="Eg.Subclass.DomesticCat, Eg"
            extends="Eg.Cat, Eg" discriminator-value="D"&gt;
             &lt;property name="name" type="string"/&gt;
        &lt;/subclass&gt;
&lt;/hibernate-mapping&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-generated"></a>5.5.&nbsp;Generated Properties</h2></div></div><div></div></div><p>
            Generated properties are properties which have their values generated by the
            database.  Typically, NHibernate applications needed to <tt class="literal">Refresh</tt>
            objects which contain any properties for which the database was generating values.
            Marking properties as generated, however, lets the application delegate this
            responsibility to NHibernate.  Essentially, whenever NHibernate issues an SQL INSERT
            or UPDATE for an entity which has defined generated properties, it immediately
            issues a select afterwards to retrieve the generated values.
        </p><p>
            Properties marked as generated must additionally be non-insertable and non-updateable.
            Only <a href="#mapping-declaration-version" title="5.1.8.&nbsp;version (optional)">Section&nbsp;5.1.8, &#8220;version (optional)&#8221;</a>,
            <a href="#mapping-declaration-timestamp" title="5.1.9.&nbsp;timestamp (optional)">Section&nbsp;5.1.9, &#8220;timestamp (optional)&#8221;</a>, and
            <a href="#mapping-declaration-property" title="5.1.10.&nbsp;property">Section&nbsp;5.1.10, &#8220;property&#8221;</a> can be marked as
            generated.
        </p><p>
            <tt class="literal">never</tt> (the default) - means that the given property value
            is not generated within the database.
        </p><p>
            <tt class="literal">insert</tt> - states that the given property value is generated on
            insert, but is not regenerated on subsequent updates.  Things like created-date would
            fall into this category.  Note that even though
            <a href="#mapping-declaration-version" title="5.1.8.&nbsp;version (optional)">Section&nbsp;5.1.8, &#8220;version (optional)&#8221;</a> and
            <a href="#mapping-declaration-timestamp" title="5.1.9.&nbsp;timestamp (optional)">Section&nbsp;5.1.9, &#8220;timestamp (optional)&#8221;</a> properties can
            be marked as generated, this option is not available there...
        </p><p>
            <tt class="literal">always</tt> - states that the property value is generated both
            on insert and on update.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-database-object"></a>5.6.&nbsp;Auxiliary Database Objects</h2></div></div><div></div></div><p>
            Allows CREATE and DROP of arbitrary database objects, in conjunction with
            NHibernate's schema evolution tools, to provide the ability to fully define
            a user schema within the NHibernate mapping files.  Although designed specifically
            for creating and dropping things like triggers or stored procedures, really any
            SQL command that can be run via a <tt class="literal">IDbCommand.ExecuteNonQuery()</tt>
            method is valid here (ALTERs, INSERTS, etc).  There are essentially two modes for
            defining auxiliary database objects.
        </p><p>
            The first mode is to explicitly list the CREATE and DROP commands out in the mapping
            file:
        </p><pre class="programlisting">&lt;nhibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;create&gt;CREATE TRIGGER my_trigger ...&lt;/create&gt;
        &lt;drop&gt;DROP TRIGGER my_trigger&lt;/drop&gt;
    &lt;/database-object&gt;
&lt;/nhibernate-mapping&gt;</pre><p>
            The second mode is to supply a custom class which knows how to construct the
            CREATE and DROP commands.  This custom class must implement the
            <tt class="literal">NHibernate.Mapping.IAuxiliaryDatabaseObject</tt> interface.
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition, MyAssembly"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre><p>
            You may also specify parameters to be passed to the database object:
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition, MyAssembly"&gt;
            &lt;param name="parameterName"&gt;parameterValue&lt;/param&gt;
        &lt;/definition&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre><p>
            NHibernate will call <tt class="literal">IAuxiliaryDatabaseObject.SetParameterValues</tt>
            passing it a dictionary of parameter names and values.
        </p><p>
            Additionally, these database objects can be optionally scoped such that they only
            apply when certain dialects are used.
        </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition"/&gt;
        &lt;dialect-scope name="NHibernate.Dialect.Oracle9iDialect"/&gt;
        &lt;dialect-scope name="NHibernate.Dialect.Oracle8iDialect"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="collections"></a>Chapter&nbsp;6.&nbsp;Collection Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-persistent"></a>6.1.&nbsp;Persistent Collections</h2></div></div><div></div></div><p>
            NHibernate requires that persistent collection-valued fields be declared
            as a generic interface type, for example:
        </p><pre class="programlisting">public class Product
{
    private string serialNumber;
    private ISet&lt;Part&gt; parts = new HashSet&lt;Part&gt;();
    
    public ISet&lt;Part&gt; Parts
    {
        get { return parts; }
        set { parts = value; }
    }

    public string SerialNumber
    {
        get { return serialNumber; }
        set { serialNumber = value; }
    }
}</pre><p>
            The actual interface might be 
            <tt class="literal">System.Collections.Generic.ICollection&lt;T&gt;</tt>,
            <tt class="literal">System.Collections.Generic.IList&lt;T&gt;</tt>,
            <tt class="literal">System.Collections.Generic.IDictionary&lt;K, V&gt;</tt>,
            <tt class="literal">System.Collections.Generic.ISet&lt;T&gt;</tt>
            or ... anything you like! (Where "anything you like" means you will
            have to write an implementation of <tt class="literal">NHibernate.UserType.IUserCollectionType</tt>.)
        </p><p>
            Notice how we initialized the instance variable with an instance of
            <tt class="literal">HashSet&lt;Part&gt;</tt>. This is the best way to initialize collection
            valued properties of newly instantiated (non-persistent) instances. When
            you make the instance persistent - by calling <tt class="literal">Save()</tt>,
            for example - NHibernate will actually replace the <tt class="literal">HashSet&lt;Part&gt;</tt>
            with an instance of NHibernate's own implementation of <tt class="literal">ISet&lt;Part&gt;</tt>.
            Watch out for errors like this:
        </p><pre class="programlisting">Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
....
ISet&lt;Cat&gt; kittens = new HashSet&lt;Cat&gt;();
kittens.Add(kitten);
cat.Kittens = kittens;
session.Save(cat);
kittens = cat.Kittens; //Okay, kittens collection is an ISet&lt;Cat&gt;
HashSet&lt;Cat&gt; hs = (HashSet&lt;Cat&gt;) cat.Kittens; //Error!</pre><p>
            Collection instances have the usual behavior of value types. They are automatically
            persisted when referenced by a persistent object and automatically deleted when
            unreferenced. If a collection is passed from one persistent object to another,
            its elements might be moved from one table to another. Two entities may not share
            a reference to the same collection instance. Due to the underlying relational model,
            collection-valued properties do not support null value semantics; NHibernate does
            not distinguish between a null collection reference and an empty collection.
        </p><p>
            You shouldn't have to worry much about any of this. Just use NHibernate's collections
            the same way you use ordinary .NET collections, but make sure you understand the
            semantics of bidirectional associations (discussed later) before using them.
        </p><p>
            Collection instances are distinguished in the database by a foreign key to
            the owning entity. This foreign key is referred to as the
            <span class="emphasis"><em>collection key </em></span>. The collection key is mapped by
            the <tt class="literal">&lt;key&gt;</tt> element.
        </p><p>
            Collections may contain almost any other NHibernate type, including all basic types,
            custom types, entity types and components. This is an important definition: An object
            in a collection can either be handled with "pass by value" semantics (it therefore
            fully depends on the collection owner) or it can be a reference to another entity
            with an own lifecycle. Collections may not contain other collections. The contained type
            is referred to as the <span class="emphasis"><em>collection element type</em></span>. Collection elements
            are mapped by <tt class="literal">&lt;element&gt;</tt>, <tt class="literal">&lt;composite-element&gt;</tt>,
            <tt class="literal">&lt;one-to-many&gt;</tt>, <tt class="literal">&lt;many-to-many&gt;</tt> or
            <tt class="literal">&lt;many-to-any&gt;</tt>. The first two map elements with value semantics,
            the other three are used to map entity associations.
        </p><p>
            All collection types except set and bag have an <span class="emphasis"><em>index
            </em></span> column - a column that maps to an array or <tt class="literal">IList&lt;T&gt;</tt> index or
            <tt class="literal">IDictionary&lt;TKey, TValue&gt;</tt> key. The index of an <tt class="literal">IDictionary&lt;TKey, TValue&gt;</tt> may be of any
            basic type, an entity type or even a composite type (it may not be a collection). The
            index of an array or list is always of type <tt class="literal">Int32</tt>. Indexes are
            mapped using <tt class="literal">&lt;index&gt;</tt>, <tt class="literal">&lt;index-many-to-many&gt;</tt>,
            <tt class="literal">&lt;composite-index&gt;</tt> or <tt class="literal">&lt;index-many-to-any&gt;</tt>.
        </p><p>
            There are quite a range of mappings that can be generated for collections,
            covering many common relational models. We suggest you experiment with the
            schema generation tool to get a feeling for how various mapping declarations
            translate to database tables.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-mapping"></a>6.2.&nbsp;Mapping a Collection</h2></div></div><div></div></div><p>
            Collections are declared by the
            <tt class="literal">&lt;set&gt;</tt>,
            <tt class="literal">&lt;list&gt;</tt>,
            <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt>,
            <tt class="literal">&lt;array&gt;</tt> and
            <tt class="literal">&lt;primitive-array&gt;</tt> elements.
            <tt class="literal">&lt;map&gt;</tt> is representative:
        </p><div class="programlistingco"><pre class="programlisting">&lt;map
    name="propertyName"                                         <span class="co">(1)</span>
    table="table_name"                                          <span class="co">(2)</span>
    schema="schema_name"                                        <span class="co">(3)</span>
    lazy="true|false|extra"                                     <span class="co">(4)</span>
    inverse="true|false"                                        <span class="co">(5)</span>
    cascade="all|none|save-update|delete|all-delete-orphan"     <span class="co">(6)</span>
    sort="unsorted|natural|comparatorClass"                     <span class="co">(7)</span>
    order-by="column_name asc|desc"                             <span class="co">(8)</span>
    where="arbitrary sql where condition"                       <span class="co">(9)</span>
    fetch="select|join"                                         <span class="co">(10)</span>
    batch-size="N"                                              <span class="co">(11)</span>
    access="field|property|ClassName"                           <span class="co">(12)</span>
    optimistic-lock="true|false"                                <span class="co">(13)</span>
    generic="true|false"                                        <span class="co">(14)</span>
&gt;

    &lt;key .... /&gt;
    &lt;index .... /&gt;
    &lt;element .... /&gt;
&lt;/map&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">name</tt> the collection property name
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">table</tt> (optional - defaults to property name) the
                        name of the collection table (not used for one-to-many associations)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">schema</tt> (optional) the name of a table schema to
                        override the schema declared on the root element
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">lazy</tt> (optional - defaults to <tt class="literal">true</tt>)
                        may be used to disable lazy fetching and specify that the association
                        is always eagerly fetched. Using <tt class="literal">extra</tt> fetches only the
						elements that are needed - see <a href="#performance-fetching" title="19.1.&nbsp;Fetching strategies">Section&nbsp;19.1, &#8220;Fetching strategies&#8221;</a> for more information.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>
                        <tt class="literal">inverse</tt> (optional - defaults to <tt class="literal">false</tt>)
                        mark this collection as the "inverse" end of a bidirectional association
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
                        <tt class="literal">cascade</tt> (optional - defaults to <tt class="literal">none</tt>)
                        enable operations to cascade to child entities
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
                        <tt class="literal">sort</tt> (optional) specify a sorted collection with
                        <tt class="literal">natural</tt> sort order, or a given comparator class
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>
                        <tt class="literal">order-by</tt> (optional) specify a table column (or columns)
                        that define the iteration order of the <tt class="literal">IDictionary&lt;TKey, TValue&gt;</tt>, <tt class="literal">ISet&lt;T&gt;</tt>
                        or bag, together with an optional <tt class="literal">asc</tt> or <tt class="literal">desc</tt>
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(9)</td><td valign="top" align="left"><p>
                        <tt class="literal">where</tt> (optional) specify an arbitrary SQL <tt class="literal">WHERE</tt>
                        condition to be used when retrieving or removing the collection (useful if the
                        collection should contain only a subset of the available data)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(10)</td><td valign="top" align="left"><p>
                        <tt class="literal">fetch</tt> (optional) Choose between outer-join fetching and fetching
                        by sequential select.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(11)</td><td valign="top" align="left"><p>
                        <tt class="literal">batch-size</tt> (optional, defaults to <tt class="literal">1</tt>) specify a
                        "batch size" for lazily fetching instances of this collection.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(12)</td><td valign="top" align="left"><p>
                        <tt class="literal">access</tt> (optional - defaults to <tt class="literal">property</tt>): The
                        strategy NHibernate should use for accessing the property value.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(13)</td><td valign="top" align="left"><p>
                        <tt class="literal">optimistic-lock</tt> (optional - defaults to <tt class="literal">true</tt>): 
                        Species that changes to the state of the collection results in increment of the
                        owning entity's version. (For one to many associations, it is often reasonable to
                        disable this setting.)
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(14)</td><td valign="top" align="left"><p>
                        <tt class="literal">generic</tt> (optional, obsolete): Choose between generic and non-generic collection
                        interfaces, currently NHibernate only supports generic collections.
                    </p></td></tr></table></div></div><p>
            The mapping of an <tt class="literal">IList&lt;T&gt;</tt> or array requires a saparate table column holding the array
            or list index (the <tt class="literal">i</tt> in <tt class="literal">foo[i]</tt>). If your relational model doesn't
            have an index column, e.g. if you're working with legacy data, use an unordered <tt class="literal">ISet&lt;T&gt;</tt>
            instead. This seems to put people off who assume that <tt class="literal">IList&lt;T&gt;</tt> should just be a more
            convenient way of accessing an unordered collection. NHibernate collections strictly obey the actual
            semantics attached to the <tt class="literal">ISet&lt;T&gt;</tt>, <tt class="literal">IList&lt;T&gt;</tt> and <tt class="literal">IDictionary&lt;TKey, TValue&gt;</tt>
            interfaces. <tt class="literal">IList&lt;T&gt;</tt> elements don't just spontaneously rearrange themselves!
        </p><p>
            On the other hand, people who planned to use the <tt class="literal">IList&lt;T&gt;</tt> to emulate
            <span class="emphasis"><em>bag</em></span> semantics have a legitimate grievance here.
            A bag is an unordered, unindexed collection which may contain the same element multiple times.
            The .NET collections framework lacks an <tt class="literal">IBag&lt;T&gt;</tt> interface, hence you have to emulate
            it with an <tt class="literal">IList&lt;T&gt;</tt>. NHibernate lets you map properties of type <tt class="literal">IList&lt;T&gt;</tt>
            or <tt class="literal">ICollection&lt;T&gt;</tt> with the <tt class="literal">&lt;bag&gt;</tt> element. Note that bag
            semantics are not really part of the <tt class="literal">ICollection&lt;T&gt;</tt> contract and they actually
            conflict with the semantics of the <tt class="literal">IList&lt;T&gt;</tt> contract (however, you can sort
            the bag arbitrarily, discussed later in this chapter).
        </p><p>
            Note: Large NHibernate bags mapped with <tt class="literal">inverse="false"</tt> are inefficient and
            should be avoided; NHibernate can't create, delete or update rows individually, because there is
            no key that may be used to identify an individual row.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-ofvalues"></a>6.3.&nbsp;Collections of Values and Many-To-Many Associations</h2></div></div><div></div></div><p>
            A collection table is required for any collection of values and any collection of
            references to other entities mapped as a many-to-many association (the natural semantics
            for a .NET collection). The table requires (foreign) key column(s), element column(s) and
            possibly index column(s).
        </p><p>
            The foreign key from the collection table to the table of the owning class is
            declared using a <tt class="literal">&lt;key&gt;</tt> element.
        </p><div class="programlistingco"><pre class="programlisting">&lt;key column="column_name"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the foreign key column.
                    </p></td></tr></table></div></div><p>
            For indexed collections like maps and lists, we require an <tt class="literal">&lt;index&gt;</tt>
            element. For lists, this column contains sequential integers numbered from zero. Make sure
            that your index really starts from zero if you have to deal with legacy data. For maps,
            the column may contain any values of any NHibernate type.
        </p><div class="programlistingco"><pre class="programlisting">&lt;index
        column="column_name"                <span class="co">(1)</span>
        type="typename"                     <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the column holding the
                        collection index values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (optional, defaults to <tt class="literal">Int32</tt>):
                        The type of the collection index.
                    </p></td></tr></table></div></div><p>
            Alternatively, a map may be indexed by objects of entity type. We use the
            <tt class="literal">&lt;index-many-to-many&gt;</tt> element.
        </p><div class="programlistingco"><pre class="programlisting">&lt;index-many-to-many
        column="column_name"                <span class="co">(1)</span>
        class="ClassName"                   <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the foreign key
                        column for the collection index values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The entity class used as the
                        collection index.
                    </p></td></tr></table></div></div><p>
            For a collection of values, we use the <tt class="literal">&lt;element&gt;</tt> tag.
        </p><div class="programlistingco"><pre class="programlisting">&lt;element
        column="column_name"                <span class="co">(1)</span>
        type="typename"                     <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the column holding the
                        collection element values.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">type</tt> (required): The type of the collection element.
                    </p></td></tr></table></div></div><p>
            A collection of entities with its own table corresponds to the relational notion
            of <span class="emphasis"><em>many-to-many association</em></span>. A many to many association is the
            most natural mapping of a .NET collection but is not usually the best relational model.
        </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-many
        column="column_name"                               <span class="co">(1)</span>
        class="ClassName"                                  <span class="co">(2)</span>
        fetch="join|select"                                <span class="co">(3)</span>
        not-found="ignore|exception"                       <span class="co">(4)</span>
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">column</tt> (required): The name of the element foreign key column.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The name of the associated class.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>
                        <tt class="literal">fetch</tt> (optional, defaults to <tt class="literal">join</tt>):
                        enables outer-join or sequential select fetching for this association. This is a
                        special case; for full eager fetching (in a single SELECT) of an entity and its
                        many-to-many relationships to other entities, you would enable join fetching not
                        only of the collection itself, but also with this attribute on the <tt class="literal">
                        &lt;many-to-many&gt;</tt> nested element.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>
                        <tt class="literal">not-found</tt> (optional - defaults to <tt class="literal">exception</tt>):
                        Specifies how foreign keys that reference missing rows will be handled:
                        <tt class="literal">ignore</tt> will treat a missing row as a null association.
                    </p></td></tr></table></div></div><p>
            Some examples, first, a set of strings:
        </p><pre class="programlisting">&lt;set name="Names" table="NAMES"&gt;
    &lt;key column="GROUPID"/&gt;
    &lt;element column="NAME" type="String"/&gt;
&lt;/set&gt;</pre><p>
            A bag containing integers (with an iteration order determined by the
            <tt class="literal">order-by</tt> attribute):
        </p><pre class="programlisting">&lt;bag name="Sizes" table="SIZES" order-by="SIZE ASC"&gt;
    &lt;key column="OWNER"/&gt;
    &lt;element column="SIZE" type="Int32"/&gt;
&lt;/bag&gt;</pre><p>
            An array of entities - in this case, a many to many association (note that
            the entities are lifecycle objects, <tt class="literal">cascade="all"</tt>):
        </p><pre class="programlisting">&lt;array name="Foos" table="BAR_FOOS" cascade="all"&gt;
    &lt;key column="BAR_ID"/&gt;
    &lt;index column="I"/&gt;
    &lt;many-to-many column="FOO_ID" class="Eg.Foo, Eg"/&gt;
&lt;/array&gt;</pre><p>
            A map from string indices to dates:
        </p><pre class="programlisting">&lt;map name="Holidays" table="holidays" schema="dbo" order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;index column="hol_name" type="String"/&gt;
    &lt;element column="hol_date" type="Date"/&gt;
&lt;/map&gt;</pre><p>
            A list of components (discussed in the next chapter):
        </p><pre class="programlisting">&lt;list name="CarComponents" table="car_components"&gt;
    &lt;key column="car_id"/&gt;
    &lt;index column="posn"/&gt;
    &lt;composite-element class="Eg.Car.CarComponent"&gt;
            &lt;property name="Price" type="float"/&gt;
            &lt;property name="Type" type="Eg.Car.ComponentType, Eg"/&gt;
            &lt;property name="SerialNumber" column="serial_no" type="String"/&gt;
    &lt;/composite-element&gt;
&lt;/list&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-onetomany"></a>6.4.&nbsp;One-To-Many Associations</h2></div></div><div></div></div><p>
            A <span class="emphasis"><em>one to many association</em></span> links the tables of two classes
            <span class="emphasis"><em>directly</em></span>, with no intervening collection table.
            (This implements a <span class="emphasis"><em>one-to-many</em></span> relational model.) This
            relational model loses some of the semantics of .NET collections:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    No null values may be contained in a dictionary, set or list
                </p></li><li><p>
                    An instance of the contained entity class may not belong to more than
                    one instance of the collection
                </p></li><li><p>
                    An instance of the contained entity class may not appear at more than
                    one value of the collection index
                </p></li></ul></div><p>
            An association from <tt class="literal">Foo</tt> to <tt class="literal">Bar</tt> requires the
            addition of a key column and possibly an index column to the table of the contained
            entity class, <tt class="literal">Bar</tt>. These columns are mapped using the
            <tt class="literal">&lt;key&gt;</tt> and <tt class="literal">&lt;index&gt;</tt> elements
            described above.
        </p><p>
            The <tt class="literal">&lt;one-to-many&gt;</tt> tag indicates a one to many association.
        </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-many
        class="ClassName"                                  <span class="co">(1)</span>
        not-found="ignore|exception"                       <span class="co">(2)</span>
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                        <tt class="literal">class</tt> (required): The name of the associated class.
                    </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                        <tt class="literal">not-found</tt> (optional - defaults to <tt class="literal">exception</tt>):
                        Specifies how foreign keys that reference missing rows will be handled:
                        <tt class="literal">ignore</tt> will treat a missing row as a null association.
                    </p></td></tr></table></div></div><p>
            Example:
        </p><pre class="programlisting">&lt;set name="Bars"&gt;
    &lt;key column="foo_id"/&gt;
    &lt;one-to-many class="Eg.Bar, Eg"/&gt;
&lt;/set&gt;</pre><p>
            Notice that the <tt class="literal">&lt;one-to-many&gt;</tt> element does not need to
            declare any columns. Nor is it necessary to specify the <tt class="literal">table</tt>
            name anywhere.
        </p><p>
            <span class="emphasis"><em>Very Important Note:</em></span> If the <tt class="literal">&lt;key&gt;</tt>
            column of a <tt class="literal">&lt;one-to-many&gt;</tt> association is declared
            <tt class="literal">NOT NULL</tt>, NHibernate may cause constraint violations
            when it creates or updates the association. To prevent this problem,
            <span class="emphasis"><em>you must use a bidirectional association</em></span> with the many valued
            end (the set or bag) marked as <tt class="literal">inverse="true"</tt>.
            See the discussion of bidirectional associations later in this chapter.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-lazy"></a>6.5.&nbsp;Lazy Initialization</h2></div></div><div></div></div><p>
            Collections (other than arrays) may be lazily initialized, meaning they load
            their state from the database only when the application needs to access it.
            Initialization happens transparently to the user so the application would not
            normally need to worry about this (in fact, transparent lazy initialization is
            the main reason why NHibernate needs its own collection implementations).
            However, if the application tries something like this:
        </p><pre class="programlisting">s = sessions.OpenSession();
ITransaction tx = sessions.BeginTransaction();
User u = s.CreateQuery("from User u where u.Name=:name").SetString("name", userName).UniqueResult&lt;User&gt;();
IDictionary permissions = u.Permissions;
tx.Commit();
s.Close();

int accessLevel = (int) permissions["accounts"];  // Error!</pre><p>
            It could be in for a nasty surprise. Since the permissions collection was not
            initialized when the <tt class="literal">ISession</tt> was committed,
            the collection will never be able to load its state. The fix is to move the
            line that reads from the collection to just before the commit. (There are
            other more advanced ways to solve this problem, however.)
        </p><p>
            Alternatively, use a non-lazy collection. Since lazy initialization can lead to
            bugs like that above, non-laziness is the default. However, it is intended that
            lazy initialization be used for almost all collections, especially for
            collections of entities (for reasons of efficiency).
        </p><p>
            Exceptions that occur while lazily initializing a collection are wrapped in a
            <tt class="literal">LazyInitializationException</tt>.
        </p><p>
            Declare a lazy collection using the optional <tt class="literal">lazy</tt> attribute:
        </p><pre class="programlisting">&lt;set name="Names" table="NAMES" lazy="true"&gt;
    &lt;key column="group_id"/&gt;
    &lt;element column="NAME" type="String"/&gt;
&lt;/set&gt;</pre><p>
            In some application architectures, particularly where the code that accesses data
            using NHibernate, and the code that uses it are in different application layers, it
            can be a problem to ensure that the <tt class="literal">ISession</tt> is open when a
            collection is initialized. There are two basic ways to deal with this issue:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    In a web-based application, an event handler can be used to close the
                    <tt class="literal">ISession</tt> only at the very end of a user request, once
                    the rendering of the view is complete. Of course, this places heavy
                    demands upon the correctness of the exception handling of your application
                    infrastructure. It is vitally important that the <tt class="literal">ISession</tt>
                    is closed and the transaction ended before returning to the user, even
                    when an exception occurs during rendering of the view. The event handler
                    has to be able to access the <tt class="literal">ISession</tt> for this approach.
                    We recommend that the current <tt class="literal">ISession</tt> is stored in the
                    <tt class="literal">HttpContext.Items</tt> collection (see chapter 1,
                    <a href="#quickstart-playingwithcats" title="1.4.&nbsp;Playing with cats">Section&nbsp;1.4, &#8220;Playing with cats&#8221;</a>, for an example implementation).
                </p></li><li><p>
                    In an application with a saparate business tier, the business logic must
                    "prepare" all collections that will be needed by the web tier before
                    returning. This means that the business tier should load all the data and
                    return all the data already initialized to the presentation/web tier that
                    is required for a particular use case. Usually, the application calls
                    <tt class="literal">NHibernateUtil.Initialize()</tt> for each collection that will
                    be needed in the web tier (this call must occur before the session is closed)
                    or retrieves the collection eagerly using a NHibernate query with a
                    <tt class="literal">FETCH</tt> clause.
                </p></li><li><p>
                    You may also attach a previously loaded object to a new <tt class="literal">ISession</tt>
                    with <tt class="literal">Update()</tt> or <tt class="literal">Lock()</tt> before
                    accessing unitialized collections (or other proxies). NHibernate can not
                    do this automatically, as it would introduce ad hoc transaction semantics!
                </p></li></ul></div><p>
            You can use the <tt class="literal">CreateFilter()</tt> method of the NHibernate ISession API to
            get the size of a collection without initializing it:
        </p><pre class="programlisting">ICollection countColl = s.CreateFilter( collection, "select count(*)" ).List();
IEnumerator countEn = countColl.GetEnumerator();
countEn.MoveNext();
int count = (int) countEn.Current;</pre><p>
            <tt class="literal">CreateFilter()</tt> is also used to
            efficiently retrieve subsets of a collection without needing to initialize the whole
            collection.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-sorted"></a>6.6.&nbsp;Sorted Collections</h2></div></div><div></div></div><p>
            NHibernate supports collections implemented by <tt class="literal">System.Collections.SortedList</tt> and
            <tt class="literal">System.Collections.Generic.SortedSet&lt;T&gt;</tt>. You must specify a comparer in the mapping file:
        </p><pre class="programlisting">&lt;set name="Aliases" table="person_aliases" sort="natural"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="String"/&gt;
&lt;/set&gt;

&lt;map name="Holidays" sort="My.Custom.HolidayComparer, MyAssembly" lazy="true"&gt;
    &lt;key column="year_id"/&gt;
    &lt;index column="hol_name" type="String"/&gt;
    &lt;element column="hol_date" type="Date"/&gt;
&lt;/map&gt;</pre><p>
            Allowed values of the <tt class="literal">sort</tt> attribute are <tt class="literal">unsorted</tt>,
            <tt class="literal">natural</tt> and the name of a class implementing
            <tt class="literal">System.Collections.IComparer</tt>.
        </p><p>
            If you want the database itself to order the collection elements use the
            <tt class="literal">order-by</tt> attribute of <tt class="literal">set</tt>, <tt class="literal">bag</tt>
            or <tt class="literal">map</tt> mappings. This performs the ordering in the SQL query, not in
            memory.
        </p><p>
            Setting the <tt class="literal">order-by</tt> attribute tells NHibernate to use
            <tt class="literal">ListDictionary</tt> or <tt class="literal">ListSet</tt> class
            internally for dictionaries and sets, maintaining the order of the elements.
            <span class="emphasis"><em>Note that lookup operations on these collections are very slow if they
            contain more than a few elements.</em></span>
        </p><pre class="programlisting">&lt;set name="Aliases" table="person_aliases" order-by="name asc"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="String"/&gt;
&lt;/set&gt;

&lt;map name="Holidays" order-by="hol_date, hol_name" lazy="true"&gt;
    &lt;key column="year_id"/&gt;
    &lt;index column="hol_name" type="String"/&gt;
    &lt;element column="hol_date type="Date"/&gt;
&lt;/map&gt;</pre><p>
            Note that the value of the <tt class="literal">order-by</tt> attribute is an SQL ordering, not
            a HQL ordering!
        </p><p>
            Associations may even be sorted by some arbitrary criteria at runtime using a
            <tt class="literal">Filter()</tt>.
        </p><pre class="programlisting">sortedUsers = s.Filter( group.Users, "order by this.Name" );</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-idbag"></a>6.7.&nbsp;Using an <tt class="literal">&lt;idbag&gt;</tt></h2></div></div><div></div></div><p>
            If you've fully embraced our view that composite keys are a bad thing and that
            entities should have synthetic identifiers (surrogate keys), then you might
            find it a bit odd that the many to many associations and collections of values
            that we've shown so far all map to tables with composite keys! Now, this point
            is quite arguable; a pure association table doesn't seem to benefit much from
            a surrogate key (though a collection of composite values <span class="emphasis"><em>might</em></span>).
            Nevertheless, NHibernate provides a feature that allows you to map many to many
            associations and collections of values to a table with a surrogate key.
        </p><p>
            The <tt class="literal">&lt;idbag&gt;</tt> element lets you map a <tt class="literal">List</tt>
            (or <tt class="literal">Collection</tt>) with bag semantics.
        </p><pre class="programlisting">&lt;idbag name="Lovers" table="LOVERS" lazy="true"&gt;
    &lt;collection-id column="ID" type="Int64"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/collection-id&gt;
    &lt;key column="PERSON1"/&gt;
    &lt;many-to-many column="PERSON2" class="Eg.Person" fetch="join"/&gt;
&lt;/idbag&gt;</pre><p>
            As you can see, an <tt class="literal">&lt;idbag&gt;</tt> has a synthetic id generator,
            just like an entity class! A different surrogate key is assigned to each collection
            row. NHibernate does not provide any mechanism to discover the surrogate key value
            of a particular row, however.
        </p><p>
            Note that the update performance of an <tt class="literal">&lt;idbag&gt;</tt> is
            <span class="emphasis"><em>much</em></span> better than a regular <tt class="literal">&lt;bag&gt;</tt>!
            NHibernate can locate individual rows efficiently and update or delete them
            individually, just like a list, map or set.
        </p><p>
            As of version 2.0, the <tt class="literal">native</tt> identifier generation
            strategy is supported for <tt class="literal">&lt;idbag&gt;</tt> collection identifiers.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-bidirectional"></a>6.8.&nbsp;Bidirectional Associations</h2></div></div><div></div></div><p>
            A <span class="emphasis"><em>bidirectional association</em></span> allows navigation from both
            "ends" of the association. Two kinds of bidirectional association are
            supported:

            </p><div class="variablelist"><dl><dt><span class="term">one-to-many</span></dt><dd><p>
                            set or bag valued at one end, single-valued at the other
                        </p></dd><dt><span class="term">many-to-many</span></dt><dd><p>
                            set or bag valued at both ends
                        </p></dd></dl></div><p>

        </p><p>
            Please note that NHibernate does not support bidirectional one-to-many associations
            with an indexed collection (list, map or array) as the "many" end, you have to
            use a set or bag mapping.
        </p><p>
            You may specify a bidirectional many-to-many association simply by mapping two
            many-to-many associations to the same database table and declaring one end as
            <span class="emphasis"><em>inverse</em></span> (which one is your choice). Here's an example of
            a bidirectional many-to-many association from a class back to <span class="emphasis"><em>itself</em></span>
            (each category can have many items and each item can be in many categories):
        </p><pre class="programlisting">&lt;class name="NHibernate.Auction.Category, NHibernate.Auction"&gt;
    &lt;id name="Id" column="ID"/&gt;
    ...
    &lt;bag name="Items" table="CATEGORY_ITEM" lazy="true"&gt;
        &lt;key column="CATEGORY_ID"/&gt;
        &lt;many-to-many class="NHibernate.Auction.Item, NHibernate.Auction" column="ITEM_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="NHibernate.Auction.Item, NHibernate.Auction"&gt;
    &lt;id name="id" column="ID"/&gt;
    ...

    &lt;!-- inverse end --&gt;
    &lt;bag name="categories" table="CATEGORY_ITEM" inverse="true" lazy="true"&gt;
        &lt;key column="ITEM_ID"/&gt;
        &lt;many-to-many class="NHibernate.Auction.Category, NHibernate.Auction" column="CATEGORY_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;</pre><p>
            Changes made only to the inverse end of the association are <span class="emphasis"><em>not</em></span>
            persisted. This means that NHibernate has two representations in memory for every
            bidirectional association, one link from A to B and another link from B to A. This
            is easier to understand if you think about the .NET object model and how we create
            a many-to-many relationship in C#:
        </p><pre class="programlisting">
category.Items.Add(item);          // The category now "knows" about the relationship
item.Categories.Add(category);     // The item now "knows" about the relationship

session.Update(item);                     // No effect, nothing will be saved!
session.Update(category);                 // The relationship will be saved</pre><p>
            The non-inverse side is used to save the in-memory representation to the database.
            We would get an unneccessary INSERT/UPDATE and probably even a foreign key violation
            if both would trigger changes! The same is of course also true for bidirectional
            one-to-many associations.
        </p><p>
            You may map a bidirectional one-to-many association by mapping a one-to-many association
            to the same table column(s) as a many-to-one association and declaring the many-valued
            end <tt class="literal">inverse="true"</tt>.
        </p><pre class="programlisting">&lt;class name="Eg.Parent, Eg"&gt;
    &lt;id name="Id" column="id"/&gt;
    ....
    &lt;set name="Children" inverse="true" lazy="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;one-to-many class="Eg.Child, Eg"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Eg.Child, Eg"&gt;
    &lt;id name="Id" column="id"/&gt;
    ....
    &lt;many-to-one name="Parent" class="Eg.Parent, Eg" column="parent_id"/&gt;
&lt;/class&gt;</pre><p>
            Mapping one end of an association with <tt class="literal">inverse="true"</tt> doesn't
            affect the operation of cascades, both are different concepts!
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-ternary"></a>6.9.&nbsp;Ternary Associations</h2></div></div><div></div></div><p>
            There are two possible approaches to mapping a ternary association. One approach is to use
            composite elements (discussed below). Another is to use an <tt class="literal">IDictionary</tt> with an
            association as its index:
        </p><pre class="programlisting">&lt;map name="Contracts" lazy="true"&gt;
    &lt;key column="employer_id"/&gt;
    &lt;index-many-to-many column="employee_id" class="Employee"/&gt;
    &lt;one-to-many class="Contract"/&gt;
&lt;/map&gt;</pre><pre class="programlisting">&lt;map name="Connections" lazy="true"&gt;
    &lt;key column="node1_id"/&gt;
    &lt;index-many-to-many column="node2_id" class="Node"/&gt;
    &lt;many-to-many column="connection_id" class="Connection"/&gt;
&lt;/map&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-heterogeneous"></a>6.10.&nbsp;Heterogeneous Associations</h2></div></div><div></div></div><p>
	        The <tt class="literal">&lt;many-to-any&gt;</tt> and <tt class="literal">&lt;index-many-to-any&gt;</tt>
	        elements provide for true heterogeneous associations. These mapping elements work in the
	        same way as the <tt class="literal">&lt;any&gt;</tt> element - and should also be used
	        rarely, if ever.
	    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections-example"></a>6.11.&nbsp;Collection examples</h2></div></div><div></div></div><p>
            The previous sections are pretty confusing. So lets look at an example. This
            class:
        </p><pre class="programlisting">using System;
using System.Collections.Generic;

namespace Eg
    
    public class Parent
    {
        private long id;
        private ISet&lt;Child&gt; children;
    
        public long Id
        {
            get { return id; }
            set { id = value; }
        }
        
        private ISet&lt;Child&gt; Children
        {
            get { return children; }
            set { children = value; }
        }
    
        ....
        ....
    }
}</pre><p>
            has a collection of <tt class="literal">Eg.Child</tt> instances. If each
            child has at most one parent, the most natural mapping is a one-to-many
            association:
        </p><pre class="programlisting">&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg"&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="Children" lazy="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="Name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            This maps to the following table definitions:
        </p><pre class="programlisting">create table parent ( Id bigint not null primary key )
create table child ( Id bigint not null primary key, Name varchar(255), parent_id bigint )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            If the parent is <span class="emphasis"><em>required</em></span>, use a bidirectional one-to-many
            association:
        </p><pre class="programlisting">&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg"&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="Children" inverse="true" lazy="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="Name"/&gt;
        &lt;many-to-one name="parent" class="Parent" column="parent_id" not-null="true"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Notice the <tt class="literal">NOT NULL</tt> constraint:
        </p><pre class="programlisting">create table parent ( Id bigint not null primary key )
create table child ( Id bigint not null
                     primary key,
                     Name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>
            On the other hand, if a child might have multiple parents, a many-to-many
            association is appropriate:
        </p><pre class="programlisting">&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg"&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="Children" lazy="true" table="childset"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;many-to-many class="Child" column="child_id"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="eg.Child"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="Name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
            Table definitions:
        </p><pre class="programlisting">create table parent ( Id bigint not null primary key )
create table child ( Id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="components"></a>Chapter&nbsp;7.&nbsp;Component Mapping</h2></div></div><div></div></div><p>
        The notion of a <span class="emphasis"><em>component</em></span> is re-used in several different contexts,
        for different purposes, throughout NHibernate.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dependentobjects"></a>7.1.&nbsp;Dependent objects</h2></div></div><div></div></div><p>
            A component is a contained object that is persisted as a value type, not an entity.
            The term "component" refers to the object-oriented notion of composition
            (not to architecture-level components). For example, you might model a person like this:
        </p><pre class="programlisting">public class Person
{
    private DateTime birthday;
    private Name name;
    private string key;
    
    public string Key
    {
        get { return key; }
        set { key = value; }
    }
    
    public DateTime Birthday
    {
        get { return birthday; }
        set { birthday = value; }
    }

    public Name Name
    {
        get { return name; }
        set { name = value; }
    }
    ......
    ......
}</pre><pre class="programlisting">public class Name
{
    char initial;
    string first;
    string last;
    
    public string First
    {
        get { return first; }
        set { first = value; }
    }
    
    public string Last
    {
        get { return last; }
        set { last = value; }
    }

    public char Initial
    {
        get { return initial; }
        set { initial = value; }
    }
}</pre><p>
            Now <tt class="literal">Name</tt> may be persisted as a component of
            <tt class="literal">Person</tt>. Notice that <tt class="literal">Name</tt> defines getter
            and setter methods for its persistent properties, but doesn't need to declare
            any interfaces or identifier properties.
        </p><p>
            Our NHibernate mapping would look like:
        </p><pre class="programlisting">&lt;class name="Eg.Person, Eg" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="Birthday" type="date"/&gt;
    &lt;component name="Name" class="Eg.Name, Eg"&gt; &lt;!-- class attribute optional --&gt;
        &lt;property name="Initial"/&gt;
        &lt;property name="First"/&gt;
        &lt;property name="Last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre><p>
            The person table would have the columns <tt class="literal">pid</tt>,
            <tt class="literal">Birthday</tt>,
            <tt class="literal">Initial</tt>,
            <tt class="literal">First</tt> and
            <tt class="literal">Last</tt>.
        </p><p>
            Like all value types, components do not support shared references. The null
            value semantics of a component are <span class="emphasis"><em>ad hoc</em></span>. When reloading the
            containing object, NHibernate will assume that if all component columns are
            null, then the entire component is null. This should be okay for most purposes.
        </p><p>
            The properties of a component may be of any NHibernate type (collections, many-to-one 
            associations, other components, etc). Nested components should <span class="emphasis"><em>not</em></span> 
            be considered an exotic usage. NHibernate is intended to support a very fine-grained 
            object model.
        </p><p>
            The <tt class="literal">&lt;component&gt;</tt> element allows a <tt class="literal">&lt;parent&gt;</tt>
            subelement that maps a property of the component class as a reference back to the
            containing entity.
        </p><pre class="programlisting">&lt;class name="Eg.Person, Eg" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="Birthday" type="date"/&gt;
    &lt;component name="Name" class="Eg.Name, Eg"&gt;
        &lt;parent name="NamedPerson"/&gt; &lt;!-- reference back to the Person --&gt;
        &lt;property name="Initial"/&gt;
        &lt;property name="First"/&gt;
        &lt;property name="Last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-incollections"></a>7.2.&nbsp;Collections of dependent objects</h2></div></div><div></div></div><p>
            Collections of components are supported (eg. an array of type
            <tt class="literal">Name</tt>). Declare your component collection by
            replacing the <tt class="literal">&lt;element&gt;</tt> tag with a
            <tt class="literal">&lt;composite-element&gt;</tt> tag.
        </p><pre class="programlisting">&lt;set name="SomeNames" table="some_names" lazy="true"&gt;
    &lt;key column="id"/&gt;
    &lt;composite-element class="Eg.Name, Eg"&gt; &lt;!-- class attribute required --&gt;
        &lt;property name="Initial"/&gt;
        &lt;property name="First"/&gt;
        &lt;property name="Last"/&gt;
    &lt;/composite-element&gt;
&lt;/set&gt;</pre><p>
            Note: if you define an <tt class="literal">ISet&lt;T&gt;</tt> of composite elements, it is 
            very important to implement <tt class="literal">Equals()</tt> and 
            <tt class="literal">GetHashCode()</tt> correctly.
        </p><p>
            Composite elements may contain components but not collections. If your
            composite element itself contains 
            components, use the <tt class="literal">&lt;nested-composite-element&gt;</tt> 
            tag. This is a pretty exotic case - a collection of components which 
            themselves have components. By this stage you should be asking yourself 
            if a one-to-many association is more appropriate. Try remodelling the 
            composite element as an entity - but note that even though the object model 
            is the same, the relational model and persistence semantics are still 
            slightly different.
        </p><p>
            Please note that a composite element mapping doesn't support null-able properties
            if you're using a <tt class="literal">&lt;set&gt;</tt>. NHibernate
            has to use each columns value to identify a record when deleting objects
            (there is no separate primary key column in the composite element table),
            which is not possible with null values. You have to either use only
            not-null properties in a composite-element or choose a
            <tt class="literal">&lt;list&gt;</tt>, <tt class="literal">&lt;map&gt;</tt>,
            <tt class="literal">&lt;bag&gt;</tt> or <tt class="literal">&lt;idbag&gt;</tt>.
        </p><p>
            A special case of a composite element is a composite element with a nested
            <tt class="literal">&lt;many-to-one&gt;</tt> element. A mapping like this allows
            you to map extra columns of a many-to-many association table to the
            composite element class. The following is a many-to-many association
            from <tt class="literal">Order</tt> to <tt class="literal">Item</tt> where 
            <tt class="literal">PurchaseDate</tt>, <tt class="literal">Price</tt> and
            <tt class="literal">Quantity</tt> are properties of the association:
        </p><pre class="programlisting">&lt;class name="Order" .... &gt;
    ....
    &lt;set name="PurchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="Purchase"&gt;
            &lt;property name="PurchaseDate"/&gt;
            &lt;property name="Price"/&gt;
            &lt;property name="Quantity"/&gt;
            &lt;many-to-one name="Item" class="Item"/&gt; &lt;!-- class attribute is optional --&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>Even ternary (or quaternary, etc) associations are possible:</p><pre class="programlisting">&lt;class name="Order" .... &gt;
    ....
    &lt;set name="PurchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="OrderLine"&gt;
            &lt;many-to-one name="PurchaseDetails class="Purchase"/&gt;
            &lt;many-to-one name="Item" class="Item"/&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Composite elements may appear in queries using the same syntax as
            associations to other entities.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-asmapindex"></a>7.3.&nbsp;Components as IDictionary indices</h2></div></div><div></div></div><p>
            The <tt class="literal">&lt;composite-index&gt;</tt> element lets you map a
            component class as the key of an <tt class="literal">IDictionary</tt>. Make sure
            you override <tt class="literal">GetHashCode()</tt> and <tt class="literal">Equals()</tt>
            correctly on the component class.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-compositeid"></a>7.4.&nbsp;Components as composite identifiers</h2></div></div><div></div></div><p>
            You may use a component as an identifier of an entity class. Your component
            class must satisfy certain requirements:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    It must be <tt class="literal">Serializable</tt>.
                </p></li><li><p>
                    It must re-implement <tt class="literal">Equals()</tt> and
                    <tt class="literal">GetHashCode()</tt>, consistently with the database's 
                    notion of composite key equality.
                </p></li></ul></div><p>
            You can't use an <tt class="literal">IIdentifierGenerator</tt> to generate composite keys.
            Instead the application must assign its own identifiers.
        </p><p>
            Since a composite identifier must be assigned to the object before saving it,
            we can't use <tt class="literal">unsaved-value</tt> of the identifier to distinguish
            between newly instantiated instances and instances saved in a previous session.
        </p><p>
            You may instead implement <tt class="literal">IInterceptor.IsTransient()</tt> if
            you wish to use <tt class="literal">SaveOrUpdate()</tt> or cascading save / update.
            As an alternative, you may also set the <tt class="literal">unsaved-value</tt>
            attribute on a <tt class="literal">&lt;version&gt;</tt> (or
            <tt class="literal">&lt;timestamp&gt;</tt>) element to specify a
            value that indicates a new transient instance. In this case, the version
            of the entity is used instead of the (assigned) identifier and you don't have
            to implement <tt class="literal">IInterceptor.IsTransient()</tt> yourself.
        </p><p>
            Use the <tt class="literal">&lt;composite-id&gt;</tt> tag (same attributes and
            elements as <tt class="literal">&lt;component&gt;</tt>) in place of
            <tt class="literal">&lt;id&gt;</tt> for the declaration of a composite identifier
            class:
        </p><pre class="programlisting">&lt;class name="Foo" table="FOOS"&gt;
    &lt;composite-id name="CompId" class="FooCompositeID"&gt;
        &lt;key-property name="String"/&gt;
        &lt;key-property name="Short"/&gt;
        &lt;key-property name="Date" column="date_" type="Date"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="Name"/&gt;
    ....
&lt;/class&gt;</pre><p>
            Now, any foreign keys into the table <tt class="literal">FOOS</tt> are also composite.
            You must declare this in your mappings for other classes. An association to
            <tt class="literal">Foo</tt> would be declared like this:
        </p><pre class="programlisting">&lt;many-to-one name="Foo" class="Foo"&gt;
&lt;!-- the "class" attribute is optional, as usual --&gt;
    &lt;column name="foo_string"/&gt;
    &lt;column name="foo_short"/&gt;
    &lt;column name="foo_date"/&gt;
&lt;/many-to-one&gt;</pre><p>
        This new <tt class="literal">&lt;column&gt;</tt> tag is also used by multi-column custom types.
        Actually it is an alternative to the <tt class="literal">column</tt> attribute everywhere. A
        collection with elements of type <tt class="literal">Foo</tt> would use:
    </p><pre class="programlisting">&lt;set name="Foos"&gt;
    &lt;key column="owner_id"/&gt;
    &lt;many-to-many class="Foo"&gt;
        &lt;column name="foo_string"/&gt;
        &lt;column name="foo_short"/&gt;
        &lt;column name="foo_date"/&gt;
    &lt;/many-to-many&gt;
&lt;/set&gt;</pre><p>
            On the other hand, <tt class="literal">&lt;one-to-many&gt;</tt>, as usual, declares no columns.
        </p><p>
            If <tt class="literal">Foo</tt> itself contains collections, they will also need a
            composite foreign key.
        </p><pre class="programlisting">&lt;class name="Foo"&gt;
    ....
    ....
    &lt;set name="Dates" lazy="true"&gt;
        &lt;key&gt;   &lt;!-- a collection inherits the composite key type --&gt;
            &lt;column name="foo_string"/&gt;
            &lt;column name="foo_short"/&gt;
            &lt;column name="foo_date"/&gt;
        &lt;/key&gt;
        &lt;element column="foo_date" type="Date"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="components-dynamic"></a>7.5.&nbsp;Dynamic components</h2></div></div><div></div></div><p>
            You may even map a property of type <tt class="literal">IDictionary</tt>:
        </p><pre class="programlisting">&lt;dynamic-component name="UserAttributes"&gt;
    &lt;property name="Foo" column="FOO"/&gt;
    &lt;property name="Bar" column="BAR"/&gt;
    &lt;many-to-one name="Baz" class="Baz" column="BAZ"/&gt;
&lt;/dynamic-component&gt;</pre><p>
            The semantics of a <tt class="literal">&lt;dynamic-component&gt;</tt> mapping are identical
            to <tt class="literal">&lt;component&gt;</tt>. The advantage of this kind of mapping is 
            the ability to determine the actual properties of the component at deployment time, just
            by editing the mapping document. (Runtime manipulation of the mapping document is 
            also possible, using a DOM parser.)
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="inheritance"></a>Chapter&nbsp;8.&nbsp;Inheritance Mapping</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-strategies"></a>8.1.&nbsp;The Three Strategies</h2></div></div><div></div></div><p>
            NHibernate supports the three basic inheritance mapping strategies.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            table per class hierarchy
        </p></li><li><p>
            table per subclass
        </p></li><li><p>
            table per concrete class
        </p></li></ul></div><p>
            In addition, NHibernate supports a fourth, slightly different kind of 
            polymorphism:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
            implicit polymorphism
        </p></li></ul></div><p>
            It is possible to use different mapping strategies for different
            branches of the same inheritance hierarchy, and then make use of implicit
            polymorphism to achieve polymorphism across the whole hierarchy. However, 
            NHibernate does not support mixing <tt class="literal">&lt;subclass&gt;</tt>,
            and <tt class="literal">&lt;joined-subclass&gt;</tt> and 
            <tt class="literal">&lt;union-subclass&gt;</tt> mappings under the same root
            <tt class="literal">&lt;class&gt;</tt> element. It is possible to mix together
            the table per hierarchy and table per subclass strategies, under the
            the same <tt class="literal">&lt;class&gt;</tt> element, by combining the 
            <tt class="literal">&lt;subclass&gt;</tt> and <tt class="literal">&lt;join&gt;</tt>
            elements (see below).
        </p><p>
             It is possible to define <tt class="literal">subclass</tt>, <tt class="literal">union-subclass</tt>,
             and <tt class="literal">joined-subclass</tt> mappings in separate mapping documents, directly beneath
             <tt class="literal">hibernate-mapping</tt>. This allows you to extend a class hierachy just by adding
             a new mapping file. You must specify an <tt class="literal">extends</tt> attribute in the subclass mapping,
             naming a previously mapped superclass.
         </p><pre class="programlisting">
 &lt;hibernate-mapping&gt;
     &lt;subclass name="DomesticCat" extends="Cat" discriminator-value="D"&gt;
          &lt;property name="name" type="string"/&gt;
     &lt;/subclass&gt;
 &lt;/hibernate-mapping&gt;</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperclass"></a>8.1.1.&nbsp;Table per class hierarchy</h3></div></div><div></div></div><p>
            Suppose we have an interface <tt class="literal">IPayment</tt>, with implementors
            <tt class="literal">CreditCardPayment</tt>, <tt class="literal">CashPayment</tt>,
            <tt class="literal">ChequePayment</tt>. The table-per-hierarchy mapping would
            look like:
        </p><pre class="programlisting">&lt;class name="IPayment" table="PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="String"/&gt;
    &lt;property name="Amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            Exactly one table is required. There is one big limitation of this
            mapping strategy: columns declared by the subclasses may not have
            <tt class="literal">NOT NULL</tt> constraints.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tablepersubclass"></a>8.1.2.&nbsp;Table per subclass</h3></div></div><div></div></div><p>
            A table-per-subclass mapping would look like:
        </p><pre class="programlisting">&lt;class name="IPayment" table="PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="Amount" column="AMOUNT"/&gt;
    ...
    &lt;joined-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
            Four tables are required. The three subclass tables have primary
            key associations to the superclass table (so the relational model
            is actually a one-to-one association).
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tablepersubclass-discriminator"></a>8.1.3.&nbsp;Table per subclass, using a discriminator</h3></div></div><div></div></div><p>
            Note that NHibernate's implementation of table-per-subclass requires
            no discriminator column. Other object/relational mappers use a
            different implementation of table-per-subclass which requires a type
            discriminator column in the superclass table. The approach taken by
            NHibernate is much more difficult to implement but arguably more
            correct from a relational point of view. If you would like to use
            a discriminator column with the table per subclass strategy, you
            may combine the use of <tt class="literal">&lt;subclass&gt;</tt> and
            <tt class="literal">&lt;join&gt;</tt>, as follow:
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="Amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            &lt;property name="CreditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        &lt;join table="CASH_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        &lt;join table="CHEQUE_PAYMENT" fetch="select"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            The optional <tt class="literal">fetch="select"</tt> declaration tells NHibernate 
            not to fetch the <tt class="literal">ChequePayment</tt> subclass data using an
            outer join when querying the superclass.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-mixing-tableperclass-tablepersubclass"></a>8.1.4.&nbsp;Mixing table per class hierarchy with table per subclass</h3></div></div><div></div></div><p>
            You may even mix the table per hierarchy and table per subclass strategies
            using this approach:
        </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="Amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;property name="CreditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
            For any of these mapping strategies, a polymorphic
            association to <tt class="literal">IPayment</tt> is mapped using
            <tt class="literal">&lt;many-to-one&gt;</tt>.
        </p><pre class="programlisting">&lt;many-to-one name="Payment" column="PAYMENT" class="IPayment"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperconcrete"></a>8.1.5.&nbsp;Table per concrete class</h3></div></div><div></div></div><p>
            There are two ways we could go about mapping the table per concrete class
            strategy. The first is to use <tt class="literal">&lt;union-subclass&gt;</tt>.
        </p><pre class="programlisting">&lt;class name="Payment"&gt;
    &lt;id name="Id" type="Int64" column="PAYMENT_ID"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/id&gt;
    &lt;property name="Amount" column="AMOUNT"/&gt;
    ...
    &lt;union-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;property name="CreditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
&lt;/class&gt;</pre><p>
            Three tables are involved for the subclasses. Each table defines columns for
            all properties of the class, including inherited properties.
        </p><p>
            The limitation of this approach is that if a property is mapped on the 
            superclass, the column name must be the same on all subclass tables.
            (We might relax this in a future release of NHibernate.) The identity
            generator strategy is not allowed in union subclass inheritance, indeed
            the primary key seed has to be shared accross all unioned subclasses
            of a hierarchy.
        </p><p>
            If your superclass is abstract, map it with <tt class="literal">abstract="true"</tt>.
            Of course, if it is not abstract, an additional table (defaults to
            <tt class="literal">PAYMENT</tt> in the example above) is needed to hold instances
            of the superclass.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritance-tableperconcreate-polymorphism"></a>8.1.6.&nbsp;Table per concrete class, using implicit polymorphism</h3></div></div><div></div></div><p>
            An alternative approach is to make use of implicit polymorphism:
        </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="Amount" column="CREDIT_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="CashPayment" table="CASH_PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="CASH_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="Amount" column="CASH_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="CHEQUE_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="Amount" column="CHEQUE_AMOUNT"/&gt;
    ...
&lt;/class&gt;</pre><p>
            Notice that nowhere do we mention the <tt class="literal">IPayment</tt> interface 
            explicitly. Also notice that properties of <tt class="literal">IPayment</tt> are 
            mapped in each of the subclasses. If you want to avoid duplication, consider
            using XML entities
            (e.g. <tt class="literal">[ &lt;!ENTITY allproperties SYSTEM "allproperties.xml"&gt; ]</tt>
            in the <tt class="literal">DOCTYPE</tt> declartion and 
            <tt class="literal">&amp;allproperties;</tt> in the mapping).
        </p><p>
            The disadvantage of this approach is that NHibernate does not generate SQL
            <tt class="literal">UNION</tt>s when performing polymorphic queries.
        </p><p>
            For this mapping strategy, a polymorphic association to <tt class="literal">IPayment</tt> 
            is usually mapped using <tt class="literal">&lt;any&gt;</tt>.
        </p><pre class="programlisting">&lt;any name="Payment" meta-type="string" id-type="Int64"&gt;
    &lt;meta-value value="CREDIT" class="CreditCardPayment"/&gt;
    &lt;meta-value value="CASH" class="CashPayment"/&gt;
    &lt;meta-value value="CHEQUE" class="ChequePayment"/&gt;
    &lt;column name="PAYMENT_CLASS"/&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritace-mixingpolymorphism"></a>8.1.7.&nbsp;Mixing implicit polymorphism with other inheritance mappings</h3></div></div><div></div></div><p>
            There is one further thing to notice about this mapping.
            Since the subclasses are each mapped in their own
            <tt class="literal">&lt;class&gt;</tt> element (and since
            <tt class="literal">IPayment</tt> is just an interface), each of
            the subclasses could easily be part of another table-per-class
            or table-per-subclass inheritance hierarchy! (And you can
            still use polymorphic queries against the
            <tt class="literal">IPayment</tt> interface.)
       </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="Id" type="Int64" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="CREDIT_CARD" type="String"/&gt;
    &lt;property name="Amount" column="CREDIT_AMOUNT"/&gt;
    ...
    &lt;subclass name="MasterCardPayment" discriminator-value="MDC"/&gt;
    &lt;subclass name="VisaPayment" discriminator-value="VISA"/&gt;
&lt;/class&gt;

&lt;class name="NonelectronicTransaction" table="NONELECTRONIC_TXN"&gt;
    &lt;id name="Id" type="Int64" column="TXN_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    ...
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="Amount" column="CASH_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="Amount" column="CHEQUE_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>
            Once again, we don't mention <tt class="literal">IPayment</tt> explicitly. If we
            execute a query against the <tt class="literal">IPayment</tt> interface - for
            example, <tt class="literal">from IPayment</tt> - NHibernate
            automatically returns instances of <tt class="literal">CreditCardPayment</tt>
            (and its subclasses, since they also implement <tt class="literal">IPayment</tt>),
            <tt class="literal">CashPayment</tt> and <tt class="literal">ChequePayment</tt> but
            not instances of <tt class="literal">NonelectronicTransaction</tt>.
        </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance-limitations"></a>8.2.&nbsp;Limitations</h2></div></div><div></div></div><p>
            There are certain limitations to the "implicit polymorphism" approach to
            the table per concrete-class mapping strategy. There are somewhat less
            restrictive limitations to <tt class="literal">&lt;union-subclass&gt;</tt>
            mappings.
        </p><p>
            The following table shows the limitations of table per concrete-class
            mappings, and of implicit polymorphism, in NHibernate.
        </p><div class="table"><a name="d0e7355"></a><p class="title"><b>Table&nbsp;8.1.&nbsp;Features of inheritance mappings</b></p><table summary="Features of inheritance mappings" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Inheritance strategy</th><th align="left">Polymorphic many-to-one</th><th align="left">Polymorphic one-to-one</th><th align="left">Polymorphic one-to-many</th><th align="left">Polymorphic many-to-many</th><th align="left">Polymorphic <tt class="literal">load()/get()</tt></th><th align="left">Polymorphic queries</th><th align="left">Polymorphic joins</th><th align="left">Outer join fetching</th></tr></thead><tbody><tr><td align="left">table per class-hierarchy</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.Get&lt;IPayment&gt;(id)</tt></td><td align="left"><tt class="literal">from IPayment p</tt></td><td align="left"><tt class="literal">from Order o join o.Payment p</tt></td><td align="left"><span class="emphasis"><em>supported</em></span></td></tr><tr><td align="left">table per subclass</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt></td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.Get&lt;IPayment&gt;(id)</tt></td><td align="left"><tt class="literal">from IPayment p</tt></td><td align="left"><tt class="literal">from Order o join o.Payment p</tt></td><td align="left"><span class="emphasis"><em>supported</em></span></td></tr><tr><td align="left">table per concrete-class (union-subclass)</td><td align="left"><tt class="literal">&lt;many-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-one&gt;</tt></td><td align="left"><tt class="literal">&lt;one-to-many&gt;</tt> (for <tt class="literal">inverse="true"</tt> only)</td><td align="left"><tt class="literal">&lt;many-to-many&gt;</tt></td><td align="left"><tt class="literal">s.Get&lt;IPayment&gt;(id)</tt></td><td align="left"><tt class="literal">from IPayment p</tt></td><td align="left"><tt class="literal">from Order o join o.Payment p</tt></td><td align="left"><span class="emphasis"><em>supported</em></span></td></tr><tr><td align="left">table per concrete class (implicit polymorphism)</td><td align="left"><tt class="literal">&lt;any&gt;</tt></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><tt class="literal">&lt;many-to-any&gt;</tt></td><td align="left"><span class="emphasis"><em>use a query</em></span></td><td align="left"><tt class="literal">from IPayment p</tt></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><span class="emphasis"><em>not supported</em></span></td></tr></tbody></table></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="manipulatingdata"></a>Chapter&nbsp;9.&nbsp;Manipulating Persistent Data</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-creating"></a>9.1.&nbsp;Creating a persistent object</h2></div></div><div></div></div><p>
            An object (entity instance) is either <span class="emphasis"><em>transient</em></span> or
            <span class="emphasis"><em>persistent</em></span> with respect to a particular
            <tt class="literal">ISession</tt>. Newly instantiated objects are, of course, transient. 
            The session offers services for saving (ie. persisting) transient instances:
        </p><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.Color = Color.Ginger;
fritz.Sex = 'M';
fritz.Name = "Fritz";
long generatedId = (long) sess.Save(fritz);</pre><pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.Color = Color.Tabby;
pk.Sex = 'F';
pk.Name = "PK";
pk.Kittens = new HashSet&lt;Cat&gt;();
pk.AddKitten(fritz);
sess.Save( pk, 1234L );</pre><p>
            The single-argument <tt class="literal">Save()</tt> generates and assigns a unique
            identifier to <tt class="literal">fritz</tt>. The two-argument form attempts to persist
            <tt class="literal">pk</tt> using the given identifier. We generally discourage the use of 
            the two-argument form since it may be used to create primary keys with business meaning.
        </p><p>
            Associated objects may be made persistent in any order you like unless you 
            have a <tt class="literal">NOT NULL</tt> constraint upon a foreign key column.
            There is never a risk of violating foreign key constraints. However, you 
            might violate a <tt class="literal">NOT NULL</tt> constraint if you
            <tt class="literal">Save()</tt> the objects in the wrong order.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-loading"></a>9.2.&nbsp;Loading an object</h2></div></div><div></div></div><p>
            The <tt class="literal">Load()</tt> methods of <tt class="literal">ISession</tt> give you 
            a way to retrieve a persistent instance if you already know its identifier. 
            One version takes a class object and will load the state into a newly instantiated 
            object. The second version allows you to supply an instance into which the state 
            will be loaded. The form which takes an instance is only useful in special
            circumstances (DIY instance pooling etc.)
        </p><pre class="programlisting">Cat fritz = sess.Load&lt;Cat&gt;(generatedId);</pre><pre class="programlisting">long pkId = 1234;
DomesticCat pk = (DomesticCat) sess.Load&lt;Cat&gt;(pkId);</pre><pre class="programlisting">Cat cat = new DomesticCat();
// load pk's state into cat
sess.Load( cat, pkId );
ISet&lt;Cat&gt; kittens = cat.Kittens;</pre><p>
            Note that <tt class="literal">Load()</tt> will throw an unrecoverable exception if there is no matching 
            database row. If the class is mapped with a proxy, <tt class="literal">Load()</tt> returns an object
            that is an uninitialized proxy and does not actually hit the database until you invoke a method of 
            the object. This behaviour is very useful if you wish to create an association to an object
            without actually loading it from the database.
        </p><p>
            If you are not certain that a matching row exists, you should use the <tt class="literal">Get()</tt>
            method, which hits the database immediately and returns null if there is no matching row.
        </p><pre class="programlisting">Cat cat = sess.Get&lt;Cat&gt;(id);
if (cat==null) {
    cat = new Cat();
    sess.Save(cat, id);
}
return cat;</pre><p>
            You may also load an objects using an SQL <tt class="literal">SELECT ... FOR UPDATE</tt>. See the next
            section for a discussion of NHibernate <tt class="literal">LockMode</tt>s.
        </p><pre class="programlisting">Cat cat = sess.Get&lt;Cat&gt;(id, LockMode.Upgrade);</pre><p>
            Note that any associated instances or contained collections are <span class="emphasis"><em>not</em></span> selected 
            <tt class="literal">FOR UPDATE</tt>.
        </p><p>
            It is possible to re-load an object and all its collections at any time, using the 
            <tt class="literal">Refresh()</tt> method. This is useful when database triggers are used to
            initialize some of the properties of the object.
        </p><pre class="programlisting">sess.Save(cat);
sess.Flush(); //force the SQL INSERT
sess.Refresh(cat); //re-read the state (after the trigger executes)</pre><p>
            An important question usually appears at this point: How much does NHibernate load
            from the database and how many SQL <tt class="literal">SELECT</tt>s will it use? This
            depends on the <span class="emphasis"><em>fetching strategy</em></span> and is explained in
            <a href="#performance-fetching" title="19.1.&nbsp;Fetching strategies">Section&nbsp;19.1, &#8220;Fetching strategies&#8221;</a>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-querying"></a>9.3.&nbsp;Querying</h2></div></div><div></div></div><p>
            If you don't know the identifier(s) of the object(s) you are looking for, use the <tt class="literal">CreateQuery()
            </tt> methods of <tt class="literal">ISession</tt>. NHibernate supports a simple but powerful object 
            oriented query language.
        </p><pre class="programlisting">IList&lt;Cat&gt; cats = sess.CreateQuery(
    "from Cat as cat where cat.Birthdate = :birthday"
).SetDate("birthday", date)
.List&lt;Cat&gt;();

IList&lt;Cat&gt; mates = sess.CreateQuery(
    "select mate from Cat as cat join cat.Mate as mate " +
    "where cat.name = :name"
).SetString("name", name)
.List&lt;Cat&gt;();

IList&lt;Cat&gt; cats = sess.CreateQuery( "from Cat as cat where cat.Mate.Birthdate is null" ).List&lt;Cat&gt;();

IList&lt;Cat&gt; moreCats = sess.CreateQuery(
    "from Cat as cat where " + 
    "cat.Name = 'Fritz' or cat.id = :id1 or cat.id = :id2"
).SetInt64("id1", id1)
.SetInt67("id2", id2)
.List&lt;Cat&gt;();

IList&lt;Cat&gt; mates = sess.CreateQuery(
    "from Cat as cat where cat.Mate = :mate"
).SetParameter("mate", izi, NHibernateUtil.Entity(typeof(Cat))
).List&lt;Cat&gt;();

IList&lt;Cat&gt; problems = sess.CreateQuery(
    "from GoldFish as fish " +
    "where fish.Birthday &gt; fish.Deceased or fish.Birthday is null"
).List&lt;Cat&gt;();</pre><p>
            The <tt class="literal">NHibernateUtil</tt> class defines a number of static methods
            and constants, providing access to most of the built-in types, as instances
            of <tt class="literal">NHibernate.Type.IType</tt>.
        </p><p>
            If you expect your query to return a very large number of objects, but you 
            don't expect to use them all, you might get better performance from the
            <tt class="literal">Enumerable()</tt> methods, which return a
            <tt class="literal">System.Collections.IEnumerable</tt>. The iterator will load objects
            on demand, using the identifiers returned by an initial SQL query (n+1 selects
            total).
        </p><pre class="programlisting">// fetch ids
IEnumerable&lt;Qux&gt; en = sess.CreateQuery("from eg.Qux q order by q.Likeliness").Enumerable&lt;Qux&gt;(); 
foreach ( Qux qux in en )
{
    // something we couldnt express in the query
    if ( qux.CalculateComplicatedAlgorithm() ) {
        // dont need to process the rest
        break;
    }
}</pre><p>
            The <tt class="literal">Enumerable()</tt> method also performs better if
            you expect that many of the objects are already loaded and cached by 
            the session, or if the query results contain the same objects many
            times. (When no data is cached or repeated, <tt class="literal">Find()</tt> 
            is almost always faster.) Heres an example of a query that should be
            called using <tt class="literal">Enumerable()</tt>:
        </p><pre class="programlisting">
IEnumerable en = sess.CreateQuery(
    "select customer, product " + 
    "from Customer customer, " +
    "Product product " +
    "join customer.Purchases purchase " +
    "where product = purchase.Product"
).Enumerable();</pre><p>
            Calling the previous query using <tt class="literal">Find()</tt> would return a very
            large ADO.NET result set containing the same data many times.
        </p><p>
            NHibernate queries sometimes return tuples of objects, in which case each tuple
            is returned as an array:
        </p><pre class="programlisting">IEnumerable foosAndBars = sess.CreateQuery(
    "select foo, bar from Foo foo, Bar bar " +
    "where bar.Date = foo.Date"
).Enumerable();
foreach (object[] tuple in foosAndBars)
{
    Foo foo = tuple[0]; Bar bar = tuple[1];
    ....
}</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-scalarqueries"></a>9.3.1.&nbsp;Scalar queries</h3></div></div><div></div></div><p>
                Queries may specify a property of a class in the <tt class="literal">select</tt> clause.
                They may even call SQL aggregate functions. Properties or aggregates are considered
                "scalar" results.
            </p><pre class="programlisting">IEnumerable results = sess.CreateQuery(
        "select cat.Color, min(cat.Birthdate), count(cat) from Cat cat " +
        "group by cat.Color"
).Enumerable();
foreach ( object[] row in results )
{
    Color type = (Color) row[0];
    DateTime oldest = (DateTime) row[1];
    int count = (int) row[2];
    .....
}</pre><pre class="programlisting">IEnumerable en = sess.CreateQuery(
    "select cat.Type, cat.Birthdate, cat.Name from DomesticCat cat"
).Enumerable();</pre><pre class="programlisting">IList&lt;Cat&gt; list = sess.CreateQuery(
    "select cat, cat.Mate.Name from DomesticCat cat"
).List&lt;Cat&gt;();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-queryinterface"></a>9.3.2.&nbsp;The IQuery interface</h3></div></div><div></div></div><p>
                If you need to specify bounds upon your result set (the maximum number of rows
                you want to retrieve and / or the first row you want to retrieve) you should
                obtain an instance of <tt class="literal">NHibernate.IQuery</tt>:
            </p><pre class="programlisting">IQuery q = sess.CreateQuery("from DomesticCat cat");
q.SetFirstResult(20);
q.SetMaxResults(10);
IList&lt;Cat&gt; cats = q.List&lt;Cat&gt;();</pre><p>
                You may even define a named query in the mapping document. (Remember to use a
                <tt class="literal">CDATA</tt> section if your query contains characters that could
                be interpreted as markup.)
            </p><pre class="programlisting">&lt;query name="Eg.DomesticCat.by.name.and.minimum.weight"&gt;&lt;![CDATA[
    from Eg.DomesticCat as cat
        where cat.Name = ?
        and cat.Weight &gt; ?
] ]&gt;&lt;/query&gt;</pre><pre class="programlisting">IQuery q = sess.GetNamedQuery("Eg.DomesticCat.by.name.and.minimum.weight");
q.SetString(0, name);
q.SetInt32(1, minWeight);
IList&lt;Cat&gt; cats = q.List&lt;Cat&gt;();</pre><p>
                The query interface supports the use of named parameters. Named parameters
                are identifiers of the form <tt class="literal">:name</tt> in the query string.
                There are methods on <tt class="literal">IQuery</tt> for binding values to named
                or positional parameters. NHibernate numbers parameters from zero.
                The advantages of named parameters are:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        named parameters are insensitive to the order they occur in the
                        query string
                    </p></li><li><p>
                        they may occur multiple times in the same query
                    </p></li><li><p>
                        they are self-documenting
                    </p></li></ul></div><pre class="programlisting">//named parameter (preferred)
IQuery q = sess.CreateQuery("from DomesticCat cat where cat.Name = :name");
q.SetString("name", "Fritz");
IEnumerable&lt;Cat&gt; cats = q.Enumerable&lt;Cat&gt;();</pre><pre class="programlisting">//positional parameter
IQuery q = sess.CreateQuery("from DomesticCat cat where cat.Name = ?");
q.SetString(0, "Izi");
IEnumerable&lt;Cat&gt; cats = q.Enumerable&lt;Cat&gt;();</pre><pre class="programlisting">//named parameter list
IList&lt;string&gt; names = new List&lt;string&gt;();
names.Add("Izi");
names.Add("Fritz");
IQuery q = sess.CreateQuery("from DomesticCat cat where cat.Name in (:namesList)");
q.SetParameterList("namesList", names);
IList&lt;Cat&gt; cats = q.List&lt;Cat&gt;();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-filtering"></a>9.3.3.&nbsp;Filtering collections</h3></div></div><div></div></div><p>
                A collection <span class="emphasis"><em>filter</em></span> is a special type of query that may be applied to
                a persistent collection or array. The query string may refer to <tt class="literal">this</tt>,
                meaning the current collection element.
            </p><pre class="programlisting">ICollection&lt;Cat&gt; blackKittens = session.CreateFilter(
    pk.Kittens, "where this.Color = ?", Color.Black, NHibernateUtil.Enum(typeof(Color))
).List&lt;Cat&gt;();</pre><p>
                The returned collection is considered a bag.
            </p><p>
                Observe that filters do not require a <tt class="literal">from</tt> clause (though they may have
                one if required). Filters are not limited to returning the collection elements themselves.
            </p><pre class="programlisting">ICollection&lt;Cat&gt; blackKittenMates = session.CreateFilter(
    pk.Kittens, "select this.Mate where this.Color = Eg.Color.Black"
).List&lt;Cat&gt;();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-criteria"></a>9.3.4.&nbsp;Criteria queries</h3></div></div><div></div></div><p>
                HQL is extremely powerful but some people prefer to build queries dynamically, using an
                object oriented API, rather than embedding strings in their .NET code. For these people,
                NHibernate provides an intuitive <tt class="literal">ICriteria</tt> query API.
            </p><pre class="programlisting">ICriteria crit = session.CreateCriteria&lt;Cat&gt;();
crit.Add( Expression.Eq("color", Eg.Color.Black) );
crit.SetMaxResults(10);
IList&lt;Cat&gt; cats = crit.List&lt;Cat&gt;();</pre><p>
                If you are uncomfortable with SQL-like syntax, this is perhaps the easiest way to get started
                with NHibernate. This API is also more extensible than HQL. Applications might provide their
                own implementations of the <tt class="literal">ICriterion</tt> interface.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-nativesql"></a>9.3.5.&nbsp;Queries in native SQL</h3></div></div><div></div></div><p>
                You may express a query in SQL, using <tt class="literal">CreateSQLQuery()</tt>. You must enclose
                SQL aliases in braces.
            </p><pre class="programlisting">IList&lt;Cat&gt; cats = session.CreateSQLQuery(
    "SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM&lt;10",
    "cat",
    typeof(Cat)
).List&lt;Cat&gt;();</pre><pre class="programlisting">IList&lt;Cat&gt; cats = session.CreateSQLQuery(
    "SELECT {cat}.ID AS {cat.Id}, {cat}.SEX AS {cat.Sex}, " +
           "{cat}.MATE AS {cat.Mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT {cat} WHERE ROWNUM&lt;10",
    "cat",
    typeof(Cat)
).List&lt;Cat&gt;()</pre><p>
                SQL queries may contain named and positional parameters, just like NHibernate queries.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-updating"></a>9.4.&nbsp;Updating objects</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-updating-insession"></a>9.4.1.&nbsp;Updating in the same ISession</h3></div></div><div></div></div><p>
                <span class="emphasis"><em>Transactional persistent instances</em></span> (ie. objects loaded, saved, created or
                queried by the <tt class="literal">ISession</tt>) may be manipulated by the application
                and any changes to persistent state will be persisted when the <tt class="literal">ISession</tt>
                is <span class="emphasis"><em>flushed</em></span> (discussed later in this chapter). So the most
                straightforward way to update the state of an object is to <tt class="literal">Load()</tt> it,
                and then manipulate it directly, while the <tt class="literal">ISession</tt> is open:
            </p><pre class="programlisting">DomesticCat cat = (DomesticCat) sess.Load&lt;Cat&gt;( 69L );
cat.Name = "PK";
sess.Flush();  // changes to cat are automatically detected and persisted</pre><p>
                Sometimes this programming model is inefficient since it would require both an SQL
                <tt class="literal">SELECT</tt> (to load an object) and an SQL <tt class="literal">UPDATE</tt>
                (to persist its updated state) in the same session. Therefore NHibernate offers an
                alternate approach.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-updating-detached"></a>9.4.2.&nbsp;Updating detached objects</h3></div></div><div></div></div><p>
                Many applications need to retrieve an object in one transaction, send it to the
                UI layer for manipulation, then save the changes in a new transaction.
                (Applications  that use this kind of approach in a high-concurrency environment
                usually use versioned  data to ensure transaction isolation.) This approach
                requires a slightly different  programming model to the one described in the
                last section. NHibernate supports this model by providing the
                method <tt class="literal">ISession.Update()</tt>.
            </p><pre class="programlisting">// in the first session
Cat cat = firstSession.Load&lt;Cat&gt;(catId);
Cat potentialMate = new Cat();
firstSession.Save(potentialMate);

// in a higher tier of the application
cat.Mate = potentialMate;

// later, in a new session
secondSession.Update(cat);  // update cat
secondSession.Update(mate); // update mate</pre><p>
                If the <tt class="literal">Cat</tt> with identifier <tt class="literal">catId</tt> had already
                been loaded  by <tt class="literal">secondSession</tt> when the application tried to
                update it, an exception would have been thrown.
            </p><p>
                The application should individually <tt class="literal">Update()</tt> transient instances
                reachable from the given transient instance if and <span class="emphasis"><em>only</em></span> if it wants
                their state also updated. (Except for lifecycle objects, discussed later.)
            </p><p>
                NHibernate users have requested a general purpose method that either saves a
                transient instance by generating a new identifier or update the persistent
                state associated with its current identifier. The <tt class="literal">SaveOrUpdate()</tt>
                method now implements this functionality.
            </p><p>
                NHibernate distinguishes "new" (unsaved) instances from "existing" (saved or
                loaded in a previous session) instances by the value of their identifier
                (or version, or timestamp) property. The <tt class="literal">unsaved-value</tt>
                attribute of the <tt class="literal">&lt;id&gt;</tt> (or <tt class="literal">&lt;version&gt;</tt>,
                or <tt class="literal">&lt;timestamp&gt;</tt>) mapping specifies which values should
                be interpreted as representing a "new" instance.
            </p><pre class="programlisting">&lt;id name="Id" type="Int64" column="uid" unsaved-value="0"&gt;
    &lt;generator class="hilo"/&gt;
&lt;/id&gt;</pre><p>
                The allowed values of <tt class="literal">unsaved-value</tt> are:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">any</tt> - always save
                    </p></li><li><p>
                    <tt class="literal">none</tt> - always update
                    </p></li><li><p>
                    <tt class="literal">null</tt> - save when identifier is null
                    </p></li><li><p>
                    valid identifier value - save when identifier is null or the given value
                    </p></li><li><p>
                    <tt class="literal">undefined</tt> - if set for <tt class="literal">version</tt> or
                        <tt class="literal">timestamp</tt>, then identifier check is used
                    </p></li></ul></div><p>
                If <tt class="literal">unsaved-value</tt> is not specified for a class, NHibernate
                will attempt to guess it by creating an instance of the class using the no-argument
                constructor and reading the property value from the instance.
            </p><pre class="programlisting">// in the first session
Cat cat = firstSession.Load&lt;Cat&gt;(catID);

// in a higher tier of the application
Cat mate = new Cat();
cat.Mate = mate;

// later, in a new session
secondSession.SaveOrUpdate(cat);   // update existing state (cat has a non-null id)
secondSession.SaveOrUpdate(mate);  // save the new instance (mate has a null id)</pre><p>
                The usage and semantics of <tt class="literal">SaveOrUpdate()</tt> seems to be confusing
                for new users. Firstly, so long as you are not trying to use instances from one session
                in another new session, you should not need to use <tt class="literal">Update()</tt> or
                <tt class="literal">SaveOrUpdate()</tt>. Some whole applications will never use either of
                these methods.
            </p><p>
                Usually <tt class="literal">Update()</tt> or <tt class="literal">SaveOrUpdate()</tt> are used in
                the following scenario:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        the application loads an object in the first session
                    </p></li><li><p>
                        the object is passed up to the UI tier
                    </p></li><li><p>
                        some modifications are made to the object
                    </p></li><li><p>
                        the object is passed back down to the business logic tier
                    </p></li><li><p>
                        the application persists these modifications by calling
                        <tt class="literal">Update()</tt> in a second session
                    </p></li></ul></div><p>
                <tt class="literal">SaveOrUpdate()</tt> does the following:
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        if the object is already persistent in this session, do nothing
                    </p></li><li><p>
                        if the object has no identifier property, <tt class="literal">Save()</tt> it
                    </p></li><li><p>
                        if the object's identifier matches the criteria specified by
                        <tt class="literal">unsaved-value</tt>, <tt class="literal">Save()</tt> it
                    </p></li><li><p>
                        if the object is versioned (<tt class="literal">version</tt> or
                        <tt class="literal">timestamp</tt>), then the version will take precedence
                        to identifier check, unless the versions
                        <tt class="literal">unsaved-value="undefined"</tt> (default value)
                    </p></li><li><p>
                        if another object associated with the session has the same
                        identifier, throw an exception
                    </p></li></ul></div><p>
                The last case can be avoided by using <tt class="literal">Merge(Object o)</tt>. This method
                copies the state of the given object onto the persistent object with the same identifier. If
                there is no persistent instance currently associated with the session, it will be loaded.
                The method returns the persistent instance. If the given instance is unsaved or does not
                exist in the database, NHibernate will save it and return it as a newly persistent instance.
                Otherwise, the given instance  does not become associated with the session. In most
                applications with detached objects, you need both methods, <tt class="literal">SaveOrUpdate()</tt>
                and <tt class="literal">Merge()</tt>.
             </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-update-lock"></a>9.4.3.&nbsp;Reattaching detached objects</h3></div></div><div></div></div><p>
                The <tt class="literal">Lock()</tt> method allows the application to reassociate
                an unmodified object with a new session.
            </p><pre class="programlisting">//just reassociate:
sess.Lock(fritz, LockMode.None);
//do a version check, then reassociate:
sess.Lock(izi, LockMode.Read);
//do a version check, using SELECT ... FOR UPDATE, then reassociate:
sess.Lock(pk, LockMode.Upgrade);</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-deleting"></a>9.5.&nbsp;Deleting persistent objects</h2></div></div><div></div></div><p>
            <tt class="literal">ISession.Delete()</tt> will remove an object's state from the database. 
            Of course, your application might still hold a reference to it. So it's best to think 
            of <tt class="literal">Delete()</tt> as making a persistent instance transient.
        </p><pre class="programlisting">sess.Delete(cat);</pre><p>
            You may also delete many objects at once by passing a NHibernate query string to
            <tt class="literal">Delete()</tt>:.
        </p><pre class="programlisting">sess.Delete("from Cat");</pre><p>
            You may now delete objects in any order you like, without risk of foreign key
            constraint violations. Of course, it is still possible to violate a <tt class="literal">NOT
            NULL</tt> constraint on a foreign key column by deleting objects in
            the wrong order.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-flushing"></a>9.6.&nbsp;Flush</h2></div></div><div></div></div><p>
            From time to time the <tt class="literal">ISession</tt> will execute the SQL statements 
            needed to synchronize the ADO.NET connection's state with the state of objects held in 
            memory. This process, <span class="emphasis"><em>flush</em></span>, occurs by default at the following 
            points
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    from some invocations of <tt class="literal">Find()</tt> or <tt class="literal">Enumerable()</tt>
                </p></li><li><p>
                    from <tt class="literal">NHibernate.ITransaction.Commit()</tt>
                </p></li><li><p>
                    from <tt class="literal">ISession.Flush()</tt>
                </p></li></ul></div><p>
            The SQL statements are issued in the following order
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    all entity insertions, in the same order the corresponding objects
                    were saved using <tt class="literal">ISession.Save()</tt>
                </p></li><li><p>
                    all entity updates
                </p></li><li><p>
                    all collection deletions
                </p></li><li><p>
                    all collection element deletions, updates and insertions
                </p></li><li><p>
                    all collection insertions
                </p></li><li><p>
                    all entity deletions, in the same order the corresponding objects
                    were deleted using <tt class="literal">ISession.Delete()</tt>
                </p></li></ol></div><p>
            (An exception is that objects using <tt class="literal">native</tt> ID generation are 
            inserted when they are saved.)
        </p><p>
            Except when you explicity <tt class="literal">Flush()</tt>, there are absolutely no 
            guarantees about <span class="emphasis"><em>when</em></span> the <tt class="literal">Session</tt> executes 
            the ADO.NET calls, only the <span class="emphasis"><em>order</em></span> in which they are executed.
            However, NHibernate does guarantee that the <tt class="literal">ISession.CreateQuery(..)</tt> 
            methods will never return stale data; nor will they return the wrong data.
        </p><p>
            It is possible to change the default behavior so that flush occurs less frequently, either by code or by configuration.
            The <tt class="literal">FlushMode</tt> class defines three different modes:
            only flush at commit time (and only when the NHibernate <tt class="literal">ITransaction</tt>
          API is used), flush automatically using the explained routine (will only work inside an explicit NHibernate <tt class="literal">ITransaction</tt>), 
          or never flush unless
            <tt class="literal">Flush()</tt> is called explicitly. The last mode is useful for long
            running units of work, where an ISession is kept open and disconnected for a long time
            (see <a href="#transactions-optimistic" title="11.4.&nbsp;Optimistic concurrency control">Section&nbsp;11.4, &#8220;Optimistic concurrency control&#8221;</a>).
        </p><pre class="programlisting">sess = sf.OpenSession();
ITransaction tx = sess.BeginTransaction();
sess.FlushMode = FlushMode.Commit; //allow queries to return stale state
Cat izi = sess.Load&lt;Cat&gt;(id);
izi.Name = "iznizi";
// execute some queries....
sess.CreateQuery("from Cat as cat left outer join cat.Kittens kitten");
//change to izi is not flushed!
...
tx.Commit(); //flush occurs</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-endingsession"></a>9.7.&nbsp;Ending a Session</h2></div></div><div></div></div><p>
            Ending a session involves four distinct phases:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    flush the session
                </p></li><li><p>
                    commit the transaction
                </p></li><li><p>
                    close the session
                </p></li><li><p>
                    handle exceptions
                </p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-flushing"></a>9.7.1.&nbsp;Flushing the Session</h3></div></div><div></div></div><p>
                If you happen to be using the <tt class="literal">ITransaction</tt> API, you don't
                need to worry about this step. It will be performed implicitly when the 
                transaction is committed. Otherwise you should call 
                <tt class="literal">ISession.Flush()</tt> to ensure that all changes are synchronized
                with the database.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-commit"></a>9.7.2.&nbsp;Committing the database transaction</h3></div></div><div></div></div><p>
                If you are using the NHibernate <tt class="literal">ITransaction</tt> API, this looks like:
            </p><pre class="programlisting">tx.Commit(); // flush the session and commit the transaction</pre><p>
                If you are managing ADO.NET transactions yourself you should manually
                <tt class="literal">Commit()</tt> the ADO.NET transaction.
            </p><pre class="programlisting">sess.Flush();
currentTransaction.Commit();</pre><p>
                If you decide <span class="emphasis"><em>not</em></span> to commit your changes:
            </p><pre class="programlisting">tx.Rollback();  // rollback the transaction</pre><p>
                or:
            </p><pre class="programlisting">currentTransaction.Rollback();</pre><p>
                If you rollback the transaction you should immediately close and discard the current
                session to ensure that NHibernate's internal state is consistent.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="manipulatingdata-endingsession-close"></a>9.7.3.&nbsp;Closing the ISession</h3></div></div><div></div></div><p>
                A call to <tt class="literal">ISession.Close()</tt> marks the end of a session. The main implication
                of <tt class="literal">Close()</tt> is that the ADO.NET connection will be relinquished by the session.
            </p><pre class="programlisting">tx.Commit();
sess.Close();</pre><pre class="programlisting">sess.Flush();
currentTransaction.Commit();
sess.Close();</pre><p>
                If you provided your own connection, <tt class="literal">Close()</tt> returns a reference 
                to it, so you can manually close it or return it to the pool. Otherwise <tt class="literal">Close()
                </tt> returns it to the pool.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-exceptions"></a>9.8.&nbsp;Exception handling</h2></div></div><div></div></div><p>
            NHibernate use might lead to exceptions, usually <tt class="literal">HibernateException</tt>.
            This exception can have	a nested inner exception (the root cause), use the <tt class="literal">
            InnerException</tt> property to access it.
        </p><p>
            If the <tt class="literal">ISession</tt> throws an exception you should immediately
            rollback the transaction, call <tt class="literal">ISession.Close()</tt>
            and discard the <tt class="literal">ISession</tt> instance. Certain
            methods of <tt class="literal">ISession</tt> will <span class="emphasis"><em>not</em></span>
            leave the session in a consistent state.
        </p><p>
            For exceptions thrown by the data provider while interacting with the database,
            NHibernate will wrap the error in an instance of <tt class="literal">ADOException</tt>.
            The underlying exception is accessible by calling <tt class="literal">ADOException.InnerException</tt>.
            NHibernate converts the <tt class="literal">DbException</tt> into an appropriate <tt class="literal">ADOException</tt>
            subclass using the <tt class="literal">ISQLExceptionConverter</tt> attached to the <tt class="literal">SessionFactory</tt>.
            By default, the <tt class="literal">ISQLExceptionConverter</tt> is defined by the configured dialect; however, it is 
            also possible to plug in a custom implementation (see the api-docs for the ISQLExceptionConverter class for details).
        </p><p>
            The following exception handling idiom shows the typical case in NHibernate applications:
        </p><pre class="programlisting">using (ISession sess = factory.OpenSession())
using (ITransaction tx = sess.BeginTransaction())
{
    // do some work
    ...
    tx.Commit();
}</pre><p>
            Or, when manually managing ADO.NET transactions:
        </p><pre class="programlisting">ISession sess = factory.openSession();
try
{
    // do some work
    ...
    sess.Flush();
    currentTransaction.Commit();
}
catch (Exception e)
{
    currentTransaction.Rollback();
    throw;
}
finally
{
    sess.Close();
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-graphs"></a>9.9.&nbsp;Lifecyles and object graphs</h2></div></div><div></div></div><p>
            To save or update all objects in a graph of associated objects, you must either
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">Save()</tt>, <tt class="literal">SaveOrUpdate()</tt> or
                    <tt class="literal">Update()</tt> each individual object OR
                </p></li><li><p>
                    map associated objects using <tt class="literal">cascade="all"</tt> or
                    <tt class="literal">cascade="save-update"</tt>.
                </p></li></ul></div><p>
            Likewise, to delete all objects in a graph, either
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">Delete()</tt> each individual object OR
                </p></li><li><p>
                    map associated objects using <tt class="literal">cascade="all"</tt>,
                    <tt class="literal">cascade="all-delete-orphan"</tt> or
                    <tt class="literal">cascade="delete"</tt>.
                </p></li></ul></div><p>
            Recommendation:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    If the child object's lifespan is bounded by the lifespan of the of the parent
                    object make it a <span class="emphasis"><em>lifecycle object</em></span> by specifying
                    <tt class="literal">cascade="all"</tt>.
                </p></li><li><p>
                    Otherwise, <tt class="literal">Save()</tt> and <tt class="literal">Delete()</tt> it
                    explicitly from application code. If you really want to save yourself some
                    extra typing, use <tt class="literal">cascade="save-update"</tt> and explicit
                    <tt class="literal">Delete()</tt>.
                </p></li></ul></div><p>
            Mapping an association (many-to-one, one-to-one or collection) with <tt class="literal">cascade="all"</tt>
            marks the association as a <span class="emphasis"><em>parent/child</em></span> style relationship where
            save/update/deletion of the parent results in save/update/deletion of the child(ren).
            Futhermore, a mere reference to a child from a persistent parent will result in save / update
            of the child. The metaphor is incomplete, however. A child which becomes unreferenced by its
            parent is <span class="emphasis"><em>not</em></span> automatically deleted, except in the cases of 
            <tt class="literal">&lt;one-to-many&gt;</tt> and <tt class="literal">&lt;one-to-one&gt;</tt> associations 
            that have been mapped with <tt class="literal">cascade="all-delete-orphan"</tt> or 
            <tt class="literal">cascade="delete-orphan"</tt>. The precise semantics of cascading operations
            are as follows:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    If a parent is saved, all children are passed to <tt class="literal">SaveOrUpdate()</tt>
                </p></li><li><p>
                    If a parent is passed to <tt class="literal">Update()</tt> or <tt class="literal">SaveOrUpdate()</tt>,
                    all children are passed to <tt class="literal">SaveOrUpdate()</tt>
                </p></li><li><p>
                    If a transient child becomes referenced by a persistent parent, it is passed to
                    <tt class="literal">SaveOrUpdate()</tt>
                </p></li><li><p>
                    If a parent is deleted, all children are passed to <tt class="literal">Delete()</tt>
                </p></li><li><p>
                    If a transient child is dereferenced by a persistent parent, <span class="emphasis"><em>nothing
                    special happens</em></span> (the application should explicitly delete the child if
                    necessary) unless <tt class="literal">cascade="all-delete-orphan"</tt> or 
                    <tt class="literal">cascade="delete-orphan"</tt>, in which case the "orphaned" child is deleted.
                </p></li></ul></div><p>
            NHibernate does not fully implement "persistence by reachability", which would imply
            (inefficient) persistent garbage collection. However, due to popular demand,
            NHibernate does support the notion of entities becoming persistent when referenced
            by another persistent object. Associations marked
            <tt class="literal">cascade="save-update"</tt> behave in this way. If you wish to use this
            approach throughout your application, it's easier to specify the
            <tt class="literal">default-cascade</tt> attribute of the
            <tt class="literal">&lt;hibernate-mapping&gt;</tt> element.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-interceptors"></a>9.10.&nbsp;Interceptors</h2></div></div><div></div></div><p>
            The <tt class="literal">IInterceptor</tt> interface provides callbacks from the session to the 
            application allowing the application to inspect and / or manipulate properties of a 
            persistent object before it is saved, updated, deleted or loaded. One 
            possible use for this is to track auditing information. For example, the following 
            <tt class="literal">IInterceptor</tt> automatically sets the  <tt class="literal">CreateTimestamp</tt> 
            when an <tt class="literal">IAuditable</tt> is created and updates the 
            <tt class="literal">LastUpdateTimestamp</tt> property when an <tt class="literal">IAuditable</tt> is 
            updated.
        </p><pre class="programlisting">using System;
using NHibernate.Type;

namespace NHibernate.Test
{
    [Serializable]
    public class AuditInterceptor : IInterceptor
    {
    
        private int updates;
        private int creates;
    
        public void OnDelete(object entity,
                             object id,
                             object[] state,
                             string[] propertyNames,
                             IType[] types)
        {
            // do nothing
        }
    
        public boolean OnFlushDirty(object entity, 
                                    object id, 
                                    object[] currentState,
                                    object[] previousState,
                                    string[] propertyNames,
                                    IType[] types) {
    
            if ( entity is IAuditable )
            {
                updates++;
                for ( int i=0; i &lt; propertyNames.Length; i++ )
                {
                    if ( "LastUpdateTimestamp" == propertyNames[i] )
                    {
                        currentState[i] = DateTime.Now;
                        return true;
                    }
                }
            }
            return false;
        }
    
        public boolean OnLoad(object entity, 
                              object id,
                              object[] state,
                              string[] propertyNames,
                              IType[] types)
        {
            return false;
        }
    
        public boolean OnSave(object entity,
                              object id,
                              object[] state,
                              string[] propertyNames,
                              IType[] types)
        {
            if ( entity is IAuditable )
            {
                creates++;
                for ( int i=0; i&lt;propertyNames.Length; i++ )
                {
                    if ( "CreateTimestamp" == propertyNames[i] )
                    {
                        state[i] = DateTime.Now;
                        return true;
                    }
                }
            }
            return false;
        }
    
        public void PostFlush(ICollection entities)
        {
            Console.Out.WriteLine("Creations: {0}, Updates: {1}", creates, updates);
        }
    
        public void PreFlush(ICollection entities) {
            updates=0;
            creates=0;
        }
        
        ......
        ......
    }
}</pre><p>
            The interceptor would be specified when a session is created.
        </p><pre class="programlisting">ISession session = sf.OpenSession( new AuditInterceptor() );</pre><p>
            You may also set an interceptor on a global level, using the <tt class="literal">Configuration</tt>:
        </p><pre class="programlisting">new Configuration().SetInterceptor( new AuditInterceptor() );</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manipulatingdata-metadata"></a>9.11.&nbsp;Metadata API</h2></div></div><div></div></div><p>
            NHibernate requires a very rich meta-level model of all entity and value types. From time
            to time, this model is very useful to the application itself. For example, the application
            might use NHibernate's metadata to implement a "smart" deep-copy algorithm that understands
            which objects should be copied (eg. mutable value types) and which should not (eg. 
            immutable value types and, possibly, associated entities).
        </p><p>
            NHibernate exposes metadata via the <tt class="literal">IClassMetadata</tt> and
            <tt class="literal">ICollectionMetadata</tt> interfaces and the <tt class="literal">IType</tt>
            hierarchy. Instances of the metadata interfaces may be obtained from the 
            <tt class="literal">ISessionFactory</tt>.
        </p><pre class="programlisting">Cat fritz = ......;
IClassMetadata catMeta = sessionfactory.GetClassMetadata(typeof(Cat));
long id = (long) catMeta.GetIdentifier(fritz);
object[] propertyValues = catMeta.GetPropertyValues(fritz);
string[] propertyNames = catMeta.PropertyNames;
IType[] propertyTypes = catMeta.PropertyTypes;

// get an IDictionary of all properties which are not collections or associations
// TODO: what about components?

IDictionary namedValues = new Hashtable();
for ( int i=0; i&lt;propertyNames.Length; i++ )
{
    if ( !propertyTypes[i].IsEntityType &amp;&amp; !propertyTypes[i].IsCollectionType )
	{
        namedValues[ propertyNames[i] ] = propertyValues[i];
    }
}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="readonly"></a>Chapter&nbsp;10.&nbsp;Read-only entities</h2></div></div><div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
            NHibernate's treatment of <span class="emphasis"><em>read-only</em></span> entities may 
            differ from what you may have encountered elsewhere. Incorrect usage 
            may cause unexpected results.
        </p></div><p>
        When an entity is read-only:

        </p><div class="itemizedlist"><ul type="disc"><li><p> 
                    NHibernate does not dirty-check the entity's simple 
                    properties or single-ended associations;
                </p></li><li><p> 
                    NHibernate will not update simple properties or updatable
                    single-ended associations; 
                </p></li><li><p> 
                    NHibernate will not update the version of the read-only 
                    entity if only simple properties or single-ended 
                    updatable associations are changed;
                </p></li></ul></div><p>
    </p><p>
        In some ways, NHibernate treats read-only entities the same as entities that are 
        not read-only:
 
        </p><div class="itemizedlist"><ul type="disc"><li><p> 
                    NHibernate cascades operations to associations as
                    defined in the entity mapping.
                </p></li><li><p> 
                    NHibernate updates the version if the entity has a 
                    collection with changes that dirties the entity;
                </p></li><li><p> 
                    A read-only entity can be deleted.
                </p></li></ul></div><p>
    </p><p>
        Even if an entity is not read-only, its collection association can 
        be affected if it contains a read-only entity.
    </p><p>
        For details about the affect of read-only entities on different
        property and association types, see 
        <a href="#readonly-proptypes" title="10.2.&nbsp;Read-only affect on property type">Section&nbsp;10.2, &#8220;Read-only affect on property type&#8221;</a>.
    </p><p>     
        For details about how to make entities read-only, see 
        <a href="#readonly-api" title="10.1.&nbsp;Making persistent entities read-only">Section&nbsp;10.1, &#8220;Making persistent entities read-only&#8221;</a>
    </p><p>
        NHibernate does some optimizing for read-only entities:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
                    It saves execution time by not dirty-checking simple properties or 
                    single-ended associations.
                 </p></li><li><p>
                    It saves memory by deleting database snapshots.
                </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="readonly-api"></a>10.1.&nbsp;Making persistent entities read-only</h2></div></div><div></div></div><p>
            Only persistent entities can be made read-only. Transient and
            detached entities must be put in persistent state before they
            can be made read-only.
        </p><p>
            NHibernate provides the following ways to make persistent entities read-only:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    you can map an entity class as <span class="emphasis"><em>immutable</em></span>;
                    when an entity of an immutable class is made persistent,
                    NHibernate automatically makes it read-only.
                    see <a href="#readonly-api-immutable" title="10.1.1.&nbsp;Entities of immutable classes">Section&nbsp;10.1.1, &#8220;Entities of immutable classes&#8221;</a> for details 
                </p></li><li><p>
                    you can change a default so that entities loaded
                    into the session by NHibernate are automatically 
                    made read-only; see <a href="#readonly-api-loaddefault" title="10.1.2.&nbsp;Loading persistent entities as read-only">Section&nbsp;10.1.2, &#8220;Loading persistent entities as read-only&#8221;</a> for details
                </p></li><li><p>
                    you can make an HQL query or criteria read-only so
                    that entities loaded when the query or criteria executes,
                    or iterates, are automatically 
                    made read-only; see <a href="#readonly-api-querycriteria" title="10.1.3.&nbsp;Loading read-only entities from an HQL query/criteria">Section&nbsp;10.1.3, &#8220;Loading read-only entities from an HQL query/criteria&#8221;</a> for details
                </p></li><li><p>
                    you can make a persistent entity that is already in the
                    in the session read-only; see 
                    <a href="#readonly-api-entity" title="10.1.4.&nbsp;Making a persistent entity read-only">Section&nbsp;10.1.4, &#8220;Making a persistent entity read-only&#8221;</a> for details
                </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="readonly-api-immutable"></a>10.1.1.&nbsp;Entities of immutable classes</h3></div></div><div></div></div><p>
                When an entity instance of an immutable class is made 
                persistent, NHibernate automatically makes it read-only. 
            </p><p>
                An entity of an immutable class can created
                and deleted the same as an entity of a mutable class.
            </p><p>
                NHibernate treats a persistent entity of an immutable 
                class the same way as a read-only persistent entity
                of a mutable class. The only exception is that 
                NHibernate will not allow an entity of an immutable
                class to be changed so it is not read-only.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="readonly-api-loaddefault"></a>10.1.2.&nbsp;Loading persistent entities as read-only</h3></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Entities of immutable classes are automatically loaded
                    as read-only.
                </p></div><p>
                To change the default behavior so NHibernate loads entity 
                instances of mutable classes into the session and automatically 
                makes them read-only, call:
            </p><pre class="programlisting">Session.DefaultReadOnly = true;</pre><p>
                To change the default back so entities loaded by NHibernate are not
                made read-only, call:
            </p><pre class="programlisting">Session.DefaultReadOnly = false;</pre><p>
                You can determine the current setting by using the property:
            </p><pre class="programlisting">Session.DefaultReadOnly;</pre><p> 
                If <tt class="literal">Session.DefaultReadOnly</tt> property returns true, entities loaded by 
                the following are automatically made read-only:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">Session.Load()</tt> and <tt class="literal">Session.Load&lt;T&gt;</tt>
                    </p></li><li><p>
                        <tt class="literal">Session.Get()</tt> and <tt class="literal">Session.Get&lt;T&gt;</tt>
                    </p></li><li><p>
                        <tt class="literal">Session.Merge()</tt>
                    </p></li><li><p>
                        executing, or iterating HQL queries and 
                        criteria; to override this setting for a particular
                        HQL query or criteria see 
                        <a href="#readonly-api-querycriteria" title="10.1.3.&nbsp;Loading read-only entities from an HQL query/criteria">Section&nbsp;10.1.3, &#8220;Loading read-only entities from an HQL query/criteria&#8221;</a> 
                    </p></li></ul></div><p>
                Changing this default has no effect on:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        persistent entities already in the session when the 
                        default was changed
                    </p></li><li><p>
                        persistent entities that are refreshed via
                        <tt class="literal">Session.Refresh()</tt>; a refreshed persistent 
                        entity will only be read-only if it was 
                        read-only before refreshing
                    </p></li><li><p>
                        persistent entities added by the application via 
                        <tt class="literal">Session.Persist()</tt>, <tt class="literal">Session.Save()</tt>, and <tt class="literal">Session.Update()</tt>
                        <tt class="literal">Session.SaveOrUpdate()</tt>
                    </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="readonly-api-querycriteria"></a>10.1.3.&nbsp;Loading read-only entities from an HQL query/criteria</h3></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Entities of immutable classes are automatically loaded
                    as read-only.
                </p></div><p>
                If Session.DefaultReadOnly returns false (the default) 
                when an HQL query or criteria executes, then entities 
                and proxies of mutable classes loaded by the query will 
                not be read-only.
            </p><p>
                You can override this behavior so that entities and proxies loaded 
                by an HQL query or criteria are automatically made read-only. 
            </p><p>
                For an HQL query, call:
            </p><pre class="programlisting">Query.SetReadOnly(true);</pre><p>
                <tt class="literal">Query.SetReadOnly(true)</tt> must be called before
                <tt class="literal">Query.List()</tt>, <tt class="literal">Query.UniqueResult()</tt>, or <tt class="literal">Query.Iterate()</tt>
            </p><p>
                For an HQL criteria, call:
            </p><pre class="programlisting">Criteria.SetReadOnly(true);</pre><p>
                <tt class="literal">Criteria.SetReadOnly(true)</tt> must be called before
                <tt class="literal">Criteria.List()</tt>, or <tt class="literal">Criteria.UniqueResult()</tt>
            </p><p>
                Entities and proxies that exist in the session before being returned
                by an HQL query or criteria are not affected.
            </p><p>
                Uninitialized persistent collections returned by the query are 
                not affected. Later, when the collection is initialized,
                entities loaded into the session will be read-only if 
                Session.DefaultReadOnly returns true.   
            </p><p>
                Using <tt class="literal">Query.SetReadOnly(true)</tt> or
                <tt class="literal">Criteria.SetReadOnly(true)</tt> works well
                when a single HQL query or criteria loads all the entities and 
                intializes all the proxies and collections that the application
                needs to be read-only.
            </p><p>
                When it is not possible to load and initialize all 
                necessary entities in a single query or criteria,
                you can temporarily change the session default to load
                entities as read-only before the query is executed.
                Then you can explicitly initialize proxies and collections 
                before restoring the session default.
            </p><pre class="programlisting">
ISession session = factory.OpenSession();
ITransaction tx = session.BeginTransaction();
 
session.DefaultReadOnly = true;
Contract contract = session.CreateQuery("from Contract where CustomerName = 'Sherman'").UniqueResult&lt;Contract&gt;();
NHibernate.Initialize(contract.Plan);
NHibernate.Initialize(contract.Variations);
NHibernate.Initialize(contract.Notes);
session.DefaultReadOnly = false;
...
tx.Commit();
session.Close();

</pre><p>
                If Session.DefaultReadOnly returns true, then you can
                use Query.SetReadOnly(false) and Criteria.SetReadOnly(false)
                to override this session setting and load entities that are 
                not read-only.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="readonly-api-entity"></a>10.1.4.&nbsp;Making a persistent entity read-only</h3></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Persistent entities of immutable classes are automatically
                    made read-only.
                </p></div><p>
                To make a persistent entity or proxy read-only, call:
            </p><pre class="programlisting">Session.SetReadOnly(entityOrProxy, true)</pre><p>
                To change a read-only entity or proxy of a mutable class so 
                it is no longer read-only, call:
            </p><pre class="programlisting">Session.SetReadOnly(entityOrProxy, false)</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                    When a read-only entity or proxy is changed so it is no longer 
                    read-only, NHibernate assumes that the current state of the 
                    read-only entity is consistent with its database representation. 
                    If this is not true, then any non-flushed changes made before
                    or while the entity was read-only, will be ignored.
                </p></div><p>        
                To throw away non-flushed changes and make the persistent entity 
                consistent with its database representation, call:
			</p><pre class="programlisting">Session.Refresh(entity);</pre><p>
                To flush changes made before or while the entity
                was read-only and make the database representation 
                consistent with the current state of the persistent
                entity:
            </p><pre class="programlisting">
// evict the read-only entity so it is detached
session.Evict(entity);

// make the detached entity (with the non-flushed changes) persistent
session.Update(entity);

// now entity is no longer read-only and its changes can be flushed
s.Flush();
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="readonly-proptypes"></a>10.2.&nbsp;Read-only affect on property type</h2></div></div><div></div></div><p>
            The following table summarizes how different property types are 
            affected by making an entity read-only.
        </p><div class="table"><a name="readonly-proptype-summary"></a><p class="title"><b>Table&nbsp;10.1.&nbsp;Affect of read-only entity on property types</b></p><table summary="Affect of read-only entity on property types" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property/Association Type</th><th>Changes flushed to DB?</th></tr></thead><tbody><tr><td>
                            Simple
                            <p>
                                (<a href="#readonly-proptypes-simple" title="10.2.1.&nbsp;Simple properties">Section&nbsp;10.2.1, &#8220;Simple properties&#8221;</a>)
                            </p></td><td>no*</td></tr><tr><td><p>Unidirectional one-to-one</p><p>Unidirectional many-to-one</p><p>
                                (<a href="#readonly-proptypes-singleended-unidir" title="10.2.2.1.&nbsp;Unidirectional one-to-one and many-to-one">Section&nbsp;10.2.2.1, &#8220;Unidirectional one-to-one and many-to-one&#8221;</a>)
                            </p></td><td><p>no*</p><p>no*</p></td></tr><tr><td><p>Unidirectional one-to-many</p><p>Unidirectional many-to-many</p><p>
                                (<a href="#readonly-proptypes-manyended-unidir" title="10.2.2.2.&nbsp;Unidirectional one-to-many and many-to-many">Section&nbsp;10.2.2.2, &#8220;Unidirectional one-to-many and many-to-many&#8221;</a>)
                            </p></td><td><p>yes</p><p>yes</p></td></tr><tr><td><p>Bidirectional one-to-one</p><p>
                                (<a href="#readonly-proptypes-onetoone-bidir" title="10.2.3.1.&nbsp;Bidirectional one-to-one">Section&nbsp;10.2.3.1, &#8220;Bidirectional one-to-one&#8221;</a>)
                            </p></td><td>only if the owning entity is not read-only*</td></tr><tr><td><p>Bidirectional one-to-many/many-to-one</p><p>inverse collection</p><p>non-inverse collection</p><p>
                                (<a href="#readonly-proptypes-onetomany-manytoone" title="10.2.3.2.&nbsp;Bidirectional one-to-many/many-to-one">Section&nbsp;10.2.3.2, &#8220;Bidirectional one-to-many/many-to-one&#8221;</a>)
                            </p></td><td><p> </p><p>only added/removed entities that are not read-only*</p><p>yes</p></td></tr><tr><td><p>Bidirectional many-to-many</p><p>
                                (<a href="#readonly-proptypes-manytomany-bidir" title="10.2.3.3.&nbsp;Bidirectional many-to-many">Section&nbsp;10.2.3.3, &#8220;Bidirectional many-to-many&#8221;</a>)
                            </p></td><td>yes</td></tr></tbody></table></div><p>
            * Behavior is different when the entity having the property/association
              is read-only, compared to when it is not read-only.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="readonly-proptypes-simple"></a>10.2.1.&nbsp;Simple properties</h3></div></div><div></div></div><p>
                When a persistent object is read-only, NHibernate does not 
                dirty-check simple properties.
            </p><p>
                NHibernate will not synchronize simple property state changes 
                to the database. If you have automatic versioning, NHibernate 
                will not increment the version if any simple properties change.
            </p><pre class="programlisting">
ISession session = factory.OpenSession();
ITransaction tx = session.BeginTransaction();

// get a contract and make it read-only
Contract contract = session.Get&lt;Contract&gt;(contractId);
session.SetReadOnly(contract, true);

// contract.CustomerName is "Sherman"
contract.CustomerName = "Yogi";
tx.Commit();

tx = session.BeginTransaction();

contract = session.Get&lt;Contract&gt;(contractId);
// contract.CustomerName is still "Sherman"
...
tx.Commit();
session.Close();
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="readonly-prop-types-unidir"></a>10.2.2.&nbsp;Unidirectional associations</h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="readonly-proptypes-singleended-unidir"></a>10.2.2.1.&nbsp;Unidirectional one-to-one and many-to-one</h4></div></div><div></div></div><p>
                    NHibernate treats unidirectional one-to-one and many-to-one
                    associations in the same way when the owning entity is 
                    read-only. 
                </p><p>
                    We use the term <span class="emphasis"><em>unidirectional single-ended 
                    association</em></span> when referring to functionality
                    that is common to unidirectional one-to-one and many-to-one
                    associations.
                </p><p>
                    NHibernate does not dirty-check unidirectional single-ended
                    associations when the owning entity is read-only. 
                </p><p>
                    If you change a read-only entity's reference to a 
                    unidirectional single-ended association to null,
                    or to refer to a different entity, that change
                    will not be flushed to the database. 
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        If an entity is of an immutable class,
                        then its references to unidirectional single-ended
                        associations must be assigned when that 
                        entity is first created. Because the entity is
                        automatically made read-only, these references can
                        not be updated.
                    </p></div><p>
                    If automatic versioning is used, NHibernate will not 
                    increment the version due to local changes to 
                    unidirectional single-ended associations.
                </p><p>
                    In the following examples, Contract has a unidirectional 
                    many-to-one association with Plan. Contract cascades save and
                    update operations to the association.
                </p><p>
                    The following shows that changing a read-only entity's 
                    many-to-one association reference to null has no effect
                    on the entity's database representation.
                </p><pre class="programlisting">// get a contract with an existing plan;
// make the contract read-only and set its plan to null 
tx = session.BeginTransaction();
Contract contract = session.Get&lt;Contract&gt;(contractId);
session.SetReadOnly(contract, true);
contract.Plan = null;
tx.Commit();

// get the same contract
tx = session.BeginTransaction();
Contract contract = session.Get&lt;Contract&gt;(contractId);

// contract.Plan still refers to the original plan;

tx.Commit();
session.Close();</pre><p>
                    The following shows that, even though
                    an update to a read-only entity's many-to-one 
                    association has no affect on the entity's 
                    database representation, flush still cascades 
                    the save-update operation to the locally
                    changed association.
                </p><pre class="programlisting">// get a contract with an existing plan;
// make the contract read-only and change to a new plan
tx = session.BeginTransaction();
Contract contract = session.Get&lt;Contract&gt;(contractId);
session.SetReadOnly(contract, true);
Plan newPlan = new Plan("new plan");
contract.Plan = newPlan;
tx.Commit();

// get the same contract
tx = session.BeginTransaction();
contract = session.Get&lt;Contract&gt;(contractId);
newPlan = session.Get&lt;Plan&gt;(newPlan.Id);

// contract.Plan still refers to the original plan;
// newPlan is non-null because it was persisted when 
// the previous transaction was committed; 

tx.Commit();
session.Close();</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="readonly-proptypes-manyended-unidir"></a>10.2.2.2.&nbsp;Unidirectional one-to-many and many-to-many</h4></div></div><div></div></div><p>
                    NHibernate treats unidirectional one-to-many 
                    and many-to-many associations owned by a read-only
                    entity the same as when owned by an entity that is not 
                    read-only.
                </p><p>
                    NHibernate dirty-checks unidirectional one-to-many and 
                    many-to-many associations;
                </p><p>
                    The collection can contain entities that 
                    are read-only, as well as entities
                    that are not read-only.
                </p><p> 
                    Entities can be added and removed from the
                    collection; changes are flushed to the database.
                </p><p> 
                    If automatic versioning is used, NHibernate will 
                    update the version due to changes in the collection
                    if they dirty the owning entity.
                </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="readonly-proptypes-bidir"></a>10.2.3.&nbsp;Bidirectional associations</h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="readonly-proptypes-onetoone-bidir"></a>10.2.3.1.&nbsp;Bidirectional one-to-one</h4></div></div><div></div></div><p>
                    If a read-only entity owns a bidirectional 
                    one-to-one association:
                </p><div class="itemizedlist"><ul type="disc"><li><p>
                            NHibernate does not dirty-check the association. 
                        </p></li><li><p>
                            updates that change the association reference 
                            to null or to refer to a different entity
                            will not be flushed to the database. 
                        </p></li><li><p>
                            If automatic versioning is used, NHibernate will not 
                            increment the version due to local changes to 
                            the association.
                       </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        If an entity is of an immutable class,
                        and it owns a bidirectional one-to-one
                        association, then its reference must be
                        assigned when that entity is first created. 
                        Because the entity is automatically made 
                        read-only, these references cannot be updated.
                    </p></div><p>
                    When the owner is not read-only, NHibernate treats 
                    an association with a read-only entity the same
                    as when the association is with an entity that is
                    not read-only.
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="readonly-proptypes-onetomany-manytoone"></a>10.2.3.2.&nbsp;Bidirectional one-to-many/many-to-one</h4></div></div><div></div></div><p>
                    A read-only entity has no impact on a bidirectional
                    one-to-many/many-to-one association if:
                </p><div class="itemizedlist"><ul type="disc"><li><p>
                            the read-only entity is on the one-to-many side
                            using an inverse collection;
                        </p></li><li><p>
                            the read-only entity is on the one-to-many side
                            using a non-inverse collection;                            
                        </p></li><li><p>
                            the one-to-many side uses a non-inverse collection 
                            that contains the read-only entity
                       </p></li></ul></div><p>
                    When the one-to-many side uses an inverse collection:
                </p><div class="itemizedlist"><ul type="disc"><li><p>
                            a read-only entity can only be added to the collection
                            when it is created;
                        </p></li><li><p>
                            a read-only entity can only be removed from the
                            collection by an orphan delete or by explicitly
                            deleting the entity.                            
                        </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="readonly-proptypes-manytomany-bidir"></a>10.2.3.3.&nbsp;Bidirectional many-to-many</h4></div></div><div></div></div><p>
                    NHibernate treats bidirectional many-to-many 
                    associations owned by a read-only entity the
                    same as when owned by an entity that is not
                    read-only.
                </p><p>
                    NHibernate dirty-checks bidirectional many-to-many 
                    associations.
                </p><p> 
                    The collection on either side of the association
                    can contain entities that are read-only, as well
                    as entities that are not read-only.
                </p><p> 
                    Entities are added and removed from both sides 
                    of the collection; changes are flushed to the 
                    database.
                </p><p> 
                    If automatic versioning is used, NHibernate will 
                    update the version due to changes in both sides of
                    the collection if they dirty the entity owning the
                    respective collections.
                </p></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="transactions"></a>Chapter&nbsp;11.&nbsp;Transactions And Concurrency</h2></div></div><div></div></div><p>
        NHibernate is not itself a database. It is a lightweight object-relational
        mapping tool. Transaction management is delegated to the underlying database
        connection. If the connection is enlisted with a distributed transaction,
        operations performed by the <tt class="literal">ISession</tt> are atomically part
        of the wider distributed transaction. NHibernate can be seen as a thin adapter
        to ADO.NET, adding object-oriented semantics.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-basics"></a>11.1.&nbsp;Configurations, Sessions and Factories</h2></div></div><div></div></div><p>
            An <tt class="literal">ISessionFactory</tt> is an expensive-to-create, threadsafe object 
            intended to be shared by all application threads. An <tt class="literal">ISession</tt> 
            is an inexpensive, non-threadsafe object that should be used once, for a single
            business process, and then discarded. For example, when using NHibernate in an
            ASP.NET application, pages could obtain an <tt class="literal">ISessionFactory</tt> 
            using:
        </p><pre class="programlisting">ISessionFactory sf = Global.SessionFactory;</pre><p>
            Each call to a service method could create a new <tt class="literal">ISession</tt>,
            <tt class="literal">Flush()</tt> it, <tt class="literal">Commit()</tt> its transaction,
            <tt class="literal">Close()</tt> it and finally discard it. (The <tt class="literal">ISessionFactory</tt>
            may also be kept in  a static <span class="emphasis"><em>Singleton</em></span> helper variable.)
        </p><p>
            We use the NHibernate <tt class="literal">ITransaction</tt> API as discussed previously,
            a single <tt class="literal">Commit()</tt> of a NHibernate <tt class="literal">ITransaction</tt>
            flushes the state and commits any underlying database connection (with special
            handling of distributed transactions).
        </p><p>
            Ensure you understand the semantics of <tt class="literal">Flush()</tt>.
            Flushing synchronizes the persistent store with in-memory changes but
            <span class="emphasis"><em>not</em></span> vice-versa. Note that for all NHibernate ADO.NET
            connections/transactions, the transaction isolation level for that connection
            applies to all operations executed by NHibernate!
        </p><p>
            The next few sections will discuss alternative approaches that utilize versioning
            to ensure transaction atomicity. These are considered "advanced" approaches to
            be used with care.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-threads"></a>11.2.&nbsp;Threads and connections</h2></div></div><div></div></div><p>
            You should observe the following practices when creating NHibernate Sessions:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Never create more than one concurrent <tt class="literal">ISession</tt> or
                    <tt class="literal">ITransaction</tt> instance per database connection.
                </p></li><li><p>
                    Be extremely careful when creating more than one <tt class="literal">ISession</tt>
                    per database per transaction. The <tt class="literal">ISession</tt> itself keeps
                    track of updates made to loaded objects, so a different <tt class="literal">ISession</tt>
                    might see stale data.
                </p></li><li><p>
                    The <tt class="literal">ISession</tt> is <span class="emphasis"><em>not</em></span> threadsafe!
                    Never access the same <tt class="literal">ISession</tt> in two concurrent threads.
                    An <tt class="literal">ISession</tt> is usually only a single unit-of-work!
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-identity"></a>11.3.&nbsp;Considering object identity</h2></div></div><div></div></div><p>
            The application may concurrently access the same persistent state in two
            different units-of-work. However, an instance of a persistent class is never shared
            between two <tt class="literal">ISession</tt> instances. Hence there are
            two different notions of identity:
        </p><div class="variablelist"><dl><dt><span class="term">Database Identity</span></dt><dd><p>
                        <tt class="literal">foo.Id.Equals( bar.Id )</tt>
                    </p></dd><dt><span class="term">CLR Identity</span></dt><dd><p>
                        <tt class="literal">foo == bar</tt>
                    </p></dd></dl></div><p>
            Then for objects attached to a <span class="emphasis"><em>particular</em></span> <tt class="literal">Session</tt>,
            the two notions are equivalent. However, while the application might concurrently access
            the "same" (persistent identity) business object in two different sessions, the two
            instances will actually be "different" (CLR identity).
        </p><p>
            This approach leaves NHibernate and the database to worry about concurrency. The
            application never needs to synchronize on any business object, as long as it sticks to a
            single thread per <tt class="literal">ISession</tt> or object identity (within an
            <tt class="literal">ISession</tt> the application may safely use <tt class="literal">==</tt> to
            compare objects).
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-optimistic"></a>11.4.&nbsp;Optimistic concurrency control</h2></div></div><div></div></div><p>
            Many business processes require a whole series of interactions with the user
            interleaved with database accesses. In web and enterprise applications it is
            not acceptable for a database transaction to span a user interaction.
        </p><p>
            Maintaining isolation of business processes becomes the partial responsibility
            of the application tier, hence we call this process a long running
            <span class="emphasis"><em>application transaction</em></span>. A single application transaction
            usually spans several database transactions. It will be atomic if only one of
            these database transactions (the last one) stores the updated data, all others
            simply read data.
        </p><p>
            The only approach that is consistent with high concurrency and high
            scalability is optimistic concurrency control with versioning. NHibernate
            provides for three possible approaches to writing application code that
            uses optimistic concurrency.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-longsession"></a>11.4.1.&nbsp;Long session with automatic versioning</h3></div></div><div></div></div><p>
                A single <tt class="literal">ISession</tt> instance and its persistent instances are
                used for the whole application transaction.
            </p><p>
                The <tt class="literal">ISession</tt> uses optimistic locking with versioning to
                ensure that many database transactions appear to the application as a single
                logical application transaction. The <tt class="literal">ISession</tt> is disconnected
                from any underlying ADO.NET connection when waiting for user interaction. This
                approach is the most efficient in terms of database access. The application
                need not concern itself with version checking or with reattaching detached
                instances.
            </p><pre class="programlisting">// foo is an instance loaded earlier by the Session
session.Reconnect();
transaction = session.BeginTransaction();
foo.Property = "bar";
session.Flush();
transaction.Commit();
session.Disconnect();</pre><p>
                The <tt class="literal">foo</tt> object still knows which <tt class="literal">ISession</tt>
                it was loaded it. As soon as the <tt class="literal">ISession</tt> has an ADO.NET connection,
                we commit the changes to the object.
            </p><p>
                This pattern is problematic if our <tt class="literal">ISession</tt> is too big to
                be stored during user think time, e.g. an <tt class="literal">HttpSession</tt> should
                be kept as small as possible. As the <tt class="literal">ISession</tt> is also the
                (mandatory) first-level cache and contains all loaded objects, we can propably
                use this strategy only for a few request/response cycles. This is indeed
                recommended, as the <tt class="literal">ISession</tt> will soon also have stale data.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-detached"></a>11.4.2.&nbsp;Many sessions with automatic versioning</h3></div></div><div></div></div><p>
                Each interaction with the persistent store occurs in a new <tt class="literal">ISession</tt>. 
                However, the same persistent instances are reused for each interaction with the database.
                The application manipulates the state of detached instances originally loaded in another
                <tt class="literal">ISession</tt> and then "reassociates" them using 
                <tt class="literal">ISession.Update()</tt> or <tt class="literal">ISession.SaveOrUpdate()</tt>.
            </p><pre class="programlisting">// foo is an instance loaded by a previous Session
foo.Property = "bar";
session = factory.OpenSession();
transaction = session.BeginTransaction();
session.SaveOrUpdate(foo);
session.Flush();
transaction.Commit();
session.Close();</pre><p>
                You may also call <tt class="literal">Lock()</tt> instead of <tt class="literal">Update()</tt>
                and use <tt class="literal">LockMode.Read</tt> (performing a version check, bypassing all
                caches) if you are sure that the object has not been modified.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-customizing"></a>11.4.3.&nbsp;Customizing automatic versioning</h3></div></div><div></div></div><p>
                You may disable NHibernate's automatic version increment for particular properties and 
                collections by setting the <tt class="literal">optimistic-lock</tt> mapping attribute to 
                <tt class="literal">false</tt>. NHibernate will then no longer increment versions if the 
                property is dirty.
            </p><p>
                Legacy database schemas are often static and can't be modified. Or, other applications
                might also access the same database and don't know how to handle version numbers or
                even timestamps. In both cases, versioning can't rely on a particular column in a table.
                To force a version check without a version or timestamp property mapping, with a
                comparison of the state of all fields in a row, turn on <tt class="literal">optimistic-lock="all"</tt>
                in the <tt class="literal">&lt;class&gt;</tt> mapping. Note that this concepetually only works
                if NHibernate can compare the old and new state, i.e. if you use a single long
                <tt class="literal">ISession</tt> and not session-per-request-with-detached-objects.
            </p><p>
                Sometimes concurrent modification can be permitted as long as the changes that have been
                made don't overlap. If you set <tt class="literal">optimistic-lock="dirty"</tt> when mapping the
                <tt class="literal">&lt;class&gt;</tt>, NHibernate will only compare dirty fields during flush.
            </p><p>
                In both cases, with dedicated version/timestamp columns or with full/dirty field
                comparison, NHibernate uses a single <tt class="literal">UPDATE</tt> statement (with an
                appropriate <tt class="literal">WHERE</tt> clause) per entity to execute the version check
                and update the information. If you use transitive persistence to cascade reattachment
                to associated entities, NHibernate might execute uneccessary updates. This is usually
                not a problem, but <span class="emphasis"><em>on update</em></span> triggers in the database might be
                executed even when no changes have been made to detached instances. You can customize
                this behavior by setting  <tt class="literal">select-before-update="true"</tt> in the
                <tt class="literal">&lt;class&gt;</tt> mapping, forcing NHibernate to <tt class="literal">SELECT</tt>
                the instance to ensure that changes did actually occur, before updating the row.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions-optimistic-manual"></a>11.4.4.&nbsp;Application version checking</h3></div></div><div></div></div><p>
                Each interaction with the database occurs in a new <tt class="literal">ISession</tt>
                that reloads all persistent instances from the database before manipulating them.
                This approach forces the application to carry out its own version checking to ensure 
                application transaction isolation. (Of course, NHibernate will still <span class="emphasis"><em>update</em></span>
                version numbers for you.) This approach is the least efficient in terms of database access.
            </p><pre class="programlisting">// foo is an instance loaded by a previous Session
session = factory.OpenSession();
transaction = session.BeginTransaction();
int oldVersion = foo.Version;
session.Load( foo, foo.Key );
if ( oldVersion != foo.Version ) throw new StaleObjectStateException();
foo.Property = "bar";
session.Flush();
transaction.Commit();
session.close();</pre><p>
                Of course, if you are operating in a low-data-concurrency environment and don't
                require version checking, you may use this approach and just skip the version
                check.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-disconnection"></a>11.5.&nbsp;Session disconnection</h2></div></div><div></div></div><p>
            The first approach described above is to maintain a single <tt class="literal">ISession</tt> 
            for a whole business process thats spans user think time. (For example, a servlet might 
            keep an <tt class="literal">ISession</tt> in the user's <tt class="literal">HttpSession</tt>.) For 
            performance reasons you should
        </p><div class="orderedlist"><ol type="1" compact><li><p>
                    commit the <tt class="literal">ITransaction</tt> and then
                </p></li><li><p>
                    disconnect the <tt class="literal">ISession</tt> from the ADO.NET connection
                </p></li></ol></div><p>
            before waiting for user activity. The method <tt class="literal">ISession.Disconnect()</tt> 
            will disconnect the session from the ADO.NET connection and return the connection to 
            the pool (unless you provided the connection).
        </p><p>
            <tt class="literal">ISession.Reconnect()</tt> obtains a new connection (or you may supply one) 
            and restarts the session. After reconnection, to force a version check on data you aren't 
            updating, you may call <tt class="literal">ISession.Lock()</tt> on any objects that might have
            been updated by another transaction. You don't need to lock any data that you
            <span class="emphasis"><em>are</em></span> updating.
        </p><p>
            Heres an example:
        </p><pre class="programlisting">ISessionFactory sessions;
IList&lt;Foo&gt; fooList;
Bar bar;
....
ISession s = sessions.OpenSession();
ITransaction tx = null;

try
{
    tx = s.BeginTransaction())

    fooList = s.CreateQuery(
    	"select foo from Eg.Foo foo where foo.Date = current date"
        // uses db2 date function
    ).List&lt;Foo&gt;();

    bar = new Bar();
    s.Save(bar);

    tx.Commit();
}
catch (Exception)
{
    if (tx != null) tx.Rollback();
    s.Close();
    throw;
}
s.Disconnect();</pre><p>
            Later on:
        </p><pre class="programlisting">s.Reconnect();

try
{
    tx = s.BeginTransaction();

    bar.FooTable = new HashMap();
    foreach (Foo foo in fooList)
    {
        s.Lock(foo, LockMode.Read);    //check that foo isn't stale
        bar.FooTable.Put( foo.Name, foo );
    }

    tx.Commit();
}
catch (Exception)
{
    if (tx != null) tx.Rollback();
    throw;
}
finally
{
    s.Close();
}</pre><p>
            You can see from this how the relationship between <tt class="literal">ITransaction</tt>s and
            <tt class="literal">ISession</tt>s is many-to-one, An <tt class="literal">ISession</tt> represents a 
            conversation between the application and the database. The
            <tt class="literal">ITransaction</tt> breaks that conversation up into atomic units of work
            at the database level.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-locking"></a>11.6.&nbsp;Pessimistic Locking</h2></div></div><div></div></div><p>
            It is not intended that users spend much time worring about locking strategies. It's usually
            enough to specify an isolation level for the ADO.NET connections and then simply let the
            database do all the work. However, advanced users may sometimes wish to obtain
            exclusive pessimistic locks, or re-obtain locks at the start of a new transaction.
        </p><p>
            NHibernate will always use the locking mechanism of the database, never lock objects
            in memory!
        </p><p>
            The <tt class="literal">LockMode</tt> class defines the different lock levels that may be acquired
            by NHibernate. A lock is obtained by the following mechanisms:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">LockMode.Write</tt> is acquired automatically when NHibernate updates or inserts 
                    a row. 
                </p></li><li><p>
                    <tt class="literal">LockMode.Upgrade</tt> may be acquired upon explicit user request using 
                    <tt class="literal">SELECT ... FOR UPDATE</tt> on databases which support that syntax.
                </p></li><li><p>
                    <tt class="literal">LockMode.UpgradeNoWait</tt> may be acquired upon explicit user request using a 
                    <tt class="literal">SELECT ... FOR UPDATE NOWAIT</tt> under Oracle.
                </p></li><li><p>
                    <tt class="literal">LockMode.Read</tt> is acquired automatically when NHibernate reads data
                    under Repeatable Read or Serializable isolation level. May be re-acquired by explicit user 
                    request.
                </p></li><li><p>
            <tt class="literal">LockMode.None</tt> represents the absence of a lock. All objects switch to this
            lock mode at the end of an <tt class="literal">ITransaction</tt>. Objects associated with the session 
            via a call to <tt class="literal">Update()</tt> or <tt class="literal">SaveOrUpdate()</tt> also start out 
            in this lock mode.
        </p></li></ul></div><p>
            The "explicit user request" is expressed in one of the following ways:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    A call to <tt class="literal">ISession.Load()</tt>, specifying a <tt class="literal">LockMode</tt>.
                </p></li><li><p>
                    A call to <tt class="literal">ISession.Lock()</tt>.
                </p></li><li><p>
                    A call to <tt class="literal">IQuery.SetLockMode()</tt>.
                </p></li></ul></div><p>
            If <tt class="literal">ISession.Load()</tt> is called with <tt class="literal">Upgrade</tt> or
            <tt class="literal">UpgradeNoWait</tt>, and the requested object was not yet loaded by
            the session, the object is loaded using <tt class="literal">SELECT ... FOR UPDATE</tt>.
            If <tt class="literal">Load()</tt> is called for an object that is already loaded with
            a less restrictive lock than the one requested, NHibernate calls 
            <tt class="literal">Lock()</tt> for that object.
        </p><p>
            <tt class="literal">ISession.Lock()</tt> performs a version number check if the specified lock
            mode is <tt class="literal">Read</tt>, <tt class="literal">Upgrade</tt> or 
            <tt class="literal">UpgradeNoWait</tt>. (In the case of <tt class="literal">Upgrade</tt> or
            <tt class="literal">UpgradeNoWait</tt>, <tt class="literal">SELECT ... FOR UPDATE</tt> is used.)
        </p><p>
            If the database does not support the requested lock mode, NHibernate will use an appropriate
            alternate mode (instead of throwing an exception). This ensures that applications will
            be portable.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transactions-connection-release"></a>11.7.&nbsp;Connection Release Modes</h2></div></div><div></div></div><p>
            The legacy (1.0.x) behavior of NHibernate in regards to ADO.NET connection management
            was that a <tt class="literal">ISession</tt> would obtain a connection when it was first
            needed and then hold unto that connection until the session was closed.
            NHibernate introduced the notion of connection release modes to tell a session
            how to handle its ADO.NET connections.  Note that the following discussion is pertinent
            only to connections provided through a configured <tt class="literal">IConnectionProvider</tt>;
            user-supplied connections are outside the breadth of this discussion.  The different
            release modes are identified by the enumerated values of
            <tt class="literal">NHibernate.ConnectionReleaseMode</tt>:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">OnClose</tt> - is essentially the legacy behavior described above. The
                    NHibernate session obtains a connection when it first needs to perform some database
                    access and holds unto that connection until the session is closed.
                </p></li><li><p>
                    <tt class="literal">AfterTransaction</tt> - says to release connections after a
                    <tt class="literal">NHibernate.ITransaction</tt> has completed.
                </p></li></ul></div><p>
            The configuration parameter <tt class="literal">hibernate.connection.release_mode</tt> is used
            to specify which release mode to use.  The possible values:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">auto</tt> (the default) - equivalent to <tt class="literal">after_transaction</tt>
                    in the current release. It is rarely a good idea to change this default behavior as failures
                    due to the value of this setting tend to indicate bugs and/or invalid assumptions in user code.
                </p></li><li><p>
                    <tt class="literal">on_close</tt> - says to use <tt class="literal">ConnectionReleaseMode.OnClose</tt>.
                    This setting is left for backwards compatibility, but its use is highly discouraged.
                </p></li><li><p>
                    <tt class="literal">after_transaction</tt> - says to use <tt class="literal">ConnectionReleaseMode.AfterTransaction</tt>.
                    Note that with <tt class="literal">ConnectionReleaseMode.AfterTransaction</tt>, if a session is considered to be in
                    auto-commit mode (i.e. no transaction was started) connections will be released after every operation.
                </p></li></ul></div><p>
            As of NHibernate, if your application manages transactions through .NET APIs such as <tt class="literal">
            System.Transactions</tt> library, <tt class="literal">ConnectionReleaseMode.AfterTransaction</tt> may cause
            NHibernate to open and close several connections during one transaction, leading to unnecessary overhead and
            transaction promotion from local to distributed. Specifying <tt class="literal">ConnectionReleaseMode.OnClose</tt>
            will revert to the legacy behavior and prevent this problem from occuring.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="events"></a>Chapter&nbsp;12.&nbsp;Interceptors and events</h2></div></div><div></div></div><p>
        It is often useful for the application to react to certain events that occur
        inside NHibernate. This allows implementation of certain kinds of generic 
        functionality, and extension of NHibernate functionality.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-interceptors"></a>12.1.&nbsp;Interceptors</h2></div></div><div></div></div><p>
            The <tt class="literal">IInterceptor</tt> interface provides callbacks from the session to the 
            application allowing the application to inspect and/or manipulate properties of a
            persistent object before it is saved, updated, deleted or loaded. One 
            possible use for this is to track auditing information. For example, the following 
            <tt class="literal">IInterceptor</tt> automatically sets the  <tt class="literal">createTimestamp</tt> 
            when an <tt class="literal">IAuditable</tt> is created and updates the 
            <tt class="literal">lastUpdateTimestamp</tt> property when an <tt class="literal">IAuditable</tt> is 
            updated.
        </p><p>
            You may either implement <tt class="literal">IInterceptor</tt> directly or (better) extend
            <tt class="literal">EmptyInterceptor</tt>.
        </p><pre class="programlisting">using System;
	
using NHibernate;
using NHibernate.Type;

public class AuditInterceptor : EmptyInterceptor {

    private int updates;
    private int creates;
    private int loads;

    public override void OnDelete(object entity,
                                  object id,
                                  object[] state,
                                  string[] propertyNames,
                                  IType[] types)
    {
        // do nothing
    }

    public override bool OnFlushDirty(object entity, 
                                      object id, 
				      object[] currentState,
				      object[] previousState, 
				      string[] propertyNames,
				      IType[] types) 
    {
        if ( entity is IAuditable ) {
            updates++;
            for ( int i=0; i &lt; propertyNames.Length; i++ ) {
                if ( "lastUpdateTimestamp".Equals( propertyNames[i] ) ) {
                    currentState[i] = new DateTime();
                    return true;
                }
            }
        }
        return false;
    }

    public override bool OnLoad(object entity, 
                                object id, 
				object[] state, 
				string[] propertyNames, 
				IType[] types)
    {
        if ( entity is IAuditable ) {
            loads++;
        }
        return false;
    }

    public override bool OnSave(object entity, 
                                object id, 
				object[] state, 
				string[] propertyNames, 
				IType[] types)
    {
        if ( entity is IAuditable ) {
            creates++;
            for ( int i=0; i&lt;propertyNames.Length; i++ ) {
                if ( "createTimestamp".Equals( propertyNames[i] ) ) {
                    state[i] = new DateTime();
                    return true;
                }
            }
        }
        return false;
    }

    public override void AfterTransactionCompletion(ITransaction tx)
    {
        if ( tx.WasCommitted ) {
            System.Console.WriteLine("Creations: " + creates + ", Updates: " + updates, "Loads: " + loads);
        }
        updates=0;
        creates=0;
        loads=0;
    }

}</pre><p>
            Interceptors come in two flavors: <tt class="literal">ISession</tt>-scoped and
            <tt class="literal">ISessionFactory</tt>-scoped.
        </p><p>
            An <tt class="literal">ISession</tt>-scoped interceptor is specified
            when a session is opened using one of the overloaded ISessionFactory.OpenSession()
            methods accepting an <tt class="literal">IInterceptor</tt>.
        </p><pre class="programlisting">ISession session = sf.OpenSession( new AuditInterceptor() );</pre><p>
            An <tt class="literal">ISessionFactory</tt>-scoped interceptor is registered with the <tt class="literal">Configuration</tt>
            object prior to building the <tt class="literal">ISessionFactory</tt>.  In this case, the supplied interceptor
            will be applied to all sessions opened from that <tt class="literal">ISessionFactory</tt>; this is true unless
            a session is opened explicitly specifying the interceptor to use.  <tt class="literal">ISessionFactory</tt>-scoped
            interceptors must be thread safe, taking care to not store session-specific state since multiple
            sessions will use this interceptor (potentially) concurrently.
        </p><pre class="programlisting">new Configuration().SetInterceptor( new AuditInterceptor() );</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-events"></a>12.2.&nbsp;Event system</h2></div></div><div></div></div><p>
            If you have to react to particular events in your persistence layer, you may
            also use the NHibernate2 <span class="emphasis"><em>event</em></span> architecture. The event
            system can be used in addition or as a replacement for interceptors.
        </p><p>
            Essentially all of the methods of the <tt class="literal">ISession</tt> interface correlate
            to an event. You have a <tt class="literal">LoadEvent</tt>, a <tt class="literal">FlushEvent</tt>, etc
            (consult the XML configuration-file XSD or the <tt class="literal">NHibernate.Event</tt>
            namespace for the full list of defined event types). When a request is made of one of
            these methods, the <tt class="literal">ISession</tt> generates an appropriate
            event and passes it to the configured event listeners for that type. Out-of-the-box,
            these listeners implement the same processing in which those methods always resulted.
            However, you are free to implement a customization of one of the listener interfaces
            (i.e., the <tt class="literal">LoadEvent</tt> is processed by the registered implemenation
            of the <tt class="literal">ILoadEventListener</tt> interface), in which case their
            implementation would be responsible for processing any <tt class="literal">Load()</tt> requests
            made of the <tt class="literal">ISession</tt>.
        </p><p>
            The listeners should be considered effectively singletons; meaning, they are shared between
            requests, and thus should not save any state as instance variables.
        </p><p>
            A custom listener should implement the appropriate interface for the event it wants to
            process and/or extend one of the convenience base classes (or even the default event
            listeners used by NHibernate out-of-the-box as their methods are declared virtual for this
            purpose). Custom listeners can either be registered programmatically through the
            <tt class="literal">Configuration</tt> object, or specified in the NHibernate configuration
            XML. Here's an example of a custom load event listener:
        </p><pre class="programlisting">public class MyLoadListener : ILoadEventListener 
{
    // this is the single method defined by the LoadEventListener interface
    public void OnLoad(LoadEvent theEvent, LoadType loadType)
    {
        if ( !MySecurity.IsAuthorized( theEvent.EntityClassName, theEvent.EntityId ) ) {
            throw new MySecurityException("Unauthorized access");
        }
    }
}</pre><p>
            You also need a configuration entry telling NHibernate to use the listener in addition
            to the default listener:
        </p><pre class="programlisting">&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        ...
        &lt;event type="load"&gt;
            &lt;listener class="MyLoadListener"/&gt;
            &lt;listener class="NHibernate.Event.Default.DefaultLoadEventListener"/&gt;
        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</pre><p>
            Instead, you may register it programmatically:
        </p><pre class="programlisting">Configuration cfg = new Configuration();
ILoadEventListener[] stack = new ILoadEventListener[] { new MyLoadListener(), new DefaultLoadEventListener() };
cfg.EventListeners.LoadEventListeners = stack;</pre><p>
            Listeners registered declaratively cannot share instances. If the same class name is
            used in multiple <tt class="literal">&lt;listener/&gt;</tt> elements, each reference will
            result in a separate instance of that class. If you need the capability to share
            listener instances between listener types you must use the programmatic registration
            approach.
        </p><p>
            Why implement an interface and define the specific type during configuration? Well, a
            listener implementation could implement multiple event listener interfaces. Having the
            type additionally defined during registration makes it easier to turn custom listeners on
            or off during configuration.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="batch"></a>Chapter&nbsp;13.&nbsp;Batch processing</h2></div></div><div></div></div><p>
        A naive approach to inserting 100 000 rows in the database using NHibernate might 
        look like this:
    </p><pre class="programlisting">ISession session = sessionFactory.OpenSession();
ITransaction tx = session.BeginTransaction();
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.Save(customer);
}
tx.Commit();
session.Close();</pre><p>
        This would fall over with an <tt class="literal">OutOfMemoryException</tt> somewhere 
        around the 50 000th row. That's because NHibernate caches all the newly inserted 
        <tt class="literal">Customer</tt> instances in the session-level cache. 
    </p><p>
        In this chapter we'll show you how to avoid this problem. First, however, if you
        are doing batch processing, it is absolutely critical that you enable the use of
        ADO batching, if you intend to achieve reasonable performance. Set the ADO batch 
        size to a reasonable number (say, 10-50):
    </p><pre class="programlisting">adonet.batch_size 20</pre><p><a name="disablebatching"></a>
        Note that NHibernate disables insert batching at the ADO level transparently if you
        use an <tt class="literal">identiy</tt> identifier generator.
    </p><p>
        You also might like to do this kind of work in a process where interaction with 
        the second-level cache is completely disabled:
    </p><pre class="programlisting">cache.use_second_level_cache false</pre><p>
        However, this is not absolutely necessary, since we can explicitly set the
        <tt class="literal">CacheMode</tt> to disable interaction with the second-level cache.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-inserts"></a>13.1.&nbsp;Batch inserts</h2></div></div><div></div></div><p>
            When making new objects persistent, you must <tt class="literal">Flush()</tt> and 
            then <tt class="literal">Clear()</tt> the session regularly, to control the size of
            the first-level cache.
        </p><pre class="programlisting">ISession session = sessionFactory.openSession();
ITransaction tx = session.BeginTransaction();
   
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.Save(customer);
    if ( i % 20 == 0 ) { //20, same as the ADO batch size
        //flush a batch of inserts and release memory:
        session.Flush();
        session.Clear();
    }
}
   
tx.Commit();
session.Close();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-statelesssession"></a>13.2.&nbsp;The StatelessSession interface</h2></div></div><div></div></div><p>
            Alternatively, NHibernate provides a command-oriented API that may be used for 
            streaming data to and from the database in the form of detached objects. A 
            <tt class="literal">IStatelessSession</tt> has no persistence context associated
            with it and does not provide many of the higher-level life cycle semantics.
            In particular, a stateless session does not implement a first-level cache nor
            interact with any second-level or query cache. It does not implement 
            transactional write-behind or automatic dirty checking. Operations performed
            using a stateless session do not ever cascade to associated instances. Collections 
            are ignored by a stateless session. Operations performed via a stateless session 
            bypass NHibernate's event model and interceptors. Stateless sessions are vulnerable 
            to data aliasing effects, due to the lack of a first-level cache. A stateless
            session is a lower-level abstraction, much closer to the underlying ADO.
        </p><pre class="programlisting">IStatelessSession session = sessionFactory.OpenStatelessSession();
ITransaction tx = session.BeginTransaction();
   
var customers = session.GetNamedQuery("GetCustomers")
    .Enumerable&lt;Customer&gt;();
while ( customers.MoveNext() ) {
    Customer customer = customers.Current;
    customer.updateStuff(...);
    session.Update(customer);
}
   
tx.Commit();
session.Close();</pre><p>
            Note that in this code example, the <tt class="literal">Customer</tt> instances returned
            by the query are immediately detached. They are never associated with any persistence
            context.
        </p><p>
            The <tt class="literal">insert(), update()</tt> and <tt class="literal">delete()</tt> operations
            defined by the <tt class="literal">StatelessSession</tt> interface are considered to be
            direct database row-level operations, which result in immediate execution of a SQL
            <tt class="literal">INSERT, UPDATE</tt> or <tt class="literal">DELETE</tt> respectively. Thus,
            they have very different semantics to the <tt class="literal">Save(), SaveOrUpdate()</tt> 
            and <tt class="literal">Delete()</tt> operations defined by the <tt class="literal">ISession</tt> 
            interface.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="batch-direct"></a>13.3.&nbsp;DML-style operations</h2></div></div><div></div></div><p>
            As already discussed, automatic and transparent object/relational mapping is concerned
            with the management of object state. This implies that the object state is available
            in memory, hence manipulating (using the SQL <tt class="literal">Data Manipulation Language</tt>
            (DML) statements: <tt class="literal">INSERT</tt>, <tt class="literal">UPDATE</tt>, <tt class="literal">DELETE</tt>)
            data directly in the database will not affect in-memory state. However, NHibernate provides methods
            for bulk SQL-style DML statement execution which are performed through the
            Hibernate Query Language (<a href="#queryhql" title="Chapter&nbsp;14.&nbsp;HQL: The Hibernate Query Language">HQL</a>).
        </p><p>
            The pseudo-syntax for <tt class="literal">UPDATE</tt> and <tt class="literal">DELETE</tt> statements
            is: <tt class="literal">( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</tt>.  Some
            points to note:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    In the from-clause, the FROM keyword is optional
                </p></li><li><p>
                    There can only be a single entity named in the from-clause; it can optionally be
                    aliased.  If the entity name is aliased, then any property references must
                    be qualified using that alias; if the entity name is not aliased, then it is
                    illegal for any property references to be qualified.
                </p></li><li><p>
                    No <a href="#">joins</a> (either implicit or explicit)
	                can be specified in a bulk HQL query.  Sub-queries may be used in the where-clause;
	                the subqueries, themselves, may contain joins.
                </p></li><li><p>
                    The where-clause is also optional.
                </p></li></ul></div><p>
            As an example, to execute an HQL <tt class="literal">UPDATE</tt>, use the
            <tt class="literal">IQuery.ExecuteUpdate()</tt> method:
        </p><pre class="programlisting">ISession session = sessionFactory.OpenSession();
ITransaction tx = session.BeginTransaction();

string hqlUpdate = "update Customer c set c.name = :newName where c.name = :oldName";
// or string hqlUpdate = "update Customer set name = :newName where name = :oldName";
int updatedEntities = s.CreateQuery( hqlUpdate )
        .SetString( "newName", newName )
        .SetString( "oldName", oldName )
        .ExecuteUpdate();
tx.Commit();
session.Close();</pre><p>
            HQL <tt class="literal">UPDATE</tt> statements, by default do not effect the
            <a href="#mapping-declaration-version" title="5.1.8.&nbsp;version (optional)">version</a>
            or the <a href="#mapping-declaration-timestamp" title="5.1.9.&nbsp;timestamp (optional)">timestamp</a> property values
            for the affected entities.  However,
            you can force NHibernate to properly reset the <tt class="literal">version</tt> or
            <tt class="literal">timestamp</tt> property values through the use of a <tt class="literal">versioned update</tt>.
            This is achieved by adding the <tt class="literal">VERSIONED</tt> keyword after the <tt class="literal">UPDATE</tt>
            keyword.
        </p><pre class="programlisting">ISession session = sessionFactory.OpenSession();
ITransaction tx = session.BeginTransaction();
string hqlVersionedUpdate = "update versioned Customer set name = :newName where name = :oldName";
int updatedEntities = s.CreateQuery( hqlUpdate )
        .SetString( "newName", newName )
        .SetString( "oldName", oldName )
        .ExecuteUpdate();
tx.Commit();
session.Close();</pre><p>
            Note that custom version types (<tt class="literal">NHibernate.Usertype.IUserVersionType</tt>)
            are not allowed in conjunction with a <tt class="literal">update versioned</tt> statement.
        </p><p>
            To execute an HQL <tt class="literal">DELETE</tt>, use the same <tt class="literal">IQuery.ExecuteUpdate()</tt>
            method:
        </p><pre class="programlisting">ISession session = sessionFactory.OpenSession();
ITransaction tx = session.BeginTransaction();

String hqlDelete = "delete Customer c where c.name = :oldName";
// or String hqlDelete = "delete Customer where name = :oldName";
int deletedEntities = s.CreateQuery( hqlDelete )
        .SetString( "oldName", oldName )
        .ExecuteUpdate();
tx.Commit();
session.Close();</pre><p>
            The <tt class="literal">int</tt> value returned by the <tt class="literal">IQuery.ExecuteUpdate()</tt>
            method indicate the number of entities effected by the operation.  Consider this may or may not
            correlate to the number of rows effected in the database.  An HQL bulk operation might result in
            multiple actual SQL statements being executed, for joined-subclass, for example.  The returned
            number indicates the number of actual entities affected by the statement.  Going back to the
            example of joined-subclass, a delete against one of the subclasses may actually result
            in deletes against not just the table to which that subclass is mapped, but also the "root"
            table and potentially joined-subclass tables further down the inheritence hierarchy.
        </p><p>
            The pseudo-syntax for <tt class="literal">INSERT</tt> statements is:
            <tt class="literal">INSERT INTO EntityName properties_list select_statement</tt>.  Some
            points to note:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Only the INSERT INTO ... SELECT ... form is supported; not the INSERT INTO ... VALUES ... form.
                </p><p>
                    The properties_list is analogous to the <tt class="literal">column speficiation</tt>
                    in the SQL <tt class="literal">INSERT</tt> statement.  For entities involved in mapped
                    inheritence, only properties directly defined on that given class-level can be
                    used in the properties_list.  Superclass properties are not allowed; and subclass
                    properties do not make sense.  In other words, <tt class="literal">INSERT</tt>
                    statements are inherently non-polymorphic.
                </p></li><li><p>
                    select_statement can be any valid HQL select query, with the caveat that the return types
                    must match the types expected by the insert.  Currently, this is checked during query
                    compilation rather than allowing the check to relegate to the database.  Note however
                    that this might cause problems between NHibernate <tt class="literal">Type</tt>s which are
                    <span class="emphasis"><em>equivalent</em></span> as opposed to <span class="emphasis"><em>equal</em></span>.  This might cause
                    issues with mismatches between a property defined as a <tt class="literal">NHibernate.Type.DateType</tt>
                    and a property defined as a <tt class="literal">NHibernate.Type.TimestampType</tt>, even though the
                    database might not make a distinction or might be able to handle the conversion.
                </p></li><li><p>
                    For the id property, the insert statement gives you two options.  You can either
                    explicitly specify the id property in the properties_list (in which case its value
                    is taken from the corresponding select expression) or omit it from the properties_list
                    (in which case a generated value is used).  This later option is only available when
                    using id generators that operate in the database; attempting to use this option with
                    any "in memory" type generators will cause an exception during parsing.  Note that
                    for the purposes of this discussion, in-database generators are considered to be
                    <tt class="literal">NHibernate.Id.SequenceGenerator</tt> (and its subclasses) and
                    any implementors of <tt class="literal">NHibernate.Id.IPostInsertIdentifierGenerator</tt>.
                    The most notable exception here is <tt class="literal">NHibernate.Id.TableHiLoGenerator</tt>,
                    which cannot be used because it does not expose a selectable way to get its values.
                </p></li><li><p>
                    For properties mapped as either <tt class="literal">version</tt> or <tt class="literal">timestamp</tt>,
                    the insert statement gives you two options.  You can either specify the property in the
                    properties_list (in which case its value is taken from the corresponding select expressions)
                    or omit it from the properties_list (in which case the <tt class="literal">seed value</tt> defined
                    by the <tt class="literal">NHibernate.Type.IVersionType</tt> is used).
                </p></li></ul></div><p>
            An example HQL <tt class="literal">INSERT</tt> statement execution:
        </p><pre class="programlisting">ISession session = sessionFactory.OpenSession();
ITransaction tx = session.BeginTransaction();

var hqlInsert = "insert into DelinquentAccount (id, name) select c.id, c.name from Customer c where ...";
int createdEntities = s.CreateQuery( hqlInsert )
        .ExecuteUpdate();
tx.Commit();
session.Close();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="queryhql"></a>Chapter&nbsp;14.&nbsp;HQL: The Hibernate Query Language</h2></div></div><div></div></div><p>
        NHibernate is equiped with an extremely powerful query language that (quite intentionally)
        looks very much like SQL. But don't be fooled by the syntax; HQL is fully object-oriented,
        understanding notions like inheritence, polymorphism and association.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-casesensitivity"></a>14.1.&nbsp;Case Sensitivity</h2></div></div><div></div></div><p>
            Queries are case-insensitive, except for names of .NET classes and properties.
            So <tt class="literal">SeLeCT</tt> is the same as
            <tt class="literal">sELEct</tt> is the same as
            <tt class="literal">SELECT</tt> but
            <tt class="literal">Eg.FOO</tt> is not
            <tt class="literal">Eg.Foo</tt> and
            <tt class="literal">foo.barSet</tt> is not
            <tt class="literal">foo.BARSET</tt>.
        </p><p>
            This manual uses lowercase HQL keywords. Some users find queries with uppercase keywords 
            more readable, but we find this convention ugly when embedded in C# code.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-from"></a>14.2.&nbsp;The from clause</h2></div></div><div></div></div><p>
            The simplest possible NHibernate query is of the form:
        </p><pre class="programlisting">from Eg.Cat</pre><p>
            which simply returns all instances of the class <tt class="literal">Eg.Cat</tt>. 
        </p><p>
            Most of the time, you will need to assign an <span class="emphasis"><em>alias</em></span>, since
            you will want to refer to the <tt class="literal">Cat</tt> in other parts of the
            query.
        </p><pre class="programlisting">from Eg.Cat as cat</pre><p>
            This query assigns the alias <tt class="literal">cat</tt> to <tt class="literal">Cat</tt>
            instances, so we could use that alias later in the query. The <tt class="literal">as</tt>
            keyword is optional; we could also write:
        </p><pre class="programlisting">from Eg.Cat cat</pre><p>
            Multiple classes may appear, resulting in a cartesian product or "cross" join.
        </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>
            It is considered good practice to name query aliases using an initial lowercase,
            consistent with naming standards for local variables
            (eg. <tt class="literal">domesticCat</tt>).
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-joins"></a>14.3.&nbsp;Associations and joins</h2></div></div><div></div></div><p>
            We may also assign aliases to associated entities, or even to elements of a collection of
            values, using a <tt class="literal">join</tt>.
        </p><pre class="programlisting">from Eg.Cat as cat 
    inner join cat.Mate as mate
    left outer join cat.Kittens as kitten

from Eg.Cat as cat left join cat.Mate.Kittens as kittens

from Formula form full join form.Parameter param</pre><p>
            The supported join types are borrowed from ANSI SQL
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">inner join</tt>
                </p></li><li><p>
                    <tt class="literal">left outer join</tt>
                </p></li><li><p>
                    <tt class="literal">right outer join</tt>
                </p></li><li><p>
                    <tt class="literal">full join</tt> (not usually useful)
                </p></li></ul></div><p>
            The <tt class="literal">inner join</tt>, <tt class="literal">left outer join</tt> and 
            <tt class="literal">right outer join</tt> constructs may be abbreviated.
        </p><pre class="programlisting">from Eg.Cat as cat 
    join cat.Mate as mate
    left join cat.Kittens as kitten</pre><p>
            In addition, a "fetch" join allows associations or collections of values to be 
            initialized along with their parent objects, using a single select. This is particularly 
            useful in the case of a collection. It effectively overrides the outer join and
            lazy declarations of the mapping file for associations and collections. See
            <a href="#performance-fetching" title="19.1.&nbsp;Fetching strategies">Section&nbsp;19.1, &#8220;Fetching strategies&#8221;</a> for more information.
        </p><pre class="programlisting">from Eg.Cat as cat 
    inner join fetch cat.Mate
    left join fetch cat.Kittens</pre><p>
            The associated objects are not returned directly in the query results. Instead, they may 
            be accessed via the parent object.
        </p><p>
            It is possible to create a cartesian product by join fetching more than one collection in
            a query, so take care in this case. Join fetching multiple collection roles is also
            disabled for bag mappings. Note also that the <tt class="literal">fetch</tt> construct may not
            be used in queries called using <tt class="literal">Enumerable()</tt>. Finally, note that
            <tt class="literal">full join fetch</tt> and <tt class="literal">right join fetch</tt> are not meaningful.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-select"></a>14.4.&nbsp;The select clause</h2></div></div><div></div></div><p>
            The <tt class="literal">select</tt> clause picks which objects and properties to return in 
            the query result set. Consider:
        </p><pre class="programlisting">select mate 
from Eg.Cat as cat 
    inner join cat.Mate as mate</pre><p>
            The query will select <tt class="literal">Mate</tt>s of other <tt class="literal">Cat</tt>s.
            Actually, you may express this query more compactly as:
        </p><pre class="programlisting">select cat.Mate from Eg.Cat cat</pre><p>
            You may even select collection elements, using the special <tt class="literal">elements</tt>
            function. The following query returns all kittens of any cat.
        </p><pre class="programlisting">select elements(cat.Kittens) from Eg.Cat cat</pre><p>
            Queries may return properties of any value type including properties of component type:
        </p><pre class="programlisting">select cat.Name from Eg.DomesticCat cat
where cat.Name like 'fri%'

select cust.Name.FirstName from Customer as cust</pre><p>
            Queries may return multiple objects and/or properties as an array of type 
            <tt class="literal">object[]</tt>
        </p><pre class="programlisting">select mother, offspr, mate.Name 
from Eg.DomesticCat as mother
    inner join mother.Mate as mate
    left outer join mother.Kittens as offspr</pre><p>
            or as an actual typesafe object
        </p><pre class="programlisting">select new Family(mother, mate, offspr)
from Eg.DomesticCat as mother
    join mother.Mate as mate
    left join mother.Kittens as offspr</pre><p>
            assuming that the class <tt class="literal">Family</tt> has an appropriate constructor.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-aggregation"></a>14.5.&nbsp;Aggregate functions</h2></div></div><div></div></div><p>
            HQL queries may even return the results of aggregate functions on properties:
        </p><pre class="programlisting">select avg(cat.Weight), sum(cat.Weight), max(cat.Weight), count(cat)
from Eg.Cat cat</pre><p>
            Collections may also appear inside aggregate functions in the <tt class="literal">select</tt> 
            clause.
        </p><pre class="programlisting">select cat, count( elements(cat.Kittens) ) 
from Eg.Cat cat group by cat.Id, cat.Weight, ...</pre><p>
            The supported aggregate functions are
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    <tt class="literal">avg(...), sum(...), min(...), max(...)</tt>
                </p></li><li><p>
                    <tt class="literal">count(*)</tt>
                </p></li><li><p>
                    <tt class="literal">count(...), count(distinct ...), count(all...)</tt>
                </p></li></ul></div><p>
            The <tt class="literal">distinct</tt> and <tt class="literal">all</tt> keywords may be used and have
            the same semantics as in SQL.
        </p><pre class="programlisting">select distinct cat.Name from Eg.Cat cat

select count(distinct cat.Name), count(cat) from Eg.Cat cat</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-polymorphism"></a>14.6.&nbsp;Polymorphic queries</h2></div></div><div></div></div><p>
            A query like:
        </p><pre class="programlisting">from Eg.Cat as cat</pre><p>
            returns instances not only of <tt class="literal">Cat</tt>, but also of subclasses like
            <tt class="literal">DomesticCat</tt>. NHibernate queries may name <span class="emphasis"><em>any</em></span> .NET 
            class or interface in the <tt class="literal">from</tt> clause. The query will return instances 
            of all persistent classes that extend that class or implement the interface. The following 
            query would return all persistent objects:
        </p><pre class="programlisting">from System.Object o</pre><p>
            The interface <tt class="literal">INamed</tt> might be implemented by various persistent
            classes:
        </p><pre class="programlisting">from Eg.Named n, Eg.Named m where n.Name = m.Name</pre><p>
            Note that these last two queries will require more than one SQL <tt class="literal">SELECT</tt>. This
            means that the <tt class="literal">order by</tt> clause does not correctly order the whole result set.
        </p><p>
			In order to use non-mapped base classes or interfaces in HQL queries, they have to be imported. See <a href="#mapping-declaration-import" title="5.1.21.&nbsp;import">Section&nbsp;5.1.21, &#8220;import&#8221;</a> for more information.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-where"></a>14.7.&nbsp;The where clause</h2></div></div><div></div></div><p>
            The <tt class="literal">where</tt> clause allows you to narrow the list of instances returned.
        </p><pre class="programlisting">from Eg.Cat as cat where cat.Name='Fritz'</pre><p>
            returns instances of <tt class="literal">Cat</tt> named 'Fritz'.
        </p><pre class="programlisting">select foo 
from Eg.Foo foo, Eg.Bar bar
where foo.StartDate = bar.Date</pre><p>
            will return all instances of <tt class="literal">Foo</tt> for which
            there exists an instance of <tt class="literal">Bar</tt> with a
            <tt class="literal">Date</tt> property equal to the
            <tt class="literal">StartDate</tt> property of the
            <tt class="literal">Foo</tt>. Compound path expressions make the
            <tt class="literal">where</tt> clause extremely powerful. Consider:
        </p><pre class="programlisting">from Eg.Cat cat where cat.Mate.Name is not null</pre><p>
            This query translates to an SQL query with a table (inner) join. If you were to write
            something like
        </p><pre class="programlisting">from Eg.Foo foo  
where foo.Bar.Baz.Customer.Address.City is not null</pre><p>
            you would end up with a query that would require four table joins in SQL.
        </p><p>
            The <tt class="literal">=</tt> operator may be used to compare not only properties, but also 
            instances:
        </p><pre class="programlisting">from Eg.Cat cat, Eg.Cat rival where cat.Mate = rival.Mate

select cat, mate 
from Eg.Cat cat, Eg.Cat mate
where cat.Mate = mate</pre><p>
            The special property (lowercase) <tt class="literal">id</tt> may be used to reference the 
            unique identifier of an object. (You may also use its property name.)
        </p><pre class="programlisting">from Eg.Cat as cat where cat.id = 123

from Eg.Cat as cat where cat.Mate.id = 69</pre><p>
            The second query is efficient. No table join is required!
        </p><p>
            Properties of composite identifiers may also be used. Suppose <tt class="literal">Person</tt> 
            has a composite identifier consisting of <tt class="literal">Country</tt> and 
            <tt class="literal">MedicareNumber</tt>.
        </p><pre class="programlisting">from Bank.Person person
where person.id.Country = 'AU' 
    and person.id.MedicareNumber = 123456

from Bank.Account account
where account.Owner.id.Country = 'AU' 
    and account.Owner.id.MedicareNumber = 123456</pre><p>
            Once again, the second query requires no table join.
        </p><p>
            Likewise, the special property <tt class="literal">class</tt> accesses the discriminator value
            of an instance in the case of polymorphic persistence. A .Net class name embedded in the 
            where clause will be translated to its discriminator value.
        </p><pre class="programlisting">from Eg.Cat cat where cat.class = Eg.DomesticCat</pre><p>
            You may also specify properties of components or composite user types (and of components 
            of components, etc). Never try to use a path-expression that ends in a property of component 
            type (as opposed to a property of a component). For example, if <tt class="literal">store.Owner</tt>
            is an entity with a component <tt class="literal">Address</tt>
        </p><pre class="programlisting">store.Owner.Address.City    // okay
store.Owner.Address         // error!</pre><p>
            An "any" type has the special properties <tt class="literal">id</tt> and <tt class="literal">class</tt>,
            allowing us to express a join in the following way (where <tt class="literal">AuditLog.Item</tt>
            is a property mapped with <tt class="literal">&lt;any&gt;</tt>).
        </p><pre class="programlisting">from Eg.AuditLog log, Eg.Payment payment 
where log.Item.class = 'Eg.Payment, Eg, Version=...' and log.Item.id = payment.id</pre><p>
            Notice that <tt class="literal">log.Item.class</tt> and <tt class="literal">payment.class</tt>
            would refer to the values of completely different database columns in the above query.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-expressions"></a>14.8.&nbsp;Expressions</h2></div></div><div></div></div><p>
            Expressions allowed in the <tt class="literal">where</tt> clause include
            most of the kind of things you could write in SQL:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    mathematical operators <tt class="literal">+, -, *, /</tt>
                </p></li><li><p>
                    binary comparison operators <tt class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</tt>
                </p></li><li><p>
                    logical operations <tt class="literal">and, or, not</tt>
                </p></li><li><p>
                    string concatenation ||
                </p></li><li><p>
                    SQL scalar functions like <tt class="literal">upper()</tt> and
                    <tt class="literal">lower()</tt>
                </p></li><li><p>
                    Parentheses <tt class="literal">( )</tt> indicate grouping
                </p></li><li><p>
                    <tt class="literal">in</tt>,
                    <tt class="literal">between</tt>,
                    <tt class="literal">is null</tt>
                </p></li><li><p>
                    positional parameters <tt class="literal">?</tt>
                </p></li><li><p>
                    named parameters <tt class="literal">:name</tt>, <tt class="literal">:start_date</tt>, <tt class="literal">:x1</tt>
                </p></li><li><p>
                    SQL literals <tt class="literal">'foo'</tt>, <tt class="literal">69</tt>, <tt class="literal">'1970-01-01 10:00:01.0'</tt>
                </p></li><li><p>
                    Enumeration values and constants <tt class="literal">Eg.Color.Tabby</tt>
                </p></li></ul></div><p>
            <tt class="literal">in</tt> and <tt class="literal">between</tt> may be used as follows:
        </p><pre class="programlisting">from Eg.DomesticCat cat where cat.Name between 'A' and 'B'

from Eg.DomesticCat cat where cat.Name in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            and the negated forms may be written
        </p><pre class="programlisting">from Eg.DomesticCat cat where cat.Name not between 'A' and 'B'

from Eg.DomesticCat cat where cat.Name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>
            Likewise, <tt class="literal">is null</tt> and <tt class="literal">is not null</tt> may be used to test 
            for null values.
        </p><p>
            Booleans may be easily used in expressions by declaring HQL query substitutions in NHibernate
            configuration:
        </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"&gt;true 1, false 0&lt;/property&gt;</pre><p>
            This will replace the keywords <tt class="literal">true</tt> and <tt class="literal">false</tt> with the
            literals <tt class="literal">1</tt> and <tt class="literal">0</tt> in the translated SQL from this HQL:
        </p><pre class="programlisting">from Eg.Cat cat where cat.Alive = true</pre><p>
            You may test the size of a collection with the special property <tt class="literal">size</tt>, or
            the special <tt class="literal">size()</tt> function.
        </p><pre class="programlisting">from Eg.Cat cat where cat.Kittens.size &gt; 0

from Eg.Cat cat where size(cat.Kittens) &gt; 0</pre><p>
            For indexed collections, you may refer to the minimum and maximum indices using
            <tt class="literal">minIndex</tt> and <tt class="literal">maxIndex</tt>. Similarly, you may refer to the
            minimum and maximum elements of a collection of basic type using <tt class="literal">minElement</tt> 
            and <tt class="literal">maxElement</tt>.
        </p><pre class="programlisting">from Calendar cal where cal.Holidays.maxElement &gt; current date</pre><p>
            There are also functional forms (which, unlike the constructs above, are not case sensitive):
        </p><pre class="programlisting">from Order order where maxindex(order.Items) &gt; 100

from Order order where minelement(order.Items) &gt; 10000</pre><p>
            The SQL functions <tt class="literal">any, some, all, exists, in</tt> are supported when passed the element 
            or index set of a collection (<tt class="literal">elements</tt> and <tt class="literal">indices</tt> functions)
            or the result of a subquery (see below).
        </p><pre class="programlisting">select mother from Eg.Cat as mother, Eg.Cat as kit
where kit in elements(mother.Kittens)

select p from Eg.NameList list, Eg.Person p
where p.Name = some elements(list.Names)

from Eg.Cat cat where exists elements(cat.Kittens)

from Eg.Player p where 3 &gt; all elements(p.Scores)

from Eg.Show show where 'fizard' in indices(show.Acts)</pre><p>
            Note that these constructs - <tt class="literal">size</tt>, <tt class="literal">elements</tt>,
            <tt class="literal">indices</tt>, <tt class="literal">minIndex</tt>, <tt class="literal">maxIndex</tt>,
            <tt class="literal">minElement</tt>, <tt class="literal">maxElement</tt> - have certain usage 
            restrictions:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    in a <tt class="literal">where</tt> clause: only for databases with subselects
                </p></li><li><p>
                    in a <tt class="literal">select</tt> clause: only <tt class="literal">elements</tt> and 
                    <tt class="literal">indices</tt> make sense
                </p></li></ul></div><p>
            Elements of indexed collections (arrays, lists, maps) may be referred to by
            index (in a where clause only):
        </p><pre class="programlisting">from Order order where order.Items[0].id = 1234

select person from Person person, Calendar calendar
where calendar.Holidays['national day'] = person.BirthDay
    and person.Nationality.Calendar = calendar

select item from Item item, Order order
where order.Items[ order.DeliveredItemIndices[0] ] = item and order.id = 11

select item from Item item, Order order
where order.Items[ maxindex(order.items) ] = item and order.id = 11</pre><p>
            The expression inside <tt class="literal">[]</tt> may even be an arithmetic expression.
        </p><pre class="programlisting">select item from Item item, Order order
where order.Items[ size(order.Items) - 1 ] = item</pre><p>
            HQL also provides the built-in <tt class="literal">index()</tt> function, for elements of
            a one-to-many association or collection of values.
        </p><pre class="programlisting">select item, index(item) from Order order 
    join order.Items item
where index(item) &lt; 5</pre><p>
            Scalar SQL functions supported by the underlying database may be used
        </p><pre class="programlisting">from Eg.DomesticCat cat where upper(cat.Name) like 'FRI%'</pre><p>
            If you are not yet convinced by all this, think how much longer and less readable the 
            following query would be in SQL:
        </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.Customers cust
where prod.Name = 'widget'
    and store.Location.Name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.CurrentOrder.LineItems)</pre><p>
            <span class="emphasis"><em>Hint:</em></span> something like
        </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-ordering"></a>14.9.&nbsp;The order by clause</h2></div></div><div></div></div><p>
            The list returned by a query may be ordered by any property of a returned class or components:
        </p><pre class="programlisting">from Eg.DomesticCat cat
order by cat.Name asc, cat.Weight desc, cat.Birthdate</pre><p>
            The optional <tt class="literal">asc</tt> or <tt class="literal">desc</tt> indicate ascending or descending order 
            respectively.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-grouping"></a>14.10.&nbsp;The group by clause</h2></div></div><div></div></div><p>
            A query that returns aggregate values may be grouped by any property of a returned class or components:
        </p><pre class="programlisting">select cat.Color, sum(cat.Weight), count(cat) 
from Eg.Cat cat
group by cat.Color

select foo.id, avg( elements(foo.Names) ), max( indices(foo.Names) ) 
from Eg.Foo foo
group by foo.id</pre><p>
            Note: You may use the <tt class="literal">elements</tt> and <tt class="literal">indices</tt> constructs
            inside a select clause, even on databases with no subselects.
        </p><p>
            A <tt class="literal">having</tt> clause is also allowed.
        </p><pre class="programlisting">select cat.color, sum(cat.Weight), count(cat) 
from Eg.Cat cat
group by cat.Color 
having cat.Color in (Eg.Color.Tabby, Eg.Color.Black)</pre><p>
            SQL functions and aggregate functions are allowed in the <tt class="literal">having</tt>
            and <tt class="literal">order by</tt> clauses, if supported by the underlying database (ie.
            not in MySQL).
        </p><pre class="programlisting">select cat
from Eg.Cat cat
    join cat.Kittens kitten
group by cat.Id, cat.Name, cat.Other, cat.Properties
having avg(kitten.Weight) &gt; 100
order by count(kitten) asc, sum(kitten.Weight) desc</pre><p>
            Note that neither the <tt class="literal">group by</tt> clause nor the
            <tt class="literal">order by</tt> clause may contain arithmetic expressions.
            Also note that NHibernate currently does not expand a grouped entity,
            so you can't write <tt class="literal">group by cat</tt> if all properties
            of <tt class="literal">cat</tt> are non-aggregated. You have to list all
            non-aggregated properties explicitly.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-subqueries"></a>14.11.&nbsp;Subqueries</h2></div></div><div></div></div><p>
            For databases that support subselects, NHibernate supports subqueries within queries. A subquery must
            be surrounded by parentheses (often by an SQL aggregate function call). Even correlated subqueries
            (subqueries that refer to an alias in the outer query) are allowed.
        </p><pre class="programlisting">from Eg.Cat as fatcat 
where fatcat.Weight &gt; ( 
    select avg(cat.Weight) from Eg.DomesticCat cat 
)

from Eg.DomesticCat as cat 
where cat.Name = some ( 
    select name.NickName from Eg.Name as name 
)
    
from Eg.Cat as cat 
where not exists ( 
    from eg.Cat as mate where mate.Mate = cat 
)

from Eg.DomesticCat as cat 
where cat.Name not in ( 
    select name.NickName from Eg.Name as name 
)</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-examples"></a>14.12.&nbsp;HQL examples</h2></div></div><div></div></div><p>
            NHibernate queries can be quite powerful and complex. In fact, the power of the query language
            is one of NHibernate's main selling points. Here are some example queries very similar to queries
            that I used on a recent project. Note that most queries you will write are much simpler than these!
        </p><p>
            The following query returns the order id, number of items and total value of the order for all 
            unpaid orders for a particular customer and given minimum total value, ordering the results by 
            total value. In determining the prices, it uses the current catalog. The resulting SQL query, 
            against the <tt class="literal">ORDER</tt>, <tt class="literal">ORDER_LINE</tt>, <tt class="literal">PRODUCT</tt>,
            <tt class="literal">CATALOG</tt> and <tt class="literal">PRICE</tt> tables has four inner joins and an
            (uncorrelated) subselect.
        </p><pre class="programlisting">select order.id, sum(price.Amount), count(item)
from Order as order
    join order.LineItems as item
    join item.Product as product,
    Catalog as catalog
    join catalog.Prices as price
where order.Paid = false
    and order.Customer = :customer
    and price.Product = product
    and catalog.EffectiveDate &lt; sysdate
    and catalog.EffectiveDate &gt;= all (
        select cat.EffectiveDate 
        from Catalog as cat
        where cat.EffectiveDate &lt; sysdate
    )
group by order
having sum(price.Amount) &gt; :minAmount
order by sum(price.Amount) desc</pre><p>
            What a monster! Actually, in real life, I'm not very keen on subqueries, so my query was 
            really more like this:
        </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.LineItems as item
    join item.Product as product,
    Catalog as catalog
    join catalog.Prices as price
where order.Paid = false
    and order.Customer = :customer
    and price.Product = product
    and catalog = :currentCatalog
group by order
having sum(price.Amount) &gt; :minAmount
order by sum(price.Amount) desc</pre><p>
            The next query counts the number of payments in each status, excluding all payments in the
            <tt class="literal">AwaitingApproval</tt> status where the most recent status change was made by the 
            current user. It translates to an SQL query with two inner joins and a correlated subselect 
            against the <tt class="literal">PAYMENT</tt>, <tt class="literal">PAYMENT_STATUS</tt> and 
            <tt class="literal">PAYMENT_STATUS_CHANGE</tt> tables.
        </p><pre class="programlisting">select count(payment), status.Name 
from Payment as payment 
    join payment.CurrentStatus as status
    join payment.StatusChanges as statusChange
where payment.Status.Name &lt;&gt; PaymentStatus.AwaitingApproval
    or (
        statusChange.TimeStamp = ( 
            select max(change.TimeStamp) 
            from PaymentStatusChange change 
            where change.Payment = payment
        )
        and statusChange.User &lt;&gt; :currentUser
    )
group by status.Name, status.SortOrder
order by status.SortOrder</pre><p>
            If I would have mapped the <tt class="literal">StatusChanges</tt> collection as a list, instead of a set, 
            the query would have been much simpler to write.
        </p><pre class="programlisting">select count(payment), status.Name 
from Payment as payment
    join payment.CurrentStatus as status
where payment.Status.Name &lt;&gt; PaymentStatus.AwaitingApproval
    or payment.StatusChanges[ maxIndex(payment.StatusChanges) ].User &lt;&gt; :currentUser
group by status.Name, status.SortOrder
order by status.SortOrder</pre><p>
            The next query uses the MS SQL Server <tt class="literal">isNull()</tt> function to return all
            the accounts and unpaid payments for the organization to which the current user belongs.
            It translates to an SQL query with three inner joins, an outer join and a subselect against 
            the <tt class="literal">ACCOUNT</tt>, <tt class="literal">PAYMENT</tt>, <tt class="literal">PAYMENT_STATUS</tt>,
            <tt class="literal">ACCOUNT_TYPE</tt>, <tt class="literal">ORGANIZATION</tt> and 
            <tt class="literal">ORG_USER</tt> tables.
        </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.Payments as payment
where :currentUser in elements(account.Holder.Users)
    and PaymentStatus.Unpaid = isNull(payment.CurrentStatus.Name, PaymentStatus.Unpaid)
order by account.Type.SortOrder, account.AccountNumber, payment.DueDate</pre><p>
            For some databases, we would need to do away with the (correlated) subselect.
        </p><pre class="programlisting">select account, payment
from Account as account
    join account.Holder.Users as user
    left outer join account.Payments as payment
where :currentUser = user
    and PaymentStatus.Unpaid = isNull(payment.CurrentStatus.Name, PaymentStatus.Unpaid)
order by account.Type.SortOrder, account.AccountNumber, payment.DueDate</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryhql-tipstricks"></a>14.13.&nbsp;Tips &amp; Tricks</h2></div></div><div></div></div><p>
            You can count the number of query results without actually returning them:
        </p><pre class="programlisting">int count = (int) session.CreateQuery("select count(*) from ....").UniqueResult();</pre><p>
            To order a result by the size of a collection, use the following query:
        </p><pre class="programlisting">select usr.id, usr.Name
from User as usr 
    left join usr.Messages as msg
group by usr.id, usr.Name
order by count(msg)</pre><p>
            If your database supports subselects, you can place a condition upon selection
            size in the where clause of your query:
        </p><pre class="programlisting">from User usr where size(usr.Messages) &gt;= 1</pre><p>
            If your database doesn't support subselects, use the following query:
        </p><pre class="programlisting">select usr.id, usr.Name
from User usr
    join usr.Messages msg
group by usr.id, usr.Name
having count(msg) &gt;= 1</pre><p>
            As this solution can't return a <tt class="literal">User</tt> with zero messages
            because of the inner join, the following form is also useful:
        </p><pre class="programlisting">select usr.id, usr.Name
from User as usr
    left join usr.Messages as msg
group by usr.id, usr.Name
having count(msg) = 0</pre><p>
            Properties of an object can be bound to named query parameters:
        </p><pre class="programlisting">IQuery q = s.CreateQuery("from foo in class Foo where foo.Name=:Name and foo.Size=:Size");
q.SetProperties(fooBean); // fooBean has properties Name and Size
IList foos = q.List();</pre><p>
            Collections are pageable by using the <tt class="literal">IQuery</tt> interface with a filter:
        </p><pre class="programlisting">IQuery q = s.CreateFilter( collection, "" ); // the trivial filter
q.setMaxResults(PageSize);
q.setFirstResult(PageSize * pageNumber);
IList page = q.List();</pre><p>
            Collection elements may be ordered or grouped using a query filter:
        </p><pre class="programlisting">ICollection orderedCollection = s.Filter( collection, "order by this.Amount" );
ICollection counts = s.Filter( collection, "select this.Type, count(this) group by this.Type" );</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="querycriteria"></a>Chapter&nbsp;15.&nbsp;Criteria Queries</h2></div></div><div></div></div><p>
        NHibernate features an intuitive, extensible criteria query API.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-creating"></a>15.1.&nbsp;Creating an <tt class="literal">ICriteria</tt> instance</h2></div></div><div></div></div><p>
            The interface <tt class="literal">NHibernate.ICriteria</tt> represents a query against
            a particular persistent class. The <tt class="literal">ISession</tt> is a factory for
            <tt class="literal">ICriteria</tt> instances.
        </p><pre class="programlisting">ICriteria crit = sess.CreateCriteria&lt;Cat&gt;();
crit.SetMaxResults(50);
List cats = crit.List();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-narrowing"></a>15.2.&nbsp;Narrowing the result set</h2></div></div><div></div></div><p>
            An individual query criterion is an instance of the interface
            <tt class="literal">NHibernate.Expression.ICriterion</tt>. The class
            <tt class="literal">NHibernate.Expression.Expression</tt> defines
            factory methods for obtaining certain built-in
            <tt class="literal">ICriterion</tt> types.
        </p><pre class="programlisting">IList&lt;Cat&gt; cats = sess.CreateCriteria&lt;Cat&gt;()
    .Add( Expression.Like("Name", "Fritz%") )
    .Add( Expression.Between("Weight", minWeight, maxWeight) )
    .List&lt;Cat&gt;();</pre><p>
            Expressions may be grouped logically.
        </p><pre class="programlisting">IList&lt;Cat&gt; cats = sess.CreateCriteria&lt;Cat&gt;()
    .Add( Expression.Like("Name", "Fritz%") )
    .Add( Expression.Or(
        Expression.Eq( "Age", 0 ),
        Expression.IsNull("Age")
    ) )
    .List&lt;Cat&gt;();</pre><pre class="programlisting">IList&lt;Cat&gt; cats = sess.CreateCriteria&lt;Cat&gt;()
    .Add( Expression.In( "Name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .Add( Expression.Disjunction()
        .Add( Expression.IsNull("Age") )
    	.Add( Expression.Eq("Age", 0 ) )
    	.Add( Expression.Eq("Age", 1 ) )
    	.Add( Expression.Eq("Age", 2 ) )
    ) )
    .List&lt;Cat&gt;();</pre><p>
            There are quite a range of built-in criterion types (<tt class="literal">Expression</tt>
            subclasses), but one that is especially useful lets you specify SQL directly.
        </p><pre class="programlisting">
        // Create a string parameter for the SqlString below
        IList&lt;Cat&gt; cats = sess.CreateCriteria&lt;Cat&gt;()
            .Add( Expression.Sql("lower({alias}.Name) like lower(?)", "Fritz%", NHibernateUtil.String )
            .List&lt;Cat&gt;();</pre><p>
            The <tt class="literal">{alias}</tt> placeholder with be replaced by the row alias
            of the queried entity.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-ordering"></a>15.3.&nbsp;Ordering the results</h2></div></div><div></div></div><p>
            You may order the results using <tt class="literal">NHibernate.Expression.Order</tt>.
        </p><pre class="programlisting">IList&lt;Cat&gt; cats = sess.CreateCriteria&lt;Cat&gt;()
    .Add( Expression.Like("Name", "F%")
    .AddOrder( Order.Asc("Name") )
    .AddOrder( Order.Desc("Age") )
    .SetMaxResults(50)
    .List&lt;Cat&gt;();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-associations"></a>15.4.&nbsp;Associations</h2></div></div><div></div></div><p>
            You may easily specify constraints upon related entities by navigating
            associations using <tt class="literal">CreateCriteria()</tt>.
        </p><pre class="programlisting">IList&lt;Cat&gt; cats = sess.CreateCriteria&lt;Cat&gt;()
    .Add( Expression.Like("Name", "F%")
    .CreateCriteria("Kittens")
        .Add( Expression.Like("Name", "F%") )
    .List&lt;Cat&gt;();</pre><p>
            note that the second <tt class="literal">CreateCriteria()</tt> returns a new
            instance of <tt class="literal">ICriteria</tt>, which refers to the elements of
            the <tt class="literal">Kittens</tt> collection.
        </p><p>
            The following, alternate form is useful in certain circumstances.
        </p><pre class="programlisting">IList&lt;Cat&gt; cats = sess.CreateCriteria&lt;Cat&gt;()
    .CreateAlias("Kittens", "kt")
    .CreateAlias("Mate", "mt")
    .Add( Expression.EqProperty("kt.Name", "mt.Name") )
    .List&lt;Cat&gt;();</pre><p>
            (<tt class="literal">CreateAlias()</tt> does not create a new instance of
            <tt class="literal">ICriteria</tt>.)
        </p><p>
            Note that the kittens collections held by the <tt class="literal">Cat</tt> instances
            returned by the previous two queries are <span class="emphasis"><em>not</em></span> pre-filtered
            by the criteria! If you wish to retrieve just the kittens that match the
            criteria, you must use <tt class="literal">SetResultTransformer(Transformers.AliasToEntityMap)</tt>.
        </p><pre class="programlisting">IList cats = sess.CreateCriteria&lt;Cat&gt;()
    .CreateCriteria("Kittens", "kt")
        .Add( Expression.Eq("Name", "F%") )
    .SetResultTransformer(Transformers.AliasToEntityMap)
    .List();
foreach ( IDictionary map in cats )
{
    Cat cat = (Cat) map[CriteriaUtil.RootAlias];
    Cat kitten = (Cat) map["kt"];
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-dynamicfetching"></a>15.5.&nbsp;Dynamic association fetching</h2></div></div><div></div></div><p>
            You may specify association fetching semantics at runtime using
            <tt class="literal">SetFetchMode()</tt>.
        </p><pre class="programlisting">IList&lt;Cat&gt; cats = sess.CreateCriteria&lt;Cat&gt;()
    .Add( Expression.Like("Name", "Fritz%") )
    .SetFetchMode("Mate", FetchMode.Eager)
    .SetFetchMode("Kittens", FetchMode.Eager)
    .List&lt;Cat&gt;();</pre><p>
            This query will fetch both <tt class="literal">Mate</tt> and <tt class="literal">Kittens</tt>
            by outer join. See <a href="#performance-fetching" title="19.1.&nbsp;Fetching strategies">Section&nbsp;19.1, &#8220;Fetching strategies&#8221;</a> for more information.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-examples"></a>15.6.&nbsp;Example queries</h2></div></div><div></div></div><p>
            The class <tt class="literal">NHibernate.Expression.Example</tt> allows
            you to construct a query criterion from a given instance.
        </p><pre class="programlisting">Cat cat = new Cat();
cat.Sex = 'F';
cat.Color = Color.Black;
List&lt;Cat&gt; results = session.CreateCriteria&lt;Cat&gt;()
    .Add( Example.Create(cat) )
    .List&lt;Cat&gt;();</pre><p>
           Version properties, identifiers and associations are ignored. By default,
           null-valued properties and properties which return an empty string from
           the call to <tt class="code">ToString()</tt> are excluded.
        </p><p>
           You can adjust how the <tt class="literal">Example</tt> is applied.
        </p><pre class="programlisting">Example example = Example.Create(cat)
    .ExcludeZeroes()           //exclude null- or zero-valued properties
    .ExcludeProperty("Color")  //exclude the property named "color"
    .IgnoreCase()              //perform case insensitive string comparisons
    .EnableLike();             //use like for string comparisons
IList&lt;Cat&gt; results = session.CreateCriteria&lt;Cat&gt;()
    .Add(example)
    .List&lt;Cat&gt;();</pre><p>
            You can even use examples to place criteria upon associated objects.
        </p><pre class="programlisting">IList&lt;Cat&gt; results = session.CreateCriteria&lt;Cat&gt;()
    .Add( Example.Create(cat) )
    .CreateCriteria("Mate")
        .Add( Example.Create( cat.Mate ) )
    .List&lt;Cat&gt;();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-projection"></a>15.7.&nbsp;Projections, aggregation and grouping</h2></div></div><div></div></div><p>
            The class <tt class="literal">NHibernate.Expression.Projections</tt> is a
            factory for <tt class="literal">IProjection</tt> instances. We apply a
            projection to a query by calling <tt class="literal">SetProjection()</tt>.
        </p><pre class="programlisting">IList results = session.CreateCriteria&lt;Cat&gt;()
    .SetProjection( Projections.RowCount() )
    .Add( Expression.Eq("Color", Color.BLACK) )
    .List();</pre><pre class="programlisting">List results = session.CreateCriteria&lt;Cat&gt;()
    .SetProjection( Projections.ProjectionList()
        .Add( Projections.RowCount() )
        .Add( Projections.Avg("Weight") )
        .Add( Projections.Max("Weight") )
        .Add( Projections.GroupProperty("Color") )
    )
    .List();</pre><p>
            There is no explicit "group by" necessary in a criteria query. Certain
            projection types are defined to be <span class="emphasis"><em>grouping projections</em></span>,
            which also appear in the SQL <tt class="literal">group by</tt> clause.
        </p><p>
            An alias may optionally be assigned to a projection, so that the projected value
            may be referred to in restrictions or orderings. Here are two different ways to
            do this:
        </p><pre class="programlisting">IList results = session.CreateCriteria&lt;Cat&gt;()
    .SetProjection( Projections.Alias( Projections.GroupProperty("Color"), "colr" ) )
    .AddOrder( Order.Asc("colr") )
    .List();</pre><pre class="programlisting">IList results = session.CreateCriteria&lt;Cat&gt;()
    .SetProjection( Projections.GroupProperty("Color").As("colr") )
    .AddOrder( Order.Asc("colr") )
    .List();</pre><p>
            The <tt class="literal">Alias()</tt> and <tt class="literal">As()</tt> methods simply wrap a
            projection instance in another, aliased, instance of <tt class="literal">IProjection</tt>.
            As a shortcut, you can assign an alias when you add the projection to a 
            projection list:
        </p><pre class="programlisting">IList results = session.CreateCriteria&lt;Cat&gt;()
    .SetProjection( Projections.ProjectionList()
        .Add( Projections.RowCount(), "catCountByColor" )
        .Add( Projections.Avg("Weight"), "avgWeight" )
        .Add( Projections.Max("Weight"), "maxWeight" )
        .Add( Projections.GroupProperty("Color"), "color" )
    )
    .AddOrder( Order.Desc("catCountByColor") )
    .AddOrder( Order.Desc("avgWeight") )
    .List();</pre><pre class="programlisting">IList results = session.CreateCriteria&lt;DomesticCat&gt;("cat")
    .CreateAlias("kittens", "kit")
    .SetProjection( Projections.ProjectionList()
        .Add( Projections.Property("cat.Name"), "catName" )
        .Add( Projections.Property("kit.Name"), "kitName" )
    )
    .AddOrder( Order.Asc("catName") )
    .AddOrder( Order.Asc("kitName") )
    .List();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycriteria-detachedqueries"></a>15.8.&nbsp;Detached queries and subqueries</h2></div></div><div></div></div><p>
            The <tt class="literal">DetachedCriteria</tt> class lets you create a query outside the scope 
            of a session, and then later execute it using some arbitrary <tt class="literal">ISession</tt>.
        </p><pre class="programlisting">DetachedCriteria query = DetachedCriteria.For&lt;Cat&gt;()
    .Add( Expression.Eq("sex", 'F') );
    
ISession session = ....;
ITransaction txn = session.BeginTransaction();
IList results = query.GetExecutableCriteria(session).SetMaxResults(100).List();
txn.Commit();
session.Close();</pre><p>
            A <tt class="literal">DetachedCriteria</tt> may also be used to express a subquery. ICriterion
            instances involving subqueries may be obtained via <tt class="literal">Subqueries</tt>
            .
        </p><pre class="programlisting">DetachedCriteria avgWeight = DetachedCriteria.For&lt;Cat&gt;()
    .SetProjection( Projections.Avg("Weight") );
session.CreateCriteria&lt;Cat&gt;()
    .Add( Subqueries.Gt("Weight", avgWeight) )
    .List();</pre><pre class="programlisting">DetachedCriteria weights = DetachedCriteria.For&lt;Cat&gt;()
    .SetProjection( Projections.Property("Weight") );
session.CreateCriteria&lt;Cat&gt;()
    .add( Subqueries.GeAll("Weight", weights) )
    .list();</pre><p>
            Even correlated subqueries are possible:
        </p><pre class="programlisting">DetachedCriteria avgWeightForSex = DetachedCriteria.For&lt;Cat&gt;("cat2")
    .SetProjection( Projections.Avg("Weight") )
    .Add( Expression.EqProperty("cat2.Sex", "cat.Sex") );
session.CreateCriteria&lt;Cat&gt;("cat")
    .Add( Subqueries.Gt("weight", avgWeightForSex) )
    .List();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="queryqueryover"></a>Chapter&nbsp;16.&nbsp;QueryOver Queries</h2></div></div><div></div></div><p>
        The ICriteria API
        is NHibernate's implementation of Query Object.
        NHibernate 3.0 introduces the QueryOver api, which combines the use of
        Extension Methods
        and
        Lambda Expressions
        (both new in .Net 3.5) to provide a statically typesafe wrapper round the ICriteria API.
    </p><p>
        QueryOver uses Lambda Expressions to provide some extra
        syntax to remove the 'magic strings' from your ICriteria queries.
    </p><p>
        So, for example:
    </p><pre class="programlisting">.Add(Expression.Eq("Name", "Smith"))</pre><p>becomes:</p><pre class="programlisting">.Where&lt;Person&gt;(p =&gt; p.Name == "Smith")</pre><p>
        With this kind of syntax there are no 'magic strings', and refactoring tools like
        'Find All References', and 'Refactor-&gt;Rename' work perfectly.
    </p><p>
        Note: QueryOver is intended to remove the references to 'magic strings'
        from the ICriteria API while maintaining it's opaqueness.  It is <span class="underline">not</span> a LINQ provider;
        NHibernate has a built-in Linq provider for this.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-querystructure"></a>16.1.&nbsp;Structure of a Query</h2></div></div><div></div></div><p>
            Queries are created from an ISession using the syntax:
        </p><pre class="programlisting">IList&lt;Cat&gt; cats =
    session.QueryOver&lt;Cat&gt;()
        .Where(c =&gt; c.Name == "Max")
        .List();</pre><p>&nbsp;</p><p>
            Detached QueryOver (analagous to DetachedCriteria) can be created, and then used with an ISession using:
        </p><pre class="programlisting">QueryOver&lt;Cat&gt; query =
    QueryOver.Of&lt;Cat&gt;()
        .Where(c =&gt; c.Name == "Paddy");
        
IList&lt;Cat&gt; cats =
    query.GetExecutableQueryOver(session)
        .List();</pre><p>
            Queries can be built up to use restrictions, projections, and ordering using
            a fluent inline syntax:    
        </p><pre class="programlisting">var catNames =
    session.QueryOver&lt;Cat&gt;()
        .WhereRestrictionOn(c =&gt; c.Age).IsBetween(2).And(8)
        .Select(c =&gt; c.Name)
        .OrderBy(c =&gt; c.Name).Asc
        .List&lt;string&gt;();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-simpleexpressions"></a>16.2.&nbsp;Simple Expressions</h2></div></div><div></div></div><p>
            The Restrictions class (used by ICriteria) has been extended to include overloads
            that allow Lambda Expression syntax.  The Where() method works for simple expressions (&lt;, &lt;=, ==, !=, &gt;, &gt;=)
            so instead of:
        </p><pre class="programlisting">ICriterion equalCriterion = Restrictions.Eq("Name", "Max")</pre><p>
            You can write:
        </p><pre class="programlisting">ICriterion equalCriterion = Restrictions.Where&lt;Cat&gt;(c =&gt; c.Name == "Max")</pre><p>&nbsp;</p><p>
            Since the QueryOver class (and IQueryOver interface) is generic and knows the type of the query,
            there is an inline syntax for restrictions that does not require the additional qualification
            of class name.  So you can also write:
        </p><pre class="programlisting">var cats =
    session.QueryOver&lt;Cat&gt;()
        .Where(c =&gt; c.Name == "Max")
        .And(c =&gt; c.Age &gt; 4)
        .List();</pre><p>
            Note, the methods Where() and And() are semantically identical; the And() method is purely to allow
            QueryOver to look similar to HQL/SQL.
        </p><p>&nbsp;</p><p>
            Boolean comparisons can be made directly instead of comparing to true/false:
        </p><pre class="programlisting">        .Where(p =&gt; p.IsParent)
        .And(p =&gt; !p.IsRetired)</pre><p>&nbsp;</p><p>
            Simple expressions can also be combined using the || and &amp;&amp; operators.  So ICriteria like:
        </p><pre class="programlisting">        .Add(Restrictions.And(
                Restrictions.Eq("Name", "test name"),
                Restrictions.Or(
                    Restrictions.Gt("Age", 21),
                    Restrictions.Eq("HasCar", true))))</pre><p>
            Can be written in QueryOver as:
        </p><pre class="programlisting">        .Where(p =&gt; p.Name == "test name" &amp;&amp; (p.Age &gt; 21 || p.HasCar))</pre><p>&nbsp;</p><p>
            Each of the corresponding overloads in the QueryOver API allows the use of regular ICriterion
            to allow access to private properties.
        </p><pre class="programlisting">        .Where(Restrictions.Eq("Name", "Max"))</pre><p>&nbsp;</p><p>
            It is worth noting that the QueryOver API is built on top of the ICriteria API.  Internally the structures are the same, so at runtime
            the statement below, and the statement above, are stored as exactly the same ICriterion.  The actual Lambda Expression is not stored
            in the query.
        </p><pre class="programlisting">        .Where(c =&gt; c.Name == "Max")</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-additionalrestrictions"></a>16.3.&nbsp;Additional Restrictions</h2></div></div><div></div></div><p>
            Some SQL operators/functions do not have a direct equivalent in C#.
            (e.g., the SQL <tt class="literal">where name like '%anna%'</tt>).
            These operators have overloads for QueryOver in the Restrictions class, so you can write:
        </p><pre class="programlisting">        .Where(Restrictions.On&lt;Cat&gt;(c =&gt; c.Name).IsLike("%anna%"))</pre><p>
            There is also an inline syntax to avoid the qualification of the type:
        </p><pre class="programlisting">        .WhereRestrictionOn(c =&gt; c.Name).IsLike("%anna%")</pre><p>&nbsp;</p><p>
            While simple expressions (see above) can be combined using the || and &amp;&amp; operators, this is not possible with the other
            restrictions.  So this ICriteria:
        </p><pre class="programlisting">        .Add(Restrictions.Or(
            Restrictions.Gt("Age", 5)
            Restrictions.In("Name", new string[] { "Max", "Paddy" })))</pre><p>
            Would have to be written as:
        </p><pre class="programlisting">        .Add(Restrictions.Or(
            Restrictions.Where&lt;Cat&gt;(c =&gt; c.Age &gt; 5)
            Restrictions.On&lt;Cat&gt;(c =&gt; c.Name).IsIn(new string[] { "Max", "Paddy" })))</pre><p>
            However, in addition to the additional restrictions factory methods, there are extension methods to allow
            a more concise inline syntax for some of the operators.  So this:
        </p><pre class="programlisting">        .WhereRestrictionOn(c =&gt; c.Name).IsLike("%anna%")</pre><p>
            May also be written as:
        </p><pre class="programlisting">        .Where(c =&gt; c..Name.IsLike("%anna%"))</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-associations"></a>16.4.&nbsp;Associations</h2></div></div><div></div></div><p>
            QueryOver can navigate association paths using JoinQueryOver() (analagous to ICriteria.CreateCriteria() to create sub-criteria).
        </p><p>
            The factory method QuerOver&lt;T&gt;() on ISession returns an IQueryOver&lt;T&gt;.
            More accurately, it returns an IQueryOver&lt;T,T&gt; (which inherits from IQueryOver&lt;T&gt;).
        </p><p>
            An IQueryOver has two types of interest; the root type (the type of entity that the query returns),
            and the type of the 'current' entity being queried.  For example, the following query uses
            a join to create a sub-QueryOver (analagous to creating sub-criteria in the ICriteria API):
        </p><pre class="programlisting">IQueryOver&lt;Cat,Kitten&gt; catQuery =
    session.QueryOver&lt;Cat&gt;()
        .JoinQueryOver(c =&gt; c.Kittens)
            .Where(k =&gt; k.Name == "Tiddles");</pre><p>
            The JoinQueryOver returns a new instance of the IQueryOver than has its root at the Kittens collection.
            The default type for restrictions is now Kitten (restricting on the name 'Tiddles' in the above example),
            while calling .List() will return an IList&lt;Cat&gt;.  The type IQueryOver&lt;Cat,Kitten&gt; inherits from IQueryOver&lt;Cat&gt;.
        </p><p>
            Note, the overload for JoinQueryOver takes an IEnumerable&lt;T&gt;, and the C# compiler infers the type from that.
            If your collection type is not IEnumerable&lt;T&gt;, then you need to qualify the type of the sub-criteria:
        </p><pre class="programlisting">IQueryOver&lt;Cat,Kitten&gt; catQuery =
    session.QueryOver&lt;Cat&gt;()
        .JoinQueryOver&lt;<span class="emphasis"><em>Kitten</em></span>&gt;(c =&gt; c.Kittens)
            .Where(k =&gt; k.Name == "Tiddles");</pre><p>&nbsp;</p><p>
            The default join is an inner-join.  Each of the additional join types can be specified using
            the methods <tt class="code">.Inner, .Left, .Right,</tt> or <tt class="code">.Full</tt>.
            For example, to left outer-join on Kittens use:
        </p><pre class="programlisting">IQueryOver&lt;Cat,Kitten&gt; catQuery =
    session.QueryOver&lt;Cat&gt;()
        .Left.JoinQueryOver(c =&gt; c.Kittens)
            .Where(k =&gt; k.Name == "Tiddles");</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-aliases"></a>16.5.&nbsp;Aliases</h2></div></div><div></div></div><p>
            In the traditional ICriteria interface aliases are assigned using 'magic strings', however their value
            does not correspond to a name in the object domain.  For example, when an alias is assigned using
            <tt class="code">.CreateAlias("Kitten", "kittenAlias")</tt>, the string "kittenAlias" does not correspond
            to a property or class in the domain.
        </p><p>
            In QueryOver, aliases are assigned using an empty variable.
            The variable can be declared anywhere (but should
            be <tt class="code">null</tt> at runtime).  The compiler can then check the syntax against the variable is
            used correctly, but at runtime the variable is not evaluated (it's just used as a placeholder for
            the alias).
        </p><p>
            Each Lambda Expression function in QueryOver has a corresponding overload to allow use of aliases,
            and a .JoinAlias function to traverse associations using aliases without creating a sub-QueryOver.
        </p><pre class="programlisting">Cat catAlias = null;
Kitten kittenAlias = null;

IQueryOver&lt;Cat,Cat&gt; catQuery =
    session.QueryOver&lt;Cat&gt;(() =&gt; catAlias)
        .JoinAlias(() =&gt; catAlias.Kittens, () =&gt; kittenAlias)
        .Where(() =&gt; catAlias.Age &gt; 5)
        .And(() =&gt; kittenAlias.Name == "Tiddles");</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-projections"></a>16.6.&nbsp;Projections</h2></div></div><div></div></div><p>
            Simple projections of the properties of the root type can be added using the <tt class="code">.Select</tt> method
            which can take multiple Lambda Expression arguments:
        </p><pre class="programlisting">IList selection =
    session.QueryOver&lt;Cat&gt;()
        .Select(
            c =&gt; c.Name,
            c =&gt; c.Age)
        .List&lt;object[]&gt;();</pre><p>
            Because this query no longer returns a Cat, the return type must be explicitly specified.
            If a single property is projected, the return type can be specified using:
        </p><pre class="programlisting">IList&lt;int&gt; ages =
    session.QueryOver&lt;Cat&gt;()
        .Select(c =&gt; c.Age)
        .List&lt;int&gt;();</pre><p>
            However, if multiple properties are projected, then the returned list will contain
            object arrays, as per a projection
            in ICriteria.  This could be fed into an anonymous type using:
        </p><pre class="programlisting">var catDetails =
    session.QueryOver&lt;Cat&gt;()
        .Select(
            c =&gt; c.Name,
            c =&gt; c.Age)
        .List&lt;object[]&gt;()
        .Select(properties =&gt; new {
            CatName = (string)properties[0],
            CatAge = (int)properties[1],
            });
            
Console.WriteLine(catDetails[0].CatName);
Console.WriteLine(catDetails[0].CatAge);</pre><p>
            Note that the second <tt class="code">.Select</tt> call in this example is an extension method on IEnumerable&lt;T&gt; supplied in System.Linq;
            it is not part of NHibernate.
        </p><p>&nbsp;</p><p>
            QueryOver allows arbitrary IProjection to be added (allowing private properties to be projected).  The Projections factory
            class also has overloads to allow Lambda Expressions to be used:
        </p><pre class="programlisting">IList selection =
    session.QueryOver&lt;Cat&gt;()
        .Select(Projections.ProjectionList()
            .Add(Projections.Property&lt;Cat&gt;(c =&gt; c.Name))
            .Add(Projections.Avg&lt;Cat&gt;(c =&gt; c.Age)))
        .List&lt;object[]&gt;();</pre><p>&nbsp;</p><p>
            In addition there is an inline syntax for creating projection lists that does not require the explicit class qualification:
        </p><pre class="programlisting">IList selection =
    session.QueryOver&lt;Cat&gt;()
        .SelectList(list =&gt; list
            .Select(c =&gt; c.Name)
            .SelectAvg(c =&gt; c.Age))
        .List&lt;object[]&gt;();</pre><p>&nbsp;</p><p>
            Projections can also have arbitrary aliases assigned to them to allow result transformation.
            If there is a CatSummary DTO class defined as:
        </p><pre class="programlisting">public class CatSummary
{
    public string Name { get; set; }
    public int AverageAge { get; set; }
}</pre><p>
            ... then aliased projections can be used with the AliasToBean&lt;T&gt; transformer:
        </p><pre class="programlisting">CatSummary summaryDto = null;
IList&lt;CatSummary&gt; catReport =
    session.QueryOver&lt;Cat&gt;()
        .SelectList(list =&gt; list
            .SelectGroup(c =&gt; c.Name).WithAlias(() =&gt; summaryDto.Name)
            .SelectAvg(c =&gt; c.Age).WithAlias(() =&gt; summaryDto.AverageAge))
        .TransformUsing(Transformers.AliasToBean&lt;CatSummary&gt;())
        .List&lt;CatSummary&gt;();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-projectionfunctions"></a>16.7.&nbsp;Projection Functions</h2></div></div><div></div></div><p>
            In addition to projecting properties, there are extension methods to allow certain common dialect-registered
            functions to be applied.  For example you can write the following to extract just the year part of a date:
        </p><pre class="programlisting">        .Where(p =&gt; p.BirthDate.YearPart() == 1971)</pre><p>
            The functions can also be used inside projections:
        </p><pre class="programlisting">        .Select(
            p =&gt; Projections.Concat(p.LastName, ", ", p.FirstName),
            p =&gt; p.Height.Abs())</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queryqueryover-subqueries"></a>16.8.&nbsp;Subqueries</h2></div></div><div></div></div><p>
            The Subqueries factory class has overloads to allow Lambda Expressions to express sub-query
            restrictions.  For example:
        </p><pre class="programlisting">QueryOver&lt;Cat&gt; maximumAge =
    QueryOver.Of&lt;Cat&gt;()
        .SelectList(p =&gt; p.SelectMax(c =&gt; c.Age));

IList&lt;Cat&gt; oldestCats =
    session.QueryOver&lt;Cat&gt;()
        .Where(Subqueries.WhereProperty&lt;Cat&gt;(c =&gt; c.Age).Eq(maximumAge))
        .List();</pre><p>&nbsp;</p><p>
            The inline syntax allows you to use subqueries without requalifying the type:
        </p><pre class="programlisting">IList&lt;Cat&gt; oldestCats =
    session.QueryOver&lt;Cat&gt;()
        .WithSubquery.WhereProperty(c =&gt; c.Age).Eq(maximumAge)
        .List();</pre><p>&nbsp;</p><p>
            There is an extension method <tt class="code">As()</tt> on (a detached) QueryOver that allows you to cast it to any type.
            This is used in conjunction with the overloads <tt class="code">Where(), WhereAll(),</tt> and <tt class="code">WhereSome()</tt>
            to allow use of the built-in C# operators for comparison, so the above query can be written as:
        </p><pre class="programlisting">IList&lt;Cat&gt; oldestCats =
    session.QueryOver&lt;Cat&gt;()
        .WithSubquery.Where(c =&gt; c.Age == maximumAge.As&lt;int&gt;())
        .List();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="querysql"></a>Chapter&nbsp;17.&nbsp;Native SQL</h2></div></div><div></div></div><p>You may also express queries in the native SQL dialect of your
  database. This is useful if you want to utilize database specific features
  such as query hints or the <tt class="literal">CONNECT</tt> keyword in Oracle. It
  also provides a clean migration path from a direct SQL/ADO.NET based
  application to NHibernate.</p><p>NHibernate allows you to specify handwritten SQL (including stored
  procedures) for all create, update, delete, and load operations.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-creating"></a>17.1.&nbsp;Using an <tt class="literal">ISQLQuery</tt></h2></div></div><div></div></div><p>Execution of native SQL queries is controlled via the
    <tt class="literal">ISQLQuery</tt> interface, which is obtained by calling
    <tt class="literal">ISession.CreateSQLQuery()</tt>. The following describes how
    to use this API for querying.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11290"></a>17.1.1.&nbsp;Scalar queries</h3></div></div><div></div></div><p>The most basic SQL query is to get a list of scalars
      (values).</p><pre class="programlisting">sess.CreateSQLQuery("SELECT * FROM CATS")
 .AddScalar("ID", NHibernateUtil.Int64)
 .AddScalar("NAME", NHibernateUtil.String)
 .AddScalar("BIRTHDATE", NHibernateUtil.Date)
</pre><p>This query specified:</p><div class="itemizedlist"><ul type="disc"><li><p>the SQL query string</p></li><li><p>the columns and types to return</p></li></ul></div><p>This will return an IList of Object arrays (object[]) with
      scalar values for each column in the CATS table. Only these three
      columns will be returned, even though the query is using
      <tt class="literal">*</tt> and could return more than the three listed
      columns.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11311"></a>17.1.2.&nbsp;Entity queries</h3></div></div><div></div></div><p>The above query was about returning scalar values,
      basically returning the "raw" values from the result set. The following
      shows how to get entity objects from a native SQL query via
      <tt class="literal">AddEntity()</tt>.</p><pre class="programlisting">sess.CreateSQLQuery("SELECT * FROM CATS").AddEntity(typeof(Cat));
sess.CreateSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").AddEntity(typeof(Cat));
</pre><p>This query specified:</p><div class="itemizedlist"><ul type="disc"><li><p>the SQL query string</p></li><li><p>the entity returned by the query</p></li></ul></div><p>Assuming that Cat is mapped as a class with the columns ID, NAME
      and BIRTHDATE the above queries will both return an IList where each
      element is a Cat entity.</p><p>If the entity is mapped with a <tt class="literal">many-to-one</tt> to
      another entity it is required to also return its identifier when
      performing the native query, otherwise a database specific "column not
      found" error will occur. The additional columns will automatically be
      returned when using the * notation, but we prefer to be explicit as in
      the following example for a <tt class="literal">many-to-one</tt> to a
      <tt class="literal">Dog</tt>:</p><pre class="programlisting">sess.CreateSQLQuery("SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS").AddEntity(typeof(Cat));
</pre><p>This will allow cat.Dog property access to function properly.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11347"></a>17.1.3.&nbsp;Handling associations and collections</h3></div></div><div></div></div><p>It is possible to eagerly join in the <tt class="literal">Dog</tt> to
      avoid the possible extra roundtrip for initializing the proxy. This is
      done via the <tt class="literal">AddJoin()</tt> method, which allows you to
      join in an association or collection.</p><pre class="programlisting">sess.CreateSQLQuery("SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID")
 .AddEntity("cat", typeof(Cat))
 .AddJoin("cat.Dog");
</pre><p>In this example the returned <tt class="literal">Cat</tt>'s will have
      their <tt class="literal">Dog</tt> property fully initialized without any
      extra roundtrip to the database. Notice that we added a alias name
      ("cat") to be able to specify the target property path of the join. It
      is possible to do the same eager joining for collections, e.g. if the
      <tt class="literal">Cat</tt> had a one-to-many to <tt class="literal">Dog</tt>
      instead.</p><pre class="programlisting">sess.CreateSQLQuery("SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID")
 .AddEntity("cat", typeof(Cat))
 .AddJoin("cat.Dogs");
</pre><p>At this stage we are reaching the limits of what is possible with
      native queries without starting to enhance the SQL queries to make them
      usable in NHibernate; the problems start to arise when returning
      multiple entities of the same type or when the default alias/column
      names are not enough.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11378"></a>17.1.4.&nbsp;Returning multiple entities</h3></div></div><div></div></div><p>Until now the result set column names are assumed to be the same
      as the column names specified in the mapping document. This can be
      problematic for SQL queries which join multiple tables, since the same
      column names may appear in more than one table.</p><p>Column alias injection is needed in the following query (which
      most likely will fail):</p><pre class="programlisting">sess.CreateSQLQuery("SELECT c.*, m.*  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID")
 .AddEntity("cat", typeof(Cat))
 .AddEntity("mother", typeof(Cat))
</pre><p>The intention for this query is to return two Cat instances per
      row, a cat and its mother. This will fail since there is a conflict of
      names since they are mapped to the same column names and on some
      databases the returned column aliases will most likely be on the form
      "c.ID", "c.NAME", etc. which are not equal to the columns specificed in
      the mappings ("ID" and "NAME").</p><p>The following form is not vulnerable to column name
      duplication:</p><pre class="programlisting">sess.CreateSQLQuery("SELECT {cat.*}, {mother.*}  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID")
 .AddEntity("cat", typeof(Cat))
 .AddEntity("mother", typeof(Cat))
</pre><p>This query specified:</p><div class="itemizedlist"><ul type="disc"><li><p>the SQL query string, with placeholders for NHibernate to
          inject column aliases</p></li><li><p>the entities returned by the query</p></li></ul></div><p>The {cat.*} and {mother.*} notation used above is a shorthand for
      "all properties". Alternatively, you may list the columns explicity, but
      even in this case we let NHibernate inject the SQL column aliases for
      each property. The placeholder for a column alias is just the property
      name qualified by the table alias. In the following example, we retrieve
      Cats and their mothers from a different table (cat_log) to the one
      declared in the mapping metadata. Notice that we may even use the
      property aliases in the where clause if we like.</p><pre class="programlisting">String sql = "SELECT ID as {c.Id}, NAME as {c.Name}, " + 
         "BIRTHDATE as {c.BirthDate}, MOTHER_ID as {c.Mother}, {mother.*} " +
         "FROM CAT_LOG c, CAT_LOG m WHERE {c.Mother} = c.ID";

IList loggedCats = sess.CreateSQLQuery(sql)
        .AddEntity("cat", typeof(Cat))
        .AddEntity("mother", typeof(Cat)).List();
</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="querysql-aliasreferences"></a>17.1.4.1.&nbsp;Alias and property references</h4></div></div><div></div></div><p>For most cases the above alias injection is needed, but for
        queries relating to more complex mappings like composite properties,
        inheritance discriminators, collections etc. there are some specific
        aliases to use to allow NHibernate to inject the proper aliases.</p><p>The following table shows the different possibilities of using
        the alias injection. Note: the alias names in the result are examples,
        each alias will have a unique and probably different name when
        used.</p><div class="table"><a name="aliasinjection-summary"></a><p class="title"><b>Table&nbsp;17.1.&nbsp;Alias injection names</b></p><table summary="Alias injection names" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Description</th><th>Syntax</th><th>Example</th></tr></thead><tbody><tr><td>A simple property</td><td><tt class="literal">{[aliasname].[propertyname]}</tt></td><td><tt class="literal">A_NAME as {item.Name}</tt></td></tr><tr><td>A composite property</td><td><tt class="literal">{[aliasname].[componentname].[propertyname]}</tt></td><td><tt class="literal">CURRENCY as {item.Amount.Currency}, VALUE as
                {item.Amount.Value}</tt></td></tr><tr><td>Discriminator of an entity</td><td><tt class="literal">{[aliasname].class}</tt></td><td><tt class="literal">DISC as {item.class}</tt></td></tr><tr><td>All properties of an entity</td><td><tt class="literal">{[aliasname].*}</tt></td><td><tt class="literal">{item.*}</tt></td></tr><tr><td>A collection key</td><td><tt class="literal">{[aliasname].key}</tt></td><td><tt class="literal">ORGID as {coll.key}</tt></td></tr><tr><td>The id of an collection</td><td><tt class="literal">{[aliasname].id}</tt></td><td><tt class="literal">EMPID as {coll.id}</tt></td></tr><tr><td>The element of an collection</td><td><tt class="literal">{[aliasname].element}</tt></td><td><tt class="literal">XID as {coll.element}</tt></td></tr><tr><td>property of the element in the collection</td><td><tt class="literal">{[aliasname].element.[propertyname]}</tt></td><td><tt class="literal">NAME as {coll.element.Name}</tt></td></tr><tr><td>All properties of the element in the collection</td><td><tt class="literal">{[aliasname].element.*}</tt></td><td><tt class="literal">{coll.element.*}</tt></td></tr><tr><td>All properties of the the collection</td><td><tt class="literal">{[aliasname].*}</tt></td><td><tt class="literal">{coll.*}</tt></td></tr></tbody></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11519"></a>17.1.5.&nbsp;Returning non-managed entities</h3></div></div><div></div></div><p>It is possible to apply an <tt class="literal">IResultTransformer</tt> to native sql queries. Allowing it to e.g. return non-managed entities.</p><pre class="programlisting">sess.CreateSQLQuery("SELECT NAME, BIRTHDATE FROM CATS")
        .SetResultTransformer(Transformers.AliasToBean&lt;CatDTO&gt;())</pre><p>This query specified:</p><div class="itemizedlist"><ul type="disc"><li><p>the SQL query string</p></li><li><p>a result transformer</p></li></ul></div><p>
        The above query will return a list of <tt class="literal">CatDTO</tt> which has been instantiated and injected the values of NAME and BIRTHNAME into its corresponding
        properties or fields.
        </p><p>
			IMPORTANT: The custom <tt class="literal">IResultTransformer</tt> should override <tt class="literal">Equals</tt> and <tt class="literal">GetHashCode</tt>, 
			otherwise the query translation won't be cached. This also will result in memory leak.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11554"></a>17.1.6.&nbsp;Handling inheritance</h3></div></div><div></div></div><p>Native SQL queries which query for entities that are mapped as part
      of an inheritance hierarchy must include all properties for the base class and all
      its subclasses.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11559"></a>17.1.7.&nbsp;Parameters</h3></div></div><div></div></div><p>Native SQL queries support positional as well as named
      parameters:</p><pre class="programlisting">Query query = sess.CreateSQLQuery("SELECT * FROM CATS WHERE NAME like ?").AddEntity(typeof(Cat));
IList pusList = query.SetString(0, "Pus%").List();
     
query = sess.CreateSQLQuery("SELECT * FROM CATS WHERE NAME like :name").AddEntity(typeof(Cat));
IList pusList = query.SetString("name", "Pus%").List();          </pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-namedqueries"></a>17.2.&nbsp;Named SQL queries</h2></div></div><div></div></div><p>Named SQL queries may be defined in the mapping document and called
    in exactly the same way as a named HQL query. In this case, we do
    <span class="emphasis"><em>not</em></span> need to call
    <tt class="literal">AddEntity()</tt>.</p><pre class="programlisting">&lt;sql-query name="persons"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    SELECT person.NAME AS {person.Name},
           person.AGE AS {person.Age},
           person.SEX AS {person.Sex}
    FROM PERSON person
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><pre class="programlisting">IList people = sess.GetNamedQuery("persons")
    .SetString("namePattern", namePattern)
    .SetMaxResults(50)
    .List();</pre><p>The <tt class="literal">&lt;return-join&gt;</tt> and
    <tt class="literal">&lt;load-collection&gt;</tt> elements are used to join
    associations and define queries which initialize collections,
    respectively.</p><pre class="programlisting">&lt;sql-query name="personsWith"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.MailingAddress"/&gt;
    SELECT person.NAME AS {person.Name},
           person.AGE AS {person.Age},
           person.SEX AS {person.Sex},
           adddress.STREET AS {address.Street},
           adddress.CITY AS {address.City},
           adddress.STATE AS {address.State},
           adddress.ZIP AS {address.Zip}
    FROM PERSON person
    JOIN ADDRESS adddress
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><p>A named SQL query may return a scalar value. You must declare the
    column alias and NHibernate type using the
    <tt class="literal">&lt;return-scalar&gt;</tt> element:</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return-scalar column="name" type="String"/&gt;
    &lt;return-scalar column="age" type="Int64"/&gt;
    SELECT p.NAME AS name,
           p.AGE AS age,
    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'
&lt;/sql-query&gt;</pre><p>You can externalize the resultset mapping informations in a
    <tt class="literal">&lt;resultset&gt;</tt> element to either reuse them accross
    several named queries or through the
    <tt class="literal">SetResultSetMapping()</tt> API.</p><pre class="programlisting">&lt;resultset name="personAddress"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.MailingAddress"/&gt;
&lt;/resultset&gt;

&lt;sql-query name="personsWith" resultset-ref="personAddress"&gt;
    SELECT person.NAME AS {person.Name},
           person.AGE AS {person.Age},
           person.SEX AS {person.Sex},
           adddress.STREET AS {address.Street},
           adddress.CITY AS {address.City},
           adddress.STATE AS {address.State},
           adddress.ZIP AS {address.Zip}
    FROM PERSON person
    JOIN ADDRESS adddress
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><p>You can alternatively use the resultset mapping information in your
    .hbm.xml files directly in code.</p><pre class="programlisting">IList cats = sess.CreateSQLQuery(
        "select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id"
    )
    .SetResultSetMapping("catAndKitten")
    .List();</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="propertyresults"></a>17.2.1.&nbsp;Using return-property to explicitly specify column/alias
      names</h3></div></div><div></div></div><p>With <tt class="literal">&lt;return-property&gt;</tt> you can explicitly
      tell NHibernate what column aliases to use, instead of using the
      <tt class="literal">{}</tt>-syntax to let NHibernate inject its own
      aliases.</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return alias="person" class="eg.Person"&gt;
        &lt;return-property name="Name" column="myName"/&gt;
        &lt;return-property name="Age" column="myAge"/&gt;
        &lt;return-property name="Sex" column="mySex"/&gt;
    &lt;/return&gt;
    SELECT person.NAME AS myName,
           person.AGE AS myAge,
           person.SEX AS mySex,
    FROM PERSON person WHERE person.NAME LIKE :name
&lt;/sql-query&gt;
</pre><p><tt class="literal">&lt;return-property&gt;</tt> also works with
      multiple columns. This solves a limitation with the
      <tt class="literal">{}</tt>-syntax which can not allow fine grained control of
      multi-column properties.</p><pre class="programlisting">&lt;sql-query name="organizationCurrentEmployments"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="Salary"&gt;
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;
        &lt;/return-property&gt;
        &lt;return-property name="EndDate" column="myEndDate"/&gt;
    &lt;/return&gt;
        SELECT EMPLOYEE AS {emp.Employee}, EMPLOYER AS {emp.Employer},
        STARTDATE AS {emp.StartDate}, ENDDATE AS {emp.EndDate},
        REGIONCODE as {emp.RegionCode}, EID AS {emp.Id}, VALUE, CURRENCY
        FROM EMPLOYMENT
        WHERE EMPLOYER = :id AND ENDDATE IS NULL
        ORDER BY STARTDATE ASC
&lt;/sql-query&gt;</pre><p>Notice that in this example we used
      <tt class="literal">&lt;return-property&gt;</tt> in combination with the
      <tt class="literal">{}</tt>-syntax for injection, allowing users to choose how
      they want to refer column and properties.</p><p>If your mapping has a discriminator you must use
      <tt class="literal">&lt;return-discriminator&gt;</tt> to specify the
      discriminator column.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sp_query"></a>17.2.2.&nbsp;Using stored procedures for querying</h3></div></div><div></div></div><p>NHibernate introduces support for queries via stored procedures
      and functions. Most of the following documentation is equivalent for
      both. The stored procedure/function must return a resultset to be able to work
      with NHibernate. An example of such a stored function in MS SQL Server 2000 and
      higher is as follows:</p><pre class="programlisting">CREATE PROCEDURE selectAllEmployments AS
    SELECT EMPLOYEE, EMPLOYER, STARTDATE, ENDDATE,
    REGIONCODE, EMPID, VALUE, CURRENCY
    FROM EMPLOYMENT
</pre><p>To use this query in NHibernate you need to map it via a named
      query.</p><pre class="programlisting">&lt;sql-query name="selectAllEmployments_SP"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="employee" column="EMPLOYEE"/&gt;
        &lt;return-property name="employer" column="EMPLOYER"/&gt;
        &lt;return-property name="startDate" column="STARTDATE"/&gt;
        &lt;return-property name="endDate" column="ENDDATE"/&gt;
        &lt;return-property name="regionCode" column="REGIONCODE"/&gt;
        &lt;return-property name="id" column="EID"/&gt;
        &lt;return-property name="salary"&gt;
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;
        &lt;/return-property&gt;
    &lt;/return&gt;
    exec selectAllEmployments
&lt;/sql-query&gt;</pre><p>Notice that stored procedures currently only return scalars and
      entities. <tt class="literal">&lt;return-join&gt;</tt> and
      <tt class="literal">&lt;load-collection&gt;</tt> are not supported.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="querysql-limits-storedprocedures"></a>17.2.2.1.&nbsp;Rules/limitations for using stored procedures</h4></div></div><div></div></div><p>To use stored procedures with NHibernate the procedures/functions
        have to follow some rules. If they do not follow those rules they are
        not usable with NHibernate. If you still want to use these procedures
        you have to execute them via <tt class="literal">session.Connection</tt>.
        The rules are different for each database, since database vendors have
        different stored procedure semantics/syntax.</p><p>Stored procedure queries can't be paged with
        <tt class="literal">SetFirstResult()/SetMaxResults()</tt>.</p><p>Recommended call form is dependent on your database. For MS
        SQL Server use <tt class="literal">exec functionName &lt;parameters&gt;</tt>.
        </p><p>For Oracle the following rules apply:</p><div class="itemizedlist"><ul type="disc" compact><li><p>A function must return a result set. The first parameter of
            a procedure must be an <tt class="literal">OUT</tt> that returns a
            result set. This is done by using a
            <tt class="literal">SYS_REFCURSOR</tt> type in Oracle 9i or later. In Oracle
            you need to define a <tt class="literal">REF CURSOR</tt> type, see
            Oracle literature.</p></li></ul></div><p>For MS SQL server the following rules apply:</p><div class="itemizedlist"><ul type="disc" compact><li><p>The procedure must return a result set. NHibernate will
            use <tt class="literal">IDbCommand.ExecuteReader()</tt> to obtain
            the results.
            </p></li><li><p>If you can enable <tt class="literal">SET NOCOUNT ON</tt> in your
            procedure it will probably be more efficient, but this is not a
            requirement.</p></li></ul></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-cud"></a>17.3.&nbsp;Custom SQL for create, update and delete</h2></div></div><div></div></div><p>NHibernate can use custom SQL statements for create, update, and
    delete operations. The class and collection persisters in NHibernate
    already contain a set of configuration time generated strings (insertsql,
    deletesql, updatesql etc.). The mapping tags
    <tt class="literal">&lt;sql-insert&gt;</tt>,
    <tt class="literal">&lt;sql-delete&gt;</tt>, and
    <tt class="literal">&lt;sql-update&gt;</tt> override these strings:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )&lt;/sql-insert&gt;
    &lt;sql-update&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-update&gt;
    &lt;sql-delete&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;
&lt;/class&gt;</pre><p>Note that the custom <tt class="literal">sql-insert</tt> will not be used
    if you use <tt class="literal">identity</tt> to generate identifier values for
    the class.
    </p><p>The SQL is directly executed in your database, so you are free to
    use any dialect you like. This will of course reduce the portability of
    your mapping if you use database specific SQL.</p><p>Stored procedures are supported if the database-native syntax is used:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert&gt;exec createPerson ?, ?&lt;/sql-insert&gt;
    &lt;sql-delete&gt;exec deletePerson ?&lt;/sql-delete&gt;
    &lt;sql-update&gt;exec updatePerson ?, ?&lt;/sql-update&gt;
&lt;/class&gt;</pre><p>The order of the positional parameters is currently vital, as they
    must be in the same sequence as NHibernate expects them.</p><p>You can see the expected order by enabling debug logging for the
    <tt class="literal">NHibernate.Persister.Entity</tt> level. With this level
    enabled NHibernate will print out the static SQL that is used to create,
    update, delete etc. entities. (To see the expected sequence, remember to
    not include your custom SQL in the mapping files as that will override the
    NHibernate generated static sql.)</p><p>The stored procedures are by default required to affect the same number
    of rows as NHibernate-generated SQL would. NHibernate uses
    <tt class="literal">IDbCommand.ExecuteNonQuery</tt> to retrieve the number of rows
    affected. This check can be disabled by using <tt class="literal">check="none"</tt>
    attribute in <tt class="literal">sql-insert</tt> element.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querysql-load"></a>17.4.&nbsp;Custom SQL for loading</h2></div></div><div></div></div><p>You may also declare your own SQL (or HQL) queries for entity
    loading:</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person" lock-mode="upgrade"/&gt;
    SELECT NAME AS {pers.Name}, ID AS {pers.Id}
    FROM PERSON
    WHERE ID=?
    FOR UPDATE
&lt;/sql-query&gt;</pre><p>This is just a named query declaration, as discussed earlier. You
    may reference this named query in a class mapping:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="Id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="Name" not-null="true"/&gt;
    &lt;loader query-ref="person"/&gt;
&lt;/class&gt;</pre><p>This even works with stored procedures.</p><p>You may even define a query for collection loading:</p><pre class="programlisting">&lt;set name="Employments" inverse="true"&gt;
    &lt;key/&gt;
    &lt;one-to-many class="Employment"/&gt;
    &lt;loader query-ref="employments"/&gt;
&lt;/set&gt;</pre><pre class="programlisting">&lt;sql-query name="employments"&gt;
    &lt;load-collection alias="emp" role="Person.Employments"/&gt;
    SELECT {emp.*}
    FROM EMPLOYMENT emp
    WHERE EMPLOYER = :id
    ORDER BY STARTDATE ASC, EMPLOYEE ASC
&lt;/sql-query&gt;</pre><p>You could even define an entity loader that loads a collection by
    join fetching:</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person"/&gt;
    &lt;return-join alias="emp" property="pers.Employments"/&gt;
    SELECT NAME AS {pers.*}, {emp.*}
    FROM PERSON pers
    LEFT OUTER JOIN EMPLOYMENT emp
        ON pers.ID = emp.PERSON_ID
    WHERE ID=?
&lt;/sql-query&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="filters"></a>Chapter&nbsp;18.&nbsp;Filtering data</h2></div></div><div></div></div><p>
        NHibernate provides an innovative new approach to handling data with "visibility" rules.
        A <span class="emphasis"><em>NHibernate filter</em></span> is a global, named, parameterized filter that may be 
        enabled or disabled for a particular NHibernate session.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectstate-filters"></a>18.1.&nbsp;NHibernate filters</h2></div></div><div></div></div><p>
            NHibernate adds the ability to pre-define filter criteria and attach those filters at both
            a class and a collection level. A filter criteria is the ability to define a restriction clause
            very similiar to the existing "where" attribute available on the class and various collection
            elements. Except these filter conditions can be parameterized. The application can then make
            the decision at runtime whether given filters should be enabled and what their parameter
            values should be. Filters can be used like database views, but parameterized inside the
            application.
        </p><p>
            In order to use filters, they must first be defined and then attached to the appropriate
            mapping elements. To define a filter, use the <tt class="literal">&lt;filter-def/&gt;</tt> element
            within a <tt class="literal">&lt;hibernate-mapping/&gt;</tt> element:
        </p><pre class="programlisting">&lt;filter-def name="myFilter"&gt;
    &lt;filter-param name="myFilterParam" type="String"/&gt;
&lt;/filter-def&gt;</pre><p>
            Then, this filter can be attached to a class:
        </p><pre class="programlisting">&lt;class name="MyClass" ...&gt;
    ...
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/class&gt;</pre><p>
            or, to a collection:
        </p><pre class="programlisting">&lt;set ...&gt;
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/set&gt;</pre><p>
            or, even to both (or multiples of each) at the same time.
        </p><p>
            The methods on <tt class="literal">ISession</tt> are: <tt class="literal">EnableFilter(string filterName)</tt>,
            <tt class="literal">GetEnabledFilter(string filterName)</tt>, and <tt class="literal">DisableFilter(string filterName)</tt>.
            By default, filters are <span class="emphasis"><em>not</em></span> enabled for a given session; they must be explcitly
            enabled through use of the <tt class="literal">ISession.EnableFilter()</tt> method, which returns an
            instance of the <tt class="literal">IFilter</tt> interface. Using the simple filter defined above, this
            would look like:
        </p><pre class="programlisting">session.EnableFilter("myFilter").SetParameter("myFilterParam", "some-value");</pre><p>
            Note that methods on the <tt class="literal">NHibernate.IFilter</tt> interface do allow the method-chaining
            common to much of NHibernate.
        </p><p>
            A full example, using temporal data with an effective record date pattern:
        </p><pre class="programlisting">&lt;filter-def name="effectiveDate"&gt;
    &lt;filter-param name="asOfDate" type="date"/&gt;
&lt;/filter-def&gt;

&lt;class name="Employee" ...&gt;
...
    &lt;many-to-one name="Department" column="dept_id" class="Department"/&gt;
    &lt;property name="EffectiveStartDate" type="date" column="eff_start_dt"/&gt;
    &lt;property name="EffectiveEndDate" type="date" column="eff_end_dt"/&gt;
...
    &lt;!--
        Note that this assumes non-terminal records have an eff_end_dt set to
        a max db date for simplicity-sake
    --&gt;
    &lt;filter name="effectiveDate"
            condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
&lt;/class&gt;

&lt;class name="Department" ...&gt;
...
    &lt;set name="Employees" lazy="true"&gt;
        &lt;key column="dept_id"/&gt;
        &lt;one-to-many class="Employee"/&gt;
        &lt;filter name="effectiveDate"
                condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
            Then, in order to ensure that you always get back currently effective records, simply
            enable the filter on the session prior to retrieving employee data:
        </p><pre class="programlisting">ISession session = ...;
session.EnableFilter("effectiveDate").SetParameter("asOfDate", DateTime.Today);
IList&lt;Employee&gt; results = session.CreateQuery("from Employee as e where e.Salary &gt; :targetSalary")
         .SetInt64("targetSalary", 1000000L)
         .List&lt;Employee&gt;();
</pre><p>
            In the HQL above, even though we only explicitly mentioned a salary constraint on the results,
            because of the enabled filter the query will return only currently active employees who have
            a salary greater than a million dollars.
        </p><p>
            Note: if you plan on using filters with outer joining (either through HQL or load fetching) be
            careful of the direction of the condition expression.  It's safest to set this up for left
            outer joining; in general, place the parameter first followed by the column name(s) after
            the operator.
        </p><p>
            Default all filter definitions are applied to <tt class="literal">&lt;many-to-one/&gt;</tt> and 
            <tt class="literal">&lt;one-to-one/&gt;</tt> elements. You can turn off this behaviour by
            using <tt class="literal">use-many-to-one</tt> attribute on <tt class="literal">&lt;filter-def/&gt;</tt>
            element.
        </p><pre class="programlisting">&lt;filter-def name="effectiveDate" use-many-to-one="false"/&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="performance"></a>Chapter&nbsp;19.&nbsp;Improving performance</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-fetching"></a>19.1.&nbsp;Fetching strategies</h2></div></div><div></div></div><p>
            A <span class="emphasis"><em>fetching strategy</em></span> is the strategy NHibernate will use for 
            retrieving associated objects if the application needs to navigate the association. 
            Fetch strategies may be declared in the O/R mapping metadata, or overridden by a 
            particular HQL or <tt class="literal">Criteria</tt> query.
        </p><p>
            NHibernate defines the following fetching strategies:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Join fetching</em></span> - NHibernate retrieves the
                    associated instance or collection in the same <tt class="literal">SELECT</tt>,
                    using an <tt class="literal">OUTER JOIN</tt>.
                </p></li><li><p>
                    <span class="emphasis"><em>Select fetching</em></span> - a second <tt class="literal">SELECT</tt>
                    is used to retrieve the associated entity or collection. Unless
                    you explicitly disable lazy fetching by specifying <tt class="literal">lazy="false"</tt>, 
                    this second select will only be executed when you actually access the
                    association.
                </p></li><li><p>
                    <span class="emphasis"><em>Subselect fetching</em></span> - a second <tt class="literal">SELECT</tt>
                    is used to retrieve the associated collections for all entities retrieved in a
                    previous query or fetch. Unless you explicitly disable lazy fetching by specifying 
                    <tt class="literal">lazy="false"</tt>, this second select will only be executed when you 
                    actually access the association.
                </p></li><li><p>
                    <span class="emphasis"><em>"Extra-lazy" collection fetching</em></span> - individual
                    elements of the collection are accessed from the database as needed.
                    NHibernate tries not to fetch the whole collection into memory unless
                    absolutely needed (suitable for very large collections)
                </p></li><li><p>
                    <span class="emphasis"><em>Batch fetching</em></span> - an optimization strategy
                    for select fetching - NHibernate retrieves a batch of entity instances 
                    or collections in a single <tt class="literal">SELECT</tt>, by specifying 
                    a list of primary keys or foreign keys.
                </p></li></ul></div><p>
            NHibernate also distinguishes between:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="emphasis"><em>Immediate fetching</em></span> - an association, collection or
                    attribute is fetched immediately, when the owner is loaded.
                </p></li><li><p>
                    <span class="emphasis"><em>Lazy collection fetching</em></span> - a collection is fetched 
                    when the application invokes an operation upon that collection. (This
                    is the default for collections.)
                </p></li><li><p>
                    <span class="emphasis"><em>Proxy fetching</em></span> - a single-valued association is 
                    fetched when a method other than the identifier getter is invoked
                    upon the associated object.
                </p></li></ul></div><p>
            We have two orthogonal notions here: <span class="emphasis"><em>when</em></span> is the association
            fetched, and <span class="emphasis"><em>how</em></span> is it fetched (what SQL is used). Don't
            confuse them! We use <tt class="literal">fetch</tt> to tune performance. We may use 
            <tt class="literal">lazy</tt> to define a contract for what data is always available 
            in any detached instance of a particular class.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-lazy"></a>19.1.1.&nbsp;Working with lazy associations</h3></div></div><div></div></div><p>
                By default, NHibernate uses lazy select fetching for collections and lazy proxy
                fetching for single-valued associations. These defaults make sense for almost
                all associations in almost all applications. 
            </p><p>
                However, lazy fetching poses one problem that you must be aware of. Access to a 
                lazy association outside of the context of an open NHibernate session will result 
                in an exception. For example:
            </p><pre class="programlisting">s = sessions.OpenSession();
Transaction tx = s.BeginTransaction();
            
User u = s.CreateQuery("from User u where u.Name=:userName")
    .SetString("userName", userName).UniqueResult&lt;User&gt;();
IDictionary permissions = u.Permissions;

tx.Commit();
s.Close();

int accessLevel = (int) permissions["accounts"];  // Error!</pre><p>
                Since the <tt class="literal">permissions</tt> collection was not initialized
                when the <tt class="literal">ISession</tt> was closed, the collection will not
                be able to load its state. <span class="emphasis"><em>NHibernate does not support lazy
                initialization for detached objects</em></span>. The fix is to move the
                code that reads from the collection to just before the transaction
                is committed.
            </p><p>
                Alternatively, we could use a non-lazy collection or association, 
                by specifying <tt class="literal">lazy="false"</tt> for the association mapping.
                However, it is intended that lazy initialization be used for almost all 
                collections and associations. If you define too many non-lazy associations 
                in your object model, NHibernate will end up needing to fetch the entire 
                database into memory in every transaction!
            </p><p>
                On the other hand, we often want to choose join fetching (which is non-lazy by 
                nature) instead of select fetching in a particular transaction. We'll now see
                how to customize the fetching strategy. In NHibernate, the mechanisms for
                choosing a fetch strategy are identical for single-valued associations and
                collections.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-custom"></a>19.1.2.&nbsp;Tuning fetch strategies</h3></div></div><div></div></div><p>
                Select fetching (the default) is extremely vulnerable to N+1 selects problems, 
                so we might want to enable join fetching in the mapping document:
            </p><pre class="programlisting">&lt;set name="Permissions" 
            fetch="join"&gt;
    &lt;key column="userId"/&gt;
    &lt;one-to-many class="Permission"/&gt;
&lt;/set</pre><pre class="programlisting">&lt;many-to-one name="Mother" class="Cat" fetch="join"/&gt;</pre><p>
                The <tt class="literal">fetch</tt> strategy defined in the mapping document affects:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        retrieval via <tt class="literal">Get()</tt> or <tt class="literal">Load()</tt>
                    </p></li><li><p>
                        retrieval that happens implicitly when an association is navigated
                    </p></li><li><p>
                        <tt class="literal">ICriteria</tt> queries
                    </p></li><li><p>
                        HQL queries if <tt class="literal">subselect</tt> fetching is used
                    </p></li></ul></div><p>
                No matter what fetching strategy you use, the defined non-lazy graph is guaranteed
                to be loaded into memory. Note that this might result in several immediate selects
                being used to execute a particular HQL query.
            </p><p>
                Usually, we don't use the mapping document to customize fetching. Instead, we
                keep the default behavior, and override it for a particular transaction, using 
                <tt class="literal">left join fetch</tt> in HQL. This tells NHibernate to fetch 
                the association eagerly in the first select, using an outer join. In the
                <tt class="literal">ICriteria</tt> query API, you would use
                <tt class="literal">SetFetchMode(FetchMode.Join)</tt>.
            </p><p>
                If you ever feel like you wish you could change the fetching strategy used by
                <tt class="literal">Get()</tt> or <tt class="literal">Load()</tt>, simply use a 
                <tt class="literal">ICriteria</tt> query, for example:
            </p><pre class="programlisting">User user = (User) session.CreateCriteria&lt;User&gt;()
                .SetFetchMode("Permissions", FetchMode.Join)
                .Add( Expression.Eq("Id", userId) )
                .UniqueResult();</pre><p>
                (This is NHibernate's equivalent of what some ORM solutions call a "fetch plan".)
            </p><p>
                A completely different way to avoid problems with N+1 selects is to use the 
                second-level cache.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-proxies"></a>19.1.3.&nbsp;Single-ended association proxies</h3></div></div><div></div></div><p>
                Lazy fetching for collections is implemented using NHibernate's own implementation
                of persistent collections. However, a different mechanism is needed for lazy
                behavior in single-ended associations. The target entity of the association must
                be proxied. NHibernate implements lazy initializing proxies for persistent objects
                using runtime bytecode enhancement.
            </p><p>
                By default, NHibernate generates proxies (at startup) for all persistent classes
                and uses them to enable lazy fetching of <tt class="literal">many-to-one</tt> and
                <tt class="literal">one-to-one</tt> associations.
            </p><p>
                The mapping file may declare an interface to use as the proxy interface for that
                class, with the <tt class="literal">proxy</tt> attribute. By default, NHibernate uses a subclass
                of the class. <span class="emphasis"><em>Note that the proxied class must implement a non-private default
                constructor. We recommend this constructor for all persistent classes!</em></span>
            </p><p>
                There are some gotchas to be aware of when extending this approach to polymorphic
                classes, eg.
            </p><pre class="programlisting">&lt;class name="Cat" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                Firstly, instances of <tt class="literal">Cat</tt> will never be castable to
                <tt class="literal">DomesticCat</tt>, even if the underlying instance is an
                instance of <tt class="literal">DomesticCat</tt>:
            </p><pre class="programlisting">Cat cat = session.Load&lt;Cat&gt;(id);  // instantiate a proxy (does not hit the db)
if ( cat.IsDomesticCat ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}</pre><p>
                Secondly, it is possible to break proxy <tt class="literal">==</tt>.
            </p><pre class="programlisting">Cat cat = session.Load&lt;Cat&gt;(id);            // instantiate a Cat proxy
DomesticCat dc = 
        session.Load&lt;DomesticCat&gt;(id);  // acquire new DomesticCat proxy!
System.out.println(cat==dc);                            // false</pre><p>
                However, the situation is not quite as bad as it looks. Even though we now have two references
                to different proxy objects, the underlying instance will still be the same object:
            </p><pre class="programlisting">cat.Weight = 11.0;  // hit the db to initialize the proxy
Console.WriteLine( dc.Weight );  // 11.0</pre><p>
                Third, you may not use a proxy for a <tt class="literal">sealed</tt> class or a class
                with any non-overridable public members.
            </p><p>
                Finally, if your persistent object acquires any resources upon instantiation (eg. in
                initializers or default constructor), then those resources will also be acquired by
                the proxy. The proxy class is an actual subclass of the persistent class.
            </p><p>
                These problems are all due to fundamental limitations in .NET's single inheritance model.
                If you wish to avoid these problems your persistent classes must each implement an interface
                that declares its business methods. You should specify these interfaces in the mapping file. eg.
            </p><pre class="programlisting">&lt;class name="CatImpl" proxy="ICat"&gt;
    ......
    &lt;subclass name="DomesticCatImpl" proxy="IDomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                where <tt class="literal">CatImpl</tt> implements the interface <tt class="literal">ICat</tt> and
                <tt class="literal">DomesticCatImpl</tt> implements the interface <tt class="literal">IDomesticCat</tt>. Then
                proxies for instances of <tt class="literal">ICat</tt> and <tt class="literal">IDomesticCat</tt> may be returned
                by <tt class="literal">Load()</tt> or <tt class="literal">Enumerable()</tt>. (Note that <tt class="literal">List()</tt>
                does not usually return proxies.)
            </p><pre class="programlisting">ICat cat = session.Load&lt;CatImpl&gt;(catid);
IEnumerator iter = session.CreateQuery("from CatImpl as cat where cat.Name='fritz'").Enumerable().GetEnumerator();
iter.MoveNext();
ICat fritz = (ICat) iter.Current;</pre><p>
                Relationships are also lazily initialized. This means you must declare any properties to be of
                type <tt class="literal">ICat</tt>, not <tt class="literal">CatImpl</tt>.
            </p><p>
                Certain operations do <span class="emphasis"><em>not</em></span> require proxy initialization
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                        <tt class="literal">Equals()</tt>, if the persistent class does not override
                        <tt class="literal">Equals()</tt>
                    </p></li><li><p>
                        <tt class="literal">GetHashCode()</tt>, if the persistent class does not override
                        <tt class="literal">GetHashCode()</tt>
                    </p></li><li><p>
                        The identifier getter method
                    </p></li></ul></div><p>
                NHibernate will detect persistent classes that override <tt class="literal">Equals()</tt> or
                <tt class="literal">GetHashCode()</tt>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-initialization"></a>19.1.4.&nbsp;Initializing collections and proxies</h3></div></div><div></div></div><p>
                A <tt class="literal">LazyInitializationException</tt> will be thrown by NHibernate if an uninitialized 
                collection or proxy is accessed outside of the scope of the <tt class="literal">ISession</tt>, ie. when 
                the entity owning the collection or having the reference to the proxy is in the detached state.
            </p><p>
                Sometimes we need to ensure that a proxy or collection is initialized before closing the
                <tt class="literal">ISession</tt>. Of course, we can alway force initialization by calling
                <tt class="literal">cat.Sex</tt> or <tt class="literal">cat.Kittens.Count</tt>, for example.
                But that is confusing to readers of the code and is not convenient for generic code.
            </p><p>
                The static methods <tt class="literal">NHibernateUtil.Initialize()</tt> and <tt class="literal">NHibernateUtil.IsInitialized()</tt>
                provide the application with a convenient way of working with lazily initialized collections or
                proxies. <tt class="literal">NHibernateUtil.Initialize(cat)</tt> will force the initialization of a proxy,
                <tt class="literal">cat</tt>, as long as its <tt class="literal">ISession</tt> is still open.
                <tt class="literal">NHibernateUtil.Initialize( cat.Kittens )</tt> has a similar effect for the collection
                of kittens.
            </p><p>
                Another option is to keep the <tt class="literal">ISession</tt> open until all needed
                collections and proxies have been loaded. In some application architectures,
                particularly where the code that accesses data using NHibernate, and the code that
                uses it are in different application layers or different physical processes, it 
                can be a problem to ensure that the <tt class="literal">ISession</tt> is open when a 
                collection is initialized. There are two basic ways to deal with this issue:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                        In a web-based application, a <tt class="literal">HttpModule</tt> can be used
                        to close the <tt class="literal">ISession</tt> only at the very end of a user
                        request, once the rendering of the view is complete (the <span class="emphasis"><em>Open
                        Session in View</em></span> pattern).  Of course, this places heavy demands
                        on the correctness of the exception handling of your application infrastructure. 
                        It is vitally important that the <tt class="literal">ISession</tt> is closed and the 
                        transaction ended before returning to the user, even when an exception occurs 
                        during rendering of the view. See the NHibernate Wiki for examples of this
                        "Open Session in View" pattern.
                    </p></li><li><p>
                        In an application with a separate business tier, the business logic must
                        "prepare" all collections that will be needed by the web tier before
                        returning. This means that the business tier should load all the data and
                        return all the data already initialized to the presentation/web tier that
                        is required for a particular use case. Usually, the application calls
                        <tt class="literal">NHibernateUtil.Initialize()</tt> for each collection that will
                        be needed in the web tier (this call must occur before the session is closed)
                        or retrieves the collection eagerly using a NHibernate query with a
                        <tt class="literal">FETCH</tt> clause or a <tt class="literal">FetchMode.Join</tt> in
                        <tt class="literal">ICriteria</tt>. This is usually easier if you adopt the
                        <span class="emphasis"><em>Command</em></span> pattern instead of a <span class="emphasis"><em>Session Facade</em></span>.
                    </p></li><li><p>
                        You may also attach a previously loaded object to a new <tt class="literal">ISession</tt>
                        with <tt class="literal">Merge()</tt> or <tt class="literal">Lock()</tt> before
                        accessing uninitialized collections (or other proxies). No, NHibernate does not,
                        and certainly <span class="emphasis"><em>should</em></span> not do this automatically, since it 
                        would introduce ad hoc transaction semantics!
                    </p></li></ul></div><p>
                Sometimes you don't want to initialize a large collection, but still need some
                information about it (like its size) or a subset of the data.
            </p><p>
                You can use a collection filter to get the size of a collection without initializing it:
            </p><pre class="programlisting">(int) s.CreateFilter( collection, "select count(*)" ).List()[0]</pre><p>
                The <tt class="literal">CreateFilter()</tt> method is also used to efficiently retrieve subsets
                of a collection without needing to initialize the whole collection:
            </p><pre class="programlisting">s.CreateFilter( lazyCollection, "").SetFirstResult(0).SetMaxResults(10).List();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-batch"></a>19.1.5.&nbsp;Using batch fetching</h3></div></div><div></div></div><p>
                NHibernate can make efficient use of batch fetching, that is, NHibernate can load several uninitialized
                proxies if one proxy is accessed (or collections. Batch fetching is an optimization of the lazy select
                fetching strategy. There are two ways you can tune batch fetching: on the class and the collection level.
            </p><p>
                Batch fetching for classes/entities is easier to understand. Imagine you have the following situation
                at runtime: You have 25 <tt class="literal">Cat</tt> instances loaded in an <tt class="literal">ISession</tt>, each
                <tt class="literal">Cat</tt> has a reference to its <tt class="literal">Owner</tt>, a <tt class="literal">Person</tt>.
                The <tt class="literal">Person</tt> class is mapped with a proxy, <tt class="literal">lazy="true"</tt>. If you now
                iterate through all cats and call <tt class="literal">cat.Owner</tt> on each, NHibernate will by default
                execute 25 <tt class="literal">SELECT</tt> statements, to retrieve the proxied owners. You can tune this
                behavior by specifying a <tt class="literal">batch-size</tt> in the mapping of <tt class="literal">Person</tt>:
            </p><pre class="programlisting">&lt;class name="Person" batch-size="10"&gt;...&lt;/class&gt;</pre><p>
                NHibernate will now execute only three queries, the pattern is 10, 10, 5.
            </p><p>
                You may also enable batch fetching of collections. For example, if each <tt class="literal">Person</tt> has
                a lazy collection of <tt class="literal">Cat</tt>s, and 10 persons are currently loaded in the
                <tt class="literal">ISesssion</tt>, iterating through all persons will generate 10 <tt class="literal">SELECT</tt>s,
                one for every call to <tt class="literal">person.Cats</tt>. If you enable batch fetching for the
                <tt class="literal">Cats</tt> collection in the mapping of <tt class="literal">Person</tt>, NHibernate can pre-fetch
                collections:
            </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;set name="Cats" batch-size="3"&gt;
        ...
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
                With a <tt class="literal">batch-size</tt> of 3, NHibernate will load 3, 3, 3, 1 collections in four
                <tt class="literal">SELECT</tt>s. Again, the value of the attribute depends on the expected number of
                uninitialized collections in a particular <tt class="literal">Session</tt>.
            </p><p>
                Batch fetching of collections is particularly useful if you have a nested tree of items, ie.
                the typical bill-of-materials pattern. (Although a <span class="emphasis"><em>nested set</em></span> or a
                <span class="emphasis"><em>materialized path</em></span> might be a better option for read-mostly trees.)
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-fetching-subselect"></a>19.1.6.&nbsp;Using subselect fetching</h3></div></div><div></div></div><p>
                If one lazy collection or single-valued proxy has to be fetched, NHibernate loads all of
                them, re-running the original query in a subselect. This works in the same way as
                batch-fetching, without the piecemeal loading.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-cache"></a>19.2.&nbsp;The Second Level Cache</h2></div></div><div></div></div><p>
            A NHibernate <tt class="literal">ISession</tt> is a transaction-level cache of persistent data. It is
            possible to configure a cluster or process-level (<tt class="literal">ISessionFactory</tt>-level) cache on 
            a class-by-class and collection-by-collection basis. You may even plug in a clustered cache. Be 
            careful. Caches are never aware of changes made to the persistent store by another application 
            (though they may be configured to regularly expire cached data).
            <span class="emphasis"><em>In NHibernate 1.x the second level cache does not work correctly in combination with
            distributed transactions.</em></span>
        </p><p>
            By default, NHibernate uses HashtableCache for process-level caching. You may choose a different
            implementation by specifying the name of a class that implements <tt class="literal">NHibernate.Cache.ICacheProvider</tt> 
            using the property <tt class="literal">hibernate.cache.provider_class</tt>.
        </p><div class="table"><a name="cacheproviders"></a><p class="title"><b>Table&nbsp;19.1.&nbsp;Cache Providers</b></p><table summary="Cache Providers" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">Provider class</th><th align="left">Type</th><th align="left">Cluster Safe</th><th align="left">Query Cache Supported</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left"><tt class="literal">NHibernate.Cache.HashtableCacheProvider</tt></td><td align="left">memory</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">ASP.NET Cache (System.Web.Cache)</td><td align="left"><tt class="literal">NHibernate.Caches.SysCache.SysCacheProvider, NHibernate.Caches.SysCache</tt></td><td align="left">memory</td><td align="left">&nbsp;</td><td align="left">yes</td></tr><tr><td align="left">Prevalence Cache</td><td align="left"><tt class="literal">NHibernate.Caches.Prevalence.PrevalenceCacheProvider, NHibernate.Caches.Prevalence</tt></td><td align="left">memory, disk</td><td align="left">&nbsp;</td><td align="left">yes</td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-mapping"></a>19.2.1.&nbsp;Cache mappings</h3></div></div><div></div></div><p>
                The <tt class="literal">&lt;cache&gt;</tt> element of a class or collection mapping has the
                following form:
            </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="read-write|nonstrict-read-write|read-only"                <span class="co">(1)</span>
    region="RegionName"                                              <span class="co">(2)</span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>
                            <tt class="literal">usage</tt> specifies the caching strategy:
                            <tt class="literal">read-write</tt>,
                            <tt class="literal">nonstrict-read-write</tt> or
                            <tt class="literal">read-only</tt>
                        </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>
                            <tt class="literal">region</tt> (optional, defaults to the class or
                            collection role name) specifies the name of the second level cache 
                            region
                        </p></td></tr></table></div></div><p>
                Alternatively (preferrably?), you may specify <tt class="literal">&lt;class-cache&gt;</tt> and 
                <tt class="literal">&lt;collection-cache&gt;</tt> elements in <tt class="literal">hibernate.cfg.xml</tt>.
            </p><p>
                The <tt class="literal">usage</tt> attribute specifies a <span class="emphasis"><em>cache concurrency strategy</em></span>.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readonly"></a>19.2.2.&nbsp;Strategy: read only</h3></div></div><div></div></div><p>
                If your application needs to read but never modify instances of a persistent class, a 
                <tt class="literal">read-only</tt> cache may be used. This is the simplest and best performing
                strategy. Its even perfectly safe for use in a cluster.
            </p><pre class="programlisting">&lt;class name="Eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-readwrite"></a>19.2.3.&nbsp;Strategy: read/write</h3></div></div><div></div></div><p>
                If the application needs to update data, a <tt class="literal">read-write</tt> cache might be appropriate. 
                This cache strategy should never be used if serializable transaction isolation level is required.
                You should ensure that the transaction is completed when <tt class="literal">ISession.Close()</tt> or
                <tt class="literal">ISession.Disconnect()</tt> is called. If you wish to use this strategy in a cluster,
                you should ensure that the underlying cache implementation supports locking. The built-in cache
                providers do <span class="emphasis"><em>not</em></span>.
            </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="Kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-cache-nonstrict"></a>19.2.4.&nbsp;Strategy: nonstrict read/write</h3></div></div><div></div></div><p>
                If the application only occasionally needs to update data (ie. if it is extremely unlikely that two 
                transactions would try to update the same item simultaneously) and strict transaction isolation is
                not required, a <tt class="literal">nonstrict-read-write</tt> cache might be appropriate.
                When using this strategy you should ensure that the transaction is completed when
                <tt class="literal">ISession.Close()</tt> or <tt class="literal">ISession.Disconnect()</tt> is called.
                
            </p></div><p>
            The following table shows which providers are compatible with which concurrency strategies.
        </p><div class="table"><a name="d0e12602"></a><p class="title"><b>Table&nbsp;19.2.&nbsp;Cache Concurrency Strategy Support</b></p><table summary="Cache Concurrency Strategy Support" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">SysCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">PrevalenceCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr></tbody></table></div><p>
            Refer to <a href="#caches" title="Chapter&nbsp;25.&nbsp;NHibernate.Caches">Chapter&nbsp;25, <i>NHibernate.Caches</i></a> for more details.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-sessioncache"></a>19.3.&nbsp;Managing the caches</h2></div></div><div></div></div><p>
            Whenever you pass an object to <tt class="literal">Save()</tt>, <tt class="literal">Update()</tt>
            or <tt class="literal">SaveOrUpdate()</tt> and whenever you retrieve an object using 
            <tt class="literal">Load()</tt>, <tt class="literal">Get()</tt>, <tt class="literal">List()</tt>,
            or <tt class="literal">Enumerable()</tt>, that object is added to the internal cache of the
            <tt class="literal">ISession</tt>.
        </p><p>
            When <tt class="literal">Flush()</tt> is subsequently called, the state of that object will
            be synchronized with the database. If you do not want this synchronization to occur or
            if you are processing a huge number of objects and need to manage memory efficiently,
            the <tt class="literal">Evict()</tt> method may be used to remove the object and its collections
            from the first-level cache.
        </p><pre class="programlisting">IEnumerable&lt;Cat&gt; cats = sess.CreateQuery("from Eg.Cat as cat").Enumerable&lt;Cat&gt;(); //a huge result set
foreach( Cat cat in cats )
{
    DoSomethingWithACat(cat);
    sess.Evict(cat);
}</pre><p>
            NHibernate will evict associated entities automatically if the association is mapped
            with <tt class="literal">cascade="all"</tt> or <tt class="literal">cascade="all-delete-orphan"</tt>.
        </p><p>
            The <tt class="literal">ISession</tt> also provides a <tt class="literal">Contains()</tt> method
            to determine if an instance belongs to the session cache.
        </p><p>
            To completely evict all objects from the session cache, call <tt class="literal">ISession.Clear()</tt>
        </p><p>
            For the second-level cache, there are methods defined on <tt class="literal">ISessionFactory</tt> for 
            evicting the cached state of an instance, entire class, collection instance or entire collection 
            role.
        </p><pre class="programlisting">sessionFactory.Evict&lt;Cat&gt;(catId); //evict a particular Cat
sessionFactory.Evict&lt;Cat&gt;();  //evict all Cats
sessionFactory.EvictCollection("Eg.Cat.Kittens", catId); //evict a particular collection of kittens
sessionFactory.EvictCollection("Eg.Cat.Kittens"); //evict all kitten collections</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-querycache"></a>19.4.&nbsp;The Query Cache</h2></div></div><div></div></div><p>
            Query result sets may also be cached. This is only useful for queries that are run
            frequently with the same parameters. To use the query cache you must first enable it:
        </p><pre class="programlisting">&lt;add key="hibernate.cache.use_query_cache" value="true" /&gt;</pre><p>
            This setting causes the creation of two new cache regions - one holding cached query
            result sets (<tt class="literal">NHibernate.Cache.StandardQueryCache</tt>), the other
            holding timestamps of the most recent updates to queryable tables 
            (<tt class="literal">NHibernate.Cache.UpdateTimestampsCache</tt>). Note that the query
            cache does not cache the state of any entities in the result set; it caches
            only identifier values and results of value type. So the query cache should always be
            used in conjunction with the second-level cache.
        </p><p>
            Most queries do not benefit from caching, so by default queries are not cached. To
            enable caching, call <tt class="literal">IQuery.SetCacheable(true)</tt>. This call allows
            the query to look for existing cache results or add its results to the cache when
            it is executed.
        </p><p>
            If you require fine-grained control over query cache expiration policies, you may
            specify a named cache region for a particular query by calling 
            <tt class="literal">IQuery.SetCacheRegion()</tt>.
        </p><pre class="programlisting">IList&lt;Blog&gt; blogs = sess.CreateQuery("from Blog blog where blog.Blogger = :blogger")
    .SetEntity("blogger", blogger)
    .SetMaxResults(15)
    .SetCacheable(true)
    .SetCacheRegion("frontpages")
    .List&lt;Blog&gt;();</pre><p>
            If the query should force a refresh of its query cache region, you may call
            <tt class="literal">IQuery.SetForceCacheRefresh()</tt> to <tt class="literal">true</tt>.
            This is particularly useful in cases where underlying data may have been updated
            via a saparate process (i.e., not modified through NHibernate) and allows the
            application to selectively refresh the query cache regions based on its
            knowledge of those events. This is a more efficient alternative to eviction of 
            a query cache region via <tt class="literal">ISessionFactory.EvictQueries()</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-collections"></a>19.5.&nbsp;Understanding Collection performance</h2></div></div><div></div></div><p>
            We've already spent quite some time talking about collections.
            In this section we will highlight a couple more issues about
            how collections behave at runtime.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-taxonomy"></a>19.5.1.&nbsp;Taxonomy</h3></div></div><div></div></div><p>NHibernate defines three basic kinds of collections:</p><div class="itemizedlist"><ul type="disc"><li><p>collections of values</p></li><li><p>one to many associations</p></li><li><p>many to many associations</p></li></ul></div><p>
                This classification distinguishes the various table and foreign key
                relationships but does not tell us quite everything we need to know
                about the relational model. To fully understand the relational structure
                and performance characteristics, we must also consider the structure of
                the primary key that is used by NHibernate to update or delete collection
                rows. This suggests the following classification:
            </p><div class="itemizedlist"><ul type="disc"><li><p>indexed collections</p></li><li><p>sets</p></li><li><p>bags</p></li></ul></div><p>
                All indexed collections (maps, lists, arrays) have a primary key consisting
                of the <tt class="literal">&lt;key&gt;</tt> and <tt class="literal">&lt;index&gt;</tt>
                columns. In this case collection updates are usually extremely efficient -
                the primary key may be efficiently indexed and a particular row may be efficiently
                located when NHibernate tries to update or delete it.
            </p><p>
                Sets have a primary key consisting of <tt class="literal">&lt;key&gt;</tt> and element
                columns. This may be less efficient for some types of collection element, particularly
                composite elements or large text or binary fields; the database may not be able to index
                a complex primary key as efficently.  On the other hand, for one to many or many to many
                associations, particularly in the case of synthetic identifiers, it is likely to be just
                as efficient. (Side-note: if you want <tt class="literal">SchemaExport</tt> to actually create
                the primary key of a <tt class="literal">&lt;set&gt;</tt> for you, you must declare all columns
                as <tt class="literal">not-null="true"</tt>.)
            </p><p>
                <tt class="literal">&lt;idbag&gt;</tt> mappings define a surrogate key, so they are
                always very efficient to update. In fact, they are the best case.
            </p><p>
                Bags are the worst case. Since a bag permits duplicate element values and has no
                index column, no primary key may be defined. NHibernate has no way of distinguishing
                between duplicate rows. NHibernate resolves this problem by completely removing
                (in a single <tt class="literal">DELETE</tt>) and recreating the collection whenever it
                changes. This might be very inefficient.
            </p><p>
                Note that for a one-to-many association, the "primary key" may not be the physical
                primary key of the database table - but even in this case, the above classification
                is still useful. (It still reflects how NHibernate "locates" individual rows of the
                collection.)
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficientupdate"></a>19.5.2.&nbsp;Lists, maps, idbags and sets are the most efficient collections to update</h3></div></div><div></div></div><p>
                From the discussion above, it should be clear that indexed collections
                and (usually) sets allow the most efficient operation in terms of adding,
                removing and updating elements.
            </p><p>
                There is, arguably, one more advantage that indexed collections have over sets for
                many to many associations or collections of values. Because of the structure of an
                <tt class="literal">ISet&lt;T&gt;</tt>, NHibernate doesn't ever <tt class="literal">UPDATE</tt> a row when
                an element is "changed". Changes to an <tt class="literal">ISet&lt;T&gt;</tt> always work via
                <tt class="literal">INSERT</tt> and <tt class="literal">DELETE</tt> (of individual rows). Once
                again, this consideration does not apply to one to many associations.
            </p><p>
                After observing that arrays cannot be lazy, we would conclude that lists, maps and
                idbags are the most performant (non-inverse) collection types, with sets not far
                behind. Sets are expected to be the most common kind of collection in NHibernate 
                applications. This is because the "set" semantics are most natural in the relational
                model.
            </p><p>
                However, in well-designed NHibernate domain models, we usually see that most collections
                are in fact one-to-many associations with <tt class="literal">inverse="true"</tt>. For these
                associations, the update is handled by the many-to-one end of the association, and so
                considerations of collection update performance simply do not apply.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-mostefficentinverse"></a>19.5.3.&nbsp;Bags and lists are the most efficient inverse collections</h3></div></div><div></div></div><p>
                Just before you ditch bags forever, there is a particular case in which bags (and also lists)
                are much more performant than sets. For a collection with <tt class="literal">inverse="true"</tt>
                (the standard bidirectional one-to-many relationship idiom, for example) we can add elements
                to a bag or list without needing to initialize (fetch) the bag elements! This is because
                <tt class="literal">IList.Add()</tt> must always succeed for a bag or <tt class="literal">IList</tt>
                (unlike an <tt class="literal">ISet&lt;T&gt;</tt>). This can make the following common code much faster.
            </p><pre class="programlisting">Parent p = sess.Load&lt;Parent&gt;(id);
    Child c = new Child();
    c.Parent = p;
    p.Children.Add(c);  //no need to fetch the collection!
    sess.Flush();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-collections-oneshotdelete"></a>19.5.4.&nbsp;One shot delete</h3></div></div><div></div></div><p>
                Occasionally, deleting collection elements one by one can be extremely inefficient. NHibernate
                isn't completely stupid, so it knows not to do that in the case of an newly-empty collection
                (if you called <tt class="literal">list.Clear()</tt>, for example). In this case, NHibernate will
                issue a single <tt class="literal">DELETE</tt> and we are done!
            </p><p>
                Suppose we add a single element to a collection of size twenty and then remove two elements.
                NHibernate will issue one <tt class="literal">INSERT</tt> statement and two <tt class="literal">DELETE</tt>
                statements (unless the collection is a bag). This is certainly desirable.
            </p><p>
                However, suppose that we remove eighteen elements, leaving two and then add thee new elements.
                There are two possible ways to proceed:
            </p><div class="itemizedlist"><ul type="disc"><li><p>Delete eighteen rows one by one and then insert three rows</p></li><li><p>Remove the whole collection (in one SQL <tt class="literal">DELETE</tt>) and insert
                all five current elements (one by one)</p></li></ul></div><p>
                NHibernate isn't smart enough to know that the second option is probably quicker in this case.
                (And it would probably be undesirable for NHibernate to be that smart; such behaviour might
                confuse database triggers, etc.)
            </p><p>
                Fortunately, you can force this behaviour (ie. the second strategy) at any time by discarding
                (ie. dereferencing) the original collection and returning a newly instantiated collection with
                all the current elements. This can be very useful and powerful from time to time.
            </p><p>
                Of course, one-shot-delete does not apply to collections mapped <tt class="literal">inverse="true"</tt>.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-batch-updates"></a>19.6.&nbsp;Batch updates</h2></div></div><div></div></div><p>
            NHibernate supports batching SQL update commands (<tt class="literal">INSERT</tt>,
            <tt class="literal">UPDATE</tt>, <tt class="literal">DELETE</tt>) with the following limitations:
        </p><div class="itemizedlist"><ul type="disc"><li><p>the Nhibernate's drive used for your RDBMS may not supports batching,</p></li><li><p>since the implementation uses reflection to access members and types
                in System.Data assembly which are not normally visible, it may not function
                in environments where necessary permissions are not granted,</p></li><li><p>optimistic concurrency checking may be impaired since ADO.NET 2.0 does not
                return the number of rows affected by each statement in the batch, only
                the total number of rows affected by the batch.</p></li></ul></div><p>
            Update batching is enabled by setting <tt class="literal">adonet.batch_size</tt>
            to a non-zero value.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-multi-query"></a>19.7.&nbsp;Multi Query</h2></div></div><div></div></div><p>
            This functionality allows you to execute several HQL queries in one round-trip
            against the database server. A simple use case is executing a paged query while
            also getting the total count of results, in a single round-trip. Here is a simple
            example:
        </p><pre class="programlisting">IMultiQuery multiQuery = s.CreateMultiQuery()
    .Add(s.CreateQuery("from Item i where i.Id &gt; ?")
            .SetInt32(0, 50).SetFirstResult(10))
    .Add(s.CreateQuery("select count(*) from Item i where i.Id &gt; ?")
            .SetInt32(0, 50));
IList results = multiQuery.List();
IList items = (IList)results[0];
long count = (long)((IList)results[1])[0];</pre><p>
            The result is a list of query results, ordered according to the order of queries
            added to the multi query. Named parameters can be set on the multi query, and are
            shared among all the queries contained in the multi query, like this:
        </p><pre class="programlisting">IList results = s.CreateMultiQuery()
    .Add(s.CreateQuery("from Item i where i.Id &gt; :id")
        .SetFirstResult(10) )
    .Add("select count(*) from Item i where i.Id &gt; :id")
    .SetInt32("id", 50)
    .List();
IList items = (IList)results[0];
long count = (long)((IList)results[1])[0];</pre><p>
            Positional parameters are not supported on the multi query, only on the individual
            queries.
        </p><p>
            As shown above, if you do not need to configure the query separately, you can simply
            pass the HQL directly to the <tt class="literal">IMultiQuery.Add()</tt> method.
        </p><p>
            Multi query is executed by concatenating the queries and sending the query to the database
            as a single string. This means that the database should support returning several result sets
            in a single query. At the moment this functionality is only enabled for Microsoft SQL Server and SQLite.
        </p><p>
            Note that the database server is likely to impose a limit on the maximum number of parameters
            in a query, in which case the limit applies to the multi query as a whole. Queries using
            <tt class="literal">in</tt> with a large number of arguments passed as parameters may easily exceed
            this limit. For example, SQL Server has a limit of 2,100 parameters per round-trip, and will
            throw an exception executing this query:
        </p><pre class="programlisting">IList allEmployeesId  = ...; //1,500 items
IMultiQuery multiQuery = s.CreateMultiQuery()
	.Add(s.CreateQuery("from Employee e where e.Id in :empIds")
		.SetParameter("empIds", allEmployeesId).SetFirstResult(10))
	.Add(s.CreateQuery("select count(*) from Employee e where e.Id in :empIds")
		.SetParameter("empIds", allEmployeesId));
	IList results = multiQuery.List(); // will throw an exception from SQL Server
	</pre><p>
            An interesting usage of this feature is to load several collections of an object in one
            round-trip, without an expensive cartesian product (blog * users * posts).
        </p><pre class="programlisting">Blog blog = s.CreateMultiQuery()
    .Add("select b from Blog b left join fetch b.Users where b.Id = :id")
    .Add("select b from Blog b left join fetch b.Posts where b.Id = :id")
    .SetInt32("id", 123)
    .UniqueResult&lt;Blog&gt;();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-multi-criteria"></a>19.8.&nbsp;Multi Criteria</h2></div></div><div></div></div><p>
			This is the counter-part to Multi Query, and allows you to perform several criteria queries
			in a single round trip. A simple use case is executing a paged query while
            also getting the total count of results, in a single round-trip. Here is a simple
            example:
        </p><pre class="programlisting">IMultiCriteria multiCrit = s.CreateMultiCriteria()
    .Add(s.CreateCriteria&lt;Item&gt;()
            .Add(Expression.Gt("Id", 50))
            .SetFirstResult(10))
    .Add(s.CreateCriteria&lt;Item&gt;()
            .Add(Expression.Gt("Id", 50))
            .SetProject(Projections.RowCount()));
IList results = multiCrit.List();
IList items = (IList)results[0];
long count = (long)((IList)results[1])[0];</pre><p>
            The result is a list of query results, ordered according to the order of queries
            added to the multi criteria. 
		</p><p>
            You can add <tt class="literal">ICriteria</tt> or <tt class="literal">DetachedCriteria</tt> to the Multi Criteria query.
            In fact, using DetachedCriteria in this fashion has some interesting implications. 
        </p><pre class="programlisting">DetachedCriteria customersCriteria = AuthorizationService.GetAssociatedCustomersQuery();
IList results = session.CreateMultiCriteria()
	.Add(customersCriteria)
	.Add(DetachedCriteria.For&lt;Policy&gt;()
		.Add( Subqueries.PropertyIn("id", CriteriaTransformer.Clone(customersCriteria)
                                                    .SetProjection(Projections.Id())
                      ) )
	).List();

ICollection&lt;Customer&gt; customers = CollectionHelper.ToArray&lt;Customer&gt;(results[0]);
ICollection&lt;Policy&gt; policies = CollectionHelper.ToArray&lt;Policy&gt;(results[1]);</pre><p>
			As you see, we get a query that represnt the customers we can access, and then we can utlize this query further in order to 
			perform additional logic (getting the policies of the customers we are associated with), all in a single database roundtrip.
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="toolsetguide"></a>Chapter&nbsp;20.&nbsp;Toolset Guide</h2></div></div><div></div></div><p>
        Roundtrip engineering with NHibernate is possible using a set of commandline tools 
        maintained as part of the NHibernate project, along with NHibernate support built into
        various code generation tools (MyGeneration, CodeSmith, ObjectMapper, AndroMDA).
    </p><p>
        The NHibernate main package comes bundled with the most important tool (it can even
        be used from "inside" NHibernate on-the-fly):
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            DDL schema generation from a mapping file
            (aka <tt class="literal">SchemaExport</tt>, <tt class="literal">hbm2ddl</tt>)
        </p></li></ul></div><p>
        Other tools directly provided by the NHibernate project are delivered with a separate
        package, <span class="emphasis"><em>NHibernateContrib</em></span>. This package includes tools for
        the following tasks:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            C# source generation from a mapping file (aka <tt class="literal">hbm2net</tt>)
        </p></li><li><p>
            mapping file generation from .NET classes marked with attributes
            (<tt class="literal">NHibernate.Mapping.Attributes</tt>, or NHMA for short)
        </p></li></ul></div><p>
        Third party tools with NHibernate support are:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
            CodeSmith, MyGeneration, and ObjectMapper (mapping file generation from an existing
            database schema)
        </p></li><li><p>
            AndroMDA (MDA (Model-Driven Architecture) approach generating code for
            persistent classes from UML diagrams and their XML/XMI representation)
        </p></li></ul></div><p>
        These 3rd party tools are not documented in this reference. Please refer to the NHibernate
        website for up-to-date information.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s1"></a>20.1.&nbsp;Schema Generation</h2></div></div><div></div></div><p>
            The generated schema includes referential integrity constraints (primary and foreign keys) for entity
            and collection tables. Tables and sequences are also created for mapped identifier generators.
        </p><p>
            You <span class="emphasis"><em>must</em></span> specify a SQL <tt class="literal">Dialect</tt> via the 
            <tt class="literal">hibernate.dialect</tt> property when using this tool.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-2"></a>20.1.1.&nbsp;Customizing the schema</h3></div></div><div></div></div><p>
                Many NHibernate mapping elements define an optional attribute named <tt class="literal">length</tt>. You may set 
                the length of a column with this attribute. (Or, for numeric/decimal data types, the precision.)
            </p><p>
                Some tags also accept a <tt class="literal">not-null</tt> attribute (for generating a <tt class="literal">NOT NULL</tt>
                constraint on table columns) and a <tt class="literal">unique</tt> attribute (for generating <tt class="literal">UNIQUE</tt>
                constraint on table columns).
            </p><p>
                Some tags accept an <tt class="literal">index</tt> attribute for specifying the
                name of an index for that column. A <tt class="literal">unique-key</tt> attribute
                can be used to group columns in a single unit key constraint. Currently, the
                specified value of the <tt class="literal">unique-key</tt> attribute is
                <span class="emphasis"><em>not</em></span> used to name the constraint, only to group the
                columns in the mapping file.
            </p><p>
                Examples:
            </p><pre class="programlisting">&lt;property name="Foo" type="String" length="64" not-null="true"/&gt;

&lt;many-to-one name="Bar" foreign-key="fk_foo_bar" not-null="true"/&gt;

&lt;element column="serial_number" type="Int64" not-null="true" unique="true"/&gt;</pre><p>
                Alternatively, these elements also accept a child <tt class="literal">&lt;column&gt;</tt> element. This is
                particularly useful for multi-column types:
            </p><pre class="programlisting">&lt;property name="Foo" type="String"&gt;
    &lt;column name="foo" length="64" not-null="true" sql-type="text"/&gt;
&lt;/property&gt;

&lt;property name="Bar" type="My.CustomTypes.MultiColumnType, My.CustomTypes"/&gt;
    &lt;column name="fee" not-null="true" index="bar_idx"/&gt;
    &lt;column name="fi" not-null="true" index="bar_idx"/&gt;
    &lt;column name="fo" not-null="true" index="bar_idx"/&gt;
&lt;/property&gt;</pre><p>
                The <tt class="literal">sql-type</tt> attribute allows the user to override the default mapping
                of NHibernate type to SQL datatype.
            </p><p>
                The <tt class="literal">check</tt> attribute allows you to specify a check constraint.
            </p><pre class="programlisting">&lt;property name="Foo" type="Int32"&gt;
    &lt;column name="foo" check="foo &gt; 10"/&gt;
&lt;/property&gt;

&lt;class name="Foo" table="foos" check="bar &lt; 100.0"&gt;
    ...
    &lt;property name="Bar" type="Single"/&gt;
&lt;/class&gt;</pre><div class="table"><a name="schemattributes-summary"></a><p class="title"><b>Table&nbsp;20.1.&nbsp;Summary</b></p><table summary="Summary" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Attribute</th><th>Values</th><th>Interpretation</th></tr></thead><tbody><tr><td><tt class="literal">length</tt></td><td>number</td><td>column length/decimal precision</td></tr><tr><td><tt class="literal">not-null</tt></td><td><tt class="literal">true|false</tt></td><td>specfies that the column should be non-nullable</td></tr><tr><td><tt class="literal">unique</tt></td><td><tt class="literal">true|false</tt></td><td>specifies that the column should have a unique constraint</td></tr><tr><td><tt class="literal">index</tt></td><td><tt class="literal">index_name</tt></td><td>specifies the name of a (multi-column) index</td></tr><tr><td><tt class="literal">unique-key</tt></td><td><tt class="literal">unique_key_name</tt></td><td>specifies the name of a multi-column unique constraint</td></tr><tr><td><tt class="literal">foreign-key</tt></td><td><tt class="literal">foreign_key_name</tt></td><td>
                                specifies the name of the foreign key constraint generated
                                for an association, use it on &lt;one-to-one&gt;, &lt;many-to-one&gt;,
                                &lt;key&gt;, and &lt;many-to-many&gt; mapping elements. Note that
                                <tt class="literal">inverse="true"</tt> sides will not be considered
                                by <tt class="literal">SchemaExport</tt>.
                            </td></tr><tr><td><tt class="literal">sql-type</tt></td><td><tt class="literal">column_type</tt></td><td>
                                overrides the default column type (attribute of 
                                <tt class="literal">&lt;column&gt;</tt> element only)
                            </td></tr><tr><td><tt class="literal">check</tt></td><td>SQL expression</td><td>
                                create an SQL check constraint on either column or table
                            </td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-3"></a>20.1.2.&nbsp;Running the tool</h3></div></div><div></div></div><p>
                The <tt class="literal">SchemaExport</tt> tool writes a DDL script to standard out and/or
                executes the DDL statements.
            </p><p>
                You may embed <tt class="literal">SchemaExport</tt> in your application:
            </p><pre class="programlisting">Configuration cfg = ....;
new SchemaExport(cfg).Create(false, true);</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-4"></a>20.1.3.&nbsp;Properties</h3></div></div><div></div></div><p>
                Database properties may be specified
            </p><div class="itemizedlist"><ul type="disc" compact><li><p>as system properties with <tt class="literal">-D</tt><span class="emphasis"><em>&lt;property&gt;</em></span></p></li><li><p>in <tt class="literal">hibernate.properties</tt></p></li><li><p>in a named properties file with <tt class="literal">--properties</tt></p></li></ul></div><p>
                The needed properties are:
            </p><div class="table"><a name="d0e13248"></a><p class="title"><b>Table&nbsp;20.2.&nbsp;SchemaExport Connection Properties</b></p><table summary="SchemaExport Connection Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">hibernate.connection.driver_class</tt></td><td>jdbc driver class</td></tr><tr><td><tt class="literal">hibernate.connection.url</tt></td><td>jdbc url</td></tr><tr><td><tt class="literal">hibernate.connection.username</tt></td><td>database user</td></tr><tr><td><tt class="literal">hibernate.connection.password</tt></td><td>user password</td></tr><tr><td><tt class="literal">hibernate.dialect</tt></td><td>dialect</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toolsetguide-s1-5"></a>20.1.4.&nbsp;Using Ant</h3></div></div><div></div></div><p>
                You can call <tt class="literal">SchemaExport</tt> from your Ant build script:
            </p><pre class="programlisting">&lt;target name="schemaexport"&gt;
    &lt;taskdef name="schemaexport"
        classname="net.sf.hibernate.tool.hbm2ddl.SchemaExportTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaexport
        properties="hibernate.properties"
        quiet="no"
        text="no"
        drop="no"
        delimiter=";"
        output="schema-export.sql"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaexport&gt;
&lt;/target&gt;</pre><p>
                If you don't specify <tt class="literal">properties</tt> or a <tt class="literal">config</tt> file,
                the <tt class="literal">SchemaExportTask</tt> will try to use normal Ant project properties instead.
                In other words, if you don't want or need an external configuration or properties file, you
                may put <tt class="literal">hibernate.*</tt> configuration properties in your build.xml or
                build.properties.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="toolsetguide-s2"></a>20.2.&nbsp;Code Generation</h2></div></div><div></div></div><p>
          The NHibernate code generator may be used to generate skeletal C# implementation classes
          from a NHibernate mapping file. This tool is included in the NHibernate Contrib package
          (a saparate download in http://sourceforge.net/projects/nhcontrib/).
        </p><p>
            <tt class="literal">hbm2net</tt> parses the mapping files and generates fully working C#
            source files from these. Thus with <tt class="literal">hbm2net</tt> one could "just" provide the
            <tt class="literal">.hbm</tt> files, and then don't worry about hand-writing/coding the C# files.
        </p><p>
            <tt class="literal">hbm2net</tt> <span class="emphasis"><em> options
            mapping_files</em></span>
        </p><div class="table"><a name="d0e13339"></a><p class="title"><b>Table&nbsp;20.3.&nbsp;Code Generator Command Line Options</b></p><table summary="Code Generator Command Line Options" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">-output:</tt><span class="emphasis"><em>output_dir</em></span></td><td>root directory for generated code</td></tr><tr><td><tt class="literal">-config:</tt><span class="emphasis"><em>config_file</em></span></td><td>optional file for configuring hbm2net</td></tr></tbody></table></div><p>
        A more detailed guide of <tt class="literal">hbm2net</tt> is available in
        https://nhibernate.info/blog/2009/12/12/t4-hbm2net-alpha-2.html
      </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-parentchild"></a>Chapter&nbsp;21.&nbsp;Example: Parent/Child</h2></div></div><div></div></div><p>
        One of the very first things that new users try to do with NHibernate is to model a parent / child type 
        relationship. There are two different approaches to this. For various reasons the most convenient 
        approach, especially for new users, is to model both <tt class="literal">Parent</tt> and <tt class="literal">Child</tt> 
        as entity classes with a <tt class="literal">&lt;one-to-many&gt;</tt> association from <tt class="literal">Parent</tt> 
        to <tt class="literal">Child</tt>. (The alternative approach is to declare the <tt class="literal">Child</tt> as a 
        <tt class="literal">&lt;composite-element&gt;</tt>.) Now, it turns out that default semantics of a one to many 
        association (in NHibernate) are much less close to the usual semantics of a parent / child relationship than 
        those of a composite element mapping. We will explain how to use a <span class="emphasis"><em>bidirectional one to many 
        association with cascades</em></span> to model a parent / child relationship efficiently and elegantly. It's 
        not at all difficult!
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-collections"></a>21.1.&nbsp;A note about collections</h2></div></div><div></div></div><p>
            NHibernate collections are considered to be a logical part of their owning entity; never of the
            contained entities. This is a crucial distinction! It has the following consequences:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                When we remove / add an object from / to a collection, the version number of the collection owner
                is incremented.
            </p></li><li><p>
                If an object that was removed from a collection is an instance of a value type (eg, a composite
                element), that object will cease to be persistent and its state will be completely removed from
                the database. Likewise, adding a value type instance to the collection will cause its state to
                be immediately persistent.
            </p></li><li><p>
                On the other hand, if an entity is removed from a collection (a one-to-many or many-to-many
                association), it will not be deleted, by default. This behavior is completely consistent - a
                change to the internal state of another entity should not cause the associated entity to vanish!
                Likewise, adding an entity to a collection does not cause that entity to become persistent, by
                default.
            </p></li></ul></div><p>
            Instead, the default behavior is that adding an entity to a collection merely creates a link between
            the two entities, while removing it removes the link. This is very appropriate for all sorts of cases.
            Where it is not appropriate at all is the case of a parent / child relationship, where the life of the
            child is bound to the lifecycle of the parent.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-bidir"></a>21.2.&nbsp;Bidirectional one-to-many</h2></div></div><div></div></div><p>
            Suppose we start with a simple <tt class="literal">&lt;one-to-many&gt;</tt> association from
            <tt class="literal">Parent</tt> to <tt class="literal">Child</tt>.
        </p><pre class="programlisting">&lt;set name="Children"&gt;
    &lt;key column="parent_id" /&gt;
    &lt;one-to-many class="Child" /&gt;
&lt;/set&gt;</pre><p>
            If we were to execute the following code
        </p><pre class="programlisting">Parent p = .....;
Child c = new Child();
p.Children.Add(c);
session.Save(c);
session.Flush();</pre><p>
            NHibernate would issue two SQL statements:
        </p><div class="itemizedlist"><ul type="disc"><li><p>an <tt class="literal">INSERT</tt> to create the record for <tt class="literal">c</tt></p></li><li><p>
                an <tt class="literal">UPDATE</tt> to create the link from <tt class="literal">p</tt> to
                <tt class="literal">c</tt>
            </p></li></ul></div><p>
            This is not only inefficient, but also violates any <tt class="literal">NOT NULL</tt> constraint on the
            <tt class="literal">parent_id</tt> column.
        </p><p>
            The underlying cause is that the link (the foreign key <tt class="literal">parent_id</tt>) from
            <tt class="literal">p</tt> to <tt class="literal">c</tt> is not considered part of the state of the <tt class="literal">Child</tt>
            object and is therefore not created in the <tt class="literal">INSERT</tt>. So the solution is to make the link part
            of the <tt class="literal">Child</tt> mapping.
        </p><pre class="programlisting">&lt;many-to-one name="Parent" column="parent_id" not-null="true"/&gt;</pre><p>
            (We also need to add the <tt class="literal">Parent</tt> property to the <tt class="literal">Child</tt> class.)
        </p><p>
            Now that the <tt class="literal">Child</tt> entity is managing the state of the link, we tell the collection not
            to update the link. We use the <tt class="literal">inverse</tt> attribute.
        </p><pre class="programlisting">&lt;set name="Children" inverse="true"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
            The following code would be used to add a new <tt class="literal">Child</tt>.
        </p><pre class="programlisting">Parent p = session.Load&lt;Parent&gt;(pid);
Child c = new Child();
c.Parent = p;
p.Children.Add(c);
session.Save(c);
session.Flush();</pre><p>
            And now, only one SQL <tt class="literal">INSERT</tt> would be issued!
        </p><p>
            To tighten things up a bit, we could create an <tt class="literal">AddChild()</tt> method of
            <tt class="literal">Parent</tt>.
        </p><pre class="programlisting">public void AddChild(Child c)
{
    c.Parent = this;
    children.Add(c);
}</pre><p>
            Now, the code to add a <tt class="literal">Child</tt> looks like
        </p><pre class="programlisting">Parent p = session.Load&lt;Parent&gt;(pid);
Child c = new Child();
p.AddChild(c);
session.Save(c);
session.Flush();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-cascades"></a>21.3.&nbsp;Cascading lifecycle</h2></div></div><div></div></div><p>
             The explicit call to <tt class="literal">Save()</tt> is still annoying. We will address this by
             using cascades.
         </p><pre class="programlisting">&lt;set name="Children" inverse="true" cascade="all"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
             This simplifies the code above to
         </p><pre class="programlisting">Parent p = session.Load&lt;Parent&gt;(pid);
Child c = new Child();
p.AddChild(c);
session.Flush();</pre><p>
             Similarly, we don't need to iterate over the children when saving or deleting a <tt class="literal">Parent</tt>.
             The following removes <tt class="literal">p</tt> and all its children from the database.
         </p><pre class="programlisting">Parent p = session.Load&lt;Parent&gt;(pid);
session.Delete(p);
session.Flush();</pre><p>
             However, this code
         </p><pre class="programlisting">Parent p = session.Load&lt;Parent&gt;(pid);
// Get one child out of the set
IEnumerator childEnumerator = p.Children.GetEnumerator();
childEnumerator.MoveNext();
Child c = (Child) childEnumerator.Current;

p.Children.Remove(c);
c.Parent = null;
session.Flush();</pre><p>
             will not remove <tt class="literal">c</tt> from the database; it will only remove the link to <tt class="literal">p</tt>
             (and cause a <tt class="literal">NOT NULL</tt> constraint violation, in this case). You need to explicitly
             <tt class="literal">Delete()</tt> the <tt class="literal">Child</tt>.
         </p><pre class="programlisting">Parent p = session.Load&lt;Parent&gt;(pid);
// Get one child out of the set
IEnumerator childEnumerator = p.Children.GetEnumerator();
childEnumerator.MoveNext();
Child c = (Child) childEnumerator.Current;

p.Children.Remove(c);
session.Delete(c);
session.Flush();</pre><p>
             Now, in our case, a <tt class="literal">Child</tt> can't really exist without its parent. So if we remove
             a <tt class="literal">Child</tt> from the collection, we really do want it to be deleted. For this, we must
             use <tt class="literal">cascade="all-delete-orphan"</tt>.
         </p><pre class="programlisting">&lt;set name="Children" inverse="true" cascade="all-delete-orphan"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>
             Note: even though the collection mapping specifies <tt class="literal">inverse="true"</tt>, cascades are still
             processed by iterating the collection elements. So if you require that an object be saved, deleted or
             updated by cascade, you must add it to the collection. It is not enough to simply set its parent.
         </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-update"></a>21.4.&nbsp;Using cascading <tt class="literal">Update()</tt></h2></div></div><div></div></div><p>
             Suppose we loaded up a <tt class="literal">Parent</tt> in one <tt class="literal">ISession</tt>, made some changes in a UI
             action and wish to persist these changes in a new ISession (by calling <tt class="literal">Update()</tt>). The
             <tt class="literal">Parent</tt> will contain a collection of children and, since cascading update is enabled, NHibernate
             needs to know which children are newly instantiated and which represent existing rows in the database. Let's assume
             that both <tt class="literal">Parent</tt> and <tt class="literal">Child</tt> have (synthetic) identifier properties of type
             <tt class="literal">long</tt>. NHibernate will use the identifier property value to determine which of the
             children are new. (You may also use the version or timestamp property, see
             <a href="#manipulatingdata-updating-detached" title="9.4.2.&nbsp;Updating detached objects">Section&nbsp;9.4.2, &#8220;Updating detached objects&#8221;</a>.)
         </p><p>
             The <tt class="literal">unsaved-value</tt> attribute is used to specify the identifier value of a newly instantiated
             instance. <span class="emphasis"><em>In NHibernate it is not necessary to specify <tt class="literal">unsaved-value</tt> explicitly.
             </em></span>
         </p><p>
             The following code will update <tt class="literal">parent</tt> and <tt class="literal">child</tt> and insert
             <tt class="literal">newChild</tt>.
         </p><pre class="programlisting">//parent and child were both loaded in a previous session
parent.AddChild(child);
Child newChild = new Child();
parent.AddChild(newChild);
session.Update(parent);
session.Flush();</pre><p>
             Well, thats all very well for the case of a generated identifier, but what about assigned identifiers
             and composite identifiers? This is more difficult, since <tt class="literal">unsaved-value</tt> can't
             distinguish between a newly instantiated object (with an identifier assigned by the user) and an object
             loaded in a previous session. In these cases, you will probably need to give NHibernate a hint; either
         </p><div class="itemizedlist"><ul type="disc"><li><p>
                 define an <tt class="literal">unsaved-value</tt> on a <tt class="literal">&lt;version&gt;</tt>
                 or <tt class="literal">&lt;timestamp&gt;</tt> property mapping for the class.
             </p></li><li><p>
                 set <tt class="literal">unsaved-value="none"</tt> and explicitly <tt class="literal">Save()</tt>
                 newly instantiated children before calling <tt class="literal">Update(parent)</tt>
             </p></li><li><p>
                 set <tt class="literal">unsaved-value="any"</tt> and explicitly <tt class="literal">Update()</tt>
                 previously persistent children before calling <tt class="literal">Update(parent)</tt>
             </p></li></ul></div><p>
             <tt class="literal">null</tt> is the default <tt class="literal">unsaved-value</tt> for assigned identifiers,
             <tt class="literal">none</tt> is the default <tt class="literal">unsaved-value</tt> for composite
             identifiers.
         </p><p>
             There is one further possibility. There is a new <tt class="literal">IInterceptor</tt> method named
             <tt class="literal">IsTransient()</tt> which lets the application implement its own strategy for distinguishing
             newly instantiated objects. For example, you could define a base class for your persistent classes.
         </p><pre class="programlisting">public class Persistent
{
    private bool _saved = false;
    
    public void OnSave()
    {
        _saved=true;
    }
    
    public void OnLoad()
    {
        _saved=true;
    }
    
    ......
    
    public bool IsSaved
    {
        get { return _saved; }
    }
}</pre><p>
             (The <tt class="literal">saved</tt> property is non-persistent.)
             Now implement <tt class="literal">IsTransient()</tt>, along with <tt class="literal">OnLoad()</tt>
             and <tt class="literal">OnSave()</tt> as follows.
         </p><pre class="programlisting">
	public object IsTransient(object entity)
{
    if (entity is Persistent)
    {
        return !( (Persistent) entity ).IsSaved;
    }
    else
    {
        return null;
    }
}

public bool OnLoad(object entity, 
    object id,
    object[] state,
    string[] propertyNames,
    IType[] types)
{
    if (entity is Persistent) ( (Persistent) entity ).OnLoad();
    return false;
}

public boolean OnSave(object entity,
    object id,
    object[] state,
    string[] propertyNames,
    IType[] types)
{
    if (entity is Persistent) ( (Persistent) entity ).OnSave();
    return false;
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-parentchild-conclusion"></a>21.5.&nbsp;Conclusion</h2></div></div><div></div></div><p>
             There is quite a bit to digest here and it might look confusing first time around. However, in practice, it
             all works out quite nicely. Most NHibernate applications use the parent / child pattern in many places.
         </p><p>
             We mentioned an alternative in the first paragraph. None of the above issues exist in the case of
             <tt class="literal">&lt;composite-element&gt;</tt> mappings, which have exactly the semantics of a parent / child
             relationship. Unfortunately, there are two big limitations to composite element classes: composite elements may
             not own collections, and they should not be the child of any entity other than the unique parent. (However,
             they <span class="emphasis"><em>may</em></span> have a surrogate primary key, using an <tt class="literal">&lt;idbag&gt;</tt> mapping.)
         </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-weblog"></a>Chapter&nbsp;22.&nbsp;Example: Weblog Application</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-classes"></a>22.1.&nbsp;Persistent Classes</h2></div></div><div></div></div><p>
            The persistent classes represent a weblog, and an item posted
            in a weblog. They are to be modelled as a standard parent/child
            relationship, but we will use an ordered bag, instead of a set.
        </p><pre class="programlisting">using System;
using System.Collections.Generic;

namespace Eg
{
    public class Blog
    {
        private long _id;
        private string _name;
        private IList&lt;BlogItem&gt; _items;
    
        public virtual long Id
        {
            get { return _id; }
            set { _id = value; }
        }
        
        public virtual IList&lt;BlogItem&gt; Items
        {
            get { return _items; }
            set { _items = value; }
        }
        
        public virtual string Name
        {
            get { return _name; }
            set { _name = value; }
        }
    }
}</pre><pre class="programlisting">using System;

namespace Eg
{
    public class BlogItem
    {
        private long _id;
        private DateTime _dateTime;
        private string _text;
        private string _title;
        private Blog _blog;

        public virtual Blog Blog
        {
            get { return _blog; }
            set { _blog = value; }
        }

        public virtual DateTime DateTime
        {
            get { return _dateTime; }
            set { _dateTime = value; }
        }

        public virtual long Id
        {
            get { return _id; }
            set { _id = value; }
        }

        public virtual string Text
        {
            get { return _text; }
            set { _text = value; }
        }

        public virtual string Title
        {
            get { return _title; }
            set { _title = value; }
        }
    }
}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-mappings"></a>22.2.&nbsp;NHibernate Mappings</h2></div></div><div></div></div><p>
            The XML mappings should now be quite straightforward.
        </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg"&gt;

    &lt;class 
        name="Blog" 
        table="BLOGS" 
        lazy="true"&gt;
        
        &lt;id 
            name="Id" 
            column="BLOG_ID"&gt;
            
            &lt;generator class="native"/&gt;
            
        &lt;/id&gt;
        
        &lt;property 
            name="Name" 
            column="NAME" 
            not-null="true" 
            unique="true"/&gt;
            
        &lt;bag 
            name="Items" 
            inverse="true" 
            lazy="true"
            order-by="DATE_TIME" 
            cascade="all"&gt;
            
            &lt;key column="BLOG_ID"/&gt;
            &lt;one-to-many class="BlogItem"/&gt;
            
        &lt;/bag&gt;
        
    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg"&gt;
    
    &lt;class 
        name="BlogItem" 
        table="BLOG_ITEMS" 
        dynamic-update="true"&gt;
        
        &lt;id 
            name="Id" 
            column="BLOG_ITEM_ID"&gt;
            
            &lt;generator class="native"/&gt;
            
        &lt;/id&gt;
        
        &lt;property 
            name="Title" 
            column="TITLE" 
            not-null="true"/&gt;
            
        &lt;property 
            name="Text" 
            column="TEXT" 
            not-null="true"/&gt;
            
        &lt;property 
            name="DateTime" 
            column="DATE_TIME" 
            not-null="true"/&gt;
            
        &lt;many-to-one 
            name="Blog" 
            column="BLOG_ID" 
            not-null="true"/&gt;
            
    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-weblog-code"></a>22.3.&nbsp;NHibernate Code</h2></div></div><div></div></div><p>
            The following class demonstrates some of the kinds of things
            we can do with these classes, using NHibernate.
        </p><pre class="programlisting">using System;
using System.Collections.Generic;

using NHibernate.Tool.hbm2ddl;

namespace Eg
{
    public class BlogMain
    {
        private ISessionFactory _sessions;
        
        public void Configure()
        {
            _sessions = new Configuration()
                .AddClass(typeof(Blog))
                .AddClass(typeof(BlogItem))
                .BuildSessionFactory();
        }
        
        public void ExportTables()
        {
            Configuration cfg = new Configuration()
                .AddClass(typeof(Blog))
                .AddClass(typeof(BlogItem));
            new SchemaExport(cfg).create(true, true);
        }
        
        public Blog CreateBlog(string name)
        {
            Blog blog = new Blog();
            blog.Name = name;
            blog.Items = new List&lt;BlogItem&gt;();
            
            using (ISession session = _sessions.OpenSession())
            using (ITransaction tx = session.BeginTransaction())
            {
                session.Save(blog);
                tx.Commit();
            }

            return blog;
        }
        
        public BlogItem CreateBlogItem(Blog blog, string title, string text)
        {
            BlogItem item = new BlogItem();
            item.Title = title;
            item.Text = text;
            item.Blog = blog;
            item.DateTime = DateTime.Now;
            blog.Items.Add(item);
            
            using (ISession session = _sessions.OpenSession())
            using (ITransaction tx = session.BeginTransaction())
            {
                session.Update(blog);
                tx.Commit();
            }

            return item;
        }
        
        public BlogItem CreateBlogItem(long blogId, string title, string text)
        {
            BlogItem item = new BlogItem();
            item.Title = title;
            item.Text = text;
            item.DateTime = DateTime.Now;
            
            using (ISession session = _sessions.OpenSession())
            using (ITransaction tx = session.BeginTransaction())
            {
                Blog blog = session.Load&lt;Blog&gt;(blogId);
                item.Blog = blog;
                blog.Items.Add(item);
                tx.Commit();
            }

            return item;
        }
        
        public void UpdateBlogItem(BlogItem item, string text)
        {
            item.Text = text;

            using (ISession session = _sessions.OpenSession())
            using (ITransaction tx = session.BeginTransaction())
            {
                session.Update(item);
                tx.Commit();
            }
        }
        
        public void UpdateBlogItem(long itemId, string text)
        {
            using (ISession session = _sessions.OpenSession())
            using (ITransaction tx = session.BeginTransaction())
            {
                BlogItem item = session.Load&lt;BlogItem&gt;(itemId);
                item.Text = text;
                tx.Commit();
            }
        }
        
        public IList&lt;BlogItem&gt; ListAllBlogNamesAndItemCounts(int max)
        {
            IList&lt;BlogItem&gt; result = null;

            using (ISession session = _sessions.OpenSession())
            using (ITransaction tx = session.BeginTransaction())
            {
                IQuery q = session.CreateQuery(
                    "select blog.id, blog.Name, count(blogItem) " +
                    "from Blog as blog " +
                    "left outer join blog.Items as blogItem " +
                    "group by blog.Name, blog.id " +
                    "order by max(blogItem.DateTime)"
                );
                q.SetMaxResults(max);
                result = q.List&lt;BlogItem&gt;();
                tx.Commit();
            }

            return result;
        }
        
        public Blog GetBlogAndAllItems(long blogId)
        {
            Blog blog = null;

            using (ISession session = _sessions.OpenSession())
            using (ITransaction tx = session.BeginTransaction())
            {
                IQuery q = session.createQuery(
                    "from Blog as blog " +
                    "left outer join fetch blog.Items " +
                    "where blog.id = :blogId"
                );
                q.SetParameter("blogId", blogId);
                blog  = (Blog) q.List()[0];
                tx.Commit();
            }

            return blog;
        }
        
        public IList&lt;Blog&gt; ListBlogsAndRecentItems()
        {
            IList&lt;Blog&gt; result = null;

            using (ISession session = _sessions.OpenSession())
            using (ITransaction tx = session.BeginTransaction())
            {
                IQuery q = session.CreateQuery(
                    "from Blog as blog " +
                    "inner join blog.Items as blogItem " +
                    "where blogItem.DateTime &gt; :minDate"
                );
    
                DateTime date = DateTime.Now.AddMonths(-1);
                q.SetDateTime("minDate", date);
                
                result = q.List&lt;Blog&gt;();
                tx.Commit();
            }

            return result;
        }
    }
}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example-mappings"></a>Chapter&nbsp;23.&nbsp;Example: Various Mappings</h2></div></div><div></div></div><p>
        This chapter shows off some more complex association mappings.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-emp"></a>23.1.&nbsp;Employer/Employee</h2></div></div><div></div></div><p>
            The following model of the relationship between <tt class="literal">Employer</tt> and 
            <tt class="literal">Employee</tt> uses an actual entity class (<tt class="literal">Employment</tt>) 
            to represent the association. This is done because there might be more than one
            period of employment for the same two parties. Components are used to model monetary 
            values and employee names.
        </p><div class="mediaobject" align="center"><img src="../shared/images/EmployerEmployee.png" align="middle"></div><p>
            Here's a possible mapping document:
        </p><pre class="programlisting">&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="..." namespace="..."&gt;

    &lt;class name="Employer" table="employers"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employer_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="Name"/&gt;
    &lt;/class&gt;

    &lt;class name="Employment" table="employment_periods"&gt;

        &lt;id name="Id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employment_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="StartDate" column="start_date"/&gt;
        &lt;property name="EndDate" column="end_date"/&gt;

        &lt;component name="HourlyRate" class="MonetaryAmount"&gt;
            &lt;property name="Amount"&gt;
                &lt;column name="hourly_rate" sql-type="NUMERIC(12, 2)"/&gt;
            &lt;/property&gt;
            &lt;property name="Currency" length="12"/&gt;
        &lt;/component&gt;

        &lt;many-to-one name="Employer" column="employer_id" not-null="true"/&gt;
        &lt;many-to-one name="Employee" column="employee_id" not-null="true"/&gt;

    &lt;/class&gt;

    &lt;class name="Employee" table="employees"&gt;
        &lt;id name="Id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employee_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="TaxfileNumber"/&gt;
        &lt;component name="Name" class="Name"&gt;
            &lt;property name="FirstName"/&gt;
            &lt;property name="Initial"/&gt;
            &lt;property name="LastName"/&gt;
        &lt;/component&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        And here's the table schema generated by <tt class="literal">SchemaExport</tt>.
    </p><pre class="programlisting">create table employers (
    Id BIGINT not null, 
    Name VARCHAR(255), 
    primary key (Id)
)

create table employment_periods (
    Id BIGINT not null,
    hourly_rate NUMERIC(12, 2),
    Currency VARCHAR(12), 
    employee_id BIGINT not null, 
    employer_id BIGINT not null, 
    end_date TIMESTAMP, 
    start_date TIMESTAMP, 
    primary key (Id)
)

create table employees (
    Id BIGINT not null, 
    FirstName VARCHAR(255), 
    Initial CHAR(1), 
    LastName VARCHAR(255), 
    TaxfileNumber VARCHAR(255), 
    primary key (Id)
)

alter table employment_periods 
    add constraint employment_periodsFK0 foreign key (employer_id) references employers
alter table employment_periods 
    add constraint employment_periodsFK1 foreign key (employee_id) references employees
create sequence employee_id_seq
create sequence employment_id_seq
create sequence employer_id_seq</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-authorwork"></a>23.2.&nbsp;Author/Work</h2></div></div><div></div></div><p>
            Consider the following model of the relationships between <tt class="literal">Work</tt>,
            <tt class="literal">Author</tt> and <tt class="literal">Person</tt>. We represent the relationship
            between <tt class="literal">Work</tt> and <tt class="literal">Author</tt> as a many-to-many
            association. We choose to represent the relationship between <tt class="literal">Author</tt> 
            and <tt class="literal">Person</tt> as one-to-one association. Another possibility would be to 
            have <tt class="literal">Author</tt> extend <tt class="literal">Person</tt>.  
        </p><div class="mediaobject" align="center"><img src="../shared/images/AuthorWork.png" align="middle"></div><p>
            The following mapping document correctly represents these relationships:
        </p><pre class="programlisting">&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="..." namespace="..."&gt;

    &lt;class name="Work" table="works" discriminator-value="W"&gt;

        &lt;id name="Id" column="id" generator="native" /&gt;

        &lt;discriminator column="type" type="character"/&gt;

        &lt;property name="Title"/&gt;
        &lt;set name="Authors" table="author_work" lazy="true"&gt;
            &lt;key&gt;
                &lt;column name="work_id" not-null="true"/&gt;
            &lt;/key&gt;
            &lt;many-to-many class="Author"&gt;
                &lt;column name="author_id" not-null="true"/&gt;
            &lt;/many-to-many&gt;
        &lt;/set&gt;

        &lt;subclass name="Book" discriminator-value="B"&gt;
            &lt;property name="Text" column="text" /&gt;
        &lt;/subclass&gt;

        &lt;subclass name="Song" discriminator-value="S"&gt;
            &lt;property name="Tempo" column="tempo" /&gt;
            &lt;property name="Genre" column="genre" /&gt;
        &lt;/subclass&gt;

    &lt;/class&gt;

    &lt;class name="Author" table="authors"&gt;

        &lt;id name="Id" column="id"&gt;
            &lt;!-- The Author must have the same identifier as the Person --&gt;
            &lt;generator class="assigned"/&gt; 
        &lt;/id&gt;

        &lt;property name="Alias" column="alias" /&gt;
        &lt;one-to-one name="Person" constrained="true"/&gt;

        &lt;set name="Works" table="author_work" inverse="true" lazy="true"&gt;
            &lt;key column="author_id"/&gt;
            &lt;many-to-many class="Work" column="work_id"/&gt;
        &lt;/set&gt;

    &lt;/class&gt;

    &lt;class name="Person" table="persons"&gt;
        &lt;id name="Id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="Name" column="name" /&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        There are four tables in this mapping. <tt class="literal">works</tt>, 
        <tt class="literal">authors</tt> and <tt class="literal">persons</tt> hold work, author
        and person data respectively. <tt class="literal">author_work</tt> is an association
        table linking authors to works. Heres the table schema, as generated by
        <tt class="literal">SchemaExport</tt>.
    </p><pre class="programlisting">create table works (
    id BIGINT not null generated by default as identity, 
    tempo FLOAT, 
    genre VARCHAR(255), 
    text INTEGER, 
    title VARCHAR(255), 
    type CHAR(1) not null, 
    primary key (id)
)

create table author_work (
    author_id BIGINT not null, 
    work_id BIGINT not null, 
    primary key (work_id, author_id)
)

create table authors (
    id BIGINT not null generated by default as identity, 
    alias VARCHAR(255), 
    primary key (id)
)

create table persons (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

alter table authors 
    add constraint authorsFK0 foreign key (id) references persons
alter table author_work 
    add constraint author_workFK0 foreign key (author_id) references authors
alter table author_work
    add constraint author_workFK1 foreign key (work_id) references works</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-mappings-customerorderproduct"></a>23.3.&nbsp;Customer/Order/Product</h2></div></div><div></div></div><p>
            Now consider a model of the relationships between <tt class="literal">Customer</tt>,
            <tt class="literal">Order</tt> and <tt class="literal">LineItem</tt> and <tt class="literal">Product</tt>.
            There is a one-to-many association between <tt class="literal">Customer</tt> and
            <tt class="literal">Order</tt>, but how should we represent <tt class="literal">Order</tt> / 
            <tt class="literal">LineItem</tt> / <tt class="literal">Product</tt>? I've chosen to map
            <tt class="literal">LineItem</tt> as an association class representing the many-to-many
            association between <tt class="literal">Order</tt> and <tt class="literal">Product</tt>. In
            NHibernate, this is called a composite element.
        </p><div class="mediaobject" align="center"><img src="../shared/images/CustomerOrderProduct.png" align="middle"></div><p>
            The mapping document:
        </p><pre class="programlisting">&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="..." namespace="..."&gt;

    &lt;class name="Customer" table="customers"&gt;
        &lt;id name="Id" column="id" generator="native" /&gt;
        &lt;property name="Name" column="name"/&gt;
        &lt;set name="Orders" inverse="true" lazy="true"&gt;
            &lt;key column="customer_id"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Order" table="orders"&gt;
        &lt;id name="Id" column="id" generator="native" /&gt;
        &lt;property name="Date" column="date"/&gt;
        &lt;many-to-one name="Customer" column="customer_id"/&gt;
        &lt;list name="LineItems" table="line_items" lazy="true"&gt;
            &lt;key column="order_id"/&gt;
            &lt;index column="line_number"/&gt;
            &lt;composite-element class="LineItem"&gt;
                &lt;property name="Quantity" column="quantity"/&gt;
                &lt;many-to-one name="Product" column="product_id"/&gt;
            &lt;/composite-element&gt;
        &lt;/list&gt;
    &lt;/class&gt;

    &lt;class name="Product" table="products"&gt;
        &lt;id name="Id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="SerialNumber" column="serial_number" /&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>
        <tt class="literal">customers</tt>, <tt class="literal">orders</tt>, <tt class="literal">line_items</tt> and 
        <tt class="literal">products</tt> hold customer, order, order line item and product data
        respectively. <tt class="literal">line_items</tt> also acts as an association table linking
        orders with products.
    </p><pre class="programlisting">create table customers (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

create table orders (
    id BIGINT not null generated by default as identity, 
    customer_id BIGINT, 
    date TIMESTAMP, 
    primary key (id)
)

create table line_items (
    line_number INTEGER not null, 
    order_id BIGINT not null, 
    product_id BIGINT, 
    quantity INTEGER, 
    primary key (order_id, line_number)
)

create table products (
    id BIGINT not null generated by default as identity, 
    serial_number VARCHAR(255), 
    primary key (id)
)

alter table orders 
    add constraint ordersFK0 foreign key (customer_id) references customers
alter table line_items
    add constraint line_itemsFK0 foreign key (product_id) references products
alter table line_items
    add constraint line_itemsFK1 foreign key (order_id) references orders</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="best-practices"></a>Chapter&nbsp;24.&nbsp;Best Practices</h2></div></div><div></div></div><div class="variablelist"><dl><dt><span class="term">Write fine-grained classes and map them using <tt class="literal">&lt;component&gt;</tt>.</span></dt><dd><p>
                    Use an <tt class="literal">Address</tt> class to encapsulate <tt class="literal">street</tt>,
                    <tt class="literal">suburb</tt>, <tt class="literal">state</tt>, <tt class="literal">postcode</tt>.
                    This encourages code reuse and simplifies refactoring.
                </p></dd><dt><span class="term">Declare identifier properties on persistent classes.</span></dt><dd><p>
                    NHibernate makes identifier properties optional. There are all sorts of reasons why
                    you should use them. We recommend that identifiers be 'synthetic' (generated, with
                    no business meaning) and of a non-primitive type. For maximum flexibility, use
                    <tt class="literal">Int64</tt> or <tt class="literal">String</tt>.
                </p></dd><dt><span class="term">Place each class mapping in its own file.</span></dt><dd><p>
                     Don't use a single monolithic mapping document. Map <tt class="literal">Eg.Foo</tt> in 
                     the file <tt class="literal">Eg/Foo.hbm.xml</tt>. This makes particularly good sense in 
                     a team environment.
                </p></dd><dt><span class="term">Embed mappings in assemblies.</span></dt><dd><p>
                    Place mapping files along with the classes they map and declare them as
                    <tt class="literal">Embedded Resource</tt>s in Visual Studio.
                </p></dd><dt><span class="term">Consider externalising query strings.</span></dt><dd><p>
                    This is a good practice if your queries call non-ANSI-standard SQL functions. 
                    Externalising the query strings to mapping files will make the application more portable.
                </p></dd><dt><span class="term">Use parameters.</span></dt><dd><p>
                     As in ADO.NET, always replace non-constant values by "?". Never use string manipulation to 
                     bind a non-constant value in a query! Even better, consider using named parameters in
                     queries.
                </p></dd><dt><span class="term">Don't manage your own ADO.NET connections.</span></dt><dd><p>
                    NHibernate lets the application manage ADO.NET connections. This approach should be considered 
                    a last-resort. If you can't use the built-in connections providers, consider providing your 
                    own implementation of <tt class="literal">NHibernate.Connection.IConnectionProvider</tt>.
                </p></dd><dt><span class="term">Consider using a custom type.</span></dt><dd><p>
                    Suppose you have a type, say from some library, that needs to be persisted but doesn't 
                    provide the accessors needed to map it as a component. You should consider implementing
                    <tt class="literal">NHibernate.UserTypes.IUserType</tt>. This approach frees the application
                    code from implementing transformations to / from an NHibernate type.
                </p></dd><dt><span class="term">Use hand-coded ADO.NET in bottlenecks.</span></dt><dd><p>
                    In performance-critical areas of the system, some kinds of operations (eg. mass update /
                    delete) might benefit from direct ADO.NET. But please, wait until you <span class="emphasis"><em>know</em></span> 
                    something is a bottleneck. And don't assume that direct ADO.NET is necessarily faster. If need to 
                    use direct ADO.NET, it might be worth opening a NHibernate <tt class="literal">ISession</tt> and using
                    that SQL connection. That way you can still use the same transaction strategy and underlying
                    connection provider.
                </p></dd><dt><span class="term">Understand <tt class="literal">ISession</tt> flushing.</span></dt><dd><p>
                    From time to time the ISession synchronizes its persistent state with the database. Performance will
                    be affected if this process occurs too often. You may sometimes minimize unnecessary flushing by 
                    disabling automatic flushing or even by changing the order of queries and other operations within a 
                    particular transaction.      
                </p></dd><dt><span class="term">In a three tiered architecture, consider using <tt class="literal">SaveOrUpdate()</tt>.</span></dt><dd><p>
                    When using a distributed architecture, you could pass persistent objects loaded in
                    the middle tier to and from the user interface tier. Use a new session to service each request. 
                    Use <tt class="literal">ISession.Update()</tt> or <tt class="literal">ISession.SaveOrUpdate()</tt> to update the 
                    persistent state of an object.
                </p></dd><dt><span class="term">In a two tiered architecture, consider using session disconnection.</span></dt><dd><p>
                    Database Transactions have to be as short as possible for best scalability. However, it is often
                    neccessary to implement long running Application Transactions, a single unit-of-work from the
                    point of view of a user. This Application Transaction might span several client requests and
                    response cycles. Either use Detached Objects or, in two tiered architectures, simply disconnect
                    the NHibernate Session from the ADO.NET connection and reconnect it for each subsequent request.
                    Never use a single Session for more than one Application Transaction usecase, otherwise, you
                    will run into stale data.
                </p></dd><dt><span class="term">Don't treat exceptions as recoverable.</span></dt><dd><p>
                    This is more of a necessary practice than a "best" practice. When an exception occurs, roll back
                    the <tt class="literal">ITransaction</tt> and close the <tt class="literal">ISession</tt>. If you don't,
                    NHibernate can't guarantee that in-memory state accurately represents persistent state.
                    As a special case of this, do not use <tt class="literal">ISession.Load()</tt> to determine if an
                    instance with the given identifier exists on the database; use <tt class="literal">Get()</tt>
                    or a query instead.
                </p></dd><dt><span class="term">Prefer lazy fetching for associations.</span></dt><dd><p><a name="best-practices-p14"></a>
                    Use eager (outer-join) fetching sparingly. Use proxies and/or lazy collections for most associations
                    to classes that are not cached in the second-level cache. For associations to cached classes, where
                    there is a high probability of a cache hit, explicitly disable eager fetching using 
                    <tt class="literal">fetch="select"</tt>. When an outer-join fetch is appropriate to a particular use
                    case, use a query with a <tt class="literal">left join fetch</tt>.
                </p></dd><dt><span class="term">Consider abstracting your business logic from NHibernate.</span></dt><dd><p>
                    Hide (NHibernate) data-access code behind an interface. Combine the <span class="emphasis"><em>DAO</em></span> and 
                    <span class="emphasis"><em>Thread Local Session</em></span> patterns. You can even have some classes persisted by
                    handcoded ADO.NET, associated to NHibernate via an <tt class="literal">IUserType</tt>. (This advice is 
                    intended for "sufficiently large" applications; it is not appropriate for an application with
                    five tables!)
                </p></dd><dt><span class="term">Implement <tt class="literal">Equals()</tt> and <tt class="literal">GetHashCode()</tt> using a unique business key.</span></dt><dd><p>
                    If you compare objects outside of the ISession scope, you have to implement <tt class="literal">Equals()</tt>
                    and <tt class="literal">GetHashCode()</tt>. Inside the ISession scope, object identity is guaranteed. If
                    you implement these methods, never ever use the database identifier! A transient object doesn't have
                    an identifier value and NHibernate would assign a value when the object is saved. If the object
                    is in an ISet&lt;T&gt; while being saved, the hash code changes, breaking the contract. To implement
                    <tt class="literal">Equals()</tt> and <tt class="literal">GetHashCode()</tt>, use a unique business key, that is,
                    compare a unique combination of class properties. Remember that this key has to be stable and unique
                    only while the object is in an ISet&lt;T&gt;, not for the whole lifetime (not as stable as a database primary
                    key). Never use collections in the <tt class="literal">Equals()</tt> comparison (lazy loading) and be careful
                    with other associated classes that might be proxied.
                </p></dd><dt><span class="term">Don't use exotic association mappings.</span></dt><dd><p>
                    Good usecases for a real many-to-many associations are rare. Most of the time you need
                    additional information stored in the "link table". In this case, it is much better to
                    use two one-to-many associations to an intermediate link class. In fact, we think that
                    most associations are one-to-many and many-to-one, you should be careful when using any
                    other association style and ask yourself if it is really neccessary.
                </p></dd></dl></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="part-contrib"></a>NHibernateContrib Documentation</h1></div></div><div></div></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="contrib-preface"></a>Preface</h2></div></div><div></div></div><p>The NHibernateContrib is various programs contributed to NHibernate by members of the NHibernate Team or by the end users. The projects in here are not considered core pieces of NHibernate but they extend it in a useful way.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="caches"></a>Chapter&nbsp;25.&nbsp;NHibernate.Caches</h2></div></div><div></div></div><div class="abstract"><a name="NHibernate.Caches-abstract"></a><p class="title"><b>What is NHibernate.Caches?</b></p><p><b>NHibernate.Caches namespace contains several second-level cache providers for NHibernate.&nbsp;</b>
				A cache is place where entities are kept after being loaded from the database; once cached, they can be
				retrieved without going to the database. This means that they are faster to (re)load.
			</p><p>
			An NHibernate session has an internal (first-level) cache where it keeps its entities. There is no sharing
			between these caches - a first-level cache belongs to a given session and is destroyed with it. NHibernate
			provides a <span class="emphasis"><em>second-level cache</em></span> system; it works at the session factory level.
			A second-level cache is shared by all sessions created by the same session factory.
		</p><p>
			An important point is that the second-level cache <span class="emphasis"><em>does not</em></span> cache instances of the object
			type being cached; instead it caches the individual values of the properties of that object. This provides two
			benefits. One, NHibernate doesn't have to worry that your client code will manipulate the objects in a way that
			will disrupt the cache. Two, the relationships and associations do not become stale, and are easy to keep
			up-to-date because they are simply identifiers. The cache is not a tree of objects but rather a map of arrays.
		</p><p>
			With the <span class="emphasis"><em>session-per-request</em></span> model, a high number of sessions can concurrently access
			the same entity without hitting the database each time; hence the performance gain.
		</p><p>
			Several cache providers have been contributed by NHibernate users:
			</p><div class="variablelist"><dl><dt><span class="term"><tt class="classname">NHibernate.Caches.Prevalence</tt></span></dt><dd><p>
							Uses <tt class="classname">Bamboo.Prevalence</tt> as the cache provider. Open the
							file <tt class="filename">Bamboo.Prevalence.license.txt</tt> for more information about its license;
							you can also visit its <a href="http://bbooprevalence.sourceforge.net/" target="_top">website</a>.
						</p></dd><dt><span class="term"><tt class="classname">NHibernate.Caches.SysCache</tt></span></dt><dd><p>
							Uses <tt class="classname">System.Web.Caching.Cache</tt> as the cache provider. This means that you can
							rely on ASP.NET caching feature to understand how it works. For more information, read (on the MSDN):
							<a href="http://msdn.microsoft.com/library/en-us/cpguide/html/cpconcacheapis.asp" target="_top">Caching Application Data</a>.
						</p></dd><dt><span class="term"><tt class="classname">NHibernate.Caches.SysCache2</tt></span></dt><dd><p>
							Similar to <tt class="classname">NHibernate.Caches.SysCache</tt>, uses ASP.NET cache. This provider also supports
							SQL dependency-based expiration, meaning that it is possible to configure certain cache regions to automatically
							expire when the relevant data in the database changes.
						</p><p>
							SysCache2 requires Microsoft SQL Server 2000 or higher and .NET Framework version 2.0 or higher.
						</p></dd><dt><span class="term"><tt class="classname">NHibernate.Caches.MemCache</tt></span></dt><dd><p>
							Uses <tt class="literal">memcached</tt>. See <a href="http://www.danga.com/memcached/" target="_top">memcached homepage</a>
							for more information.
						</p></dd><dt><span class="term"><tt class="classname">NCache provider for NHibernate</tt></span></dt><dd><p>
							Uses <tt class="literal">NCache</tt>,NCache is a commercial distributed caching system with a provider for NHibernate. 
							The NCache Express version is free for use, see 
							<a href="http://www.alachisoft.com/ncache/ncache_express.html" target="_top">NCache Express homepage</a>
							for more information.
						</p></dd></dl></div><p>
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NHibernate.Caches-howto"></a>25.1.&nbsp;How to use a cache?</h2></div></div><div></div></div><p>
			Here are the steps to follow to enable the second-level cache in NHibernate:

			</p><div class="itemizedlist"><ul type="disc"><li><p>
						Choose the cache provider you want to use and copy its assembly in your assemblies directory
						(<tt class="filename">NHibernate.Caches.Prevalence.dll</tt> or
						<tt class="filename">NHibernate.Caches.SysCache.dll</tt>).
					</p></li><li><p>
						To tell NHibernate which cache provider to use, add in your NHibernate configuration file
						(can be <tt class="filename">YourAssembly.exe.config</tt> or <tt class="filename">web.config</tt> or a
						<tt class="filename">.cfg.xml</tt> file, in the latter case the syntax will be different from what
						is shown below):
						</p><pre class="programlisting">
&lt;add key="hibernate.cache.provider_class" value="<tt class="literal">XXX</tt>" /&gt;<a name="hibernate.cache.provider_class-co" href="#hibernate.cache.provider_class">(1)</a>
&lt;add key="expiration" value="<tt class="literal">120</tt>" /&gt;<a name="nhcaches-expiration-co" href="#nhcaches-expiration">(2)</a>
						</pre><p>
						</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><a name="hibernate.cache.provider_class"></a><a href="#hibernate.cache.provider_class-co">(1)</a> </td><td valign="top" align="left"><p>
									"<tt class="literal">XXX</tt>" is the assembly-qualified class name of a class
									implementing <tt class="classname">ICacheProvider</tt>, eg.
									"<tt class="classname">NHibernate.Caches.SysCache.SysCacheProvider,
									NHibernate.Caches.SysCache</tt>".
								</p></td></tr><tr><td width="5%" valign="top" align="left"><a name="nhcaches-expiration"></a><a href="#nhcaches-expiration-co">(2)</a> </td><td valign="top" align="left"><p>
									The <tt class="literal">expiration</tt> value is the number of seconds you wish
									to cache each entry (here two minutes). This example applies to SysCache only.
								</p></td></tr></table></div><p>
					</p></li><li><p>
						Add <tt class="literal">&lt;cache usage="read-write|nonstrict-read-write|read-only"/&gt;</tt> (just
						after <tt class="literal">&lt;class&gt;</tt>) in the mapping of the entities you want to cache. It
						also works for collections (bag, list, map, set, ...).
					</p></li></ul></div><p>
		</p><p><b>Be careful.&nbsp;</b>
				Caches are never aware of changes made to the persistent store by another process (though they may be
				configured to regularly expire cached data). As the caches are created at the session factory level,
				they are destroyed with the SessionFactory instance; so you must keep them alive as long as you need
				them.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NHibernate.Caches.Prevalence"></a>25.2.&nbsp;Prevalence Cache Configuration</h2></div></div><div></div></div><p>
			There is only one configurable parameter: <tt class="literal">prevalenceBase</tt>. This is the directory on the
			file system where the Prevalence engine will save data. It can be relative to the current directory or a
			full path. If the directory doesn't exist, it will be created.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NHibernate.Caches.SysCache"></a>25.3.&nbsp;SysCache Configuration</h2></div></div><div></div></div><p>
			As SysCache relies on <tt class="classname">System.Web.Caching.Cache</tt> for the underlying implementation,
			the configuration is based on the available options that make sense for NHibernate to utilize.
		</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">expiration</tt></span></dt><dd>
					Number of seconds to wait before expiring each item.
				</dd><dt><span class="term"><tt class="literal">priority</tt></span></dt><dd>
					A numeric cost of expiring each item, where 1 is a low cost, 5 is the highest, and 3 is normal.
					Only values 1 through 5 are valid.
				</dd></dl></div><p>
			SysCache has a config file section handler to allow configuring different expirations and priorities for
			different regions. Here's an example:
		</p><div class="example"><a name="d0e14378"></a><p class="title"><b>Example&nbsp;25.1.&nbsp;</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
	&lt;configSections&gt;
		&lt;section name="syscache" type="NHibernate.Caches.SysCache.SysCacheSectionHandler,NHibernate.Caches.SysCache" /&gt;
	&lt;/configSections&gt;

	&lt;syscache&gt;
		&lt;cache region="foo" expiration="500" priority="4" /&gt;
		&lt;cache region="bar" expiration="300" priority="3" /&gt;
	&lt;/syscache&gt;
&lt;/configuration&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NHibernate.Caches.SysCache2"></a>25.4.&nbsp;SysCache2 Configuration</h2></div></div><div></div></div><p>
			SysCache2 can use SqlCacheDependencies to invalidate cache regions when data in an underlying SQL Server
			table or query changes. Query dependencies are only available for SQL Server 2005. To use the cache
			provider, the application must be setup and configured to support SQL notifications as described in the
			MSDN documentation.
		</p><p>
			To configure cache regions with SqlCacheDependencies a <tt class="literal">syscache2</tt> config section must be
			defined in the application's configuration file. See the sample below.
		</p><div class="example"><a name="d0e14391"></a><p class="title"><b>Example&nbsp;25.2.&nbsp;</b></p><pre class="programlisting">
&lt;configSections&gt;
	&lt;section name="syscache2" type="NHibernate.Caches.SysCache2.SysCacheSection, NHibernate.Caches.SysCache2"/&gt;
&lt;/configSections&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14394"></a>25.4.1.&nbsp;Table-based Dependency</h3></div></div><div></div></div><p>
				A table-based dependency will monitor the data in a database table for changes. Table-based dependencies
				are generally used for a SQL Server 2000 database but will work with SQL Server 2005 or superior as	well.
				Before you can use SQL Server cache invalidation with table based dependencies, you need to
				enable notifications for the database. This task is performed with the <span><b class="command">aspnet_regsql</b></span>
				command. With table-based notifications, the application will poll the database for changes at a
				predefined interval. A cache region will not be invalidated immediately when data in the table changes.
				The cache will be invalidated the next time the application polls the database for changes.
			</p><p>
				To configure the data in a cache region to be invalidated when data in an underlying table is changed,
				a cache region must be configured in the application's configuration file. See the sample below.
			</p><div class="example"><a name="d0e14404"></a><p class="title"><b>Example&nbsp;25.3.&nbsp;</b></p><pre class="programlisting">&lt;syscache2&gt;
	&lt;cacheRegion name="Product"&gt;
		&lt;dependencies&gt;
			&lt;tables&gt;
				&lt;add name="price"
					databaseEntryName="Default"
					tableName="VideoTitle" /&gt;
			&lt;/tables&gt;
		&lt;/dependencies&gt;
	&lt;/cacheRegion&gt;	
&lt;/syscache2&gt;</pre></div></div><div class="variablelist"><p class="title"><b>Table-based Dependency Configuration Properties</b></p><dl><dt><span class="term"><tt class="literal">name</tt></span></dt><dd>Unique name for the dependency</dd><dt><span class="term"><tt class="literal">tableName</tt></span></dt><dd>
					The name of the database table that the dependency is associated with. The table must be enabled
					for notification support with the <tt class="literal">AspNet_SqlCacheRegisterTableStoredProcedure</tt>.
				</dd><dt><span class="term"><tt class="literal">databaseEntryName</tt></span></dt><dd>
					The name of a database defined in the <tt class="literal">databases</tt> element for
					<tt class="literal">sqlCacheDependency</tt> for caching (ASP.NET Settings Schema) element of the
					application's <tt class="literal">Web.config</tt> file.
				</dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14440"></a>25.4.2.&nbsp;Command-Based Dependencies</h3></div></div><div></div></div><p>
				A command-based dependency will use a SQL command to identify records to monitor for data changes.
				Command-based dependencies work only with SQL Server 2005.
			</p><p>
				Before you can use SQL Server cache invalidation with command-based dependencies, you need to enable
				the Service Broker for query notifications. The application must also start the listener for receiving
				change notifications from SQL Server. With command based notifications, SQL Server will notify the
				application when the data of a record returned in the results of a SQL query has changed. Note that a
				change will be indicated if the data in any of the columns of a record change, not just the columns
				returned by a query. The query is a way to limit the number of records monitored for changes, not the
				columns.  As soon as data in one of the records is modified, the data in the cache region will be
				invalidated immediately.
			</p><p>
				To configure the data in a cache region to be invalidated based on a SQL command, a cache region must
				be configured in the application's configuration file. See the samples below.
			</p><div class="example"><a name="d0e14449"></a><p class="title"><b>Example&nbsp;25.4.&nbsp;Stored Procedure</b></p><pre class="programlisting">&lt;cacheRegion name="Product" priority="High" &gt;
	&lt;dependencies&gt;
		&lt;commands&gt;
			&lt;add name="price"
				command="ActiveProductsStoredProcedure" 
				isStoredProcedure="true"/&gt;
		&lt;/commands&gt;
	&lt;/dependencies&gt;
&lt;/cacheRegion&gt;</pre></div><div class="example"><a name="d0e14454"></a><p class="title"><b>Example&nbsp;25.5.&nbsp;SELECT Statement</b></p><pre class="programlisting">&lt;cacheRegion name="Product" priority="High"&gt;
	&lt;dependencies&gt;
		&lt;commands&gt;
			&lt;add name="price"
				command="Select VideoTitleId from dbo.VideoTitle where Active = 1"
				connectionName="default"
				connectionStringProviderType="NHibernate.Caches.SysCache2.ConfigConnectionStringProvider, NHibernate.Caches.SysCache2"/&gt;
		&lt;/commands&gt;
	&lt;/dependencies&gt;
&lt;/cacheRegion&gt;</pre></div><div class="variablelist"><p class="title"><b>Command Configuration Properties</b></p><dl><dt><span class="term"><tt class="literal">name</tt></span></dt><dd>Unique name for the dependency</dd><dt><span class="term"><tt class="literal">command</tt> (required)</span></dt><dd>SQL command that returns results which should be monitored for data changes</dd><dt><span class="term"><tt class="literal">isStoredProcedure</tt> (optional)</span></dt><dd>
						Indicates if command is a stored procedure. The default is <tt class="literal">false</tt>.
					</dd><dt><span class="term"><tt class="literal">connectionName</tt> (optional)</span></dt><dd>
						The name of the connection in the applications configuration file to use for registering the
						cache dependency for change notifications. If no value is supplied for <tt class="literal">connectionName
						</tt> or <tt class="literal">connectionStringProviderType</tt>, the connection properties from
						the NHibernate configruation will be used.
					</dd><dt><span class="term"><tt class="literal">connectionStringProviderType</tt> (optional)</span></dt><dd><tt class="classname">IConnectionStringProvider</tt> to use for retrieving the connection string to
						use for registering the cache dependency for change notifications.  If no value is supplied for
						<tt class="literal">connectionName</tt>, the unnamed connection supplied by the provider will be
						used.
					</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14510"></a>25.4.3.&nbsp;Aggregate Dependencies</h3></div></div><div></div></div><p>
				Multiple cache dependencies can be specified.  If any of the dependencies triggers a change
				notification, the data in the cache region will be invalidated.  See the samples below.
			</p><div class="example"><a name="d0e14515"></a><p class="title"><b>Example&nbsp;25.6.&nbsp;Multiple commands</b></p><pre class="programlisting">&lt;cacheRegion name="Product"&gt;
	&lt;dependencies&gt;
		&lt;commands&gt;
			&lt;add name="price"
				command="ActiveProductsStoredProcedure" 
				isStoredProcedure="true"/&gt;
			&lt;add name="quantity"
				command="Select quantityAvailable from dbo.VideoAvailability"/&gt;
		&lt;/commands&gt;
	&lt;/dependencies&gt;
&lt;/cacheRegion&gt;

				</pre></div><div class="example"><a name="d0e14520"></a><p class="title"><b>Example&nbsp;25.7.&nbsp;Mixed</b></p><pre class="programlisting">&lt;cacheRegion name="Product"&gt;
	&lt;dependencies&gt;
		&lt;commands&gt;
			&lt;add name="price"
				command="ActiveProductsStoredProcedure" 
				isStoredProcedure="true"/&gt;
		&lt;/commands&gt;
		&lt;tables&gt;
			&lt;add name="quantity"
				databaseEntryName="Default"
				tableName=" VideoAvailability" /&gt;
		&lt;/tables&gt;
	&lt;/dependencies&gt;
&lt;/cacheRegion&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14525"></a>25.4.4.&nbsp;Additional Settings</h3></div></div><div></div></div><p>
				In addition to data dependencies for the cache regions, time based expiration policies can be specified
				for each item added to the cache.  Time based expiration policies will not invalidate the data
				dependencies for the whole cache region, but serve as a way to remove items from the cache after they
				have been in the cache for a specified amount of time.  See the samples below.
			</p><div class="example"><a name="d0e14530"></a><p class="title"><b>Example&nbsp;25.8.&nbsp;Relative Expiration</b></p><pre class="programlisting">&lt;cacheRegion name="Product" relativeExpiration="300" priority="High" /&gt;</pre></div><div class="example"><a name="d0e14535"></a><p class="title"><b>Example&nbsp;25.9.&nbsp;Time of Day Expiration</b></p><pre class="programlisting">&lt;cacheRegion name="Product" timeOfDayExpiration="2:00:00" priority="High" /&gt;</pre></div><div class="variablelist"><p class="title"><b>Additional Configuration Properties</b></p><dl><dt><span class="term"><tt class="literal">relativeExpiration</tt></span></dt><dd><p>
							Number of seconds that an individual item will exist in the cache before being removed.
						</p></dd><dt><span class="term"><tt class="literal">timeOfDayExpiration</tt></span></dt><dd><p>
							24 hour based time of day that an item will exist in the cache until. 12am is specified as
							00:00:00; 10pm is specified as 22:00:00. Only valid if relativeExpiration is not specified.
							Time of Day Expiration is useful for scenarios where items should be expired from the cache
							after a daily process completes. 
						</p></dd><dt><span class="term"><tt class="literal">priority</tt></span></dt><dd><tt class="classname">System.Web.Caching.CacheItemPriority</tt> that identifies the relative
						priority of items stored in the cache.
					</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14565"></a>25.4.5.&nbsp;Patches</h3></div></div><div></div></div><p>
				There is a known issue where some SQL Server 2005 notifications might not be received when an
				application subscribes to query notifications by using ADO.NET 2.0. To fix this problem install
				<a href="http://support.microsoft.com/Default.aspx?kbid=913364" target="_top">SQL hotfix for kb 913364</a>.
			</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mapping-attributes"></a>Chapter&nbsp;26.&nbsp;NHibernate.Mapping.Attributes</h2></div></div><div></div></div><div class="abstract"><a name="mapping-attributes-abstract"></a><p class="title"><b>What is NHibernate.Mapping.Attributes?</b></p><p><b>NHibernate.Mapping.Attributes is an add-in for <a href="http://www.nhibernate.org" target="_top">NHibernate</a> contributed by Pierre Henri Kuat&eacute; (aka <span class="emphasis"><em>KPixel</em></span>); the former implementation was made by John Morris.&nbsp;</b>NHibernate require mapping streams to bind your domain model to your database. Usually, they are written (and maintained) in separated hbm.xml files.</p><p>With NHibernate.Mapping.Attributes, you can use .NET attributes to decorate your entities and these attributes will be used to generate these mapping .hbm.xml (as files or streams). So you will no longer have to bother with these <span class="emphasis"><em>nasty</em></span> xml files ;).</p><p><b>Content of this library.&nbsp;</b>
				</p><div class="orderedlist"><ol type="1"><li><p>
							<span class="strong">NHibernate.Mapping.Attributes</span>: That the only project you need (as end-user)</p></li><li><p>
							<span class="strong">Test</span>: a working sample using attributes and HbmSerializer as NUnit TestFixture</p></li><li><p>
							<span class="strong">Generator</span>: The program used to generate attributes and HbmWriter</p></li><li><p>
							<a href="http://mbunit.tigris.org/" target="_top">
								<span class="strong">Refly</span>
							</a>: Thanks to <a href="http://www.dotnetwiki.org/" target="_top">Jonathan de Halleux</a> for this library which make it so easy to generate code</p></li></ol></div><p>
			</p><p>
			</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
					This library is generated using the file <tt class="filename">/src/NHibernate.Mapping.Attributes/nhibernate-mapping.xsd</tt>
					(which is embedded in the assembly to be able to validate generated XML streams).
					As this file can change at each new release of NHibernate, you should regenerate it before using it
					with a different version (open the Generator solution, compile and run the Generator project).
					But, no test has been done with versions prior to 0.8.
				</p></div><p>
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-attributes-new"></a>26.1.&nbsp;What's new?</h2></div></div><div></div></div><p><b>NHibernate.&nbsp;</b>introduces many new features, improvements and changes:</p><div class="orderedlist"><ol type="1"><li><p>It is possible to import classes by simply decorating them with <tt class="literal">[Import] class ImportedClass1 {}</tt>. Note that you must use <tt class="literal">HbmSerializer.Serialize(assembly)</tt>; The <tt class="literal">&lt;import/&gt;</tt> mapping will be added before the classes mapping. If you prefer to keep these imports in the class using them, you can specify them all on the class: <tt class="literal">[Import(ClassType=typeof(ImportedClass1))] class Query {}</tt>.</p></li><li><p><tt class="classname">[RawXmlAttribute]</tt> is a new attribute allowing to insert xml as-is in the mapping. This feature can be very useful to do complex mapping (eg: components). It may also be used to quickly move the mapping from xml files to attributes. Usage: <tt class="literal">[RawXml(After=typeof(ComponentAttribute), Content="&lt;component name="..."&gt;...&lt;/component&gt;")]</tt>. <tt class="methodname">After</tt> tells after which kind of mapping the xml should be inserted (generally, it is the type of the mapping you are inserting); it is optional (in which case the xml is inserted on the top of the mapping). Note: At the moment, all raw xmls are prefixed by a <tt class="literal">&lt;!----&gt;</tt> (in the generated stream); this is a known side-effect.</p></li><li><p><tt class="classname">[AttributeIdentifierAttribute]</tt> is a new attribute allowing to provide the value of a defined "place holder". Eg: </p><pre class="programlisting">
public class Base {
    [Id(..., Column="{{Id.Column}}")]
    [AttributeIdentifier(Name="Id.Column", Value="ID")] // Default value
    public int Id { ... }
}
[AttributeIdentifier(Name="Id.Column", Value="SUB_ID")]
[Class] public class MappedSubClass : Base { }</pre><p>
				The idea is that, when you have a mapping which is shared by many subclasses but which has minor differences (like different column names), you can put the mapping in the base class with place holders on these fields and give their values in subclasses. Note that this is possible for any mapping field taking a string (column, name, type, access, etc.). And, instead of <tt class="methodname">Value</tt>, you can use <tt class="methodname">ValueType</tt> or <tt class="methodname">ValueObject</tt> (if you use an enum, you can control its formatting with <tt class="methodname">ValueObject</tt>).
				</p><p>The "place holder" is defined like this: <tt class="literal">{{XXX}}</tt>. If you don't want to use these double curly brackets, you can change them using the properties <tt class="methodname">StartQuote</tt> and <tt class="methodname">EndQuote</tt> of the class <tt class="classname">HbmWriter</tt>.</p></li><li><p>It is possible to register patterns (using Regular Expressions) to automatically transform fully qualified names of properties types into something else. Eg: <tt class="literal">HbmSerializer.Default.HbmWriter.Patterns.Add(@"Namespace.(\S+), Assembly", "$1");</tt> will map all properties with a not-qualified type name.</p></li><li><p>Two methods have been added to allow writing: <tt class="literal">cfg.AddInputStream( HbmSerializer.Default.Serialize(typeof(XXX)) )</tt> and <tt class="literal">cfg.AddInputStream( HbmSerializer.Default.Serialize(typeof(XXX).Assembly) )</tt>. So it is no longer required to create a MemoryStream for these simple cases.</p></li><li><p>Two <tt class="methodname">WriteUserDefinedContent()</tt> methods have been added to <tt class="classname">HbmWriter</tt>. They improve the extensibility of this library; it is now very easy to create a .NET attribute and integrate it in the mapping.</p></li><li><p>Attributes <tt class="classname">[(Jcs)Cache]</tt>, <tt class="classname">[Discriminator]</tt> and <tt class="classname">[Key]</tt> can be specified at class-level.</p></li><li><p>Interfaces can be mapped (just like classes and structs).</p></li><li><p>A notable "bug" fix is the re-ordering of (joined-)subclasses; This operation may be required when a subclass extends another subclass. In this case, the extended class mapping must come before the extending class mapping. Note that the re-ordering takes place only for "top-level" classes (that is not nested in other mapped classes). Anyway, it is quite unusual to put a interdependent mapped subclasses in a mapped class.</p></li><li><p>There are also many other little changes; refer to the release notes for more details.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-attributes-howto"></a>26.2.&nbsp;How to use it?</h2></div></div><div></div></div><p><b>The <span class="emphasis"><em>end-user class</em></span> is <tt class="classname">NHibernate.Mapping.Attributes.HbmSerializer</tt>.&nbsp;</b>This class <span class="emphasis"><em>serialize</em></span> your domain model to mapping streams. You can either serialize classes one by one or an assembly. Look at <tt class="classname">NHibernate.Mapping.Attributes.Test</tt> project for a working sample.</p><p>The first step is to decorate your entities with attributes; you can use: <tt class="classname">[Class]</tt>, <tt class="classname">[Subclass]</tt>, <tt class="classname">[JoinedSubclass]</tt> or <tt class="classname">[Component]</tt>. Then, you decorate your members (fields/properties); they can take as many attributes as required by your mapping. Eg:</p><pre class="programlisting">
    [NHibernate.Mapping.Attributes.Class]
    public class Example
    {
        [NHibernate.Mapping.Attributes.Property]
        public string Name;
    }</pre><p>After this step, you use <tt class="classname">NHibernate.Mapping.Attributes.HbmSerializer</tt>: (here, we use <tt class="methodname">Default</tt> which is an instance you can use if you don't need/want to create it yourself).</p><pre class="programlisting">
    NHibernate.Cfg.Configuration cfg = new NHibernate.Cfg.Configuration();
    cfg.Configure();
    NHibernate.Mapping.Attributes.HbmSerializer.Default.Validate = true; // Enable validation (optional)
    // Here, we serialize all decorated classes (but you can also do it class by class)
    cfg.AddInputStream( NHibernate.Mapping.Attributes.HbmSerializer.Default.Serialize(
        System.Reflection.Assembly.GetExecutingAssembly() ); );
    // Now you can use this configuration to build your SessionFactory...</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
				As you can see here: NHibernate.Mapping.Attributes is <span class="strong">not</span> (really) intrusive.
				Setting attributes on your objects doesn't force you to use them with NHibernate and doesn't break any constraint on your architecture.
				Attributes are purely informative (like documentation)!
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-attributes-tips"></a>26.3.&nbsp;Tips</h2></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>In production, it is recommended to generate a XML mapping file from NHibernate.Mapping.Attributes and use this file each time the SessionFactory need to be built. Use: <tt class="literal">HbmSerializer.Default.Serialize(typeof(XXX).Assembly, "DomainModel.hbm.xml");</tt> It is slightly faster.</p></li><li><p>Use <tt class="methodname">HbmSerializer.Validate</tt> to enable/disable the validation of generated xml streams (against NHibernate mapping schema); this is useful to quickly find errors (they are written in StringBuilder <tt class="methodname">HbmSerializer.Error</tt>). If the error is due to this library then see if it is a know issue and report it; you can contribute a solution if you solve the problem :)</p></li><li><p>Your classes, fields and properties (members) can be private; just make sure that you have the permission to access private members using reflection (<tt class="methodname">ReflectionPermissionFlag.MemberAccess</tt>).</p></li><li><p>Members of a mapped classes are also seek in its base classes (until we reach <span class="emphasis"><em>mapped</em></span> base class). So you can decorate some members of a (not mapped) base class and use it in its (mapped) sub class(es).</p></li><li><p>For a Name taking a <tt class="classname">System.Type</tt>, set the type with <tt class="methodname">Name</tt><tt class="literal">="xxx"</tt> (as <tt class="classname">string</tt>) or <tt class="methodname">Name</tt><tt class="literal">Type=typeof(xxx)</tt>; (add "<tt class="literal">Type</tt>" to "<tt class="methodname">Name</tt>")</p></li><li><p>By default, .NET attributes don't keep the order of attributes; so you need to set it yourself when the order matter (using the first parameter of each attribute); it is <span class="emphasis"><em>highly</em></span> recommended to set it when you have more than one attribute on the same member.</p></li><li><p>As long as there is no ambiguity, you can decorate a member with many unrelated attributes. A good example is to put class-related attributes (like <tt class="literal">&lt;discriminator&gt;</tt>) on the identifier member. But don't forget that the order matters (the <tt class="literal">&lt;discriminator&gt;</tt> must be after the <tt class="literal">&lt;id&gt;</tt>). The order used comes from the order of elements in the NHibernate mapping schema. Personally, I prefer using negative numbers for these attributes (if they come before!).</p></li><li><p>You can add <tt class="classname">[HibernateMapping]</tt> on your classes to specify <tt class="literal">&lt;hibernate-mapping&gt;</tt> attributes (used when serializing the class in its stream). You can also use <tt class="methodname">HbmSerializer.Hbm*</tt> properties (used when serializing an assembly or a type that is not decorated with <tt class="classname">[HibernateMapping]</tt>).</p></li><li><p>Instead of using a string for <tt class="methodname">DiscriminatorValue</tt> (in <tt class="classname">[Class]</tt> and <tt class="classname">[Subclass]</tt>), you can use any object you want. Example: </p><pre class="programlisting">[Subclass(DiscriminatorValueEnumFormat="d", DiscriminatorValueObject=DiscEnum.Val1)]</pre><p> Here, the object is an Enum, and you can set the format you want (the default value is "g"). Note that you must put it <span class="strong">before</span>! For others types, It simply use the <tt class="methodname">ToString()</tt> method of the object.</p></li><li><p>If you are using members of the type <tt class="classname">Nullables.NullableXXX</tt> (from the library <a href="#">Nullables</a>), then they will be mapped to <tt class="classname">Nullables.NHibernate.NullableXXXType</tt> automatically; don't set <tt class="literal">Type="..."</tt> in <tt class="classname">[Property]</tt> (leave it null). This is also the case for <tt class="classname">SqlTypes</tt> (and you can add your own patterns). Thanks to <span class="emphasis"><em>Michael Third</em></span> for the idea :)</p></li><li><p>Each stream generated by NHibernate.Mapping.Attributes can contain a comment with the date of the generation; You may enable/disable this by using the property <tt class="methodname">HbmSerializer.WriteDateComment</tt>.</p></li><li><p>If you forget to provide a required xml attribute, it will obviously throw an exception while generating the mapping.</p></li><li><p>The recommended and easiest way to map <tt class="classname">[Component]</tt> is to use <tt class="classname">[ComponentProperty]</tt>. The first step is to put <tt class="classname">[Component]</tt> on the component class and map its fields/properties. Note that you shouldn't set the <tt class="methodname">Name</tt> in <tt class="classname">[Component]</tt>. Then, on each member in your classes, add <tt class="classname">[ComponentProperty]</tt>. But you can't override <tt class="methodname">Access</tt>, <tt class="methodname">Update</tt> or <tt class="methodname">Insert</tt> for each member.</p><p>There is a working example in <span class="emphasis"><em>NHibernate.Mapping.Attributes.Test</em></span> (look for the class <tt class="classname">CompAddress</tt> and its usage in others classes).</p></li><li><p>Another way to map <tt class="classname">[Component]</tt> is to use the way this library works: If a mapped class contains a mapped component, then this component will be include in the class. <span class="emphasis"><em>NHibernate.Mapping.Attributes.Test</em></span> contains the classes <tt class="classname">JoinedBaz</tt> and <tt class="classname">Stuff</tt> which both use the component <tt class="classname">Address</tt>.</p><p>Basically, it is done by adding </p><pre class="programlisting">[Component(Name = "MyComp")] private class SubComp : Comp {}</pre><p> in each class. One of the advantages is that you can override <tt class="methodname">Access</tt>, <tt class="methodname">Update</tt> or <tt class="methodname">Insert</tt> for each member. But you have to add the component subclass in <span class="strong">each</span> class (and it can not be inherited). Another advantage is that you can use <tt class="classname">[AttributeIdentifier]</tt>.</p></li><li><p>Finally, whenever you think that it is easier to write the mapping in XML (this is often the case for <tt class="classname">[Component]</tt>), you can use <tt class="classname">[RawXml]</tt>.</p></li><li><p><b>About customization.&nbsp;</b><tt class="classname">HbmSerializer</tt> uses <tt class="classname">HbmWriter</tt> to serialize each kind of attributes. Their methods are virtual; so you can create a subclass and override any method you want (to change its default behavior).</p><p>Use the property <tt class="methodname">HbmSerializer.HbmWriter</tt> to change the writer used (you may set a subclass of <tt class="classname">HbmWriter</tt>).</p></li></ol></div><p>Example using some this tips: (0, 1 and 2 are position indexes)
</p><pre class="programlisting">
    [NHibernate.Mapping.Attributes.Id(0, TypeType=typeof(int))] // Don't put it after [ManyToOne] !!!
        [NHibernate.Mapping.Attributes.Generator(1, Class="uuid.hex")]
    [NHibernate.Mapping.Attributes.ManyToOne(2, ClassType=typeof(Foo), OuterJoin=OuterJoinStrategy.True)]
    private Foo Entity;
</pre><p>
			Generates:
</p><pre class="programlisting">
    &lt;id type="Int32"&gt;
        &lt;generator class="uuid.hex" /&gt;
    &lt;/id&gt;
    &lt;many-to-one name="Entity" class="Namespaces.Foo, SampleAssembly" outer-join="true" /&gt;
</pre><p>
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-attributes-todo"></a>26.4.&nbsp;Known issues and TODOs</h2></div></div><div></div></div><p>First, read TODOs in the source code ;)</p><p>A <tt class="methodname">Position</tt> property has been added to all attributes to order them. But there is still a problem:</p><p>When a parent element "p" has a child element "x" that is also the child element of another child element "c" of "p" (preceding "x") :D
Illustration:</p><pre class="programlisting">
    &lt;p&gt;
        &lt;c&gt;
            &lt;x /&gt;
        &lt;/c&gt;
        &lt;x /&gt;
    &lt;/p&gt;
</pre><p>
		</p><p>In this case, when writing:
			</p><pre class="programlisting">
    [Attributes.P(0)]
        [Attributes.C(1)]
            [Attributes.X(2)]
        [Attributes.X(3)]
    public MyType MyProperty;</pre><p>
		X(3) will always belong to C(1) ! (as X(2)).
		</p><p>It is the case for <tt class="literal">&lt;dynamic-component&gt;</tt> and <tt class="literal">&lt;nested-composite-element&gt;</tt>.</p><p>Another bad news is that, currently, XML elements coming after this elements can not be included in them. Eg: There is no way put a collection in <tt class="literal">&lt;dynamic-component&gt;</tt>. The reason is that the file <tt class="filename">nhibernate-mapping.xsd</tt> tells how elements are built and in which order, and NHibernate.Mapping.Attributes use this order.</p><p>Anyway, the solution would be to add a <tt class="methodname">int ParentNode</tt> property to BaseAttribute so that you can create a real graph...</p><p>For now, you can fallback on <tt class="classname">[RawXml]</tt>.</p><p>Actually, there is no other know issue nor planned modification. This library should be stable and complete; but if you find a bug or think of an useful improvement, contact us!</p><p>On side note, it would be nice to write a better TestFixture than <span class="emphasis"><em>NHibernate.Mapping.Attributes.Test</em></span> :D</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapping-attributes-devnotes"></a>26.5.&nbsp;Developer Notes</h2></div></div><div></div></div><p>Any change to the schema (<tt class="filename">nhibernate-mapping.xsd</tt>) implies:</p><div class="orderedlist"><ol type="1"><li><p>Checking if there is any change to do in the Generator (like updating KnowEnums / AllowMultipleValue / IsRoot / IsSystemType / IsSystemEnum / CanContainItself)</p></li><li><p>Updating <tt class="filename">/src/NHibernate.Mapping.Attributes/nhibernate-mapping.xsd</tt> (copy/paste) and running the Generator again (even if it wasn't modified)</p></li><li><p>Running the Test project and make sure that no exception is thrown. A class/property should be modified/added in this project to be sure that any new breaking change will be caught (=&gt; update the reference hbm.xml files and/or the project <tt class="filename">NHibernate.Mapping.Attributes-2.0.csproj</tt>)</p></li></ol></div><p>This implementation is based on NHibernate mapping schema; so there is probably lot of "standard schema features" that are not supported...</p><p>The version of NHibernate.Mapping.Attributes should be the version of the NHibernate schema used to generate it (=&gt; the version of NHibernate library).</p><p>In the design of this project, performance is a (<span class="emphasis"><em>very</em></span>) minor goal :) Easier implementation and maintenance are far more important because you can (and should) avoid to use this library in production (Cf. the first tip in <a href="#mapping-attributes-tips" title="26.3.&nbsp;Tips">Section&nbsp;26.3, &#8220;Tips&#8221;</a>).</p></div></div></div></div></body></html>
